# 1 "tramp3d-v4.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "tramp3d-v4.cpp"
# 1 "/usr/include/sys/time.h" 1 3 4
# 21 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 368 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 415 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 416 "/usr/include/sys/cdefs.h" 2 3 4
# 369 "/usr/include/features.h" 2 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 22 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4



# 30 "/usr/include/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 122 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 24 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/time.h" 1 3 4
# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 26 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 28 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 22 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 46 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 48 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 66 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 98 "/usr/include/sys/select.h" 3 4
extern "C" {
# 108 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 120 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 133 "/usr/include/sys/select.h" 3 4
}
# 30 "/usr/include/sys/time.h" 2 3 4







extern "C" {
# 55 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 189 "/usr/include/sys/time.h" 3 4
}
# 2 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/cstddef" 1 3
# 42 "/usr/include/c++/6/cstddef" 3
       
# 43 "/usr/include/c++/6/cstddef" 3






# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 1 3


# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 4 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 2 3
# 2086 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 2108 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 2385 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/os_defines.h" 1 3
# 2386 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 2 3


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/cpu_defines.h" 1 3
# 2389 "/usr/include/c++/6/x86_64-suse-linux/bits/c++config.h" 2 3
# 50 "/usr/include/c++/6/cstddef" 2 3
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 149 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 216 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 426 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/include/c++/6/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 3 "tramp3d-v4.cpp" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 88 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 89 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();





# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 4 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/fenv.h" 1 3
# 32 "/usr/include/c++/6/fenv.h" 3
       
# 33 "/usr/include/c++/6/fenv.h" 3



# 1 "/usr/include/fenv.h" 1 3 4
# 57 "/usr/include/fenv.h" 3 4
# 1 "/usr/include/bits/fenv.h" 1 3 4
# 24 "/usr/include/bits/fenv.h" 3 4
enum
  {
    FE_INVALID =

      0x01,
    __FE_DENORM = 0x02,
    FE_DIVBYZERO =

      0x04,
    FE_OVERFLOW =

      0x08,
    FE_UNDERFLOW =

      0x10,
    FE_INEXACT =

      0x20
  };







enum
  {
    FE_TONEAREST =

      0,
    FE_DOWNWARD =

      0x400,
    FE_UPWARD =

      0x800,
    FE_TOWARDZERO =

      0xc00
  };



typedef unsigned short int fexcept_t;






typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved1;
    unsigned short int __status_word;
    unsigned short int __glibc_reserved2;
    unsigned short int __tags;
    unsigned short int __glibc_reserved3;
    unsigned int __eip;
    unsigned short int __cs_selector;
    unsigned int __opcode:11;
    unsigned int __glibc_reserved4:5;
    unsigned int __data_offset;
    unsigned short int __data_selector;
    unsigned short int __glibc_reserved5;

    unsigned int __mxcsr;

  }
fenv_t;
# 58 "/usr/include/fenv.h" 2 3 4

extern "C" {




extern int feclearexcept (int __excepts) throw ();



extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) throw ();


extern int feraiseexcept (int __excepts) throw ();



extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) throw ();



extern int fetestexcept (int __excepts) throw ();





extern int fegetround (void) throw () __attribute__ ((__pure__));


extern int fesetround (int __rounding_direction) throw ();






extern int fegetenv (fenv_t *__envp) throw ();




extern int feholdexcept (fenv_t *__envp) throw ();



extern int fesetenv (const fenv_t *__envp) throw ();




extern int feupdateenv (const fenv_t *__envp) throw ();
# 122 "/usr/include/fenv.h" 3 4
extern int feenableexcept (int __excepts) throw ();




extern int fedisableexcept (int __excepts) throw ();


extern int fegetexcept (void) throw ();


}
# 37 "/usr/include/c++/6/fenv.h" 2 3
# 55 "/usr/include/c++/6/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 5 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/cstdarg" 1 3
# 39 "/usr/include/c++/6/cstdarg" 3
       
# 40 "/usr/include/c++/6/cstdarg" 3



# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdarg.h" 1 3 4
# 40 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 44 "/usr/include/c++/6/cstdarg" 2 3
# 53 "/usr/include/c++/6/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 6 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/complex" 1 3
# 39 "/usr/include/c++/6/complex" 3
       
# 40 "/usr/include/c++/6/complex" 3


# 1 "/usr/include/c++/6/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/6/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/6/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/6/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "/usr/include/c++/6/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "/usr/include/c++/6/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/6/complex" 2 3
# 1 "/usr/include/c++/6/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/6/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/6/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/6/complex" 2 3
# 1 "/usr/include/c++/6/cmath" 1 3
# 39 "/usr/include/c++/6/cmath" 3
       
# 40 "/usr/include/c++/6/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" {


# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 32 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 45 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 28 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 49 "/usr/include/math.h" 2 3 4
# 83 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));

# 208 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));
# 247 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 84 "/usr/include/math.h" 2 3 4
# 104 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));








extern int isinff (float __value) throw () __attribute__ ((__const__));



extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));






extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 105 "/usr/include/math.h" 2 3 4
# 151 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));








extern int isinfl (long double __value) throw () __attribute__ ((__const__));



extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));






extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 152 "/usr/include/math.h" 2 3 4
# 168 "/usr/include/math.h" 3 4
extern int signgam;
# 209 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 347 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 370 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 534 "/usr/include/math.h" 3 4
}
# 46 "/usr/include/c++/6/cmath" 2 3
# 77 "/usr/include/c++/6/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 435 "/usr/include/c++/6/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 559 "/usr/include/c++/6/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 956 "/usr/include/c++/6/cmath" 3

}
# 1072 "/usr/include/c++/6/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 1797 "/usr/include/c++/6/cmath" 3
}
# 45 "/usr/include/c++/6/complex" 2 3
# 1 "/usr/include/c++/6/sstream" 1 3
# 36 "/usr/include/c++/6/sstream" 3
       
# 37 "/usr/include/c++/6/sstream" 3

# 1 "/usr/include/c++/6/istream" 1 3
# 36 "/usr/include/c++/6/istream" 3
       
# 37 "/usr/include/c++/6/istream" 3

# 1 "/usr/include/c++/6/ios" 1 3
# 36 "/usr/include/c++/6/ios" 3
       
# 37 "/usr/include/c++/6/ios" 3

# 1 "/usr/include/c++/6/iosfwd" 1 3
# 36 "/usr/include/c++/6/iosfwd" 3
       
# 37 "/usr/include/c++/6/iosfwd" 3


# 1 "/usr/include/c++/6/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/6/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/6/bits/stringfwd.h" 3


# 1 "/usr/include/c++/6/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/6/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/6/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/6/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/include/c++/6/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/usr/include/c++/6/iosfwd" 2 3
# 1 "/usr/include/c++/6/bits/postypes.h" 1 3
# 38 "/usr/include/c++/6/bits/postypes.h" 3
       
# 39 "/usr/include/c++/6/bits/postypes.h" 3

# 1 "/usr/include/c++/6/cwchar" 1 3
# 39 "/usr/include/c++/6/cwchar" 3
       
# 40 "/usr/include/c++/6/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 36 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/include/bits/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 357 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 309 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

# 408 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 533 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 683 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 739 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 804 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 830 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 840 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 894 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/6/cwchar" 2 3
# 62 "/usr/include/c++/6/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/6/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/6/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/6/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/include/c++/6/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/6/bits/postypes.h" 2 3
# 68 "/usr/include/c++/6/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/6/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/6/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/6/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/6/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/6/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/6/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/exception" 1 3
# 33 "/usr/include/c++/6/exception" 3
       
# 34 "/usr/include/c++/6/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/6/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/6/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/6/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/include/c++/6/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/include/c++/6/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 129 "/usr/include/c++/6/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 160 "/usr/include/c++/6/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/6/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/6/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/6/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/6/bits/exception_ptr.h" 2 3





extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 113 "/usr/include/c++/6/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 140 "/usr/include/c++/6/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 171 "/usr/include/c++/6/exception" 2 3
# 1 "/usr/include/c++/6/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/6/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/6/bits/move.h" 1 3
# 34 "/usr/include/c++/6/bits/move.h" 3
# 1 "/usr/include/c++/6/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/6/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/6/bits/concept_check.h" 3
# 35 "/usr/include/c++/6/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "/usr/include/c++/6/type_traits" 1 3
# 32 "/usr/include/c++/6/type_traits" 3
       
# 33 "/usr/include/c++/6/type_traits" 3
# 42 "/usr/include/c++/6/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/usr/include/c++/6/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/usr/include/c++/6/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 182 "/usr/include/c++/6/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 314 "/usr/include/c++/6/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 926 "/usr/include/c++/6/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };



  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1774 "/usr/include/c++/6/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1863 "/usr/include/c++/6/type_traits" 3
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1893 "/usr/include/c++/6/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "/usr/include/c++/6/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "/usr/include/c++/6/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };





  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;


  template<template<typename...> class _Default,
    template<typename...> class _Op, typename... _Args>
    using __detected_or_t_ =
      __detected_or_t<_Default<_Args...>, _Op, _Args...>;
# 2590 "/usr/include/c++/6/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename _Tp>
    inline
    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };


}
# 58 "/usr/include/c++/6/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/6/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/6/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "/usr/include/c++/6/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 159 "/usr/include/c++/6/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 174 "/usr/include/c++/6/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/6/bits/nested_exception.h" 2 3





extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp =
            dynamic_cast<const nested_exception*>(std::__addressof(__t)))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop
# 172 "/usr/include/c++/6/exception" 2 3
# 40 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/6/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/6/bits/char_traits.h" 3

# 1 "/usr/include/c++/6/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/6/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/6/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/6/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/6/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/6/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/6/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/6/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/6/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/6/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_pair.h" 1 3
# 65 "/usr/include/c++/6/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/6/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, const _U1&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, const _U2&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<const _U1&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<const _U2&, _T2>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _MoveConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, _U1&&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, _U2&&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyMoveConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<_U1&&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<_U2&&, _T2>>>::value;
  }
# 146 "/usr/include/c++/6/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }







      template<typename _U1 = _T1, typename _U2=_T2, typename
                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 210 "/usr/include/c++/6/bits/stl_pair.h" 3
      template<typename _U1, typename _U2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
         _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _U1, _T2>()),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                           _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _T1, _U2>()),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
           _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__is_nothrow_swappable<_T1>::value
               && __is_nothrow_swappable<_T2>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 422 "/usr/include/c++/6/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 441 "/usr/include/c++/6/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 230 "/usr/include/c++/6/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/6/debug/assertions.h" 1 3
# 66 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 133 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 192 "/usr/include/c++/6/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/6/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/6/bits/ptr_traits.h" 1 3
# 37 "/usr/include/c++/6/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = typename _Tp::template rebind<_Up>;

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind
   = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
      static_assert(!is_same<rebind<element_type>, __undefined>::value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "/usr/include/c++/6/bits/stl_iterator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 160 "/usr/include/c++/6/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 290 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>





    inline auto
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())

    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }




  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 448 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 483 "/usr/include/c++/6/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 525 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 540 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 574 "/usr/include/c++/6/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 616 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 635 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 686 "/usr/include/c++/6/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 730 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 754 "/usr/include/c++/6/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 854 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 1006 "/usr/include/c++/6/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "/usr/include/c++/6/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/6/debug/debug.h" 1 3
# 48 "/usr/include/c++/6/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/usr/include/c++/6/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/6/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/6/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
# 72 "/usr/include/c++/6/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "/usr/include/c++/6/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "/usr/include/c++/6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 40 "/usr/include/c++/6/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/6/cwchar" 1 3
# 39 "/usr/include/c++/6/cwchar" 3
       
# 40 "/usr/include/c++/6/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/6/cwchar" 2 3
# 42 "/usr/include/c++/6/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/6/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/include/c++/6/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "/usr/include/c++/6/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/usr/include/c++/6/cstdint" 1 3
# 32 "/usr/include/c++/6/cstdint" 3
       
# 33 "/usr/include/c++/6/cstdint" 3
# 41 "/usr/include/c++/6/cstdint" 3
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdint.h" 1 3 4
# 9 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 36 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/6/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 421 "/usr/include/c++/6/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/6/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/6/bits/localefwd.h" 3


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/6/x86_64-suse-linux/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/6/x86_64-suse-linux/bits/c++locale.h" 3

# 1 "/usr/include/c++/6/clocale" 1 3
# 39 "/usr/include/c++/6/clocale" 3
       
# 40 "/usr/include/c++/6/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 50 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/6/clocale" 2 3
# 51 "/usr/include/c++/6/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/6/x86_64-suse-linux/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/c++/6/x86_64-suse-linux/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/6/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/6/cctype" 1 3
# 39 "/usr/include/c++/6/cctype" 3
       
# 40 "/usr/include/c++/6/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4






# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/bits/byteswap.h" 2 3 4
# 44 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 347 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/6/cctype" 2 3
# 62 "/usr/include/c++/6/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/6/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/6/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/6/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/6/bits/ios_base.h" 3

# 1 "/usr/include/c++/6/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/6/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/6/ext/atomicity.h" 3


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr.h" 1 3
# 30 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr.h" 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 1 3
# 35 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 73 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[4096 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 202 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 220 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 114 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 155 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 190 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 228 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 494 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 506 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 540 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 742 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 806 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 888 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1000 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1044 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1111 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1159 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 2 3
# 47 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/c++/6/x86_64-suse-linux/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/6/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/6/x86_64-suse-linux/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/6/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/6/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/6/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/6/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/6/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/6/bits/locale_classes.h" 3


# 1 "/usr/include/c++/6/string" 1 3
# 36 "/usr/include/c++/6/string" 3
       
# 37 "/usr/include/c++/6/string" 3




# 1 "/usr/include/c++/6/bits/allocator.h" 1 3
# 46 "/usr/include/c++/6/bits/allocator.h" 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/6/x86_64-suse-linux/bits/c++allocator.h" 3
# 1 "/usr/include/c++/6/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/6/ext/new_allocator.h" 3
# 1 "/usr/include/c++/6/new" 1 3
# 37 "/usr/include/c++/6/new" 3
       
# 38 "/usr/include/c++/6/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 116 "/usr/include/c++/6/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));



inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/6/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/6/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "/usr/include/c++/6/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/c++/6/x86_64-suse-linux/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/c++/6/x86_64-suse-linux/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/6/bits/allocator.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      typedef true_type is_always_equal;

    };
# 96 "/usr/include/c++/6/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/6/string" 2 3


# 1 "/usr/include/c++/6/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/6/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/6/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/6/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/6/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/6/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/6/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/6/string" 2 3



# 1 "/usr/include/c++/6/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/6/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/6/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "/usr/include/c++/6/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/6/backward/binders.h" 1 3
# 60 "/usr/include/c++/6/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/6/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "/usr/include/c++/6/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/6/string" 2 3


# 1 "/usr/include/c++/6/bits/range_access.h" 1 3
# 33 "/usr/include/c++/6/bits/range_access.h" 3
       
# 34 "/usr/include/c++/6/bits/range_access.h" 3


# 1 "/usr/include/c++/6/initializer_list" 1 3
# 33 "/usr/include/c++/6/initializer_list" 3
       
# 34 "/usr/include/c++/6/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/usr/include/c++/6/bits/range_access.h" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 319 "/usr/include/c++/6/bits/range_access.h" 3

}
# 52 "/usr/include/c++/6/string" 2 3
# 1 "/usr/include/c++/6/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/6/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/6/bits/basic_string.h" 3


# 1 "/usr/include/c++/6/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/6/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/6/ext/alloc_traits.h" 3



# 1 "/usr/include/c++/6/bits/alloc_traits.h" 1 3
# 41 "/usr/include/c++/6/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Alloc, typename _Up>
      using __rebind = typename _Alloc::template rebind<_Up>::other;

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __diff_type = typename _Tp::difference_type;
    template<typename _Tp>
      using __size_type = typename _Tp::size_type;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,
         __allocator_traits_base::__rebind,
         _Alloc, _Up>;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;







      using const_pointer
 = __detected_or_t<__ptr_rebind<pointer, const value_type>,
     __c_pointer, _Alloc>;







      using void_pointer
 = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;







      using const_void_pointer
 = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,
     _Alloc>;







      using difference_type
 = __detected_or_t<typename pointer_traits<pointer>::difference_type,
     __diff_type, _Alloc>;







      using size_type
 = __detected_or_t<typename make_unsigned<difference_type>::type,
     __size_type, _Alloc>;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,
   "allocator defines rebind or is like Alloc<T, Args>");

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 279 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 294 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 306 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 321 "/usr/include/c++/6/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 334 "/usr/include/c++/6/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 346 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 357 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 414 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 428 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 440 "/usr/include/c++/6/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 452 "/usr/include/c++/6/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 464 "/usr/include/c++/6/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "/usr/include/c++/6/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/usr/include/c++/6/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/include/c++/6/bits/basic_string.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 71 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 258 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 410 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 426 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 444 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 476 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 544 "/usr/include/c++/6/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {

  _M_destroy(_M_allocated_capacity);
  _M_data(_M_local_data());
  _M_set_length(0);
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 599 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 617 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 813 "/usr/include/c++/6/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 826 "/usr/include/c++/6/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 875 "/usr/include/c++/6/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 904 "/usr/include/c++/6/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 921 "/usr/include/c++/6/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 942 "/usr/include/c++/6/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 963 "/usr/include/c++/6/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1026 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1084 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1126 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1150 "/usr/include/c++/6/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1194 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1217 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1233 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1249 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1266 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1279 "/usr/include/c++/6/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1315 "/usr/include/c++/6/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1357 "/usr/include/c++/6/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1393 "/usr/include/c++/6/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1413 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1436 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1459 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1478 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1502 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1520 "/usr/include/c++/6/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1544 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
# 1560 "/usr/include/c++/6/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1579 "/usr/include/c++/6/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1620 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1642 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1667 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1692 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1716 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1734 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1754 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 1776 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1797 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 1822 "/usr/include/c++/6/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 1854 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1913 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 1956 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1966 "/usr/include/c++/6/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 1976 "/usr/include/c++/6/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2009 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 2022 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2037 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2054 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2067 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2084 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 2097 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2114 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2128 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2145 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2158 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2177 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2192 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2209 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2222 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2241 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2255 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2272 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2286 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2303 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2318 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2335 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2349 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2366 "/usr/include/c++/6/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2382 "/usr/include/c++/6/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2401 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2433 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2459 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2477 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2501 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2528 "/usr/include/c++/6/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
# 4927 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 5048 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 5095 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 5133 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 5171 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 5209 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 5247 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 5285 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 5305 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 5323 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 5346 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 5363 "/usr/include/c++/6/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/6/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/6/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/6/ext/string_conversions.h" 3
# 41 "/usr/include/c++/6/ext/string_conversions.h" 3
# 1 "/usr/include/c++/6/cstdlib" 1 3
# 39 "/usr/include/c++/6/cstdlib" 3
       
# 40 "/usr/include/c++/6/cstdlib" 3
# 75 "/usr/include/c++/6/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 56 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 100 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 200 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 266 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 136 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;
# 146 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 200 "/usr/include/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 222 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 276 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 454 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 567 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 580 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 590 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 602 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 612 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 623 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 634 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 644 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 654 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 666 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 772 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 859 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 921 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 922 "/usr/include/stdlib.h" 2 3 4
# 934 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/6/cstdlib" 2 3
# 118 "/usr/include/c++/6/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 201 "/usr/include/c++/6/cstdlib" 3

}
# 215 "/usr/include/c++/6/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 247 "/usr/include/c++/6/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "/usr/include/c++/6/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/6/cwchar" 1 3
# 39 "/usr/include/c++/6/cwchar" 3
       
# 40 "/usr/include/c++/6/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/6/cwchar" 2 3
# 43 "/usr/include/c++/6/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/6/cstdio" 1 3
# 39 "/usr/include/c++/6/cstdio" 3
       
# 40 "/usr/include/c++/6/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 333 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 429 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 459 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 521 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4
# 110 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 166 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 167 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 207 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 229 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 254 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 264 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 297 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 465 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 524 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 552 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 563 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 596 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 642 "/usr/include/stdio.h" 3 4

# 651 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 667 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 728 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 739 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 775 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 794 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 817 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 856 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 874 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 944 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/6/cstdio" 2 3





extern "C" char* gets (char* __s) __attribute__((__deprecated__));
# 96 "/usr/include/c++/6/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/6/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/6/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/6/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/6/cerrno" 1 3
# 39 "/usr/include/c++/6/cerrno" 3
       
# 40 "/usr/include/c++/6/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 24 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/bits/errno.h" 2 3 4
# 50 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 43 "/usr/include/c++/6/cerrno" 2 3
# 45 "/usr/include/c++/6/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 5403 "/usr/include/c++/6/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/6/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/6/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/6/bits/functional_hash.h" 3

# 1 "/usr/include/c++/6/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/6/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/6/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/usr/include/c++/6/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/6/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 108 "/usr/include/c++/6/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 171 "/usr/include/c++/6/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 5629 "/usr/include/c++/6/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}
# 53 "/usr/include/c++/6/string" 2 3
# 1 "/usr/include/c++/6/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/6/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/6/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1145 "/usr/include/c++/6/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/6/string" 2 3
# 41 "/usr/include/c++/6/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/6/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/6/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/6/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/6/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/6/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/6/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/6/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/6/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/6/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/6/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/6/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/6/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/6/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/include/c++/6/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/include/c++/6/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/include/c++/6/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/include/c++/6/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/include/c++/6/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/include/c++/6/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    class __shim;

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;
  };
# 482 "/usr/include/c++/6/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 640 "/usr/include/c++/6/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 667 "/usr/include/c++/6/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 681 "/usr/include/c++/6/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 698 "/usr/include/c++/6/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 717 "/usr/include/c++/6/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 731 "/usr/include/c++/6/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 760 "/usr/include/c++/6/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 774 "/usr/include/c++/6/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 787 "/usr/include/c++/6/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/6/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/6/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/6/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/6/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/6/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 851 "/usr/include/c++/6/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/6/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/6/system_error" 1 3
# 32 "/usr/include/c++/6/system_error" 3
       
# 33 "/usr/include/c++/6/system_error" 3






# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/error_constants.h" 1 3
# 34 "/usr/include/c++/6/x86_64-suse-linux/bits/error_constants.h" 3
# 1 "/usr/include/c++/6/cerrno" 1 3
# 39 "/usr/include/c++/6/cerrno" 3
       
# 40 "/usr/include/c++/6/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 43 "/usr/include/c++/6/cerrno" 2 3
# 35 "/usr/include/c++/6/x86_64-suse-linux/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/6/system_error" 2 3

# 1 "/usr/include/c++/6/stdexcept" 1 3
# 36 "/usr/include/c++/6/stdexcept" 3
       
# 37 "/usr/include/c++/6/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/6/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/include/c++/6/system_error" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };

  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 102 "/usr/include/c++/6/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };


}
# 47 "/usr/include/c++/6/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc e) noexcept
  { return error_code(static_cast<int>(e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc e) noexcept
  { return error_condition(static_cast<int>(e), iostream_category()); }
# 228 "/usr/include/c++/6/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/6/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/6/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/6/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/6/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/6/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/6/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "/usr/include/c++/6/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "/usr/include/c++/6/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "/usr/include/c++/6/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "/usr/include/c++/6/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "/usr/include/c++/6/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "/usr/include/c++/6/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "/usr/include/c++/6/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "/usr/include/c++/6/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "/usr/include/c++/6/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "/usr/include/c++/6/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "/usr/include/c++/6/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "/usr/include/c++/6/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "/usr/include/c++/6/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "/usr/include/c++/6/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "/usr/include/c++/6/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "/usr/include/c++/6/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/streambuf" 1 3
# 36 "/usr/include/c++/6/streambuf" 3
       
# 37 "/usr/include/c++/6/streambuf" 3
# 45 "/usr/include/c++/6/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/6/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/6/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/6/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/6/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/6/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/6/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/6/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/6/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/6/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/6/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/6/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/6/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/6/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/6/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/6/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/6/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/6/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/6/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/6/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/6/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/6/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/6/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/6/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/6/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/6/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/6/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/6/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/6/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/6/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/6/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/6/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/6/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/6/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/6/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/6/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/6/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/6/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/6/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "/usr/include/c++/6/streambuf" 2 3
# 44 "/usr/include/c++/6/ios" 2 3
# 1 "/usr/include/c++/6/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/6/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/6/bits/basic_ios.h" 3



# 1 "/usr/include/c++/6/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/6/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/6/bits/locale_facets.h" 3

# 1 "/usr/include/c++/6/cwctype" 1 3
# 39 "/usr/include/c++/6/cwctype" 3
       
# 40 "/usr/include/c++/6/cwctype" 3
# 50 "/usr/include/c++/6/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/include/c++/6/cwctype" 2 3
# 80 "/usr/include/c++/6/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/6/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/6/cctype" 1 3
# 39 "/usr/include/c++/6/cctype" 3
       
# 40 "/usr/include/c++/6/cctype" 3
# 41 "/usr/include/c++/6/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/6/x86_64-suse-linux/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/6/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/6/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/6/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/6/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/6/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/6/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/6/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/6/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/6/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/6/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/6/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/6/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "/usr/include/c++/6/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "/usr/include/c++/6/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1156 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/6/x86_64-suse-linux/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "/usr/include/c++/6/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "/usr/include/c++/6/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "/usr/include/c++/6/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "/usr/include/c++/6/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "/usr/include/c++/6/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "/usr/include/c++/6/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "/usr/include/c++/6/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "/usr/include/c++/6/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "/usr/include/c++/6/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "/usr/include/c++/6/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/6/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/6/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/6/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/6/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/6/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/6/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/6/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/6/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/6/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "/usr/include/c++/6/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/6/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/6/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/6/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/6/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/6/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/6/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/6/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/6/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/6/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/6/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/6/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/6/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/6/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/6/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/6/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/6/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/6/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/6/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/6/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/6/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/6/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/6/ios" 2 3
# 39 "/usr/include/c++/6/istream" 2 3
# 1 "/usr/include/c++/6/ostream" 1 3
# 36 "/usr/include/c++/6/ostream" 3
       
# 37 "/usr/include/c++/6/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/6/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/6/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/6/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/6/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "/usr/include/c++/6/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "/usr/include/c++/6/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "/usr/include/c++/6/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "/usr/include/c++/6/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 626 "/usr/include/c++/6/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}

# 1 "/usr/include/c++/6/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/6/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/6/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 639 "/usr/include/c++/6/ostream" 2 3
# 40 "/usr/include/c++/6/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/6/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/6/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/6/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/6/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/6/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/6/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/6/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/6/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/6/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/6/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/6/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/6/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/6/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/6/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/6/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/6/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/6/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/6/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/6/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/6/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/6/istream" 3
      int
      sync();
# 570 "/usr/include/c++/6/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/6/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/6/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/6/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/6/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 922 "/usr/include/c++/6/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}

# 1 "/usr/include/c++/6/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/6/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/6/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/include/c++/6/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 935 "/usr/include/c++/6/istream" 2 3
# 39 "/usr/include/c++/6/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/6/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/6/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/usr/include/c++/6/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "/usr/include/c++/6/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "/usr/include/c++/6/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "/usr/include/c++/6/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* __str = __from._M_string.data();
   if (__from.eback())
     {
     _M_goff[0] = __from.eback() - __str;
     _M_goff[1] = __from.gptr() - __str;
     _M_goff[2] = __from.egptr() - __str;
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 343 "/usr/include/c++/6/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 366 "/usr/include/c++/6/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 402 "/usr/include/c++/6/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 420 "/usr/include/c++/6/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 471 "/usr/include/c++/6/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 510 "/usr/include/c++/6/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 546 "/usr/include/c++/6/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 564 "/usr/include/c++/6/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 615 "/usr/include/c++/6/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 654 "/usr/include/c++/6/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 689 "/usr/include/c++/6/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 705 "/usr/include/c++/6/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 756 "/usr/include/c++/6/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/6/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/6/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/6/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/include/c++/6/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 814 "/usr/include/c++/6/sstream" 2 3
# 46 "/usr/include/c++/6/complex" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/6/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 121 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 172 "/usr/include/c++/6/complex" 3
      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);



      complex& operator=(const complex&) = default;



      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 570 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 606 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 636 "/usr/include/c++/6/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 770 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 862 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 906 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 934 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 963 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1097 "/usr/include/c++/6/complex" 3
      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1248 "/usr/include/c++/6/complex" 3
      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1400 "/usr/include/c++/6/complex" 3
      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1621 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1657 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1701 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1737 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1776 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1820 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);

  template<typename _Tp>
    std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    {
      const _Tp __den = (__z.real() * __z.real()
    + __z.imag() * __z.imag() + _Tp(1.0));

      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,
          (_Tp(2.0) * __z.imag()) / __den);
    }


  inline __complex__ float
  __complex_proj(__complex__ float __z)
  { return __builtin_cprojf(__z); }

  inline __complex__ double
  __complex_proj(__complex__ double __z)
  { return __builtin_cproj(__z); }

  inline __complex__ long double
  __complex_proj(const __complex__ long double& __z)
  { return __builtin_cprojl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z.__rep()); }
# 1925 "/usr/include/c++/6/complex" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    proj(_Tp __x)
    { return __x; }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    conj(_Tp __x)
    { return __x; }



inline namespace literals {
inline namespace complex_literals {



  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }

}
}




}
# 7 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/algorithm" 1 3
# 58 "/usr/include/c++/6/algorithm" 3
       
# 59 "/usr/include/c++/6/algorithm" 3

# 1 "/usr/include/c++/6/utility" 1 3
# 58 "/usr/include/c++/6/utility" 3
       
# 59 "/usr/include/c++/6/utility" 3
# 69 "/usr/include/c++/6/utility" 3
# 1 "/usr/include/c++/6/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/6/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/usr/include/c++/6/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/6/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/6/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/6/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/usr/include/c++/6/utility" 2 3
# 78 "/usr/include/c++/6/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;


  template<typename>
    struct __is_tuple_like_impl : false_type
    { };




  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



}
# 61 "/usr/include/c++/6/algorithm" 2 3

# 1 "/usr/include/c++/6/bits/stl_algo.h" 1 3
# 59 "/usr/include/c++/6/bits/stl_algo.h" 3
# 1 "/usr/include/c++/6/cstdlib" 1 3
# 39 "/usr/include/c++/6/cstdlib" 3
       
# 40 "/usr/include/c++/6/cstdlib" 3
# 60 "/usr/include/c++/6/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/6/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/6/bits/algorithmfwd.h" 3
       
# 34 "/usr/include/c++/6/bits/algorithmfwd.h" 3
# 42 "/usr/include/c++/6/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 194 "/usr/include/c++/6/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 552 "/usr/include/c++/6/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 581 "/usr/include/c++/6/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/include/c++/6/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/6/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
   __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
 __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 148 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_less_val());
    }
# 183 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 263 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_less_iter());
 }
    }
# 296 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 351 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 377 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 412 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 439 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 466 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last),
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 494 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last),
          __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 517 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 530 "/usr/include/c++/6/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
# 62 "/usr/include/c++/6/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/6/bits/stl_tempbuf.h" 1 3
# 60 "/usr/include/c++/6/bits/stl_tempbuf.h" 3
# 1 "/usr/include/c++/6/bits/stl_construct.h" 1 3
# 63 "/usr/include/c++/6/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "/usr/include/c++/6/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 61 "/usr/include/c++/6/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/include/c++/6/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/6/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/include/c++/6/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "/usr/include/c++/6/bits/stl_algo.h" 2 3



# 1 "/usr/include/c++/6/bits/uniform_int_dist.h" 1 3
# 35 "/usr/include/c++/6/bits/uniform_int_dist.h" 3
# 1 "/usr/include/c++/6/limits" 1 3
# 40 "/usr/include/c++/6/limits" 3
       
# 41 "/usr/include/c++/6/limits" 3
# 158 "/usr/include/c++/6/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/6/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/6/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 314 "/usr/include/c++/6/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1569 "/usr/include/c++/6/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1592 "/usr/include/c++/6/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/usr/include/c++/6/bits/uniform_int_dist.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 260 "/usr/include/c++/6/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 344 "/usr/include/c++/6/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }


}
# 67 "/usr/include/c++/6/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 598 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 665 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 697 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 731 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 794 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 822 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 891 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 924 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 990 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1020 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1175 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1202 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1429 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1466 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1543 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1646 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1732 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1746 "/usr/include/c++/6/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1781 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1797 "/usr/include/c++/6/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2018 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2072 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2102 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2173 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2209 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2242 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2275 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2569 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2610 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2782 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2821 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2865 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2900 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2949 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2981 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3049 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3081 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3131 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3165 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3204 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3218 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3247 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3271 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3296 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3317 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3397 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3425 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3537 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3568 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3661 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3688 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3716 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 3761 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
# 3782 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3806 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3837 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3877 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 3909 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3934 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 3959 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 3982 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4022 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4061 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4096 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4129 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4163 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4200 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4233 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4265 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4297 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4328 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4364 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4404 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4437 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4472 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4512 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4545 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4583 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4619 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4658 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4695 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4725 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4786 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4836 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 4900 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 4934 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5002 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5051 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5121 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5169 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5241 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5291 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5369 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5419 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5472 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5497 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5536 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5561 "/usr/include/c++/6/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


}
# 63 "/usr/include/c++/6/algorithm" 2 3
# 8 "tramp3d-v4.cpp" 2

# 1 "/usr/include/c++/6/math.h" 1 3
# 36 "/usr/include/c++/6/math.h" 3
# 1 "/usr/include/c++/6/cmath" 1 3
# 39 "/usr/include/c++/6/cmath" 3
       
# 40 "/usr/include/c++/6/cmath" 3
# 37 "/usr/include/c++/6/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 10 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/cstring" 1 3
# 39 "/usr/include/c++/6/cstring" 3
       
# 40 "/usr/include/c++/6/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib64/gcc/x86_64-suse-linux/6/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 90 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 206 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 229 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 256 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 308 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 335 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 377 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 433 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 482 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 510 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 656 "/usr/include/string.h" 3 4
}
# 43 "/usr/include/c++/6/cstring" 2 3
# 71 "/usr/include/c++/6/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/6/cstring" 3

}
# 11 "tramp3d-v4.cpp" 2


# 12 "tramp3d-v4.cpp"
namespace Smarts {
template<class T>
class IterateScheduler;
template<class T>
class Iterate;
template<class T>
class DataObject;
}
namespace Smarts {
class Runnable
{
public:
  Runnable()
  {
    priority_m = 0;
  }
  Runnable(int)
  {
    priority_m = 0;
  }
  virtual ~Runnable() {}
  inline int
  priority() { return priority_m; }
  inline void
  priority(int _priority) { priority_m = _priority; }
  virtual void execute()
  {
    run();
  }
protected:
  virtual void run() {}
private:
  int priority_m;
};
typedef Runnable *RunnablePtr_t;
inline void add(RunnablePtr_t);
}
namespace Smarts {
class Stub
{
public:
  enum Action { Read, Write };
};
template<> class Iterate<Stub>;
template<> class IterateScheduler<Stub>;
template<> class DataObject<Stub>;
template<>
class Iterate<Stub> : public Runnable
{
public:
  inline Iterate(IterateScheduler<Stub> & scheduler, int affinity=-1);
  virtual ~Iterate() {}
  virtual void run() = 0;
  int affinity() { return 0; }
  int hintAffinity() { return 0; }
  void affinity(int) {}
  void hintAffinity(int) {}
  void generation(int gen) { generation_m=gen; }
  int generation() { return generation_m; }
protected:
  IterateScheduler<Stub> &scheduler_m;
private:
  int generation_m;
};
template<>
class IterateScheduler<Stub>
{
public:
  inline
  void beginGeneration() { generation_m++; }
  inline
  void endGeneration() {}
  inline
  void blockingEvaluate() {}
  inline
  void releaseIterates() { }
  inline
  IterateScheduler()
    : generation_m(0)
  { }
  inline
  ~IterateScheduler() {}
  inline int generation() const { return generation_m; }
  inline
  void handOff(Iterate<Stub>* it)
  {
    it->run();
    delete it;
  }
protected:
private:
  int generation_m;
};
inline Iterate<Stub>::Iterate(IterateScheduler<Stub> & scheduler, int)
  : scheduler_m(scheduler)
{
  generation(scheduler.generation());
}
template<>
class DataObject<Stub>
{
public:
    inline DataObject(int=-1) {}
    inline int affinity() const { return 0; };
    inline void affinity(int) {}
    inline void request(Iterate<Stub>&, Stub::Action) {}
    inline void release(Stub::Action) {}
protected:
private:
};
inline void concurrency(int)
{
}
inline int concurrency()
{
  return 1;
}
inline void wait()
{
}
inline void add(Runnable *runnable)
{
  runnable->execute();
  delete runnable;
}
}
namespace Pooma {
  typedef Smarts::Stub SmartsTag_t;
}
namespace Pooma {
static const char schedulerVersion[] = "stub scheduler";
typedef Smarts::IterateScheduler<SmartsTag_t> Scheduler_t;
typedef Smarts::DataObject<SmartsTag_t> DataObject_t;
typedef Smarts::Iterate<SmartsTag_t> Iterate_t;
typedef Smarts::Runnable Runnable_t;
inline void addRunnable(Runnable_t *runnable)
{
  Smarts::add(runnable);
}
}
namespace Pooma {
class Assertion
{
  char *msg_m;
  char *file_m;
  int line_m;
public:
  Assertion(const char *msg, const char *file, int line);
  Assertion(const Assertion &a);
  ~Assertion() { delete[] msg_m; delete [] file_m; }
  Assertion &operator=(const Assertion &a);
  const char *what() const { return msg_m; }
  const char *file() const { return file_m; }
  int line() const { return line_m; }
  template<class OS>
  void print(OS &os) const
  {
    os << "### POOMA Assertion Failure ###\n";
    os << "### " << what() << "\n";
    os << "### File " << file() << "; Line " << line();
  }
};
void toss_cookies(const char *msg, const char *file, int line ...) __attribute__((noreturn));
}
template<bool B> struct PoomaCTAssert {};
template<> struct PoomaCTAssert<true> { static inline void test() {} };
template<class T1, class T2>
struct SameType
{
  enum { same = false };
};
template<class T1>
struct SameType<T1, T1>
{
  enum { same = true };
};
namespace Pooma {
  class DummyMutex
  {
  public:
    inline DummyMutex() { }
    inline DummyMutex(const DummyMutex &) { }
    inline DummyMutex &operator=(const DummyMutex &) { return *this; }
    inline void lock() { }
    inline void unlock() { }
  };
  typedef DummyMutex Mutex_t;
}
# 1 "/usr/include/c++/6/iostream" 1 3
# 36 "/usr/include/c++/6/iostream" 3
       
# 37 "/usr/include/c++/6/iostream" 3






# 42 "/usr/include/c++/6/iostream" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/6/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 201 "tramp3d-v4.cpp" 2
# 1 "/usr/include/c++/6/map" 1 3
# 58 "/usr/include/c++/6/map" 3
       
# 59 "/usr/include/c++/6/map" 3

# 1 "/usr/include/c++/6/bits/stl_tree.h" 1 3
# 61 "/usr/include/c++/6/bits/stl_tree.h" 3
       
# 62 "/usr/include/c++/6/bits/stl_tree.h" 3







# 1 "/usr/include/c++/6/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/6/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/6/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };






  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}
# 70 "/usr/include/c++/6/bits/stl_tree.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "/usr/include/c++/6/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 153 "/usr/include/c++/6/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Cmp, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Cmp, typename _SfinaeType>
    struct __has_is_transparent<_Cmp, _SfinaeType,
    __void_t<typename _Cmp::is_transparent>>
    { typedef void type; };


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
   : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 536 "/usr/include/c++/6/bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   try
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
       throw;
     }
 }

      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();
      }


      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:

      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }


   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
     _M_header(), _M_node_count(0)
   { _M_initialize(); }


   void
   _M_reset()
   {
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
     this->_M_node_count = 0;
   }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
        iterator
        _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
        iterator
        _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 789 "/usr/include/c++/6/bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      _Link_type
      _M_copy(_Const_Link_type __x, _Base_ptr __p)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __p, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare,
         _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      _Rb_tree(_Rb_tree&& __x)
      : _M_impl(__x._M_impl._M_key_compare,
  std::move(__x._M_get_Node_allocator()))
      {
 if (__x._M_root() != 0)
   _M_move_data(__x, std::true_type());
      }

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
        pair<iterator, bool>
        _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
# 1011 "/usr/include/c++/6/bits/stl_tree.h" 3
      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1059 "/usr/include/c++/6/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1081 "/usr/include/c++/6/bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
        _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_find_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_find_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_find_tr(const _Kt& __k) const
 {
   auto __j = _M_lower_bound_tr(__k);
   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
     __j = end();
   return __j;
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 size_type
 _M_count_tr(const _Kt& __k) const
 {
   auto __p = _M_equal_range_tr(__k);
   return std::distance(__p.first, __p.second);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_lower_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_lower_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (!_M_impl._M_key_compare(_S_key(__x), __k))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_upper_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_upper_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (_M_impl._M_key_compare(__k, _S_key(__x)))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 pair<iterator, iterator>
 _M_equal_range_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   auto __ret = __const_this->_M_equal_range_tr(__k);
   return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 pair<const_iterator, const_iterator>
 _M_equal_range_tr(const _Kt& __k) const
 {
   auto __low = _M_lower_bound_tr(__k);
   auto __high = __low;
   auto& __cmp = _M_impl._M_key_compare;
   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
     ++__high;
   return { __low, __high };
 }



      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree&, std::true_type);



      void
      _M_move_data(_Rb_tree&, std::false_type);


      void
      _M_move_assign(_Rb_tree&, std::true_type);



      void
      _M_move_assign(_Rb_tree&, std::false_type);

    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = typename _Alloc_traits::is_always_equal;
      if (__x._M_root() != nullptr)
 _M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::true_type)
    {
      _M_root() = __x._M_root();
      _M_leftmost() = __x._M_leftmost();
      _M_rightmost() = __x._M_rightmost();
      _M_root()->_M_parent = _M_end();

      __x._M_root() = 0;
      __x._M_leftmost() = __x._M_end();
      __x._M_rightmost() = __x._M_end();

      this->_M_impl._M_node_count = __x._M_impl._M_node_count;
      __x._M_impl._M_node_count = 0;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
   _M_move_data(__x, std::true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
   _M_leftmost() = _S_minimum(_M_root());
   _M_rightmost() = _S_maximum(_M_root());
   _M_impl._M_node_count = __x._M_impl._M_node_count;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, std::true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
   _M_leftmost() = _S_minimum(_M_root());
   _M_rightmost() = _S_maximum(_M_root());
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = __x._M_impl._M_key_compare;
      constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
      _M_move_assign(__x, __bool_constant<__move_storage>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end(), __roan);
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 try
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 catch(...)
   {
     _M_erase(__top);
     throw;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();
       _M_impl._M_node_count = __t._M_impl._M_node_count;

       __t._M_impl._M_reset();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();
   __t._M_impl._M_node_count = _M_impl._M_node_count;

   _M_impl._M_reset();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
# 61 "/usr/include/c++/6/map" 2 3
# 1 "/usr/include/c++/6/bits/stl_map.h" 1 3
# 63 "/usr/include/c++/6/bits/stl_map.h" 3
# 1 "/usr/include/c++/6/tuple" 1 3
# 32 "/usr/include/c++/6/tuple" 3
       
# 33 "/usr/include/c++/6/tuple" 3






# 1 "/usr/include/c++/6/array" 1 3
# 32 "/usr/include/c++/6/array" 3
       
# 33 "/usr/include/c++/6/array" 3
# 43 "/usr/include/c++/6/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 89 "/usr/include/c++/6/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/6/tuple" 2 3
# 1 "/usr/include/c++/6/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/6/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }


}
# 41 "/usr/include/c++/6/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 158 "/usr/include/c++/6/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };

  template<typename... _Elements>
    class tuple;



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements)),
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
# 64 "/usr/include/c++/6/bits/stl_map.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 94 "/usr/include/c++/6/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 185 "/usr/include/c++/6/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 196 "/usr/include/c++/6/bits/stl_map.h" 3
      map(map&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 211 "/usr/include/c++/6/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 255 "/usr/include/c++/6/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 272 "/usr/include/c++/6/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 295 "/usr/include/c++/6/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      map&
      operator=(map&&) = default;
# 318 "/usr/include/c++/6/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 473 "/usr/include/c++/6/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 518 "/usr/include/c++/6/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 556 "/usr/include/c++/6/bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 586 "/usr/include/c++/6/bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 730 "/usr/include/c++/6/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        std::pair<iterator, bool>
        insert(_Pair&& __x)
        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
# 751 "/usr/include/c++/6/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 779 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_unique_(__position,
     std::forward<_Pair>(__x)); }
# 805 "/usr/include/c++/6/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 943 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 979 "/usr/include/c++/6/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 999 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 1031 "/usr/include/c++/6/bits/stl_map.h" 3
      void
      swap(map& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 1078 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 1103 "/usr/include/c++/6/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 1124 "/usr/include/c++/6/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
# 1148 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
# 1173 "/usr/include/c++/6/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
# 1193 "/usr/include/c++/6/bits/stl_map.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
# 1213 "/usr/include/c++/6/bits/stl_map.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
# 1242 "/usr/include/c++/6/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }
# 1271 "/usr/include/c++/6/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 1305 "/usr/include/c++/6/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1322 "/usr/include/c++/6/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 62 "/usr/include/c++/6/map" 2 3
# 1 "/usr/include/c++/6/bits/stl_multimap.h" 1 3
# 64 "/usr/include/c++/6/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 92 "/usr/include/c++/6/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      multimap()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 183 "/usr/include/c++/6/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 194 "/usr/include/c++/6/bits/stl_multimap.h" 3
      multimap(multimap&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 208 "/usr/include/c++/6/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 251 "/usr/include/c++/6/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 267 "/usr/include/c++/6/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 290 "/usr/include/c++/6/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      multimap&
      operator=(multimap&&) = default;
# 313 "/usr/include/c++/6/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 471 "/usr/include/c++/6/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 498 "/usr/include/c++/6/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 519 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(_Pair&& __x)
        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
# 552 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_equal_(__position,
           std::forward<_Pair>(__x)); }
# 579 "/usr/include/c++/6/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 592 "/usr/include/c++/6/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 613 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 649 "/usr/include/c++/6/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 670 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 705 "/usr/include/c++/6/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 751 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 775 "/usr/include/c++/6/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 793 "/usr/include/c++/6/bits/stl_multimap.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 817 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
# 842 "/usr/include/c++/6/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
# 862 "/usr/include/c++/6/bits/stl_multimap.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
# 882 "/usr/include/c++/6/bits/stl_multimap.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
# 909 "/usr/include/c++/6/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }
# 936 "/usr/include/c++/6/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 970 "/usr/include/c++/6/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 987 "/usr/include/c++/6/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/6/map" 2 3
# 202 "tramp3d-v4.cpp" 2

# 202 "tramp3d-v4.cpp"
class InformStream;
class Inform
{
public:
  typedef int ID_t;
  typedef int Level_t;
  typedef int Context_t;
  enum { out, app };
  enum { allContexts = (-1) };
  enum { off = (-1), on = 0 };
  Inform(const char *prefix = 0, Context_t outputContext = 0);
  Inform(const char *prefix, const char *fname, int writemode,
  Context_t outputContext = 0);
  Inform(const char *prefix, std::ostream &outstream,
  Context_t outputContext = 0);
  ~Inform();
  const std::string &prefix() const { return prefix_m; }
  void setPrefix(const char *prefix = 0);
  ID_t open(Context_t context = 0);
  ID_t open(const char *fname, int writemode, Context_t context = 0);
  ID_t open(std::ostream &outstream, Context_t context = 0);
  void close(ID_t);
  void close();
  Level_t messageLevel() const { return level_m; }
  Inform &setMessageLevel(Level_t newval) { level_m = newval; return *this; }
  Level_t outputLevel(ID_t id = 0) const;
  void setOutputLevel(Level_t newval, ID_t id);
  void setOutputLevel(Level_t newval);
  Context_t outputContext(ID_t id = 0) const;
  void setOutputContext(Context_t outputContext, ID_t id);
  void setOutputContext(Context_t outputContext);
  inline static Context_t context() { return context_s; }
  inline static Context_t numContexts() { return nContexts_s; }
  static inline void setContext(Context_t c) { context_s = c; }
  static inline void setNumContexts(Context_t n) { nContexts_s = n; }
  void flush();
  void print() { flush(); }
  void output() { flush(); }
  typedef std::ios_base::fmtflags FmtFlags_t;
  std::ostream& stream() { return *message_m; }
  FmtFlags_t
    setf(FmtFlags_t setbits,FmtFlags_t field)
    { return message_m->setf(setbits,field);}
  FmtFlags_t
    setf(FmtFlags_t f) { return message_m->setf(f); }
  void unsetf(FmtFlags_t f) { message_m->unsetf(f); }
  long flags() const { return message_m->flags(); }
  long flags(FmtFlags_t f) { return message_m->flags(f); }
  int width() const { return message_m->width(); }
  int width(int w) { return message_m->width(w); }
  char fill() const { return message_m->fill(); }
  char fill(char c) { return message_m->fill(c); }
  int precision() const { return message_m->precision(); }
  int precision(int p) { return message_m->precision(p); }
  void lock() const { mutex_m.lock(); }
  void unlock() const { mutex_m.unlock(); }
private:
  typedef std::map<ID_t, InformStream *> StreamList_t;
  typedef StreamList_t::size_type Size_t;
  typedef StreamList_t::value_type Value_t;
  typedef StreamList_t::iterator iterator;
  typedef StreamList_t::const_iterator const_iterator;
  std::string prefix_m;
  Context_t outputContext_m;
  Level_t level_m;
  StreamList_t streams_m;
  std::ostringstream *message_m;
  char *buffer_m;
  static const unsigned int bufSize;
  ID_t nextID_m;
  mutable Pooma::Mutex_t mutex_m;
  static Pooma::Mutex_t outputMutex_s;
  static Context_t context_s;
  static Context_t nContexts_s;
  InformStream *findStream(ID_t) const;
  void setup(const char *prefix);
};
namespace std {
  extern Inform &endl(Inform &);
  extern Inform &flush(Inform &);
  extern Inform &lock(Inform &);
  extern Inform &unlock(Inform &);
}
inline Inform &operator<<(Inform &o, Inform &(*d)(Inform &))
{
  return d(o);
}
inline Inform &operator<<(Inform &o, std::ios_base &(*d)(std::ios_base &))
{
  d(o.stream());
  return o;
}
template<class T>
inline Inform &operator<<(Inform &o, const T &val)
{
  o.stream() << val;
  return o;
}
inline Inform &operator<<(Inform &o, const void *val)
{
  Inform::FmtFlags_t oldformat =
    o.setf(std::ios::hex, std::ios::basefield);
  o.stream() << "0x" << reinterpret_cast<long>(val);
  o.setf(oldformat, std::ios::basefield);
  return o;
}
inline Inform &operator<<(Inform &o, const char *s)
{
  o.stream() << s;
  return o;
}
inline Inform &operator<<(Inform &o, const std::string &s)
{
  o.stream() << s.c_str();
  return o;
}
# 1 "/usr/include/c++/6/iterator" 1 3
# 58 "/usr/include/c++/6/iterator" 3
       
# 59 "/usr/include/c++/6/iterator" 3







# 1 "/usr/include/c++/6/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/6/bits/stream_iterator.h" 3
       
# 34 "/usr/include/c++/6/bits/stream_iterator.h" 3




# 37 "/usr/include/c++/6/bits/stream_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "/usr/include/c++/6/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 183 "/usr/include/c++/6/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "/usr/include/c++/6/iterator" 2 3
# 319 "tramp3d-v4.cpp" 2

# 319 "tramp3d-v4.cpp"
template <class T>
class InformIterator
{
public:
  typedef std::output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;
  InformIterator(Inform &s) : out_m(&s), delim_m(0) { }
  InformIterator(Inform &s, const char *d) : out_m(&s), delim_m(d) { }
  InformIterator &operator=(const T &value)
  {
    *out_m << value;
    if (delim_m != 0)
      *out_m << delim_m;
    return *this;
  }
  InformIterator &operator*() { return *this; }
  InformIterator &operator++() { return *this; }
  InformIterator &operator++(int) { return *this; }
private:
  Inform *out_m;
  const char *delim_m;
};
namespace Pooma {
class Options
{
public:
  Options();
  Options(int &argc, char ** argv);
  Options(const Options &opts);
  Options &operator=(const Options &opts);
  ~Options();
  int concurrency() const { return concurrency_m; }
  void concurrency(int c)
    {
      ;
      concurrency_m = c;
    }
  bool printInfo() const { return info_m; }
  void printInfo(bool p) { info_m = p; }
  bool printWarnings() const { return warn_m; }
  void printWarnings(bool p) { warn_m = p; }
  bool printErrors() const { return err_m; }
  void printErrors(bool p) { err_m = p; }
  const std::string &logfile() const { return logfile_m; }
  void logfile(const std::string &s) { logfile_m = s; }
  bool printStats() const { return stats_m; }
  void printStats(bool p) { stats_m = p; }
  int debug() const { return debug_m; }
  void debug(int p) { debug_m = p; }
  bool neverCompress() const { return neverCompress_m; }
  void neverCompress(bool p) { neverCompress_m = p; }
  bool deferredGuardFills() const { return deferredFills_m; }
  void deferredGuardFills(bool p) { deferredFills_m = p; }
  bool hardInit() const { return hardinit_m; }
  void hardInit(bool p) { hardinit_m = p; }
  bool hardRun() const { return hardrun_m; }
  void hardRun(bool p) { hardrun_m = p; }
  bool lockThreads() const { return lockthreads_m; }
  void lockThreads(bool p) { lockthreads_m = p; }
  bool blockingExpressions() const { return blockingExpressions_m; }
  void blockingExpressions(bool p) { blockingExpressions_m = p; }
  void usage();
  void reset();
  void parse(int &argc, char ** &argv);
private:
  int concurrency_m;
  bool info_m;
  bool warn_m;
  bool err_m;
  std::string logfile_m;
  bool stats_m;
  int debug_m;
  bool neverCompress_m;
  bool deferredFills_m;
  bool hardinit_m;
  bool hardrun_m;
  bool lockthreads_m;
  bool blockingExpressions_m;
};
bool intArgument(int argc, char **argv, int pos, int &val);
bool stringArgument(int argc, char **argv, int pos, std::string &val);
bool doubleArgument(int argc, char **argv, int pos, double &val);
}
namespace Pooma {
  typedef void (*AbortHandler_t)();
  typedef int Context_t;
  typedef int PatchID_t;
  namespace Arch {
    inline void dawdle() { }
    inline void getCommandLineArguments(int &, char** &) { }
    inline void initialize() { }
    inline void finalize() { }
  }
  void incrementNumExpressions(long val = 1);
  void incrementNumMultiPatchExpressions(long val = 1);
  void incrementNumZBExpressions(long val = 1);
  void incrementNumCompressedAssigns(long val = 1);
  void incrementNumAssignsRequiringUnCompression(long val = 1);
  void incrementNumInlineEvaluations(long val = 1);
  void incrementNumLocalPatchesEvaluated(long val = 1);
  void incrementNumReductions(long val = 1);
  void incrementNumUnCompresses(long val = 1);
  void incrementNumUnsuccessfulTryCompresses(long val = 1);
  void incrementNumSuccessfulTryCompresses(long val = 1);
  void incrementNumPolls(long val = 1);
  extern Inform pinfo;
  extern Inform pwarn;
  extern Inform perr;
  extern Inform pdebug;
  bool initialize(int &argc, char ** &argv,
    bool initRTS = true, bool getCLArgsArch = true, bool initArch = true);
  bool initialize(Pooma::Options &opts, bool initRTS = true,
    bool initArch = true);
  bool finalize();
  bool finalize(bool quitRTS, bool quitArch);
  void pAbort(int errorcode = 0) __attribute__((noreturn));
  void pAbort(const char *msg, int errorcode = 0) __attribute__((noreturn));
  void stopHere();
  AbortHandler_t abortHandler();
  AbortHandler_t abortHandler(AbortHandler_t);
  AbortHandler_t resetAbortHandler();
  const char *version();
  int majorVersion();
  int minorVersion();
  const char *buildDate();
  bool printStats();
  void printStats(bool on);
  bool infoMessages();
  void infoMessages(bool on);
  bool warnMessages();
  void warnMessages(bool on);
  bool errorMessages();
  void errorMessages(bool on);
  void logMessages(const char *filename);
  int debugLevel();
  void debugLevel(int val);
  bool neverCompress();
  void neverCompress(bool p);
  bool deferredGuardFills();
  void deferredGuardFills(bool p);
  extern Context_t myContext_g;
  extern int numContexts_g;
  extern int expression_g;
  inline Context_t context() { return myContext_g; }
  inline int contexts() { return numContexts_g; }
  Scheduler_t &scheduler();
  void blockAndEvaluate();
  bool hardInit();
  void hardInit(bool on);
  bool hardRun();
  void hardRun(bool on);
  bool lockThreads();
  void lockThreads(bool on);
  bool blockingExpressions();
  void blockingExpressions(bool on);
  inline void beginExpression()
  {
    scheduler().beginGeneration();
  }
  inline void endExpression()
  {
    scheduler().endGeneration();
    expression_g++;
    if (blockingExpressions())
      blockAndEvaluate();
  }
  inline int expression()
  {
    return expression_g;
  }
inline void poll()
{
    ;
}
}
template<int Dim, class T, class EngineTag> class Array;
template<int Dim, class T, class EngineTag> class Engine;
template<class Subject, class Sub1, bool SV>
struct View1Implementation;
template <class LayoutTag, class PatchTag>
struct MultiPatch;
template <class LayoutTag, class PatchTag, int Dim2>
struct MultiPatchView;
template<class Expr>
struct ExpressionTag;
template <int Dim, class T, class EngineTag>
class Engine;
template <class Engine, class SubDomain>
struct NewEngine
{
};
template <class Engine, class SubDomain>
struct NewEngineEngine
{
  typedef Engine Type_t;
  static inline
  const Engine &apply(const Engine &e, const SubDomain &)
  {
    return e;
  }
} ;
template <class Engine, class SubDomain>
struct NewEngineDomain
{
  typedef SubDomain Type_t;
  typedef const SubDomain &Return_t;
  static inline
  Return_t apply(const Engine &, const SubDomain &i)
  {
    return i;
  }
} ;
template<class Eng, class Dom>
inline typename NewEngineEngine<Eng, Dom>::Type_t
newEngineEngine(const Eng &e, const Dom &dom)
{
  return NewEngineEngine<Eng, Dom>::apply(e, dom);
}
template<class Eng, class Dom>
inline typename NewEngineDomain<Eng, Dom>::Type_t
newEngineDomain(const Eng &e, const Dom &dom)
{
  return NewEngineDomain<Eng, Dom>::apply(e, dom);
}
struct EngineConstructTag
{
  EngineConstructTag() { };
  ~EngineConstructTag() { };
  EngineConstructTag(const EngineConstructTag &) { };
  EngineConstructTag &operator=(const EngineConstructTag &) { return *this; }
};
template<class T>
class Scalar
{
public:
  inline
  Scalar() { }
  inline
  Scalar(const T &t) : scalar_m(t) { }
  template<class T1>
  inline
  explicit Scalar(const T1 &t) : scalar_m(t) { }
  template<class Arg>
  inline
  Scalar(const Scalar<T> &s, const Arg &)
    : scalar_m(s.scalar_m) { }
  template<class Arg1, class Arg2>
  inline
  Scalar(const Scalar<T> &s, const Arg1 &, const Arg2 &)
    : scalar_m(s.scalar_m) { }
  inline
  Scalar(const Scalar<T> &s) : scalar_m(s.scalar_m) { }
  inline
  const T &value() const { return scalar_m; }
  inline
  Scalar<T> &operator=(const Scalar<T> &rhs)
  {
    scalar_m = rhs.scalar_m;
    return *this;
  }
  inline
  Scalar<T> &operator=(const T &rhs)
  {
    scalar_m = rhs;
    return *this;
  }
private:
  T scalar_m;
};
template<class T, class Op>
struct UnaryReturn {
  typedef T Type_t;
};
template<class T1, class T2>
struct Promote { typedef T1 Type_t; };
template<>
struct Promote<bool, bool> {
  typedef bool Type_t;
};
template<>
struct Promote<bool, char> {
  typedef char Type_t;
};
template<>
struct Promote<bool, short> {
  typedef short Type_t;
};
template<>
struct Promote<bool, int> {
  typedef int Type_t;
};
template<>
struct Promote<bool, long> {
  typedef long Type_t;
};
template<>
struct Promote<bool, float> {
  typedef float Type_t;
};
template<>
struct Promote<bool, double> {
  typedef double Type_t;
};
template<>
struct Promote<char, bool> {
  typedef char Type_t;
};
template<>
struct Promote<char, char> {
  typedef char Type_t;
};
template<>
struct Promote<char, short> {
  typedef short Type_t;
};
template<>
struct Promote<char, int> {
  typedef int Type_t;
};
template<>
struct Promote<char, long> {
  typedef long Type_t;
};
template<>
struct Promote<char, float> {
  typedef float Type_t;
};
template<>
struct Promote<char, double> {
  typedef double Type_t;
};
template<>
struct Promote<short, bool> {
  typedef short Type_t;
};
template<>
struct Promote<short, char> {
  typedef short Type_t;
};
template<>
struct Promote<short, short> {
  typedef short Type_t;
};
template<>
struct Promote<short, int> {
  typedef int Type_t;
};
template<>
struct Promote<short, long> {
  typedef long Type_t;
};
template<>
struct Promote<short, float> {
  typedef float Type_t;
};
template<>
struct Promote<short, double> {
  typedef double Type_t;
};
template<>
struct Promote<int, bool> {
  typedef int Type_t;
};
template<>
struct Promote<int, char> {
  typedef int Type_t;
};
template<>
struct Promote<int, short> {
  typedef int Type_t;
};
template<>
struct Promote<int, int> {
  typedef int Type_t;
};
template<>
struct Promote<int, long> {
  typedef long Type_t;
};
template<>
struct Promote<int, float> {
  typedef float Type_t;
};
template<>
struct Promote<int, double> {
  typedef double Type_t;
};
template<>
struct Promote<long, bool> {
  typedef long Type_t;
};
template<>
struct Promote<long, char> {
  typedef long Type_t;
};
template<>
struct Promote<long, short> {
  typedef long Type_t;
};
template<>
struct Promote<long, int> {
  typedef long Type_t;
};
template<>
struct Promote<long, long> {
  typedef long Type_t;
};
template<>
struct Promote<long, float> {
  typedef float Type_t;
};
template<>
struct Promote<long, double> {
  typedef double Type_t;
};
template<>
struct Promote<float, bool> {
  typedef float Type_t;
};
template<>
struct Promote<float, char> {
  typedef float Type_t;
};
template<>
struct Promote<float, short> {
  typedef float Type_t;
};
template<>
struct Promote<float, int> {
  typedef float Type_t;
};
template<>
struct Promote<float, long> {
  typedef float Type_t;
};
template<>
struct Promote<float, float> {
  typedef float Type_t;
};
template<>
struct Promote<float, double> {
  typedef double Type_t;
};
template<>
struct Promote<double, bool> {
  typedef double Type_t;
};
template<>
struct Promote<double, char> {
  typedef double Type_t;
};
template<>
struct Promote<double, short> {
  typedef double Type_t;
};
template<>
struct Promote<double, int> {
  typedef double Type_t;
};
template<>
struct Promote<double, long> {
  typedef double Type_t;
};
template<>
struct Promote<double, float> {
  typedef double Type_t;
};
template<>
struct Promote<double, double> {
  typedef double Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn {
  typedef typename Promote<T1, T2>::Type_t Type_t;
};
template<class T1, class T2, class T3, class Op>
struct TrinaryReturn {
  typedef typename BinaryReturn<T2, T3, Op>::Type_t Type_t;
};
template<class T>
struct Reference
{
  typedef T Type_t;
  inline
  Reference(const T &reference)
    : reference_m(reference)
  { }
  inline
  Reference(const Reference<T> &model)
    : reference_m(model.reference())
  { }
  inline
  const T &reference() const
  {
    return reference_m;
  }
  operator const T& () const { return reference_m; }
  operator T& () const { return const_cast<T&>(reference_m); }
  const T &reference_m;
};
template<class T>
struct DeReference
{
  typedef const T &Return_t;
  typedef T Type_t;
  static inline Return_t apply(const T &a) { return a; }
};
template<class T>
struct DeReference<Reference<T> >
{
  typedef const T &Return_t;
  typedef T Type_t;
  static inline Return_t apply(const Reference<T> &a) { return a.reference(); }
};
template<class Op, class Child>
class UnaryNode
{
public:
  inline
  typename DeReference<Child>::Return_t
  child() const { return DeReference<Child>::apply(child_m); }
  inline
  UnaryNode(const Child &c)
    : child_m(c) { }
  inline
  UnaryNode(const UnaryNode<Op, Child> &t)
    : child_m(t.child()) { }
  template<class OtherChild>
  inline
  UnaryNode(const UnaryNode<Op, OtherChild> &t)
    : child_m(t.child()) { }
  template<class OtherChild, class Arg>
  inline
  UnaryNode(const UnaryNode<Op, OtherChild> &t, const Arg &a)
    : child_m(t.child(), a) { }
  template<class OtherChild, class Arg1, class Arg2>
  inline
  UnaryNode(const UnaryNode<Op, OtherChild> &t,
     const Arg1 &a1, const Arg2 &a2)
    : child_m(t.child(), a1, a2)
    { }
private:
  Child child_m;
};
template<class Op, class Left, class Right>
class BinaryNode
{
public:
  inline
  typename DeReference<Left>::Return_t
  left() const { return DeReference<Left>::apply(left_m); }
  inline
  typename DeReference<Right>::Return_t
  right() const { return DeReference<Right>::apply(right_m); }
  inline
  BinaryNode(const Left &l, const Right &r)
    : left_m(l), right_m(r)
  { }
  inline
  BinaryNode(const BinaryNode<Op, Left, Right> &t)
    : left_m(t.left()), right_m(t.right())
  { }
  template<class OtherLeft, class OtherRight>
  inline
  BinaryNode(const BinaryNode<Op, OtherLeft, OtherRight> &t)
    : left_m(t.left()), right_m(t.right())
  { }
  template<class OtherLeft, class OtherRight, class Arg>
  inline
  BinaryNode(const BinaryNode<Op, OtherLeft, OtherRight> &t,
      const Arg &a)
    : left_m(t.left(), a), right_m(t.right(), a)
  { }
  template<class OtherLeft, class OtherRight, class Arg1, class Arg2>
  inline
  BinaryNode(const BinaryNode<Op, OtherLeft, OtherRight> &t,
      const Arg1 &a1, const Arg2 &a2)
    : left_m(t.left(), a1, a2), right_m(t.right(), a1, a2)
  { }
private:
  Left left_m;
  Right right_m;
};
template< class Op, class Left, class Middle, class Right>
class TrinaryNode
{
public:
  inline
  typename DeReference<Left>::Return_t
  left() const { return DeReference<Left>::apply(left_m); }
  inline
  typename DeReference<Right>::Return_t
  right() const { return DeReference<Right>::apply(right_m); }
  inline
  typename DeReference<Middle>::Return_t
  middle() const { return DeReference<Middle>::apply(middle_m); }
  inline
  TrinaryNode(const Left &l, const Middle &m, const Right &r)
    : left_m(l), middle_m(m), right_m(r)
  { }
  inline
  TrinaryNode(const TrinaryNode<Op, Left, Middle, Right> &t)
    : left_m(t.left()), middle_m(t.middle()), right_m(t.right())
  { }
  template<class OtherLeft, class OtherMiddle, class OtherRight>
  inline
  TrinaryNode(const TrinaryNode<Op, OtherLeft, OtherMiddle, OtherRight> & t)
    : left_m(t.left()), middle_m(t.middle()), right_m(t.right())
  { }
  template<class OtherLeft, class OtherMiddle, class OtherRight, class Arg>
  inline
  TrinaryNode(const TrinaryNode<Op, OtherLeft, OtherMiddle, OtherRight> &t,
       const Arg &a)
    : left_m(t.left(), a), middle_m(t.middle(), a), right_m(t.right(), a)
  { }
  template<class OtherLeft, class OtherMiddle, class OtherRight,
    class Arg1, class Arg2>
  inline
  TrinaryNode(const TrinaryNode<Op, OtherLeft, OtherMiddle, OtherRight> &t,
       const Arg1 &a1, const Arg2 &a2)
    : left_m(t.left(), a1, a2),
      middle_m(t.middle(), a1, a2) , right_m(t.right(), a1, a2)
  { }
private:
  Left left_m;
  Middle middle_m;
  Right right_m;
};
struct FnArcCos
{

  template<class T>
  inline typename UnaryReturn<T, FnArcCos >::Type_t
  operator()(const T &a) const
  {
    return (acos(a));
  }
};
struct FnArcSin
{

  template<class T>
  inline typename UnaryReturn<T, FnArcSin >::Type_t
  operator()(const T &a) const
  {
    return (asin(a));
  }
};
struct FnArcTan
{

  template<class T>
  inline typename UnaryReturn<T, FnArcTan >::Type_t
  operator()(const T &a) const
  {
    return (atan(a));
  }
};
struct FnCeil
{

  template<class T>
  inline typename UnaryReturn<T, FnCeil >::Type_t
  operator()(const T &a) const
  {
    return (ceil(a));
  }
};
struct FnCos
{

  template<class T>
  inline typename UnaryReturn<T, FnCos >::Type_t
  operator()(const T &a) const
  {
    return (cos(a));
  }
};
struct FnHypCos
{

  template<class T>
  inline typename UnaryReturn<T, FnHypCos >::Type_t
  operator()(const T &a) const
  {
    return (cosh(a));
  }
};
struct FnExp
{

  template<class T>
  inline typename UnaryReturn<T, FnExp >::Type_t
  operator()(const T &a) const
  {
    return (exp(a));
  }
};
struct FnFabs
{

  template<class T>
  inline typename UnaryReturn<T, FnFabs >::Type_t
  operator()(const T &a) const
  {
    return (fabs(a));
  }
};
struct FnFloor
{

  template<class T>
  inline typename UnaryReturn<T, FnFloor >::Type_t
  operator()(const T &a) const
  {
    return (floor(a));
  }
};
struct FnLog
{

  template<class T>
  inline typename UnaryReturn<T, FnLog >::Type_t
  operator()(const T &a) const
  {
    return (log(a));
  }
};
struct FnLog10
{

  template<class T>
  inline typename UnaryReturn<T, FnLog10 >::Type_t
  operator()(const T &a) const
  {
    return (log10(a));
  }
};
struct FnSin
{

  template<class T>
  inline typename UnaryReturn<T, FnSin >::Type_t
  operator()(const T &a) const
  {
    return (sin(a));
  }
};
struct FnHypSin
{

  template<class T>
  inline typename UnaryReturn<T, FnHypSin >::Type_t
  operator()(const T &a) const
  {
    return (sinh(a));
  }
};
struct FnSqrt
{

  template<class T>
  inline typename UnaryReturn<T, FnSqrt >::Type_t
  operator()(const T &a) const
  {
    return (sqrt(a));
  }
};
struct FnTan
{

  template<class T>
  inline typename UnaryReturn<T, FnTan >::Type_t
  operator()(const T &a) const
  {
    return (tan(a));
  }
};
struct FnHypTan
{

  template<class T>
  inline typename UnaryReturn<T, FnHypTan >::Type_t
  operator()(const T &a) const
  {
    return (tanh(a));
  }
};
struct OpUnaryMinus
{

  template<class T>
  inline typename UnaryReturn<T, OpUnaryMinus >::Type_t
  operator()(const T &a) const
  {
    return (-a);
  }
};
struct OpUnaryPlus
{

  template<class T>
  inline typename UnaryReturn<T, OpUnaryPlus >::Type_t
  operator()(const T &a) const
  {
    return (+a);
  }
};
struct OpBitwiseNot
{

  template<class T>
  inline typename UnaryReturn<T, OpBitwiseNot >::Type_t
  operator()(const T &a) const
  {
    return (~a);
  }
};
struct OpIdentity
{

  template<class T>
  inline typename UnaryReturn<T, OpIdentity >::Type_t
  operator()(const T &a) const
  {
    return (a);
  }
};
struct OpNot
{

  template<class T>
  inline typename UnaryReturn<T, OpNot >::Type_t
  operator()(const T &a) const
  {
    return (!a);
  }
};
template<class T >
struct UnaryReturn<T, OpNot > {
  typedef bool Type_t;
};
template <class T1>
struct OpCast
{

  template<class T2>
  inline UnaryReturn<T2, OpCast<T1> >
  operator()(const T2 &a) const
  {
    return T1(a);
  }
};
template<class T1, class T2>
struct UnaryReturn<T2, OpCast<T1> > {
  typedef T1 Type_t;
};
struct OpAdd
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpAdd >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a + b);
  }
};
struct OpSubtract
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpSubtract >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a - b);
  }
};
struct OpMultiply
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpMultiply >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a * b);
  }
};
struct OpDivide
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpDivide >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a / b);
  }
};
struct OpMod
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpMod >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a % b);
  }
};
struct OpBitwiseAnd
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseAnd >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a & b);
  }
};
struct OpBitwiseOr
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseOr >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a | b);
  }
};
struct OpBitwiseXor
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseXor >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a ^ b);
  }
};
struct FnLdexp
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnLdexp >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (ldexp(a,b));
  }
};
struct FnPow
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnPow >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (pow(a,b));
  }
};
struct FnFmod
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnFmod >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (fmod(a,b));
  }
};
struct FnArcTan2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnArcTan2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (atan2(a,b));
  }
};
struct OpLT
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLT >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a < b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLT > {
  typedef bool Type_t;
};
struct OpLE
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLE >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a <= b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLE > {
  typedef bool Type_t;
};
struct OpGT
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpGT >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a > b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpGT > {
  typedef bool Type_t;
};
struct OpGE
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpGE >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a >= b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpGE > {
  typedef bool Type_t;
};
struct OpEQ
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpEQ >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a == b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpEQ > {
  typedef bool Type_t;
};
struct OpNE
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpNE >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a != b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpNE > {
  typedef bool Type_t;
};
struct OpAnd
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpAnd >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a && b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpAnd > {
  typedef bool Type_t;
};
struct OpOr
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpOr >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a || b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpOr > {
  typedef bool Type_t;
};
struct OpLeftShift
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLeftShift >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a << b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLeftShift > {
  typedef T1 Type_t;
};
struct OpRightShift
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpRightShift >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a >> b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpRightShift > {
  typedef T1 Type_t;
};
struct OpAddAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpAddAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) += b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpAddAssign > {
  typedef T1 &Type_t;
};
struct OpSubtractAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpSubtractAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) -= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpSubtractAssign > {
  typedef T1 &Type_t;
};
struct OpMultiplyAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpMultiplyAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) *= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpMultiplyAssign > {
  typedef T1 &Type_t;
};
struct OpDivideAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpDivideAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) /= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpDivideAssign > {
  typedef T1 &Type_t;
};
struct OpModAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpModAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) %= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpModAssign > {
  typedef T1 &Type_t;
};
struct OpBitwiseOrAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseOrAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) |= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpBitwiseOrAssign > {
  typedef T1 &Type_t;
};
struct OpBitwiseAndAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseAndAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) &= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpBitwiseAndAssign > {
  typedef T1 &Type_t;
};
struct OpBitwiseXorAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpBitwiseXorAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) ^= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpBitwiseXorAssign > {
  typedef T1 &Type_t;
};
struct OpLeftShiftAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLeftShiftAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) <<= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLeftShiftAssign > {
  typedef T1 &Type_t;
};
struct OpRightShiftAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpRightShiftAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    (const_cast<T1 &>(a) >>= b); return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpRightShiftAssign > {
  typedef T1 &Type_t;
};
struct OpAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (const_cast<T1 &>(a) = b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpAssign > {
  typedef T1 &Type_t;
};
struct FnWhere
{

  template<class T1, class T2, class T3>
  inline typename TrinaryReturn<T1, T2, T3, FnWhere >
  ::Type_t
  operator()(T1 &a, const T2 &b, const T3 &c) const
  {
    if (a) return b; else return c;
  }
};
template<class LeafType, class LeafTag>
struct LeafFunctor
{ };
template<class LeafType, class LeafTag>
inline
typename LeafFunctor<LeafType, LeafTag>::Type_t
leafFunctor(const LeafType &leaf, const LeafTag &tag)
{
  return LeafFunctor<LeafType, LeafTag>::apply(leaf, tag);
}
struct EvalLeaf1
{
  int i1_m;
  inline EvalLeaf1(int i1) : i1_m(i1) { }
  inline int val1() const { return i1_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf1>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf1 &)
  {
    return s.value();
  }
};
struct EvalLeaf2
{
  int i1_m, i2_m;
  inline EvalLeaf2(int i1, int i2) : i1_m(i1), i2_m(i2) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf2>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf2 &)
  {
    return s.value();
  }
};
struct EvalLeaf3
{
  int i1_m, i2_m, i3_m;
  inline EvalLeaf3(int i1, int i2, int i3)
    : i1_m(i1), i2_m(i2), i3_m(i3) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf3>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf3 &)
  {
    return s.value();
  }
};
struct EvalLeaf4
{
  int i1_m, i2_m, i3_m, i4_m;
  inline EvalLeaf4(int i1, int i2, int i3, int i4)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf4>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf4 &)
  {
    return s.value();
  }
};
struct EvalLeaf5
{
  int i1_m, i2_m, i3_m, i4_m, i5_m;
  inline EvalLeaf5(int i1, int i2, int i3, int i4, int i5)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf5>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf5 &)
  {
    return s.value();
  }
};
struct EvalLeaf6
{
  int i1_m, i2_m, i3_m, i4_m, i5_m, i6_m;
  inline EvalLeaf6(int i1, int i2, int i3, int i4, int i5, int i6)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5), i6_m(i6) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
  inline int val6() const { return i6_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf6>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf6 &)
  {
    return s.value();
  }
};
struct EvalLeaf7
{
  int i1_m, i2_m, i3_m, i4_m, i5_m, i6_m, i7_m;
  inline EvalLeaf7(int i1, int i2, int i3, int i4, int i5, int i6,
    int i7)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5), i6_m(i6), i7_m(i7) { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
  inline int val6() const { return i6_m; }
  inline int val7() const { return i7_m; }
};
template<class T>
struct LeafFunctor<Scalar<T>, EvalLeaf7>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const EvalLeaf7 &)
  {
    return s.value();
  }
};
struct IncrementLeaf
{ };
template<class T>
struct LeafFunctor<T, IncrementLeaf>
{
  typedef int Type_t;
  inline static
  Type_t apply(const T &cl, const IncrementLeaf &)
  {
    T &l = const_cast<T &>(cl);
    ++l;
    return 0;
  }
};
template<class T>
struct LeafFunctor<Scalar<T>, IncrementLeaf>
{
  typedef int Type_t;
  inline static
  Type_t apply(const Scalar<T> &, const IncrementLeaf &)
  {
    return 0;
  }
};
struct DecrementLeaf
{ };
template<class T>
struct LeafFunctor<T, DecrementLeaf>
{
  typedef int Type_t;
  inline static
  Type_t apply(const T &cl, const DecrementLeaf &)
  {
    T &l = const_cast<T &>(cl);
    --l;
    return 0;
  }
};
template<class T>
struct LeafFunctor<Scalar<T>, DecrementLeaf>
{
  typedef int Type_t;
  inline static
  Type_t apply(const Scalar<T> &, const DecrementLeaf &)
  {
    return 0;
  }
};
struct DereferenceLeaf
{ };
template<class ForwardIterator>
struct LeafFunctor<ForwardIterator, DereferenceLeaf>
{
  typedef typename std::iterator_traits<ForwardIterator>::value_type Type_t;
  inline static
  Type_t apply(const ForwardIterator &i, const DereferenceLeaf &)
  {
    return *i;
  }
};
template<class T>
struct LeafFunctor<Scalar<T>, DereferenceLeaf>
{
  typedef T Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const DereferenceLeaf &)
  {
    return s.value();
  }
};
template<class A, class Op, class Tag>
struct Combine1
{
  typedef A Type_t;
  inline static
  Type_t combine(const A &a, const Tag &) { return a; }
};
template<class A, class B, class Op, class Tag>
struct Combine2
{
};
template<class A,class B,class C,class Op,class Tag>
struct Combine3
{
  typedef typename Combine2<A, B, Op, Tag>::Type_t Type1_t;
  typedef typename Combine2<Type1_t, C, Op, Tag>::Type_t Type_t;
  inline static
  Type_t combine(const A& a, const B& b, const C& c, const Tag& t)
  {
    return
      Combine2<Type1_t, C,
      Op, Tag>::combine(Combine2<A, B, Op, Tag>::combine(a,b,t),c,t);
  }
};
template<class A, class Op, class Tag>
inline typename Combine1<A, Op, Tag>::Type_t
peteCombine(const A &a, const Op &, const Tag &t)
{
  return Combine1<A, Op, Tag>::combine(a, t);
}
template<class A, class B, class Op, class Tag>
inline typename Combine2<A, B, Op, Tag>::Type_t
peteCombine(const A &a, const B &b, const Op &, const Tag &t)
{
  return Combine2<A, B, Op, Tag>::combine(a, b, t);
}
template<class A, class B, class C, class Op, class Tag>
inline typename Combine3<A, B, C, Op, Tag>::Type_t
peteCombine(const A &a, const B &b, const C &c, const Op &, const Tag &t)
{
  return Combine3<A, B, C, Op, Tag>::combine(a, b, c, t);
}
struct TreeCombine
{

};
template<class A, class Op>
struct Combine1<A, Op, TreeCombine >
{
  typedef UnaryNode<Op, A> Type_t;
  inline static
  Type_t combine(const A &a, const TreeCombine &t)
  {
    return Type_t(a);
  }
};
template<class A, class B, class Op>
struct Combine2<A, B, Op, TreeCombine >
{
  typedef BinaryNode<Op, A, B> Type_t;
  inline static
  Type_t combine(const A &a, const B &b, const TreeCombine &t)
  {
    return Type_t(a, b);
  }
};
template<class A, class B, class C, class Op>
struct Combine3<A, B, C, Op, TreeCombine >
{
  typedef TrinaryNode<Op, A, B, C> Type_t;
  inline static
  Type_t combine(const A &a, const B &b, const C &c, const TreeCombine &t)
  {
    return Type_t(a, b, c);
  }
};
struct OpCombine
{

};
template<class A,class Op>
struct Combine1<A, Op, OpCombine>
{
  typedef typename UnaryReturn<A, Op>::Type_t Type_t;
  inline static
  Type_t combine(A a, OpCombine) { return Op()(a); }
};
template<class A,class B,class Op>
struct Combine2<A, B, Op, OpCombine>
{
  typedef typename BinaryReturn<A, B, Op>::Type_t Type_t;
  inline static
  Type_t combine(A a, B b, OpCombine)
  {
    return Op()(a, b);
  }
};
template<class A,class B,class C,class Op>
struct Combine3<A, B, C, Op, OpCombine>
{
  typedef typename TrinaryReturn<A, B, C, Op>::Type_t Type_t;
  inline static
  Type_t combine(A a, B b, C c, OpCombine)
  {
    return Op()(a, b, c);
  }
};
struct AndCombine
{

};
template<class Op>
struct Combine2<bool, bool, Op, AndCombine>
{
  typedef bool Type_t;
  inline static
  Type_t combine(bool a, bool b, AndCombine)
  {
    return (a && b);
  }
};
struct OrCombine
{

};
template<class Op>
struct Combine2<bool, bool, Op, OrCombine>
{
  typedef bool Type_t;
  inline static
  Type_t combine(bool a, bool b, OrCombine)
  {
    return (a || b);
  }
};
struct NullCombine
{

};
template<class Op>
struct Combine2<int, int, Op, NullCombine>
{
  typedef int Type_t;
  inline static
  Type_t combine(int, int, NullCombine)
  {
    return 0;
  }
};
struct SumCombine
{

};
template<class Op>
struct Combine2<int, int, Op, SumCombine>
{
  typedef int Type_t;
  inline static
  Type_t combine(int a, int b, SumCombine)
  {
    return a + b;
  }
};
template<class Expr, class FTag, class CTag>
struct ForEach
{
  typedef typename LeafFunctor<Expr, FTag>::Type_t Type_t;
  inline static
  Type_t apply(const Expr &expr, const FTag &f, const CTag &)
  {
    return LeafFunctor<Expr, FTag>::apply(expr, f);
  }
};
template<class Expr, class FTag, class CTag>
inline typename ForEach<Expr,FTag,CTag>::Type_t
forEach(const Expr &e, const FTag &f, const CTag &c)
{
  return ForEach<Expr, FTag, CTag>::apply(e, f, c);
}
template<class Op, class A, class FTag, class CTag>
struct ForEach<UnaryNode<Op, A>, FTag, CTag>
{
  typedef typename ForEach<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename Combine1<TypeA_t, Op, CTag>::Type_t Type_t;
  inline static
  Type_t apply(const UnaryNode<Op, A> &expr, const FTag &f,
    const CTag &c)
  {
    return Combine1<TypeA_t, Op, CTag>::
      combine(ForEach<A, FTag, CTag>::apply(expr.child(), f, c), c);
  }
};
template<class Op, class A, class B, class FTag, class CTag>
struct ForEach<BinaryNode<Op, A, B>, FTag, CTag >
{
  typedef typename ForEach<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename ForEach<B, FTag, CTag>::Type_t TypeB_t;
  typedef typename Combine2<TypeA_t, TypeB_t, Op, CTag>::Type_t Type_t;
  inline static
  Type_t apply(const BinaryNode<Op, A, B> &expr, const FTag &f,
        const CTag &c)
  {
    return Combine2<TypeA_t, TypeB_t, Op, CTag>::
      combine(ForEach<A, FTag, CTag>::apply(expr.left(), f, c),
              ForEach<B, FTag, CTag>::apply(expr.right(), f, c),
       c);
  }
};
template<class Op, class A, class B, class C, class FTag, class CTag>
struct ForEach<TrinaryNode<Op, A, B, C>, FTag, CTag >
{
  typedef typename ForEach<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename ForEach<B, FTag, CTag>::Type_t TypeB_t;
  typedef typename ForEach<C, FTag, CTag>::Type_t TypeC_t;
  typedef typename Combine3<TypeA_t, TypeB_t, TypeC_t, Op, CTag>::Type_t
    Type_t;
  inline static
  Type_t apply(const TrinaryNode<Op, A, B, C> &expr, const FTag &f,
        const CTag &c)
  {
    return Combine3<TypeA_t, TypeB_t, TypeC_t, Op, CTag>::
      combine(ForEach<A, FTag, CTag>::apply(expr.left(), f, c),
       ForEach<B, FTag, CTag>::apply(expr.middle(), f, c),
       ForEach<C, FTag, CTag>::apply(expr.right(), f, c),
       c);
  }
};
template<class T> class Expression;
template<class T, class FTag, class CTag>
struct ForEach<Expression<T>, FTag, CTag>
{
  typedef typename ForEach<T, FTag, CTag>::Type_t Type_t;
  inline static
  Type_t apply(const Expression<T> &expr, const FTag &f,
        const CTag &c)
  {
    return ForEach<T, FTag, CTag>::apply(expr.expression(), f, c);
  }
};
template<class T> struct Reference;
template<class T, class FTag, class CTag>
struct ForEach<Reference<T>, FTag, CTag>
{
  typedef typename ForEach<T, FTag, CTag>::Type_t Type_t;
  inline static
  Type_t apply(const Reference<T> &ref, const FTag &f,
        const CTag &c)
  {
    return ForEach<T, FTag, CTag>::apply(ref.reference(), f, c);
  }
};
template<class T>
class Expression
{
public:
  typedef T Expression_t;
  Expression(const T& expr) : expr_m(expr)
  { }
  const Expression_t& expression() const
  {
    return expr_m;
  }
private:
  T expr_m;
};
template<class T>
struct CreateLeaf
{
  typedef Scalar<T> Leaf_t;
  inline static
  Leaf_t make(const T &a)
  {
    return Scalar<T>(a);
  }
};
template<class T>
struct CreateLeaf<Expression<T> >
{
  typedef typename Expression<T>::Expression_t Leaf_t;
  inline static
  const Leaf_t &make(const Expression<T> &a)
  {
    return a.expression();
  }
};
template<class T>
struct MakeReturn
{
  typedef Expression<T> Expression_t;
  inline static
  Expression_t make(const T &a) { return Expression_t(a); }
};
struct ErrorType
{
};
template<class Expr, class FTag, class CTag>
struct ForEachRef
{
  typedef typename LeafFunctor<Expr, FTag>::Type_t Type_t;
  inline static
  const Type_t &apply(const Expr &expr, const FTag &f, const CTag &)
    {
      return LeafFunctor<Expr, FTag>::apply(expr, f);
    }
};
template<class Expr, class FTag, class CTag>
inline const typename ForEachRef<Expr,FTag,CTag>::Type_t &
forEachRef(const Expr &e, const FTag &f, const CTag &c)
{
  return ForEachRef<Expr, FTag, CTag>::apply(e, f, c);
}
template<class Op, class A, class FTag, class CTag>
struct ForEachRef<UnaryNode<Op, A>, FTag, CTag>
{
  typedef typename ForEachRef<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename Combine1<TypeA_t, Op, CTag>::Type_t Type_t;
  inline static
  const Type_t &apply(const UnaryNode<Op, A> &expr, const FTag &f,
    const CTag &c)
    {
      return Combine1<TypeA_t, Op, CTag>::
        combine(ForEachRef<A, FTag, CTag>::apply(expr.child(), f, c),
                c);
    }
};
template<class Op, class A, class B, class FTag, class CTag>
struct ForEachRef<BinaryNode<Op, A, B>, FTag, CTag >
{
  typedef typename ForEachRef<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename ForEachRef<B, FTag, CTag>::Type_t TypeB_t;
  typedef typename Combine2<TypeA_t, TypeB_t, Op, CTag>::Type_t Type_t;
  inline static
  const Type_t &apply(const BinaryNode<Op, A, B> &expr, const FTag &f,
                   const CTag &c)
    {
      return Combine2<TypeA_t, TypeB_t, Op, CTag>::
        combine(ForEachRef<A, FTag, CTag>::apply(expr.left(), f, c),
                ForEachRef<B, FTag, CTag>::apply(expr.right(), f, c),
         c);
    }
};
template<class Op, class A, class B, class C, class FTag, class CTag>
struct ForEachRef<TrinaryNode<Op, A, B, C>, FTag, CTag >
{
  typedef typename ForEachRef<A, FTag, CTag>::Type_t TypeA_t;
  typedef typename ForEachRef<B, FTag, CTag>::Type_t TypeB_t;
  typedef typename ForEachRef<C, FTag, CTag>::Type_t TypeC_t;
  typedef typename Combine3<TypeA_t, TypeB_t, TypeC_t, Op, CTag>::Type_t
    Type_t;
  inline static
  const Type_t &apply(const TrinaryNode<Op, A, B, C> &expr, const FTag &f,
                   const CTag &c)
    {
      return Combine3<TypeA_t, TypeB_t, TypeC_t, Op, CTag>::
        combine(ForEachRef<A, FTag, CTag>::apply(expr.left(), f, c),
         ForEachRef<B, FTag, CTag>::apply(expr.middle(), f, c),
         ForEachRef<C, FTag, CTag>::apply(expr.right(), f, c),
         c);
    }
};
template<class T, class FTag, class CTag>
struct ForEachRef<Expression<T>, FTag, CTag>
{
  typedef typename ForEachRef<T, FTag, CTag>::Type_t Type_t;
  inline static
  const Type_t &apply(const Expression<T> &expr, const FTag &f,
                   const CTag &c)
    {
      return ForEachRef<T, FTag, CTag>::apply(expr.expression(), f, c);
    }
};
template<class T, class FTag, class CTag>
struct ForEachRef<Reference<T>, FTag, CTag>
{
  typedef typename ForEachRef<T, FTag, CTag>::Type_t Type_t;
  inline static
  const Type_t &apply(const Reference<T> &ref, const FTag &f,
                   const CTag &c)
    {
      return ForEachRef<T, FTag, CTag>::apply(ref.reference(), f, c);
    }
};
template<int Integer> class WrappedInt
{
public:
  enum { val = Integer };

};
template<int Dim, class T, class EngineTag> class Engine;
template<class Eng, class Tag>
struct EngineFunctorDefault
{ };
template<class Eng, class Tag>
struct EngineFunctor
{
  typedef typename EngineFunctorDefault<Eng,Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Eng &e, const Tag &t)
  {
    return EngineFunctorDefault<Eng,Tag>::apply(e,t);
  }
};
template<class Eng, class Tag>
inline typename EngineFunctor<Eng,Tag>::Type_t
engineFunctor(const Eng &e, const Tag &tag)
{
  return EngineFunctor<Eng,Tag>::apply(e,tag);
}
template<class T, class Tag>
struct EngineFunctorScalar
{ };
template<class Tag>
struct EngineView;
template<class Node, class Tag>
struct LeafFunctor<Node, EngineView<Tag> >
{
};
template<class T, class Tag>
struct LeafFunctor<Scalar<T>, EngineView<Tag> >
{
  typedef Scalar<T> Type_t;
  static inline
  Type_t apply(const Scalar<T> &s, const EngineView<Tag> &)
  {
    return s;
  }
};
template<class Engine, class Tag>
struct DefaultEngineView;
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Engine<Dim, T, E>, EngineView<Tag> >
{
  typedef Engine<Dim, T, E> Subject_t;
  typedef DefaultEngineView<Subject_t, Tag> EngineView_t;
  typedef typename EngineView_t::Type_t Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const EngineView<Tag> &tag)
  {
    return EngineView_t::apply(engine, tag);
  }
};
template<class Tag>
struct ExpressionApply
{
  inline
  ExpressionApply(const Tag &tag)
    : tag_m(tag)
  {
  }
  template<class A>
  void operator()(const A &a) const
  {
    forEach(a, *this, NullCombine());
  }
  const Tag &tag() const { return tag_m; }
  const Tag &tag_m;
};
template<class A, class Tag>
inline void
expressionApply(const A &a, const Tag &tag)
{
  forEach(a, ExpressionApply<Tag>(tag), NullCombine());
}
template<class Node, class Tag>
struct LeafFunctor<Node, ExpressionApply<Tag> >
{
};
template<class T, class Tag>
struct LeafFunctor<Scalar<T>, ExpressionApply<Tag> >
{
  typedef int Type_t;
  static inline
  Type_t apply(const Scalar<T> &, const ExpressionApply<Tag> &)
  {
    return 0;
  }
};
template<class Engine, class Tag>
struct DefaultExpressionApply;
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Engine<Dim, T, E>, ExpressionApply<Tag> >
{
  typedef Engine<Dim, T, E> Subject_t;
  typedef DefaultExpressionApply<Subject_t, Tag> ExpressionApply_t;
  typedef int Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const ExpressionApply<Tag> &tag)
  {
    return ExpressionApply_t::apply(engine, tag);
  }
};
namespace Pooma {
class NoInit
{
public:

};
}
template <class T> class DomainTraits;
template <class T>
struct SizeTypePromotion
{
  typedef T Type_t;
};
template <>
struct SizeTypePromotion<int>
{
  typedef long Type_t;
};
template <>
struct SizeTypePromotion<float>
{
  typedef double Type_t;
};
template <int I>
struct Dom1Initialize {
  template <class DT>
  static inline void apply(typename DT::Storage_t& s)
  {
    Dom1Initialize<I-1>::template apply<DT>(s);
    DomainTraits<typename DT::OneDomain_t>::initializeStorage(s[I].storage());
  }
};
template <>
struct Dom1Initialize<0> {
  template <class DT>
  static inline void apply(typename DT::Storage_t& s)
  {
    DomainTraits<typename DT::OneDomain_t>::initializeStorage(s[0].storage());
  }
};
template <class Domain>
struct WrapNoInit : public Domain
{
  WrapNoInit() : Domain(Pooma::NoInit()) {}
};
template<class DomT, class T, int Dim>
struct DomainTraitsDomain
{
  typedef typename SizeTypePromotion<T>::Type_t Size_t;
  typedef T Element_t;
  typedef DomT Domain_t;
  typedef DomT NewDomain1_t;
  enum { domain = true };
  enum { dimensions = Dim };
  static bool getIgnorable(const Domain_t &, int) { return false; }
};
template<class DomT, class T>
struct DomainTraitsDomain<DomT, T, 1>
{
  typedef typename SizeTypePromotion<T>::Type_t Size_t;
  typedef T Element_t;
  typedef DomT Domain_t;
  typedef DomT NewDomain1_t;
  enum { domain = true };
  enum { dimensions = 1 };
  inline
  static Element_t getFirst(const Domain_t &d) { return d.first(); }
  inline
  static Element_t getLast(const Domain_t &d) { return d.last(); }
  inline
  static Element_t getStride(const Domain_t &d) { return d.stride(); }
  inline
  static Size_t getLength(const Domain_t &d) { return d.length(); }
  inline
  static Size_t getSize(const Domain_t &d) { return d.size(); }
  inline
  static Element_t getMin(const Domain_t &d) { return d.min(); }
  inline
  static Element_t getMax(const Domain_t &d) { return d.max(); }
  inline
  static bool getEmpty(const Domain_t &d) { return d.empty(); }
  inline
  static int getLoop(const Domain_t &d) { return d.loop(); }
  inline
  static Element_t getElem(const Domain_t &d, int n) { return d.elem(n); }
  inline
  static bool getIgnorable(const Domain_t &, int) { return false; }
};
template<class DomT, class T, class NewDom1T>
struct DomainTraitsScalar
{
  typedef DomT Domain_t;
  typedef DomT OneDomain_t;
  typedef NewDom1T NewDomain1_t;
  typedef T PointDomain_t;
  typedef T Element_t;
  typedef int Size_t;
  enum { domain = false };
  enum { dimensions = 1,
  sliceDimensions = 0 };
  enum { loopAware = false };
  enum { singleValued = true };
  enum { unitStride = true };
  enum { wildcard = false };
  inline
  static OneDomain_t getDomain(T d, int) { return OneDomain_t(d); }
  inline
  static PointDomain_t getPointDomain(T d, int) { return d; }
  inline
  static Element_t getFirst(const Element_t &d) { return d; }
  inline
  static Element_t getLast(const Element_t &d) { return d; }
  inline
  static int getStride(const Element_t &) { return 1; }
  inline
  static Size_t getLength(const Element_t &) { return 1; }
  inline
  static Size_t getSize(const Element_t &d) { return 1; }
  inline
  static Element_t getMin(const Element_t &d) { return d; }
  inline
  static Element_t getMax(const Element_t &d) { return d; }
  inline
  static bool getEmpty(const Element_t &) { return false; }
  inline
  static int getLoop(const Element_t &) { return 0; }
  inline
  static Element_t getElem(const Element_t &d, int) { return d; }
};
template<class T>
struct DomainTraits : public DomainTraitsScalar<T, T, T>
{
  typedef DomainTraitsScalar<T, T, T> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::OneDomain_t OneDomain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef typename Base_t::PointDomain_t PointDomain_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Size_t Size_t;
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = Base_t::sliceDimensions };
  enum { loopAware = Base_t::loopAware };
  enum { singleValued = Base_t::singleValued };
  enum { unitStride = Base_t::unitStride };
  enum { wildcard = Base_t::wildcard };
};
template<class T, int Dim>
struct DomainChangeDim {
  typedef T OldType_t;
  typedef T NewType_t;
  enum { oldDim = Dim,
  newDim = Dim };
};
template <class Dom, class Storage, class T1, class T2>
inline void
setDomain(const Dom&, Storage& data, const T1& beg, const T2& end) {
  DomainTraits<Dom>::setDomain(data, beg, end);
}
template <int Dim> class Interval;
template <> class Interval<1>;
template <int Dim> class Loc;
template <> class Loc<1>;
template<>
struct DomainTraits<char>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<unsigned char>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<short>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<unsigned short>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<int>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<unsigned int>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<long>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<>
struct DomainTraits<unsigned long>
  : public DomainTraitsScalar<Interval<1>, int, Loc<1> > { };
template<class T1, class T2, bool strided>
struct ContainsDomainSingle {
  static bool contains(const T1 &a, const T2 &b) {
    return (a.min() <= b.min() && a.max() >= b.max());
  }
};
template<class T1, class T2>
struct ContainsDomainSingle<T1,T2,true> {
  static bool contains(const T1 &a, const T2 &b) {
    typedef typename DomainTraits<T1>::Element_t E1_t;
    typedef typename DomainTraits<T2>::Element_t E2_t;
    E1_t a0 = a.min();
    E1_t a1 = a.max();
    E1_t s = a.stride();
    E2_t b0 = b.min();
    E2_t b1 = b.max();
    E2_t t = b.stride();
    if (s < 0)
      s = -s;
    if (t < 0)
      t = -t;
    bool quicktest = (a0 <= b0 && a1 >= b1);
    if (!quicktest || s == 1)
      return quicktest;
    return (t % s == 0) && ((b0-a0) % s == 0) && ((a1-b1) % s == 0);
  }
};
template<class T1, class T2, int Dim>
struct ContainsDomain {
  enum { strided = !DomainTraits<T1>::unitStride };
  enum { n = Dim - 1 };
  static bool contains(const T1 &a, const T2 &b) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    return ContainsDomainSingle<Dom1_t,Dom2_t,strided>::contains(
      DomainTraits<T1>::getDomain(a,n), DomainTraits<T2>::getDomain(b,n)) &&
      ContainsDomain<T1,T2,n>::contains(a,b);
  }
};
template<class T1, class T2>
struct ContainsDomain<T1,T2,1> {
  enum { strided = !DomainTraits<T1>::unitStride };
  static bool contains(const T1 &a, const T2 &b) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    return ContainsDomainSingle<Dom1_t,Dom2_t,strided>::contains(
      DomainTraits<T1>::getDomain(a,0), DomainTraits<T2>::getDomain(b,0));
  }
};
template<class T1, class T2>
inline bool contains(const T1 &a, const T2 &b)
{
  PoomaCTAssert<((int)DomainTraits<T1>::dimensions == DomainTraits<T2>::dimensions)>::test();
  return ContainsDomain<T1,T2,DomainTraits<T1>::dimensions>::contains(a, b);
}
template<int Dim>
class Loc;
template<int Dim>
class Interval;
template<int Dim>
class Range;
template<class T>
class IndirectionList;
template<int Dim>
class Grid;
template<class T1,class T2 >
struct DomainArithOpsTraits
{
};
template <>
struct DomainArithOpsTraits< Loc<1> , Loc<1> >
{
  typedef Loc<1> AddResult_t;
  typedef Loc<1> SubResult_t;
  typedef Loc<1> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Loc<1> , Loc<Dim> >
{
  typedef Loc<Dim> AddResult_t;
  typedef Loc<Dim> SubResult_t;
  typedef Loc<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Loc<Dim> , Loc<1> >
{
  typedef Loc<Dim> AddResult_t;
  typedef Loc<Dim> SubResult_t;
  typedef Loc<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Loc<Dim> , Loc<Dim2> >
{
  typedef Loc<Dim> AddResult_t;
  typedef Loc<Dim> SubResult_t;
  typedef Loc<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Loc<1> , Interval<Dim> >
{
  typedef Interval<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Interval<Dim>, Loc<1> >
{
  typedef Interval<Dim> AddResult_t;
  typedef Interval<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Loc<Dim> , Interval<Dim2> >
{
  typedef Interval<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Interval<Dim>, Loc<Dim2> >
{
  typedef Interval<Dim> AddResult_t;
  typedef Interval<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Loc<1> , Range<Dim> >
{
  typedef Range<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Range<Dim>, Loc<1> >
{
  typedef Range<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Loc<Dim> , Range<Dim2> >
{
  typedef Range<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Range<Dim>, Loc<Dim2> >
{
  typedef Range<Dim> AddResult_t;
  typedef Range<Dim> SubResult_t;
  typedef Range<Dim> MultResult_t;
};
template< >
struct DomainArithOpsTraits<Loc<1> , IndirectionList<int> >
{
  typedef IndirectionList<int> AddResult_t;
  typedef IndirectionList<int> SubResult_t;
  typedef IndirectionList<int> MultResult_t;
};
template< >
struct DomainArithOpsTraits<IndirectionList<int>, Loc<1> >
{
  typedef IndirectionList<int> AddResult_t;
  typedef IndirectionList<int> SubResult_t;
  typedef IndirectionList<int> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Loc<1> , Grid<Dim> >
{
  typedef Grid<Dim> AddResult_t;
  typedef Grid<Dim> SubResult_t;
  typedef Grid<Dim> MultResult_t;
};
template<int Dim>
struct DomainArithOpsTraits<Grid<Dim>, Loc<1> >
{
  typedef Grid<Dim> AddResult_t;
  typedef Grid<Dim> SubResult_t;
  typedef Grid<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Loc<Dim> , Grid<Dim2> >
{
  typedef Grid<Dim> AddResult_t;
  typedef Grid<Dim> SubResult_t;
  typedef Grid<Dim> MultResult_t;
};
template<int Dim,int Dim2>
struct DomainArithOpsTraits<Grid<Dim>, Loc<Dim2> >
{
  typedef Grid<Dim> AddResult_t;
  typedef Grid<Dim> SubResult_t;
  typedef Grid<Dim> MultResult_t;
};
template <class Dom>
class DomainIterator
{
public:
  typedef DomainIterator<Dom> This_t;
  typedef Dom Domain_t;
  typedef typename Domain_t::AskDomain_t Value_t;
  typedef std::input_iterator_tag iterator_category;
  typedef Value_t value_type;
  typedef ptrdiff_t difference_type;
  typedef const Value_t* pointer;
  typedef const Value_t& reference;
  enum { dimensions = DomainTraits<Dom>::dimensions };
  DomainIterator(const Dom &d, int size = 0)
    : domain_m(d), loc_m(d.firsts()), index_m(domain_m.size()-size)
    {
      ;
      for (int i=0; i < dimensions; ++i)
 current_m[i] = 0;
    }
  DomainIterator(const This_t &model)
    : domain_m(model.domain_m), loc_m(model.loc_m), index_m(model.index_m)
    {
      ;
      for (int i=0; i < dimensions; ++i)
 current_m[i] = model.current_m[i];
    }
  DomainIterator()
    : index_m(0)
    {
      for (int i=0; i < dimensions; ++i)
 current_m[i] = 0;
    }
  inline const Value_t &operator*() const
    {
      ;
      return loc_m;
    }
  inline const Value_t *operator->() const
    {
      ;
      return &loc_m;
    }
  inline bool operator==(const This_t &rhs) const
    {
      return (index_m == rhs.index_m);
    }
  inline bool operator!=(const This_t &rhs) const
    {
      return (index_m != rhs.index_m);
    }
  bool done() const
    {
      return (index_m == 0);
    }
  This_t &operator=(const This_t &model)
    {
      index_m = model.index_m;
      domain_m = model.domain_m;
      loc_m = model.loc_m;
      for (int i=0; i < dimensions; ++i)
 current_m[i] = model.current_m[i];
      return *this;
    }
  This_t &operator++()
    {
      increment(WrappedInt<Domain_t::unitStride>());
      return *this;
    }
  This_t operator++(int)
    {
      DomainIterator<Dom> save(*this);
      increment(WrappedInt<Domain_t::unitStride>());
      return save;
    }
private:
  Domain_t domain_m;
  Value_t loc_m;
  int current_m[dimensions];
  int index_m;
  void increment(const WrappedInt<true>&)
    {
      ;
      --index_m;
      ++(current_m[0]);
      ++loc_m[0];
      if (__builtin_expect(current_m[0] < domain_m[0].length(), 1))
        return;
      for (int i = 1; i < dimensions; ++i)
 {
   current_m[i-1] = 0;
   loc_m[i-1] = domain_m[i-1].first();
   ++(current_m[i]);
   ++loc_m[i];
   if (__builtin_expect(current_m[i] < domain_m[i].length(), 1))
     return;
 }
    }
  void increment(const WrappedInt<false>&)
    {
      ;
      --index_m;
      ++(current_m[0]);
      if (__builtin_expect(current_m[0] < domain_m[0].length(), 1)) {
        loc_m[0] = domain_m[0](current_m[0]);
        return;
      }
      for (int i = 1; i < dimensions; ++i)
 {
   current_m[i-1] = 0;
   loc_m[i-1] = domain_m[i-1].first();
   ++(current_m[i]);
   if (__builtin_expect(current_m[i] < domain_m[i].length(), 1)) {
     loc_m[i] = domain_m[i](current_m[i]);
     return;
   }
 }
    }
};
template <class Dom>
class DomainBlockIterator
{
public:
  typedef DomainBlockIterator<Dom> This_t;
  typedef Dom Domain_t;
  typedef typename Domain_t::OneDomain_t OneDomain_t;
  typedef typename Domain_t::AskDomain_t Value_t;
  typedef typename Domain_t::BlockDomain_t Block_t;
  typedef typename Block_t::OneDomain_t OneBlock_t;
  typedef typename OneDomain_t::iterator iterator;
  typedef typename Domain_t::Element_t Element_t;
  enum { dimensions = DomainTraits<Dom>::dimensions };
  DomainBlockIterator()
    : index_m(-1)
    {
    }
  DomainBlockIterator(const Dom &d);
  DomainBlockIterator(const This_t &model);
  ~DomainBlockIterator()
    {
    }
  inline const Block_t &operator*() const
    {
      ;
      return block_m;
    }
  inline const Block_t *operator->() const
    {
      ;
      return block_m;
    }
  inline const Value_t &point() const
    {
      ;
      return loc_m;
    }
  inline int index() const
    {
      ;
      return index_m;
    }
  inline bool operator==(const This_t &rhs) const
    {
      if (done() || rhs.done())
 return (done() && rhs.done());
      else
 return (block_m == *rhs);
    }
  inline bool operator!=(const This_t &rhs) const
    {
      return !(operator==(rhs));
    }
  bool done() const
    {
      return (index_m < 0);
    }
  This_t &operator=(const This_t &model)
    {
      domain_m = model.domain_m;
      loc_m = model.loc_m;
      block_m = model.block_m;
      index_m = model.index_m;
      for (int i=0; i < dimensions; ++i)
 current_m[i] = model.current_m[i];
      return *this;
    }
  This_t &operator++()
    {
      increment();
      return *this;
    }
  This_t operator++(int)
    {
      This_t save(*this);
      increment();
      return save;
    }
private:
  Domain_t domain_m;
  iterator current_m[dimensions];
  Value_t loc_m;
  Block_t block_m;
  int index_m;
  void setDone()
    {
      index_m = (-1);
    }
  void increment();
};
template<class Dom>
DomainBlockIterator<Dom>::DomainBlockIterator(const Dom &d)
  : domain_m(d), loc_m(0), index_m(0)
{
  for (int i=0; i < dimensions; ++i)
    {
      if (d[i].begin() == d[i].end())
 {
   setDone();
   break;
 }
      else
 {
   current_m[i] = d[i].begin();
   iterator next = current_m[i];
   Element_t a, b;
   if (++next == d[i].end())
     {
       a = b = (*(current_m[i])).first();
     }
   else
     {
       a = (*(current_m[i])).first();
       b = (*next).first();
     }
   if (b < a)
     block_m[i] = OneBlock_t(b + 1, a);
   else if (b == a)
     block_m[i] = OneBlock_t(a, a);
   else
     block_m[i] = OneBlock_t(a, b - 1);
 }
    }
}
template<class Dom>
DomainBlockIterator<Dom>::DomainBlockIterator(const This_t &model)
  : domain_m(model.domain_m), loc_m(model.loc_m),
    block_m(model.block_m), index_m(model.index_m)
{
  for (int i=0; i < dimensions; ++i)
    current_m[i] = model.current_m[i];
}
template<class Dom>
void DomainBlockIterator<Dom>::increment()
{
  ;
  for (int i = 0; i < dimensions; ++i)
    {
      if (++(current_m[i]) == domain_m[i].end())
 {
   if (i >= dimensions-1)
     {
       setDone();
       break;
     }
 }
      else
 {
   iterator next = current_m[i];
   if (++next == domain_m[i].end())
     {
       if (i < dimensions-1)
  {
    current_m[i] = domain_m[i].begin();
    next = current_m[i];
    Element_t a, b;
    if (++next == domain_m[i].end())
      {
        a = b = (*(current_m[i])).first();
      }
    else
      {
        a = (*(current_m[i])).first();
        b = (*next).first();
      }
    if (b < a)
      block_m[i] = OneBlock_t(b + 1, a);
    else if (b == a)
      block_m[i] = OneBlock_t(a, a);
    else
      block_m[i] = OneBlock_t(a, b - 1);
    loc_m[i] = 0;
  }
       else
  {
    setDone();
    break;
  }
     }
   else
     {
       Element_t a = (*(current_m[i])).first();
       Element_t b = (*next).first();
       if (b < a)
  block_m[i] = OneBlock_t(b + 1, a);
       else
  block_m[i] = OneBlock_t(a, b - 1);
       loc_m[i] = loc_m[i].first() + 1;
       index_m++;
       break;
     }
 }
    }
}
template<class DT>
class DomainBase
{
public:
  typedef typename DT::Domain_t Domain_t;
  typedef typename DT::AskDomain_t AskDomain_t;
  typedef typename DT::MultResult_t MultResult_t;
  typedef typename DT::Storage_t Storage_t;
  typedef DomainIterator<Domain_t> const_iterator;
  typedef DomainIterator<Domain_t> iterator;
  typedef DomainBlockIterator<Domain_t> const_blockIterator;
  typedef DomainBlockIterator<Domain_t> blockIterator;
  inline
  DomainBase() {
    PoomaCTAssert<(DT::dimensions > 0)>::test();
    DT::initializeStorage(domain_m);
  }
  inline
  DomainBase(const Pooma::NoInit &) {
    PoomaCTAssert<(DT::dimensions > 0)>::test();
  }
  inline
  Domain_t &unwrap() { return *static_cast<Domain_t *>(this); }
  const Domain_t &unwrap() const {
    return *static_cast<const Domain_t *>(this);
  }
  inline
  AskDomain_t firsts() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].first();
    return retval;
  }
  inline
  AskDomain_t lasts() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].last();
    return retval;
  }
  inline
  AskDomain_t strides() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].stride();
    return retval;
  }
  inline
  AskDomain_t lengths() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].length();
    return retval;
  }
  inline
  AskDomain_t sizes() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].size();
    return retval;
  }
  inline
  AskDomain_t mins() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].min();
    return retval;
  }
  inline
  AskDomain_t maxes() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].max();
    return retval;
  }
  inline
  AskDomain_t loops() const {
    AskDomain_t retval = Pooma::NoInit();
    for (int i=0; i < DT::dimensions; ++i)
      retval[i] = unwrap()[i].loop();
    return retval;
  }
  Storage_t& storage() { return domain_m; }
  const Storage_t& storage() const { return domain_m; }
  MultResult_t operator-() const {
    return (MultResult_t(unwrap()) * (-1));
  }
  const_iterator begin() const { return const_iterator(unwrap()); }
  const_iterator end() const { return const_iterator(unwrap(),
           unwrap().size()); }
  const_blockIterator beginBlock() const{return const_blockIterator(unwrap());}
  const_blockIterator endBlock() const { return const_blockIterator(); }
  template<class Out>
  void print(Out &o) const;
protected:
  Storage_t domain_m;
private:
  DomainBase(const DomainBase<DT> &);
  void operator=(const DomainBase<DT> &);
};
template<class DT>
template<class Out>
void DomainBase<DT>::print(Out &o) const
{
  const Domain_t &d = unwrap();
  o << "[";
  for (int i=0; i < DT::dimensions; ++i) {
    o << d[i].first() << ":" << d[i].last() << ":" << d[i].stride();
    if (i < (DT::dimensions-1))
      o << ",";
  }
  o << "]";
}
template <class T1, class T2, bool SV>
struct DomPair {
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::AddResult_t
  add(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::AddResult_t
      retval(d1.unwrap());
    return (retval += d2.unwrap());
  }
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::SubResult_t
  sub(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::SubResult_t
      retval(d1.unwrap());
    return (retval -= d2.unwrap());
  }
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::MultResult_t
  mult(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::MultResult_t
      retval(d1.unwrap());
    return (retval *= d2.unwrap());
  }
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::MultResult_t
  div(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::MultResult_t
      retval(d1.unwrap());
    return (retval /= d2.unwrap());
  }
};
template <class T1, class T2>
struct DomPair<T1,T2,false> {
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::AddResult_t
  add(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::AddResult_t
      retval(d2.unwrap());
    return (retval += d1.unwrap());
  }
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::SubResult_t
  sub(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::SubResult_t
      retval(d2.unwrap());
    retval = -retval;
    return (retval += d1.unwrap());
  }
  static typename DomainArithOpsTraits<typename T1::Domain_t,
                                       typename T2::Domain_t>::MultResult_t
  mult(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
  {
    typename DomainArithOpsTraits<typename T1::Domain_t,
                                  typename T2::Domain_t>::MultResult_t
      retval(d2.unwrap());
    return (retval *= d1.unwrap());
  }
};
template<class T1, class T2>
inline typename DomainArithOpsTraits<typename T1::Domain_t,
                                     typename T2::Domain_t>::AddResult_t
operator+(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
{
  return DomPair<T1,T2,T2::singleValued>::add(d1,d2);
}
template<class T1, class T2>
inline typename DomainArithOpsTraits<typename T1::Domain_t,
                                     typename T2::Domain_t>::SubResult_t
operator-(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
{
  return DomPair<T1,T2,T2::singleValued>::sub(d1,d2);
}
template<class T1, class T2>
inline typename DomainArithOpsTraits<typename T1::Domain_t,
                                     typename T2::Domain_t>::MultResult_t
operator*(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
{
  return DomPair<T1,T2,T2::singleValued>::mult(d1,d2);
}
template<class T1, class T2>
inline typename DomainArithOpsTraits<typename T1::Domain_t,
                                     typename T2::Domain_t>::MultResult_t
operator/(const DomainBase<T1> &d1, const DomainBase<T2> &d2)
{
  return DomPair<T1,T2,T2::singleValued>::div(d1,d2);
}
template<class T> inline bool operator==(char d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(short d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(int d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(long d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(float d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); } template<class T> inline bool operator==(double d1, const DomainBase<T> &d2) { return (d2.unwrap() == d1); }
template<class T> inline bool operator!=(char d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(short d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(int d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(long d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(float d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); } template<class T> inline bool operator!=(double d1, const DomainBase<T> &d2) { return (d2.unwrap() != d1); }
template<class T> inline bool operator<(char d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(short d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(int d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(long d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(float d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); } template<class T> inline bool operator<(double d1, const DomainBase<T> &d2) { return (d2.unwrap() < d1); }
template<class T> inline bool operator>(char d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(short d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(int d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(long d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(float d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); } template<class T> inline bool operator>(double d1, const DomainBase<T> &d2) { return (d2.unwrap() > d1); }
template<class T> inline bool operator<=(char d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(short d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(int d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(long d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(float d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); } template<class T> inline bool operator<=(double d1, const DomainBase<T> &d2) { return (d2.unwrap() <= d1); }
template<class T> inline bool operator>=(char d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(unsigned char d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(short d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(unsigned short d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(int d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(unsigned int d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(long d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(unsigned long d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(float d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); } template<class T> inline bool operator>=(double d1, const DomainBase<T> &d2) { return (d2.unwrap() >= d1); }
template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, char d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(char d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, unsigned char d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(unsigned char d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, short d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(short d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, unsigned short d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(unsigned short d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, int d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(int d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, unsigned int d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(unsigned int d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, long d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(long d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, unsigned long d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(unsigned long d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, float d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(float d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); } template<class T> inline typename T::AddResult_t operator+(const DomainBase<T> &d1, double d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval += d2); } template<class T> inline typename T::AddResult_t operator+(double d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval += d1); }
template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, char d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(char d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, unsigned char d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(unsigned char d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, short d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(short d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, unsigned short d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(unsigned short d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, int d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(int d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, unsigned int d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(unsigned int d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, long d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(long d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, unsigned long d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(unsigned long d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, float d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(float d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); } template<class T> inline typename T::AddResult_t operator-(const DomainBase<T> &d1, double d2) { typename T::AddResult_t retval(d1.unwrap()); return (retval -= d2); } template<class T> inline typename T::AddResult_t operator-(double d1, const DomainBase<T> &d2) { typename T::AddResult_t retval(d2.unwrap()); return (retval -= d1); }
template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, char d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(char d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, unsigned char d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(unsigned char d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, short d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(short d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, unsigned short d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(unsigned short d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, int d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(int d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, unsigned int d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(unsigned int d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, long d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(long d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, unsigned long d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(unsigned long d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, float d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(float d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); } template<class T> inline typename T::MultResult_t operator*(const DomainBase<T> &d1, double d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval *= d2); } template<class T> inline typename T::MultResult_t operator*(double d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval *= d1); }
template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, char d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(char d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, unsigned char d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(unsigned char d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, short d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(short d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, unsigned short d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(unsigned short d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, int d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(int d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, unsigned int d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(unsigned int d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, long d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(long d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, unsigned long d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(unsigned long d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, float d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(float d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); } template<class T> inline typename T::MultResult_t operator/(const DomainBase<T> &d1, double d2) { typename T::MultResult_t retval(d1.unwrap()); return (retval /= d2); } template<class T> inline typename T::MultResult_t operator/(double d1, const DomainBase<T> &d2) { typename T::MultResult_t retval(d2.unwrap()); return (retval /= d1); }
template<class D, class V>
inline void DomainToVector(const D &dom, V &vec)
{
  for (int i=0; i < DomainTraits<D>::dimensions; ++i)
    vec(i) = dom[i].first();
}
template<class V, class D>
inline void VectorToDomain(const V &vec, D &dom)
{
  for (int i=0; i < DomainTraits<D>::dimensions; ++i)
    dom[i] = DomainTraits<D>::OneDomain_t(vec(i), vec(i));
}
template<class DT>
std::ostream& operator<<(std::ostream &o, const DomainBase<DT> &dbase)
{
  dbase.print(o);
  return o;
}
template <int Dim, int C>
struct DomainDelta;
template <int Dim, int C>
struct DomainDelta;
template<int Dim, class DT>
class Domain : public DomainBase<DT>
{
  typedef DomainBase<DT> Base_t;
public:
  typedef typename DT::Size_t Size_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename DT::OneDomain_t OneDomain_t;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename Base_t::blockIterator blockIterator;
  inline
  Domain() {
    PoomaCTAssert<(DT::dimensions == Dim && Dim > 0)>::test();
  }
  inline Domain(const Pooma::NoInit &d) : Base_t(d) {
    PoomaCTAssert<(DT::dimensions == Dim && Dim > 0)>::test();
  }
  inline
  ~Domain() { }
  inline
  const OneDomain_t &operator[](int d) const { return this->domain_m[d]; }
  inline
  OneDomain_t &operator[](int d) { return this->domain_m[d]; }
  inline
  Size_t size() const {
    Size_t sz = this->domain_m[0].size();
    for (int i = 1; i < Dim; i++)
      sz *= this->domain_m[i].size();
    return sz;
  }
  inline
  bool empty() const {
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i].empty())
        return true;
    return false;
  }
  inline
  bool initialized() const { return (!empty()); }
  template<class T>
  bool operator==(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] != DomainTraits<T>::getDomain(d2, i))
        return false;
    return true;
  }
  template<class T>
  bool operator<(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] >= DomainTraits<T>::getDomain(d2, i))
        return false;
    return true;
  }
  template<class T>
  bool operator!=(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] != DomainTraits<T>::getDomain(d2, i))
        return true;
    return false;
  }
  template<class T>
  bool operator>(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] <= DomainTraits<T>::getDomain(d2, i))
        return false;
    return true;
  }
  template<class T>
  bool operator<=(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] > DomainTraits<T>::getDomain(d2, i))
        return false;
    return true;
  }
  template<class T>
  bool operator>=(const T &d2) const {
    PoomaCTAssert<(Dim == DomainTraits<T>::dimensions)>::test();
    for (int i = 0; i < Dim; i++)
      if (this->domain_m[i] < DomainTraits<T>::getDomain(d2, i))
        return false;
    return true;
  }
  Domain_t &operator++() {
    for (int i=0; i<Dim; ++i)
      this->domain_m[i] += this->domain_m[i].stride();
    return this->unwrap();
  }
  Domain_t &operator--() {
    for (int i=0; i<Dim; ++i)
      this->domain_m[i] -= this->domain_m[i].stride();
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator+=(const T &d2)
  {
    PoomaCTAssert<(DomainTraits<T>::dimensions == Dim || DomainTraits<T>::dimensions == 1 || Dim == 1)>::test();
    int d = DomainTraits<T>::dimensions > Dim ?
      DomainTraits<T>::dimensions : Dim;
    for (int i = 0; i < d; i++)
      this->domain_m[i] += DomainTraits<T>::getPointDomain(d2, i);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator-=(const T &d2) {
    PoomaCTAssert<(DomainTraits<T>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == Dim || DomainTraits<T>::dimensions == 1)>::test();
    for (int i = 0; i < Dim; i++)
      this->domain_m[i] -= DomainTraits<T>::getPointDomain(d2, i);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator*=(const T &d2) {
    PoomaCTAssert<(DomainTraits<T>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == Dim || DomainTraits<T>::dimensions == 1)>::test();
    for (int i = 0; i < Dim; i++)
      this->domain_m[i] *= DomainTraits<T>::getPointDomain(d2, i);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator/=(const T &d2) {
    PoomaCTAssert<(DomainTraits<T>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == Dim || DomainTraits<T>::dimensions == 1)>::test();
    for (int i = 0; i < Dim; i++)
      this->domain_m[i] /= DomainTraits<T>::getPointDomain(d2, i);
    return this->unwrap();
  }
  template <int Dim2, int C>
  inline
  Domain_t &operator+=(const DomainDelta<Dim2, C>&)
  {
    if (C < Dim)
      this->domain_m[C] += 1;
    return this->unwrap();
  }
  template <int Dim2, int C>
  inline
  Domain_t &operator-=(const DomainDelta<Dim2, C>&)
  {
    if (C < Dim)
      this->domain_m[C] -= 1;
    return this->unwrap();
  }
private:
  Domain(const Domain<Dim,DT> &);
  void operator=(const Domain<Dim,DT> &);
};
template<class DT, class ST, class T, class UT, bool wildcard>
struct SetDomainFunctor
{
  inline
  static void setDomain(ST &domain, const T &newdom) {
    DT::setDomain(domain, newdom);
  }
  inline
  static void setWildcardDomain(ST &domain, const UT &, const T &newdom) {
    DT::setDomain(domain, newdom);
  }
};
template<class DT, class ST, class T, class UT>
struct SetDomainFunctor<DT, ST, T, UT, true>
{
  inline
  static void setDomain(ST &, const T &) { }
  inline
  static void setWildcardDomain(ST &domain, const UT &u, const T &newdom) {
    DT::setWildcardDomain(domain, u, newdom);
  }
};
template<class DT>
class Domain<1, DT> : public DomainBase<DT>
{
  typedef DomainBase<DT> Base_t;
public:
  typedef typename DT::Size_t Size_t;
  typedef typename DT::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::Storage_t Storage_t;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename Base_t::blockIterator blockIterator;
  inline
  Domain() { }
  inline
  Domain(const Pooma::NoInit &d) : Base_t(d) { }
  inline
  Domain_t &operator[](int) { return this->unwrap(); }
  inline
  const Domain_t &operator[](int) const { return this->unwrap(); }
  inline
  Element_t elem(int n) const { return DT::elem(this->domain_m, n); }
  inline
  Element_t operator()(int n) const { return DT::elem(this->domain_m, n); }
  inline
  Element_t first() const { return DT::first(this->domain_m); }
  inline
  Element_t last() const { return DT::last(this->domain_m); }
  inline
  Element_t stride() const { return DT::stride(this->domain_m); }
  inline
  Size_t length() const { return DT::length(this->domain_m); }
  inline
  Element_t min() const { return DT::min(this->domain_m); }
  inline
  Element_t max() const { return DT::max(this->domain_m); }
  inline
  Size_t size() const { return length(); }
  inline
  bool empty() const { return DT::empty(this->domain_m); }
  inline
  bool initialized() const { return (!empty()); }
  inline
  int loop() const { return DT::loop(this->domain_m); }
  template<class T>
  inline
  void setDomain(const T &newdom) {
    SetDomainFunctor<DT,Storage_t,T,T,DomainTraits<T>::wildcard>::
      setDomain(this->domain_m, newdom);
  }
  template<class UT, class T>
  inline
  void setWildcardDomain(const UT &u, const T &newdom) {
    SetDomainFunctor<DT,Storage_t,T,UT,DomainTraits<T>::wildcard>::
      setWildcardDomain(this->domain_m, u, newdom);
  }
  inline
  void setLoop(int newloop) { DT::setLoop(this->domain_m, newloop); }
  template<class T>
  bool operator==(const T &d2) const {
    return DT::isEqualTo(this->domain_m, d2);
  }
  template<class T>
  bool operator<(const T &d2) const {
    return DT::isLessThan(this->domain_m, d2);
  }
  template<class T>
  bool operator!=(const T &d2) const { return !(*this == d2); }
  template<class T>
  bool operator>(const T &d2) const { return !(*this < d2 || *this == d2); }
  template<class T>
  bool operator<=(const T &d2) const { return (*this < d2 || *this == d2); }
  template<class T>
  bool operator>=(const T &d2) const { return !(*this < d2); }
  Domain_t &operator++() {
    DT::addAccum(this->domain_m, DT::stride(this->domain_m));
    return this->unwrap();
  }
  Domain_t &operator--() {
    DT::subtractAccum(this->domain_m, DT::stride(this->domain_m));
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator+=(const T &d2) {
    DT::addAccum(this->domain_m, d2);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator-=(const T &d2) {
    DT::subtractAccum(this->domain_m, d2);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator*=(const T &d2) {
    DT::multiplyAccum(this->domain_m, d2);
    return this->unwrap();
  }
  template<class T>
  inline
  Domain_t &operator/=(const T &d2) {
    DT::divideAccum(this->domain_m, d2);
    return this->unwrap();
  }
  template <int Dim2, int C>
  inline
  Domain_t &operator+=(const DomainDelta<Dim2, C>&)
  {
    if (C == 0)
      DT::addAccum(this->domain_m, 1);
    return this->unwrap();
  }
  template <int Dim2, int C>
  inline
  Domain_t &operator-=(const DomainDelta<Dim2, C>&)
  {
    if (C == 0)
      DT::subtractAccum(this->domain_m, 1);
    return this->unwrap();
  }
private:
  Domain(const Domain<1,DT> &);
  void operator=(const Domain<1,DT> &);
};
template <int Dim> class Loc;
template <> class Loc<1>;
template <int Dim> class Interval;
template <> class Interval<1>;
template <int Dim> class Range;
template <> class Range<1>;
template<int Dim>
struct DomainTraits< Interval<Dim> >
  : public DomainTraitsDomain<Interval<Dim>, int, Dim>
{
  typedef DomainTraitsDomain<Interval<Dim>, int, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef Interval<1> OneDomain_t;
  typedef Interval<1> PointDomain_t;
  typedef Interval<Dim> BlockDomain_t;
  typedef Loc<Dim> AskDomain_t;
  typedef Interval<Dim> AddResult_t;
  typedef Range<Dim> MultResult_t;
  typedef WrapNoInit<OneDomain_t> Storage_t[Dim];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = Dim };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = true };
  enum { wildcard = false };
  inline
  static OneDomain_t &getDomain(Domain_t &d, int n) { return d[n]; }
  inline
  static const OneDomain_t &getDomain(const Domain_t &d,int n) { return d[n]; }
  inline
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  inline
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  inline
  static void initializeStorage(Storage_t &dom) {
    Dom1Initialize<Dim-1>::template apply<DomainTraits<Interval<Dim> > >(dom);
  }
};
template<>
struct DomainTraits< Interval<1> >
  : public DomainTraitsDomain<Interval<1>, int, 1>
{
  typedef Interval<1> OneDomain_t;
  typedef Interval<1> PointDomain_t;
  typedef Interval<1> BlockDomain_t;
  typedef Loc<1> AskDomain_t;
  typedef Interval<1> AddResult_t;
  typedef Range<1> MultResult_t;
  typedef Element_t Storage_t[2];
  enum { dimensions = 1,
         sliceDimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = true };
  enum { wildcard = false };
  inline
  static Element_t first(const Storage_t &d) { return d[0]; }
  inline
  static Element_t last(const Storage_t &d) { return d[0] + d[1] - 1; }
  inline
  static Element_t stride(const Storage_t &) { return 1; }
  inline
  static Element_t length(const Storage_t &d) { return d[1]; }
  inline
  static Element_t min(const Storage_t &d) { return d[0]; }
  inline
  static Element_t max(const Storage_t &d) { return d[0] + d[1] - 1; }
  inline
  static bool empty(const Storage_t &d) { return (d[1] < 1); }
  inline
  static int loop(const Storage_t &) { return 0; }
  inline
  static Element_t elem(const Storage_t &d, int n) { return d[0] + n; }
  inline
  static OneDomain_t &getDomain(Domain_t &d, int) { return d; }
  inline
  static const OneDomain_t &getDomain(const Domain_t &d, int) { return d; }
  inline
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  inline
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  inline
  static void initializeStorage(Storage_t &dom) {
    dom[0] = 0;
    dom[1] = 0;
  }
  template<class T>
  inline
  static void setDomain(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    dom[0] = DomainTraits<T>::getFirst(newdom);
    dom[1] = DomainTraits<T>::getLength(newdom);
  }
  template<class T1, class T2>
  inline
  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T2>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T1>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T2>::singleValued)>::test();
    dom[0] = begval;
    dom[1] = (endval - begval + 1);
    ;
  }
  inline
  static void setLoop(Storage_t &, int) { }
  template<class UT, class T>
  inline
  static void setWildcardDomain(Storage_t &dom, const UT &u, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::wildcard)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<UT>::dimensions == 1)>::test();
    dom[0] = newdom.first(u);
    dom[1] = newdom.length(u);
  }
  template<class T>
  static bool isLessThan(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    return (dom[1] < DomainTraits<T>::getLength(newdom) ||
     (dom[1] == DomainTraits<T>::getLength(newdom) &&
      (dom[0] < DomainTraits<T>::getFirst(newdom) ||
       (dom[0] == DomainTraits<T>::getFirst(newdom) &&
        DomainTraits<T>::getStride(newdom) > 1))));
  }
  template<class T>
  static bool isEqualTo(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    return ((dom[1] == 0 && DomainTraits<T>::getLength(newdom) == 0) ||
     (dom[0] == DomainTraits<T>::getFirst(newdom) &&
      dom[1] == DomainTraits<T>::getLength(newdom) &&
      DomainTraits<T>::getStride(newdom) == 1));
  }
  template<class T>
  inline
  static void addAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] += DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  inline
  static void subtractAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] -= DomainTraits<T>::getFirst(newdom);
  }
};
template<int Dim1, int Dim2>
struct DomainChangeDim<Interval<Dim1>, Dim2>
{
  typedef Interval<Dim1> OldType_t;
  typedef Interval<Dim2> NewType_t;
  enum { oldDim = Dim1,
  newDim = Dim2 };
};
template<int Dim> class Loc;
template<int Dim> class Interval;
template<int Dim> class Range;
template<int Dim> class Grid;
template<int Dim> class AllDomain;
template<int Dim> class LeftDomain;
template<int Dim> class RightDomain;
template<int Dim, int SliceDim> class SliceInterval;
template<int Dim, int SliceDim> class SliceRange;
template<int Dim, class T> class Region;
template<class T> class IndirectionList;
template<class RT, class CT, int DS>
struct CombineDomain {
  enum { DRT = DomainTraits<RT>::dimensions };
  enum { DCT = DomainTraits<CT>::dimensions };
  static void combine(RT &rt, const CT& ct) {
    PoomaCTAssert<(DS >= 0)>::test();
    PoomaCTAssert<(DRT > (DS + DCT - 1))>::test();
    for (int i=0; i < DCT; ++i)
      DomainTraits<RT>::getDomain(rt, DS + i).setDomain(
                         DomainTraits<CT>::getDomain(ct, i));
  }
};
template<class RT, class UT, class CT, int DS, int SliceDS,
         bool incl, bool wc>
struct CombineSliceDomainWC {
  enum { DRT = DomainTraits<RT>::dimensions };
  enum { DCT = DomainTraits<CT>::dimensions };
  static void combine(RT &rt, const UT &, const CT& ct) {
    PoomaCTAssert<(DS >= 0)>::test();
    PoomaCTAssert<(DRT > (DS + DCT - 1))>::test();
    for (int i=0; i < DCT; ++i)
      DomainTraits<RT>::getDomain(rt, DS + i).setDomain(
                         DomainTraits<CT>::getPointDomain(ct, i));
  }
};
template<class RT, class UT, class CT, int DS, int SliceDS>
struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,true,false> {
  enum { DRT = DomainTraits<RT>::dimensions };
  enum { DCT = DomainTraits<CT>::dimensions };
  static void combine(RT &rt, const UT &, const CT& ct) {
    PoomaCTAssert<(DS >= 0 && SliceDS >= 0)>::test();
    PoomaCTAssert<(DRT > (DS + DCT - 1))>::test();
    for (int i=0; i < DCT; ++i) {
      DomainTraits<RT>::getDomain(rt, DS + i).setDomain(
 DomainTraits<CT>::getPointDomain(ct, i));
      DomainTraits<RT>::setIgnorable(rt, DS + i,
        DomainTraits<CT>::getIgnorable(ct, i));
    }
    rt.setSliceFromTotal();
  }
};
template<class RT, class UT, class CT, int DS, int SliceDS>
struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,false,true> {
  enum { DRT = DomainTraits<RT>::dimensions };
  enum { DUT = DomainTraits<UT>::dimensions };
  enum { DCT = DomainTraits<CT>::dimensions };
  static void combine(RT &rt, const UT &u, const CT& ct) {
    PoomaCTAssert<(DS >= 0)>::test();
    PoomaCTAssert<(DRT > (DS + DCT - 1))>::test();
    PoomaCTAssert<(DUT == DRT)>::test();
    for (int i=0; i < DCT; ++i)
      DomainTraits<RT>::getDomain(rt, DS + i).setWildcardDomain(
 DomainTraits<UT>::getPointDomain(u, DS + i),
 DomainTraits<CT>::getPointDomain(ct, i));
  }
};
template<class RT, class UT, class CT, int DS, int SliceDS>
struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,true,true> {
  enum { DRT = DomainTraits<RT>::dimensions };
  enum { DUT = DomainTraits<UT>::dimensions };
  enum { DCT = DomainTraits<CT>::dimensions };
  static void combine(RT &rt, const UT &u, const CT& ct) {
    PoomaCTAssert<(DS >= 0 && SliceDS >= 0)>::test();
    PoomaCTAssert<(DRT > (DS + DCT - 1))>::test();
    PoomaCTAssert<((int)DUT == DRT)>::test();
    for (int i=0; i < DCT; ++i) {
      DomainTraits<RT>::getDomain(rt, DS + i).setWildcardDomain(
 DomainTraits<UT>::getPointDomain(u, DS + i),
 DomainTraits<CT>::getPointDomain(ct, i));
      DomainTraits<RT>::getSliceDomain(rt, SliceDS + i).setWildcardDomain(
 DomainTraits<UT>::getPointDomain(u, DS + i),
 DomainTraits<CT>::getPointDomain(ct, i));
      DomainTraits<RT>::cantIgnoreDomain(rt, DS + i);
    }
  }
};
template<class RT, class UT, class CT, int DS, int SliceDS, bool incl>
struct CombineSliceDomain {
  static void combine(RT &rt, const UT &u, const CT& ct) {
    CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,incl,
      DomainTraits<CT>::wildcard>::combine(rt, u, ct);
  }
};
template<class T1, class T2, class TCombine, class TSCombine>
struct NewDomain2Base
{
  typedef TCombine Type_t;
  typedef TSCombine SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a, b);
    }
  template<class RT>
  inline static RT &fill(RT &retval, const T1 &a, const T2 &b)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::
 combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::
 combine(retval,u,b);
      return retval;
    }
};
template<class T1, class T2>
struct AddNewDomain2Dimensions
{
  enum { dimensions =
    DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions };
};
template<class T1, class T2>
struct NewDomain2
  : public NewDomain2Base<T1, T2,
                          Interval<AddNewDomain2Dimensions<T1,T2>::dimensions>,
                          Loc<AddNewDomain2Dimensions<T1,T2>::dimensions> >
{ };
template <int D1, int D2> struct NewDomain2< Range<D1>, Range<D2> > : public NewDomain2Base< Range<D1>, Range<D2>, Range<D1+D2>, Range<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Range<D1>, Loc<D2> > : public NewDomain2Base< Range<D1>, Loc<D2>, Range<D1+D2>, SliceRange<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, Range<D1> > : public NewDomain2Base< Loc<D2>, Range<D1>, Range<D1+D2>, SliceRange<D1+D2,D1> > { }; template <int D> struct NewDomain2< Range<D>, char > : public NewDomain2Base< Range<D>, char, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< char, Range<D> > : public NewDomain2Base< char, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, unsigned char > : public NewDomain2Base< Range<D>, unsigned char, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, Range<D> > : public NewDomain2Base< unsigned char, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, short > : public NewDomain2Base< Range<D>, short, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< short, Range<D> > : public NewDomain2Base< short, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, unsigned short > : public NewDomain2Base< Range<D>, unsigned short, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, Range<D> > : public NewDomain2Base< unsigned short, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, int > : public NewDomain2Base< Range<D>, int, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< int, Range<D> > : public NewDomain2Base< int, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, unsigned int > : public NewDomain2Base< Range<D>, unsigned int, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, Range<D> > : public NewDomain2Base< unsigned int, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, long > : public NewDomain2Base< Range<D>, long, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< long, Range<D> > : public NewDomain2Base< long, Range<D>, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Range<D>, unsigned long > : public NewDomain2Base< Range<D>, unsigned long, Range<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, Range<D> > : public NewDomain2Base< unsigned long, Range<D>, Range<D+1>, SliceRange<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< Range<D1>, Interval<D2> > : public NewDomain2Base< Range<D1>, Interval<D2>, Range<D1+D2>, Range<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Interval<D1>, Range<D2> > : public NewDomain2Base< Interval<D1>, Range<D2>, Range<D1+D2>, Range<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Range<D1>, AllDomain<D2> > : public NewDomain2Base< Range<D1>, AllDomain<D2>, Range<D1+D2>, Range<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< AllDomain<D1>, Range<D2> > : public NewDomain2Base< AllDomain<D1>, Range<D2>, Range<D1+D2>, Range<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Range<D1>, LeftDomain<D2> > : public NewDomain2Base< Range<D1>, LeftDomain<D2>, Range<D1+D2>, Range<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, Range<D2> > : public NewDomain2Base< LeftDomain<D1>, Range<D2>, Range<D1+D2>, Range<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Range<D1>, RightDomain<D2> > : public NewDomain2Base< Range<D1>, RightDomain<D2>, Range<D1+D2>, Range<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, Range<D2> > : public NewDomain2Base< RightDomain<D1>, Range<D2>, Range<D1+D2>, Range<D1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, Loc<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, Loc<D2>, SliceRange<D1+D2,DS1>, SliceRange<D1+D2,DS1> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Loc<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< Loc<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1>, SliceRange<D1+D2,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, char > : public NewDomain2Base< SliceRange<D1,DS1>, char ,SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, unsigned char > : public NewDomain2Base< SliceRange<D1,DS1>, unsigned char, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< char, SliceRange<D1,DS1> > : public NewDomain2Base< char, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned char, SliceRange<D1,DS1> > : public NewDomain2Base< unsigned char, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, short > : public NewDomain2Base< SliceRange<D1,DS1>, short ,SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, unsigned short > : public NewDomain2Base< SliceRange<D1,DS1>, unsigned short, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< short, SliceRange<D1,DS1> > : public NewDomain2Base< short, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned short, SliceRange<D1,DS1> > : public NewDomain2Base< unsigned short, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, int > : public NewDomain2Base< SliceRange<D1,DS1>, int ,SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, unsigned int > : public NewDomain2Base< SliceRange<D1,DS1>, unsigned int, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< int, SliceRange<D1,DS1> > : public NewDomain2Base< int, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned int, SliceRange<D1,DS1> > : public NewDomain2Base< unsigned int, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, long > : public NewDomain2Base< SliceRange<D1,DS1>, long ,SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceRange<D1,DS1>, unsigned long > : public NewDomain2Base< SliceRange<D1,DS1>, unsigned long, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< long, SliceRange<D1,DS1> > : public NewDomain2Base< long, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned long, SliceRange<D1,DS1> > : public NewDomain2Base< unsigned long, SliceRange<D1,DS1>, SliceRange<D1+1,DS1>, SliceRange<D1+1,DS1> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, Range<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, Range<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Range<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< Range<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, Interval<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, Interval<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Interval<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< Interval<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, AllDomain<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, AllDomain<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< AllDomain<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< AllDomain<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, LeftDomain<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, LeftDomain<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< LeftDomain<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< LeftDomain<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceRange<D1,DS1>, RightDomain<D2> > : public NewDomain2Base< SliceRange<D1,DS1>, RightDomain<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< RightDomain<D2>, SliceRange<D1,DS1> > : public NewDomain2Base< RightDomain<D2>, SliceRange<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int D2> struct NewDomain2< Interval<D1>, Interval<D2> > : public NewDomain2Base< Interval<D1>, Interval<D2>, Interval<D1+D2>, Interval<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Interval<D1>, Loc<D2> > : public NewDomain2Base< Interval<D1>, Loc<D2>, Interval<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, Interval<D1> > : public NewDomain2Base< Loc<D2>, Interval<D1>, Interval<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D> struct NewDomain2< Interval<D>, char > : public NewDomain2Base< Interval<D>, char, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< char, Interval<D> > : public NewDomain2Base< char, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, unsigned char > : public NewDomain2Base< Interval<D>, unsigned char, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, Interval<D> > : public NewDomain2Base< unsigned char, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, short > : public NewDomain2Base< Interval<D>, short, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< short, Interval<D> > : public NewDomain2Base< short, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, unsigned short > : public NewDomain2Base< Interval<D>, unsigned short, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, Interval<D> > : public NewDomain2Base< unsigned short, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, int > : public NewDomain2Base< Interval<D>, int, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< int, Interval<D> > : public NewDomain2Base< int, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, unsigned int > : public NewDomain2Base< Interval<D>, unsigned int, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, Interval<D> > : public NewDomain2Base< unsigned int, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, long > : public NewDomain2Base< Interval<D>, long, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< long, Interval<D> > : public NewDomain2Base< long, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< Interval<D>, unsigned long > : public NewDomain2Base< Interval<D>, unsigned long, Interval<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, Interval<D> > : public NewDomain2Base< unsigned long, Interval<D>, Interval<D+1>, SliceInterval<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< Interval<D1>, AllDomain<D2> > : public NewDomain2Base< Interval<D1>, AllDomain<D2>, Interval<D1+D2>, Interval<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< AllDomain<D1>, Interval<D2> > : public NewDomain2Base< AllDomain<D1>, Interval<D2>, Interval<D1+D2>, Interval<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Interval<D1>, LeftDomain<D2> > : public NewDomain2Base< Interval<D1>, LeftDomain<D2>, Interval<D1+D2>, Interval<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, Interval<D2> > : public NewDomain2Base< LeftDomain<D1>, Interval<D2>, Interval<D1+D2>, Interval<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Interval<D1>, RightDomain<D2> > : public NewDomain2Base< Interval<D1>, RightDomain<D2>, Interval<D1+D2>, Interval<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, Interval<D2> > : public NewDomain2Base< RightDomain<D1>, Interval<D2>, Interval<D1+D2>, Interval<D1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, Loc<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, Loc<D2>, SliceInterval<D1+D2,DS1>, SliceInterval<D1+D2,DS1> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Loc<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< Loc<D2>, SliceInterval<D1,DS1>, SliceInterval<D1+D2,DS1>, SliceInterval<D1+D2,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, char > : public NewDomain2Base< SliceInterval<D1,DS1>, char ,SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, unsigned char > : public NewDomain2Base< SliceInterval<D1,DS1>, unsigned char, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< char, SliceInterval<D1,DS1> > : public NewDomain2Base< char, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned char, SliceInterval<D1,DS1> > : public NewDomain2Base< unsigned char, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, short > : public NewDomain2Base< SliceInterval<D1,DS1>, short ,SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, unsigned short > : public NewDomain2Base< SliceInterval<D1,DS1>, unsigned short, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< short, SliceInterval<D1,DS1> > : public NewDomain2Base< short, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned short, SliceInterval<D1,DS1> > : public NewDomain2Base< unsigned short, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, int > : public NewDomain2Base< SliceInterval<D1,DS1>, int ,SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, unsigned int > : public NewDomain2Base< SliceInterval<D1,DS1>, unsigned int, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< int, SliceInterval<D1,DS1> > : public NewDomain2Base< int, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned int, SliceInterval<D1,DS1> > : public NewDomain2Base< unsigned int, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, long > : public NewDomain2Base< SliceInterval<D1,DS1>, long ,SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< SliceInterval<D1,DS1>, unsigned long > : public NewDomain2Base< SliceInterval<D1,DS1>, unsigned long, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< long, SliceInterval<D1,DS1> > : public NewDomain2Base< long, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { }; template <int D1, int DS1> struct NewDomain2< unsigned long, SliceInterval<D1,DS1> > : public NewDomain2Base< unsigned long, SliceInterval<D1,DS1>, SliceInterval<D1+1,DS1>, SliceInterval<D1+1,DS1> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, Interval<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, Interval<D2>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Interval<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< Interval<D2>, SliceInterval<D1,DS1>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, Range<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, Range<D2>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< Range<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< Range<D2>, SliceInterval<D1,DS1>, SliceRange<D1+D2,DS1+D2>, SliceRange<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, AllDomain<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, AllDomain<D2>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< AllDomain<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< AllDomain<D2>, SliceInterval<D1,DS1>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, LeftDomain<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, LeftDomain<D2>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< LeftDomain<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< LeftDomain<D2>, SliceInterval<D1,DS1>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { };
template <int D1, int DS1, int D2> struct NewDomain2< SliceInterval<D1,DS1>, RightDomain<D2> > : public NewDomain2Base< SliceInterval<D1,DS1>, RightDomain<D2>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { }; template <int D1, int DS1, int D2> struct NewDomain2< RightDomain<D2>, SliceInterval<D1,DS1> > : public NewDomain2Base< RightDomain<D2>, SliceInterval<D1,DS1>, SliceInterval<D1+D2,DS1+D2>, SliceInterval<D1+D2,DS1+D2> > { };
template <int D1, int D2> struct NewDomain2< AllDomain<D1>, AllDomain<D2> > : public NewDomain2Base< AllDomain<D1>, AllDomain<D2>, AllDomain<D1+D2>, AllDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< AllDomain<D1>, Loc<D2> > : public NewDomain2Base< AllDomain<D1>, Loc<D2>, AllDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, AllDomain<D1> > : public NewDomain2Base< Loc<D2>, AllDomain<D1>, AllDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D> struct NewDomain2< AllDomain<D>, char > : public NewDomain2Base< AllDomain<D>, char, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< char, AllDomain<D> > : public NewDomain2Base< char, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, unsigned char > : public NewDomain2Base< AllDomain<D>, unsigned char, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, AllDomain<D> > : public NewDomain2Base< unsigned char, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, short > : public NewDomain2Base< AllDomain<D>, short, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< short, AllDomain<D> > : public NewDomain2Base< short, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, unsigned short > : public NewDomain2Base< AllDomain<D>, unsigned short, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, AllDomain<D> > : public NewDomain2Base< unsigned short, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, int > : public NewDomain2Base< AllDomain<D>, int, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< int, AllDomain<D> > : public NewDomain2Base< int, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, unsigned int > : public NewDomain2Base< AllDomain<D>, unsigned int, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, AllDomain<D> > : public NewDomain2Base< unsigned int, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, long > : public NewDomain2Base< AllDomain<D>, long, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< long, AllDomain<D> > : public NewDomain2Base< long, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< AllDomain<D>, unsigned long > : public NewDomain2Base< AllDomain<D>, unsigned long, AllDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, AllDomain<D> > : public NewDomain2Base< unsigned long, AllDomain<D>, AllDomain<D+1>, SliceInterval<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, LeftDomain<D2> > : public NewDomain2Base< LeftDomain<D1>, LeftDomain<D2>, LeftDomain<D1+D2>, LeftDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, Loc<D2> > : public NewDomain2Base< LeftDomain<D1>, Loc<D2>, LeftDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, LeftDomain<D1> > : public NewDomain2Base< Loc<D2>, LeftDomain<D1>, LeftDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D> struct NewDomain2< LeftDomain<D>, char > : public NewDomain2Base< LeftDomain<D>, char, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< char, LeftDomain<D> > : public NewDomain2Base< char, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, unsigned char > : public NewDomain2Base< LeftDomain<D>, unsigned char, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, LeftDomain<D> > : public NewDomain2Base< unsigned char, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, short > : public NewDomain2Base< LeftDomain<D>, short, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< short, LeftDomain<D> > : public NewDomain2Base< short, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, unsigned short > : public NewDomain2Base< LeftDomain<D>, unsigned short, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, LeftDomain<D> > : public NewDomain2Base< unsigned short, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, int > : public NewDomain2Base< LeftDomain<D>, int, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< int, LeftDomain<D> > : public NewDomain2Base< int, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, unsigned int > : public NewDomain2Base< LeftDomain<D>, unsigned int, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, LeftDomain<D> > : public NewDomain2Base< unsigned int, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, long > : public NewDomain2Base< LeftDomain<D>, long, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< long, LeftDomain<D> > : public NewDomain2Base< long, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< LeftDomain<D>, unsigned long > : public NewDomain2Base< LeftDomain<D>, unsigned long, LeftDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, LeftDomain<D> > : public NewDomain2Base< unsigned long, LeftDomain<D>, LeftDomain<D+1>, SliceInterval<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< RightDomain<D1>, RightDomain<D2> > : public NewDomain2Base< RightDomain<D1>, RightDomain<D2>, RightDomain<D1+D2>, RightDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, Loc<D2> > : public NewDomain2Base< RightDomain<D1>, Loc<D2>, RightDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, RightDomain<D1> > : public NewDomain2Base< Loc<D2>, RightDomain<D1>, RightDomain<D1+D2>, SliceInterval<D1+D2,D1> > { }; template <int D> struct NewDomain2< RightDomain<D>, char > : public NewDomain2Base< RightDomain<D>, char, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< char, RightDomain<D> > : public NewDomain2Base< char, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, unsigned char > : public NewDomain2Base< RightDomain<D>, unsigned char, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, RightDomain<D> > : public NewDomain2Base< unsigned char, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, short > : public NewDomain2Base< RightDomain<D>, short, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< short, RightDomain<D> > : public NewDomain2Base< short, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, unsigned short > : public NewDomain2Base< RightDomain<D>, unsigned short, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, RightDomain<D> > : public NewDomain2Base< unsigned short, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, int > : public NewDomain2Base< RightDomain<D>, int, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< int, RightDomain<D> > : public NewDomain2Base< int, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, unsigned int > : public NewDomain2Base< RightDomain<D>, unsigned int, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, RightDomain<D> > : public NewDomain2Base< unsigned int, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, long > : public NewDomain2Base< RightDomain<D>, long, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< long, RightDomain<D> > : public NewDomain2Base< long, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< RightDomain<D>, unsigned long > : public NewDomain2Base< RightDomain<D>, unsigned long, RightDomain<D+1>, SliceInterval<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, RightDomain<D> > : public NewDomain2Base< unsigned long, RightDomain<D>, RightDomain<D+1>, SliceInterval<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< AllDomain<D1>, LeftDomain<D2> > : public NewDomain2Base< AllDomain<D1>, LeftDomain<D2>, AllDomain<D1+D2>, AllDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, AllDomain<D2> > : public NewDomain2Base< LeftDomain<D1>, AllDomain<D2>, AllDomain<D1+D2>, AllDomain<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< AllDomain<D1>, RightDomain<D2> > : public NewDomain2Base< AllDomain<D1>, RightDomain<D2>, AllDomain<D1+D2>, AllDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, AllDomain<D2> > : public NewDomain2Base< RightDomain<D1>, AllDomain<D2>, AllDomain<D1+D2>, AllDomain<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, RightDomain<D2> > : public NewDomain2Base< LeftDomain<D1>, RightDomain<D2>, LeftDomain<D1+D2>, LeftDomain<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, LeftDomain<D2> > : public NewDomain2Base< RightDomain<D1>, LeftDomain<D2>, LeftDomain<D1+D2>, LeftDomain<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, Grid<D2> > : public NewDomain2Base< Grid<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Grid<D1>, Loc<D2> > : public NewDomain2Base< Grid<D1>, Loc<D2>, Grid<D1+D2>, SliceRange<D1+D2,D1> > { }; template <int D1, int D2> struct NewDomain2< Loc<D2>, Grid<D1> > : public NewDomain2Base< Loc<D2>, Grid<D1>, Grid<D1+D2>, SliceRange<D1+D2,D1> > { }; template <int D> struct NewDomain2< Grid<D>, char > : public NewDomain2Base< Grid<D>, char, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< char, Grid<D> > : public NewDomain2Base< char, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, unsigned char > : public NewDomain2Base< Grid<D>, unsigned char, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned char, Grid<D> > : public NewDomain2Base< unsigned char, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, short > : public NewDomain2Base< Grid<D>, short, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< short, Grid<D> > : public NewDomain2Base< short, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, unsigned short > : public NewDomain2Base< Grid<D>, unsigned short, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned short, Grid<D> > : public NewDomain2Base< unsigned short, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, int > : public NewDomain2Base< Grid<D>, int, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< int, Grid<D> > : public NewDomain2Base< int, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, unsigned int > : public NewDomain2Base< Grid<D>, unsigned int, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned int, Grid<D> > : public NewDomain2Base< unsigned int, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, long > : public NewDomain2Base< Grid<D>, long, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< long, Grid<D> > : public NewDomain2Base< long, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< Grid<D>, unsigned long > : public NewDomain2Base< Grid<D>, unsigned long, Grid<D+1>, SliceRange<D+1,D> > { }; template <int D> struct NewDomain2< unsigned long, Grid<D> > : public NewDomain2Base< unsigned long, Grid<D>, Grid<D+1>, SliceRange<D+1,D> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, Range<D2> > : public NewDomain2Base< Grid<D1>, Range<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Range<D1>, Grid<D2> > : public NewDomain2Base< Range<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, Interval<D2> > : public NewDomain2Base< Grid<D1>, Interval<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< Interval<D1>, Grid<D2> > : public NewDomain2Base< Interval<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, AllDomain<D2> > : public NewDomain2Base< Grid<D1>, AllDomain<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< AllDomain<D1>, Grid<D2> > : public NewDomain2Base< AllDomain<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, LeftDomain<D2> > : public NewDomain2Base< Grid<D1>, LeftDomain<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< LeftDomain<D1>, Grid<D2> > : public NewDomain2Base< LeftDomain<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { };
template <int D1, int D2> struct NewDomain2< Grid<D1>, RightDomain<D2> > : public NewDomain2Base< Grid<D1>, RightDomain<D2>, Grid<D1+D2>, Grid<D1+D2> > { }; template <int D1, int D2> struct NewDomain2< RightDomain<D1>, Grid<D2> > : public NewDomain2Base< RightDomain<D1>, Grid<D2>, Grid<D1+D2>, Grid<D1+D2> > { };
template<int D>
struct NewDomain2< Grid<D>, IndirectionList<int> >
  : public NewDomain2Base<Grid<D>,IndirectionList<int>,Grid<D+1>,Grid<D+1> >{};
template<int D>
struct NewDomain2< IndirectionList<int>, Grid<D> >
  : public NewDomain2Base<IndirectionList<int>,Grid<D>,Grid<D+1>,Grid<D+1> >{};
template<int D1, int D2>
struct NewDomain2< Loc<D1>, Loc<D2> >
  : public NewDomain2Base<Loc<D1>, Loc<D2>, Loc<D1+D2>, Loc<D1+D2> > { };
template <int D1, class T1, int D2, class T2> struct NewDomain2< Region<D1,T1>, Region<D2,T2> > : public NewDomain2Base< Region<D1,T1>, Region<D2,T2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, char > : public NewDomain2Base< Region<D1,T1>, char, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< char, Region<D1,T1> > : public NewDomain2Base< char, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, unsigned char > : public NewDomain2Base< Region<D1,T1>, unsigned char, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< unsigned char, Region<D1,T1> > : public NewDomain2Base< unsigned char, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, short > : public NewDomain2Base< Region<D1,T1>, short, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< short, Region<D1,T1> > : public NewDomain2Base< short, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, unsigned short > : public NewDomain2Base< Region<D1,T1>, unsigned short, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< unsigned short, Region<D1,T1> > : public NewDomain2Base< unsigned short, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, int > : public NewDomain2Base< Region<D1,T1>, int, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< int, Region<D1,T1> > : public NewDomain2Base< int, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, unsigned int > : public NewDomain2Base< Region<D1,T1>, unsigned int, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< unsigned int, Region<D1,T1> > : public NewDomain2Base< unsigned int, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, long > : public NewDomain2Base< Region<D1,T1>, long, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< long, Region<D1,T1> > : public NewDomain2Base< long, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, unsigned long > : public NewDomain2Base< Region<D1,T1>, unsigned long, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< unsigned long, Region<D1,T1> > : public NewDomain2Base< unsigned long, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, float > : public NewDomain2Base< Region<D1,T1>, float, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< float, Region<D1,T1> > : public NewDomain2Base< float, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1> struct NewDomain2< Region<D1,T1>, double > : public NewDomain2Base< Region<D1,T1>, double, Region<D1+1,T1>, Region<D1+1,T1> > { }; template <int D1, class T1> struct NewDomain2< double, Region<D1,T1> > : public NewDomain2Base< double, Region<D1,T1>, Region<D1+1,T1>, Region<D1+1,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, Range<D2> > : public NewDomain2Base< Region<D1,T1>, Range<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< Range<D2>, Region<D1,T1> > : public NewDomain2Base< Range<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, Interval<D2> > : public NewDomain2Base< Region<D1,T1>, Interval<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< Interval<D2>, Region<D1,T1> > : public NewDomain2Base< Interval<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, Loc<D2> > : public NewDomain2Base< Region<D1,T1>, Loc<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< Loc<D2>, Region<D1,T1> > : public NewDomain2Base< Loc<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, AllDomain<D2> > : public NewDomain2Base< Region<D1,T1>, AllDomain<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< AllDomain<D2>, Region<D1,T1> > : public NewDomain2Base< AllDomain<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, LeftDomain<D2> > : public NewDomain2Base< Region<D1,T1>, LeftDomain<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< LeftDomain<D2>, Region<D1,T1> > : public NewDomain2Base< LeftDomain<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <int D1, class T1, int D2> struct NewDomain2< Region<D1,T1>, RightDomain<D2> > : public NewDomain2Base< Region<D1,T1>, RightDomain<D2>, Region<D1+D2,T1>, Region<D1+D2,T1> > { }; template <int D1, class T1, int D2> struct NewDomain2< RightDomain<D2>, Region<D1,T1> > : public NewDomain2Base< RightDomain<D2>, Region<D1,T1>, Region<D1+D2,T1>, Region<D1+D2,T1> > { };
template <> struct NewDomain2<double, double> : public NewDomain2Base< double, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<float, float> : public NewDomain2Base< float, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<double, char> : public NewDomain2Base< double, char, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<char, double> : public NewDomain2Base< char, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, unsigned char> : public NewDomain2Base< double, unsigned char, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<unsigned char, double> : public NewDomain2Base< unsigned char, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, short> : public NewDomain2Base< double, short, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<short, double> : public NewDomain2Base< short, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, unsigned short> : public NewDomain2Base< double, unsigned short, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<unsigned short, double> : public NewDomain2Base< unsigned short, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, int> : public NewDomain2Base< double, int, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<int, double> : public NewDomain2Base< int, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, unsigned int> : public NewDomain2Base< double, unsigned int, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<unsigned int, double> : public NewDomain2Base< unsigned int, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, long> : public NewDomain2Base< double, long, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<long, double> : public NewDomain2Base< long, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, unsigned long> : public NewDomain2Base< double, unsigned long, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<unsigned long, double> : public NewDomain2Base< unsigned long, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<double, float> : public NewDomain2Base< double, float, Region<2,double>, Region<2,double> > { }; template <> struct NewDomain2<float, double> : public NewDomain2Base< float, double, Region<2,double>, Region<2,double> > { };
template <> struct NewDomain2<float, char> : public NewDomain2Base< float, char, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<char, float> : public NewDomain2Base< char, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, unsigned char> : public NewDomain2Base< float, unsigned char, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<unsigned char, float> : public NewDomain2Base< unsigned char, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, short> : public NewDomain2Base< float, short, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<short, float> : public NewDomain2Base< short, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, unsigned short> : public NewDomain2Base< float, unsigned short, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<unsigned short, float> : public NewDomain2Base< unsigned short, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, int> : public NewDomain2Base< float, int, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<int, float> : public NewDomain2Base< int, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, unsigned int> : public NewDomain2Base< float, unsigned int, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<unsigned int, float> : public NewDomain2Base< unsigned int, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, long> : public NewDomain2Base< float, long, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<long, float> : public NewDomain2Base< long, float, Region<2,float>, Region<2,float> > { };
template <> struct NewDomain2<float, unsigned long> : public NewDomain2Base< float, unsigned long, Region<2,float>, Region<2,float> > { }; template <> struct NewDomain2<unsigned long, float> : public NewDomain2Base< unsigned long, float, Region<2,float>, Region<2,float> > { };
template <int D1> struct NewDomain2< double, Loc<D1> > : public NewDomain2Base< double, Loc<D1>, Region<D1+1,double>, Region<D1+1,double> > { }; template <int D1> struct NewDomain2< Loc<D1>, double > : public NewDomain2Base< Loc<D1>, double, Region<D1+1,double>, Region<D1+1,double> > { };
template <int D1> struct NewDomain2< double, Interval<D1> > : public NewDomain2Base< double, Interval<D1>, Region<D1+1,double>, Region<D1+1,double> > { }; template <int D1> struct NewDomain2< Interval<D1>, double > : public NewDomain2Base< Interval<D1>, double, Region<D1+1,double>, Region<D1+1,double> > { };
template <int D1> struct NewDomain2< double, Range<D1> > : public NewDomain2Base< double, Range<D1>, Region<D1+1,double>, Region<D1+1,double> > { }; template <int D1> struct NewDomain2< Range<D1>, double > : public NewDomain2Base< Range<D1>, double, Region<D1+1,double>, Region<D1+1,double> > { };
template <int D1> struct NewDomain2< float, Loc<D1> > : public NewDomain2Base< float, Loc<D1>, Region<D1+1,float>, Region<D1+1,float> > { }; template <int D1> struct NewDomain2< Loc<D1>, float > : public NewDomain2Base< Loc<D1>, float, Region<D1+1,float>, Region<D1+1,float> > { };
template <int D1> struct NewDomain2< float, Interval<D1> > : public NewDomain2Base< float, Interval<D1>, Region<D1+1,float>, Region<D1+1,float> > { }; template <int D1> struct NewDomain2< Interval<D1>, float > : public NewDomain2Base< Interval<D1>, float, Region<D1+1,float>, Region<D1+1,float> > { };
template <int D1> struct NewDomain2< float, Range<D1> > : public NewDomain2Base< float, Range<D1>, Region<D1+1,float>, Region<D1+1,float> > { }; template <int D1> struct NewDomain2< Range<D1>, float > : public NewDomain2Base< Range<D1>, float, Region<D1+1,float>, Region<D1+1,float> > { };
template<class ND, class T>
struct NewDomainNBase
{
  typedef typename ND::Type_t PrevType_t;
  typedef typename ND::SliceType_t PrevSliceType_t;
  typedef typename NewDomain2<PrevType_t,T>::Type_t Type_t;
  typedef typename NewDomain2<PrevSliceType_t,T>::SliceType_t SliceType_t;
};
template<class T1>
struct NewDomain1
{
  typedef typename DomainTraits<T1>::Domain_t Type_t;
  typedef typename DomainTraits<T1>::NewDomain1_t SliceType_t;
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  inline static Type_t combine(const T1 &a)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a);
    }
  template<class RT>
  inline static RT &fill(RT &retval, const T1 &a)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u, const T1 &a)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      return retval;
    }
};
template<class T1, class T2, class T3>
struct NewDomain3 : public NewDomainNBase<NewDomain2<T1,T2>, T3>
{
  typedef typename NewDomainNBase<NewDomain2<T1,T2>, T3>::Type_t Type_t;
  typedef typename NewDomainNBase<NewDomain2<T1,T2>, T3>::SliceType_t SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { S3 = S2 + DomainTraits<T2>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  enum { DX3 = DomainTraits<T3>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b, const T3 &c)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a, b, c);
    }
  template<class RT>
  inline static RT &fill(RT &retval,
    const T1 &a, const T2 &b, const T3 &c)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      CombineDomain<RT,T3,S3>::combine(retval,c);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b, const T3 &c)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b, c);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b, const T3 &c)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::combine(retval,u,b);
      CombineSliceDomain<RT,UT,T3,S3,DX1+DX2,(DX3>0 && RDX)>::
        combine(retval,u,c);
      return retval;
    }
};
template<class T1, class T2, class T3, class T4>
struct NewDomain4 : public NewDomainNBase<NewDomain3<T1,T2,T3>, T4>
{
  typedef typename NewDomainNBase<NewDomain3<T1,T2,T3>, T4>::Type_t Type_t;
  typedef typename NewDomainNBase<NewDomain3<T1,T2,T3>, T4>::SliceType_t
    SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { S3 = S2 + DomainTraits<T2>::dimensions };
  enum { S4 = S3 + DomainTraits<T3>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  enum { DX3 = DomainTraits<T3>::sliceDimensions };
  enum { DX4 = DomainTraits<T4>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b, const T3 &c,
          const T4 &d)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a, b, c, d);
    }
  template<class RT>
  inline static RT &fill(RT &retval,
    const T1 &a, const T2 &b, const T3 &c,
    const T4 &d)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      CombineDomain<RT,T3,S3>::combine(retval,c);
      CombineDomain<RT,T4,S4>::combine(retval,d);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b, const T3 &c,
      const T4 &d)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b, c, d);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b, const T3 &c,
         const T4 &d)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::combine(retval,u,b);
      CombineSliceDomain<RT,UT,T3,S3,DX1+DX2,(DX3>0 && RDX)>::
        combine(retval,u,c);
      CombineSliceDomain<RT,UT,T4,S4,DX1+DX2+DX3,(DX4>0 && RDX)>::
        combine(retval,u,d);
      return retval;
    }
};
template<class T1, class T2, class T3, class T4, class T5>
struct NewDomain5 : public NewDomainNBase<NewDomain4<T1,T2,T3,T4>, T5>
{
  typedef typename NewDomainNBase<NewDomain4<T1,T2,T3,T4>, T5>::Type_t Type_t;
  typedef typename NewDomainNBase<NewDomain4<T1,T2,T3,T4>, T5>::SliceType_t
    SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { S3 = S2 + DomainTraits<T2>::dimensions };
  enum { S4 = S3 + DomainTraits<T3>::dimensions };
  enum { S5 = S4 + DomainTraits<T4>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  enum { DX3 = DomainTraits<T3>::sliceDimensions };
  enum { DX4 = DomainTraits<T4>::sliceDimensions };
  enum { DX5 = DomainTraits<T5>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b, const T3 &c,
          const T4 &d, const T5 &e)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a, b, c, d, e);
    }
  template<class RT>
  inline static RT &fill(RT &retval,
    const T1 &a, const T2 &b, const T3 &c,
    const T4 &d, const T5 &e)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      CombineDomain<RT,T3,S3>::combine(retval,c);
      CombineDomain<RT,T4,S4>::combine(retval,d);
      CombineDomain<RT,T5,S5>::combine(retval,e);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b, const T3 &c,
      const T4 &d, const T5 &e)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b, c, d, e);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b, const T3 &c,
         const T4 &d, const T5 &e)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::combine(retval,u,b);
      CombineSliceDomain<RT,UT,T3,S3,DX1+DX2,(DX3>0 && RDX)>::
        combine(retval,u,c);
      CombineSliceDomain<RT,UT,T4,S4,DX1+DX2+DX3,(DX4>0 && RDX)>::
        combine(retval,u,d);
      CombineSliceDomain<RT,UT,T5,S5,DX1+DX2+DX3+DX4,(DX5>0 && RDX)>::
        combine(retval,u,e);
      return retval;
    }
};
template<class T1, class T2, class T3, class T4, class T5, class T6>
struct NewDomain6 : public NewDomainNBase<NewDomain5<T1,T2,T3,T4,T5>, T6>
{
  typedef typename
    NewDomainNBase<NewDomain5<T1,T2,T3,T4,T5>, T6>::Type_t Type_t;
  typedef typename
    NewDomainNBase<NewDomain5<T1,T2,T3,T4,T5>, T6>::SliceType_t SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { S3 = S2 + DomainTraits<T2>::dimensions };
  enum { S4 = S3 + DomainTraits<T3>::dimensions };
  enum { S5 = S4 + DomainTraits<T4>::dimensions };
  enum { S6 = S5 + DomainTraits<T5>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  enum { DX3 = DomainTraits<T3>::sliceDimensions };
  enum { DX4 = DomainTraits<T4>::sliceDimensions };
  enum { DX5 = DomainTraits<T5>::sliceDimensions };
  enum { DX6 = DomainTraits<T6>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b,
          const T3 &c, const T4 &d,
          const T5 &e, const T6 &f)
    {
      Type_t retval = Pooma::NoInit();
      return fill(retval, a, b, c, d, e, f);
    }
  template<class RT>
  inline static RT &fill(RT &retval,
    const T1 &a, const T2 &b,
    const T3 &c, const T4 &d,
    const T5 &e, const T6 &f)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      CombineDomain<RT,T3,S3>::combine(retval,c);
      CombineDomain<RT,T4,S4>::combine(retval,d);
      CombineDomain<RT,T5,S5>::combine(retval,e);
      CombineDomain<RT,T6,S6>::combine(retval,f);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b,
      const T3 &c, const T4 &d,
      const T5 &e, const T6 &f)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b, c, d, e, f);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b, const T3 &c,
         const T4 &d, const T5 &e, const T6 &f)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::combine(retval,u,b);
      CombineSliceDomain<RT,UT,T3,S3,DX1+DX2,(DX3>0 && RDX)>::
        combine(retval,u,c);
      CombineSliceDomain<RT,UT,T4,S4,DX1+DX2+DX3,(DX4>0 && RDX)>::
        combine(retval,u,d);
      CombineSliceDomain<RT,UT,T5,S5,DX1+DX2+DX3+DX4,(DX5>0 && RDX)>::
        combine(retval,u,e);
      CombineSliceDomain<RT,UT,T6,S6,DX1+DX2+DX3+DX4+DX5,(DX6>0 && RDX)>::
        combine(retval,u,f);
      return retval;
    }
};
template<class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct NewDomain7 : public NewDomainNBase<NewDomain6<T1,T2,T3,T4,T5,T6>, T7>
{
  typedef typename
    NewDomainNBase<NewDomain6<T1,T2,T3,T4,T5,T6>, T7>::Type_t Type_t;
  typedef typename
    NewDomainNBase<NewDomain6<T1,T2,T3,T4,T5,T6>, T7>::SliceType_t SliceType_t;
  enum { S2 = DomainTraits<T1>::dimensions };
  enum { S3 = S2 + DomainTraits<T2>::dimensions };
  enum { S4 = S3 + DomainTraits<T3>::dimensions };
  enum { S5 = S4 + DomainTraits<T4>::dimensions };
  enum { S6 = S5 + DomainTraits<T5>::dimensions };
  enum { S7 = S6 + DomainTraits<T6>::dimensions };
  enum { DX1 = DomainTraits<T1>::sliceDimensions };
  enum { DX2 = DomainTraits<T2>::sliceDimensions };
  enum { DX3 = DomainTraits<T3>::sliceDimensions };
  enum { DX4 = DomainTraits<T4>::sliceDimensions };
  enum { DX5 = DomainTraits<T5>::sliceDimensions };
  enum { DX6 = DomainTraits<T6>::sliceDimensions };
  enum { DX7 = DomainTraits<T7>::sliceDimensions };
  inline static Type_t combine(const T1 &a, const T2 &b,
          const T3 &c, const T4 &d,
          const T5 &e, const T6 &f,
          const T7 &g)
    {
      Type_t retval = Pooma::NoInit();
      NewDomain7<T1,T2,T3,T4,T5,T6,T7>::fill(retval, a, b, c, d, e, f, g);
      return fill(retval, a, b, c, d, e, f,g);
    }
  template<class RT>
  inline static RT &fill(RT &retval,
    const T1 &a, const T2 &b,
    const T3 &c, const T4 &d,
    const T5 &e, const T6 &f,
    const T7 &g)
    {
      CombineDomain<RT,T1,0>::combine(retval,a);
      CombineDomain<RT,T2,S2>::combine(retval,b);
      CombineDomain<RT,T3,S3>::combine(retval,c);
      CombineDomain<RT,T4,S4>::combine(retval,d);
      CombineDomain<RT,T5,S5>::combine(retval,e);
      CombineDomain<RT,T6,S6>::combine(retval,f);
      CombineDomain<RT,T7,S7>::combine(retval,g);
      return retval;
    }
  template<class UT>
  inline static SliceType_t combineSlice(const UT &u,
      const T1 &a, const T2 &b,
      const T3 &c, const T4 &d,
      const T5 &e, const T6 &f,
      const T7 &g)
    {
      SliceType_t retval = Pooma::NoInit();
      return fillSlice(retval, u, a, b, c, d, e, f, g);
    }
  template<class RT, class UT>
  inline static RT &fillSlice(RT &retval, const UT &u,
         const T1 &a, const T2 &b,
         const T3 &c, const T4 &d,
         const T5 &e, const T6 &f,
         const T7 &g)
    {
      enum { RDX =
        DomainTraits<RT>::dimensions > DomainTraits<RT>::sliceDimensions };
      CombineSliceDomain<RT,UT,T1,0,0,(DX1>0 && RDX)>::combine(retval,u,a);
      CombineSliceDomain<RT,UT,T2,S2,DX1,(DX2>0 && RDX)>::combine(retval,u,b);
      CombineSliceDomain<RT,UT,T3,S3,DX1+DX2,(DX3>0 && RDX)>::
        combine(retval,u,c);
      CombineSliceDomain<RT,UT,T4,S4,DX1+DX2+DX3,(DX4>0 && RDX)>::
        combine(retval,u,d);
      CombineSliceDomain<RT,UT,T5,S5,DX1+DX2+DX3+DX4,(DX5>0 && RDX)>::
        combine(retval,u,e);
      CombineSliceDomain<RT,UT,T6,S6,DX1+DX2+DX3+DX4+DX5,(DX6>0 && RDX)>::
        combine(retval,u,f);
      CombineSliceDomain<RT,UT,T7,S7,DX1+DX2+DX3+DX4+DX5+DX6,(DX7>0 && RDX)>::
        combine(retval,u,g);
      return retval;
    }
};
template<class Domain, class Sub>
struct TemporaryNewDomain1
{
  typedef typename NewDomain1<Sub>::SliceType_t SliceType_t;
  static inline
  SliceType_t combineSlice(const Domain &d, const Sub &s)
  {
    return NewDomain1<Sub>::combineSlice(d, s);
  }
};
template<class Domain, int N>
struct TemporaryNewDomain1<Domain, AllDomain<N> >
{
  typedef Domain SliceType_t;
  static inline
  const SliceType_t &combineSlice(const Domain &d, const AllDomain<N> &)
  {
    return d;
  }
};
template<int Dim>
class Interval : public Domain<Dim, DomainTraits<Interval<Dim> > >
{
  typedef DomainTraits< Interval<Dim> > DT_t;
  typedef Domain<Dim, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Interval() { }
  Interval(const Interval<Dim> &a)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain1<Interval<Dim> >::fill(*this, a);
  }
  Interval(const Pooma::NoInit &a)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(a)
  { }
  template<class T1>
  explicit Interval(const T1 &a)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  template<class T1, class T2>
  Interval(const T1 &a, const T2 &b)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain2<T1,T2>::fill(*this, a, b);
  }
  template<class T1, class T2, class T3>
  Interval(const T1 &a, const T2 &b, const T3 &c)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain3<T1,T2,T3>::fill(*this, a, b, c);
  }
  template<class T1, class T2, class T3, class T4>
  Interval(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain4<T1,T2,T3,T4>::fill(*this, a, b, c, d);
  }
  template<class T1, class T2, class T3, class T4, class T5>
  Interval(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain5<T1,T2,T3,T4,T5>::fill(*this, a, b, c, d, e);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  Interval(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain6<T1,T2,T3,T4,T5,T6>::fill(*this, a, b, c, d, e, f);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  Interval(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f, const T7 &g)
    : Domain<Dim, DomainTraits<Interval<Dim> > >(Pooma::NoInit()) {
    NewDomain7<T1,T2,T3,T4,T5,T6,T7>::fill(*this, a, b, c, d, e, f, g);
  }
  ~Interval() { }
  template<class T>
  Interval<Dim> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Interval<Dim> &operator=(const Interval<Dim> &newdom) {
    return NewDomain1<Interval<Dim> >::fill(*this, newdom);
  }
protected:
private:
};
template<>
class Interval<1> : public Domain<1, DomainTraits<Interval<1> > >
{
  typedef DomainTraits< Interval<1> > DT_t;
public:
  typedef DT_t::Element_t Element_t;
  typedef DT_t::Domain_t Domain_t;
  typedef DT_t::OneDomain_t OneDomain_t;
  typedef DT_t::BlockDomain_t BlockDomain_t;
  typedef DT_t::AskDomain_t AskDomain_t;
  typedef DT_t::AddResult_t AddResult_t;
  typedef DT_t::MultResult_t MultResult_t;
  typedef DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Interval() { }
  Interval(const Interval<1> &a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    NewDomain1<Interval<1> >::fill(*this, a);
  }
  Interval(const Pooma::NoInit &a)
    : Domain<1, DomainTraits<Interval<1> > >(a)
  { }
  template<class T1>
  explicit Interval(const T1 &a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  Interval(char a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(unsigned char a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(short a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(unsigned short a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(int a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(unsigned int a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(long a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  Interval(unsigned long a)
    : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
    DomainTraits<Interval<1> >::setDomain(domain_m, 0, a - 1);
  }
  template<class T1, class T2>
  Interval(const T1 &m, const T2 &n);
  template<class T1, class T2, class T3>
  Interval(const T1 &m, const T2 &n, const T3 &s);
  template<class T>
  Interval<1> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Interval<1> &operator=(const Interval<1> &newdom) {
    return NewDomain1<Interval<1> >::fill(*this, newdom);
  }
  const OneDomain_t &operator[](int d) const { return *this; }
  OneDomain_t &operator[](int d) { return *this; }
};
template <class T1, class T2>
inline
Interval<1>::Interval(const T1 &m, const T2 &n)
  : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
  DomainTraits<Interval<1> >::setDomain(domain_m, m, n);
}
template <class T1, class T2, class T3>
inline
Interval<1>::Interval(const T1 &m, const T2 &n, const T3 &s)
  : Domain<1, DomainTraits<Interval<1> > >(Pooma::NoInit()) {
  ;
  DomainTraits<Interval<1> >::setDomain(domain_m, m, n);
}
template <int Dim> class Loc;
template <> class Loc<1>;
template <int Dim> class Interval;
template <> class Interval<1>;
template<int Dim>
struct DomainTraits< Loc<Dim> >
  : public DomainTraitsDomain<Loc<Dim>, int, Dim>
{
  typedef DomainTraitsDomain<Loc<Dim>, int, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef Loc<1> OneDomain_t;
  typedef Loc<1> PointDomain_t;
  typedef Interval<Dim> BlockDomain_t;
  typedef Loc<Dim> AskDomain_t;
  typedef Loc<Dim> AddResult_t;
  typedef Loc<Dim> MultResult_t;
  typedef WrapNoInit<OneDomain_t> Storage_t[Dim];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = 0 };
  enum { loopAware = false };
  enum { singleValued = true };
  enum { unitStride = true };
  enum { wildcard = false };
  inline
  static OneDomain_t &getDomain(Domain_t &d, int n) {
    return d[n];
  }
  inline
  static const OneDomain_t &getDomain(const Domain_t &d, int n) {
    return d[n];
  }
  inline
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return d[n];
  }
  inline
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return d[n];
  }
  static void initializeStorage(Storage_t &dom) {
    Dom1Initialize<Dim-1>::template apply<DomainTraits<Loc<Dim> > >(dom);
  }
  template<class T>
  inline
  static void addAccum(Storage_t &dom, const T &newdom)
  {
    PoomaCTAssert<(DomainTraits<T>::singleValued && (DomainTraits<T>::dimensions == 1 || DomainTraits<T>::dimensions == dimensions ))>::test();
    if (DomainTraits<T>::dimensions > 1)
      for (int i = 0;i< DomainTraits<T>::dimensions ; ++i)
 dom[i] += DomainTraits<T>::getFirst(newdom[i]);
    else
      for (int i = 0;i< dimensions ; ++i)
 dom[i] += DomainTraits<T>::getFirst(newdom[0]);
  }
  template<class T>
  inline
  static void subtractAccum(Storage_t &dom, const T &newdom)
  {
    PoomaCTAssert<(DomainTraits<T>::singleValued && (DomainTraits<T>::dimensions == 1 || DomainTraits<T>::dimensions == dimensions ))>::test();
    if (DomainTraits<T>::dimensions > 1)
      for (int i = 0;i< DomainTraits<T>::dimensions ; ++i)
 dom[i] -= DomainTraits<T>::getFirst(newdom[i]);
    else
      for (int i = 0;i< dimensions ; ++i)
 dom[i] -= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void multiplyAccum(Storage_t &dom, const T &newdom)
  {
    PoomaCTAssert<(DomainTraits<T>::singleValued && (DomainTraits<T>::dimensions == 1 || DomainTraits<T>::dimensions == dimensions ))>::test();
    if (DomainTraits<T>::dimensions > 1)
      for (int i = 0;i< DomainTraits<T>::dimensions ; ++i)
 dom[i] *= DomainTraits<T>::getFirst(newdom[i]);
    else
      for (int i = 0;i< dimensions ; ++i)
 dom[i] *= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void divideAccum(Storage_t &dom, const T &newdom)
  {
    PoomaCTAssert<(DomainTraits<T>::singleValued && (DomainTraits<T>::dimensions == 1 || DomainTraits<T>::dimensions == dimensions ))>::test();
    if (DomainTraits<T>::dimensions > 1)
      for (int i = 0;i< DomainTraits<T>::dimensions ; ++i)
 dom[i] /= DomainTraits<T>::getFirst(newdom[i]);
    else
      for (int i = 0;i< dimensions ; ++i)
 dom[i] /= DomainTraits<T>::getFirst(newdom);
  }
};
template<>
struct DomainTraits< Loc<1> >
  : public DomainTraitsDomain<Loc<1>, int, 1>
{
  typedef Loc<1> OneDomain_t;
  typedef Loc<1> PointDomain_t;
  typedef Interval<1> BlockDomain_t;
  typedef Loc<1> AskDomain_t;
  typedef Loc<1> AddResult_t;
  typedef Loc<1> MultResult_t;
  typedef Element_t Storage_t;
  enum { dimensions = 1,
         sliceDimensions = 0 };
  enum { loopAware = false };
  enum { singleValued = true };
  enum { unitStride = true };
  enum { wildcard = false };
  inline
  static Element_t first(Storage_t d) { return d; }
  inline
  static Element_t last(Storage_t d) { return d; }
  inline
  static Element_t stride(Storage_t) { return 1; }
  inline
  static Element_t length(Storage_t) { return 1; }
  inline
  static Element_t min(Storage_t d) { return d; }
  inline
  static Element_t max(Storage_t d) { return d; }
  inline
  static bool empty(Storage_t) { return false; }
  inline
  static int loop(Storage_t) { return 0; }
  inline
  static Element_t elem(Storage_t d, int) { return d; }
  inline
  static OneDomain_t &getDomain(Domain_t &d, int) {
    return d;
  }
  inline
  static const OneDomain_t &getDomain(const Domain_t &d, int) {
    return d;
  }
  inline
  static PointDomain_t &getPointDomain(Domain_t &d, int) {
    return d;
  }
  inline
  static const PointDomain_t &getPointDomain(const Domain_t &d, int) {
    return d;
  }
  inline
  static void initializeStorage(Storage_t &dom) {
    dom = 0;
  }
  template<class T>
  inline
  static void setDomain(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    dom = DomainTraits<T>::getFirst(newdom);
  }
  inline
  static void setLoop(Storage_t &, int) { }
  template<class UT, class T>
  inline
  static void setWildcardDomain(Storage_t &dom, const UT &u, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::wildcard)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<UT>::dimensions == 1)>::test();
    dom = newdom.first(u);
  }
  template<class T>
  static bool isLessThan(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    return (dom < DomainTraits<T>::getFirst(newdom));
  }
  template<class T>
  static bool isEqualTo(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    return (dom == DomainTraits<T>::getFirst(newdom));
  }
  template<class T>
  inline
  static void addAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
   dom += DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  inline
  static void subtractAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom -= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void multiplyAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom *= DomainTraits<T>::getFirst(newdom);
  }
 template<class T>
  static void divideAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom /= DomainTraits<T>::getFirst(newdom);
  }
};
template<int Dim1, int Dim2>
struct DomainChangeDim<Loc<Dim1>, Dim2>
{
  typedef Loc<Dim1> OldType_t;
  typedef Loc<Dim2> NewType_t;
  enum { oldDim = Dim1,
  newDim = Dim2 };
};
template <int dstIndex, int toGo>
struct FillLocStorage
{
  template <int Dim, class T>
  static inline
  void fill(Loc<Dim> &loc, const T &a)
  {
    PoomaCTAssert<(dstIndex < Dim)>::test();
    loc[dstIndex].setDomain(DomainTraits<T>::getPointDomain(a, DomainTraits<T>::dimensions-toGo-1));
    FillLocStorage<dstIndex+1,toGo-1>::fill(loc, a);
  }
};
template <int dstIndex>
struct FillLocStorage<dstIndex, 0>
{
  template <int Dim, class T>
  static inline
  void fill(Loc<Dim> &loc, const T &a)
  {
    PoomaCTAssert<(dstIndex < Dim)>::test();
    loc[dstIndex].setDomain(DomainTraits<T>::getPointDomain(a, DomainTraits<T>::dimensions-1));
  }
};
template <int i>
struct FillAllLocStorage
{
  template <int Dim, class T>
  inline
  static void fill(Loc<Dim> &loc, const T &a)
  {
    loc[Dim-i-1].setDomain(DomainTraits<T>::getPointDomain(a, 0));
    FillAllLocStorage<i-1>::fill(loc, a);
  }
};
template <>
struct FillAllLocStorage<0>
{
  template <int Dim, class T>
  inline
  static void fill(Loc<Dim> &loc, const T &a)
  {
    loc[Dim-1].setDomain(DomainTraits<T>::getPointDomain(a, 0));
  }
};
template<int Dim, class T1>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a)
{
  FillLocStorage<0, DomainTraits<T1>::dimensions-1>::fill(loc, a);
}
template<int Dim, class T1, class T2>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b)
{
  fillLocStorage(loc, a);
  FillLocStorage<DomainTraits<T1>::dimensions, DomainTraits<T2>::dimensions-1>::fill(loc, b);
}
template<int Dim, class T1, class T2, class T3>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b, const T3 &c)
{
  fillLocStorage(loc, a, b);
  FillLocStorage<DomainTraits<T1>::dimensions
     + DomainTraits<T2>::dimensions,
                 DomainTraits<T3>::dimensions-1>::fill(loc, c);
}
template<int Dim, class T1, class T2, class T3, class T4>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b, const T3 &c,
      const T4 &d)
{
  fillLocStorage(loc, a, b, c);
  FillLocStorage<DomainTraits<T1>::dimensions
     + DomainTraits<T2>::dimensions
     + DomainTraits<T3>::dimensions,
                 DomainTraits<T4>::dimensions-1>::fill(loc, d);
}
template<int Dim, class T1, class T2, class T3, class T4, class T5>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b, const T3 &c,
      const T4 &d, const T5 &e)
{
  fillLocStorage(loc, a, b, c, d);
  FillLocStorage<DomainTraits<T1>::dimensions
     + DomainTraits<T2>::dimensions
     + DomainTraits<T3>::dimensions
     + DomainTraits<T4>::dimensions,
                 DomainTraits<T5>::dimensions-1>::fill(loc, e);
}
template<int Dim, class T1, class T2, class T3, class T4, class T5, class T6>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b, const T3 &c,
      const T4 &d, const T5 &e, const T6 &f)
{
  fillLocStorage(loc, a, b, c, d, e);
  FillLocStorage<DomainTraits<T1>::dimensions
     + DomainTraits<T2>::dimensions
     + DomainTraits<T3>::dimensions
     + DomainTraits<T4>::dimensions
     + DomainTraits<T5>::dimensions,
                 DomainTraits<T6>::dimensions-1>::fill(loc, f);
}
template<int Dim, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline
void fillLocStorage(Loc<Dim> &loc, const T1 &a, const T2 &b, const T3 &c,
      const T4 &d, const T5 &e, const T6 &f, const T7 &g)
{
  fillLocStorage(loc, a, b, c, d, e, f);
  FillLocStorage<DomainTraits<T1>::dimensions
     + DomainTraits<T2>::dimensions
     + DomainTraits<T3>::dimensions
     + DomainTraits<T4>::dimensions
     + DomainTraits<T5>::dimensions
     + DomainTraits<T6>::dimensions,
                 DomainTraits<T7>::dimensions-1>::fill(loc, g);
}
template<int Dim, class T, int DimT, bool wildcard>
struct CopyLocStorageImpl
{
  inline
  static void copy(Loc<Dim> &, const T &) { }
};
template<int Dim, class T, int DimT>
struct CopyLocStorageImpl<Dim, T, DimT, false>
{
  inline
  static void copy(Loc<Dim> &loc, const T &a) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == DimT)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions <= Dim)>::test();
    fillLocStorage(loc, a);
  }
};
template<int Dim, class T>
struct CopyLocStorageImpl<Dim, T, 1, false>
{
  inline
  static void copy(Loc<Dim> &loc, const T &a) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    FillAllLocStorage<Dim-1>::fill(loc, a);
  }
};
template<int Dim, class T>
struct CopyLocStorage
{
  inline
  static void copy(Loc<Dim> &loc, const T &a) {
    CopyLocStorageImpl<Dim, T, DomainTraits<T>::dimensions,
                       DomainTraits<T>::wildcard>::copy(loc, a);
  }
};
template<int Dim>
class Loc : public Domain<Dim, DomainTraits<Loc<Dim> > >
{
  typedef DomainTraits< Loc<Dim> > DT_t;
  typedef Domain<Dim, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  inline
  Loc() { }
  inline
  Loc(const Loc<Dim> &a)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    fillLocStorage(*this, a);
  }
  Loc(const Pooma::NoInit &a)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(a)
  { }
  template<class T1>
  inline
  explicit Loc(const T1 &a)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    CopyLocStorage<Dim, T1>::copy(*this, a);
  }
  template<class T1, class T2>
  inline
  Loc(const T1 &a, const T2 &b)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions))>::test();
    fillLocStorage(*this, a, b);
  }
  template<class T1, class T2, class T3>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions + DomainTraits<T3>::dimensions))>::test();
    fillLocStorage(*this, a, b, c);
  }
  template<class T1, class T2, class T3, class T4>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions + DomainTraits<T3>::dimensions + DomainTraits<T4>::dimensions))>::test();
    fillLocStorage(*this, a, b, c, d);
  }
  template<class T1, class T2, class T3, class T4, class T5>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions + DomainTraits<T3>::dimensions + DomainTraits<T4>::dimensions + DomainTraits<T5>::dimensions))>::test();
    fillLocStorage(*this, a, b, c, d, e);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions + DomainTraits<T3>::dimensions + DomainTraits<T4>::dimensions + DomainTraits<T5>::dimensions + DomainTraits<T6>::dimensions))>::test();
    fillLocStorage(*this, a, b, c, d, e, f);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f, const T7 &g)
    : Domain<Dim, DomainTraits<Loc<Dim> > >(Pooma::NoInit()) {
    PoomaCTAssert<(Dim >= (DomainTraits<T1>::dimensions + DomainTraits<T2>::dimensions + DomainTraits<T3>::dimensions + DomainTraits<T4>::dimensions + DomainTraits<T5>::dimensions + DomainTraits<T6>::dimensions + DomainTraits<T7>::dimensions))>::test();
    fillLocStorage(*this, a, b, c, d, e, f, g);
  }
  inline
  ~Loc() { }
  template<class T>
  inline
  Loc<Dim> &operator=(const T &newdom) {
    CopyLocStorage<Dim, T>::copy(*this, newdom);
    return *this;
  }
  inline
  Loc<Dim> &operator=(const Loc<Dim> &newdom) {
    fillLocStorage(*this, newdom);
    return *this;
  }
  template<class Out>
  void print(Out &o) const;
protected:
private:
};
template<int Dim>
template<class Out>
void Loc<Dim>::print(Out &o) const
{
  const Domain_t &d = this->unwrap();
  o << "[";
  for (int i=0; i < Dim; ++i) {
    o << d[i].first();
    if (i < (Dim-1))
      o << ",";
  }
  o << "]";
}
template<>
class Loc<1> : public Domain<1, DomainTraits<Loc<1> > >
{
  typedef DomainTraits< Loc<1> > DT_t;
public:
  typedef DT_t::Element_t Element_t;
  typedef DT_t::Domain_t Domain_t;
  typedef DT_t::OneDomain_t OneDomain_t;
  typedef DT_t::BlockDomain_t BlockDomain_t;
  typedef DT_t::AskDomain_t AskDomain_t;
  typedef DT_t::AddResult_t AddResult_t;
  typedef DT_t::MultResult_t MultResult_t;
  typedef DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  inline
  Loc() { }
  inline
  Loc(const Loc<1> &a)
    : Domain<1, DomainTraits<Loc<1> > >(Pooma::NoInit()) {
    setDomain(a);
  }
  Loc(const Pooma::NoInit &a)
    : Domain<1, DomainTraits<Loc<1> > >(a)
  { }
  template<class T1>
  inline
  explicit Loc(const T1 &a)
    : Domain<1, DomainTraits<Loc<1> > >(Pooma::NoInit()) {
    setDomain(DomainTraits<T1>::getPointDomain(a, 0));
  }
  template<class T1, class T2>
  inline
  Loc(const T1 &a, const T2 &b)
    : Domain<1, DomainTraits<Loc<1> > >(Pooma::NoInit()) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1 && DomainTraits<T2>::dimensions == 1 && DomainTraits<T1>::singleValued && DomainTraits<T2>::singleValued)>::test();
    ;
    setDomain(DomainTraits<T1>::getPointDomain(a, 0));
  }
  template<class T1, class T2, class T3>
  inline
  Loc(const T1 &a, const T2 &b, const T3 &c)
    : Domain<1, DomainTraits<Loc<1> > >(Pooma::NoInit()) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1 && DomainTraits<T2>::dimensions == 1 && DomainTraits<T3>::dimensions == 1 && DomainTraits<T1>::singleValued && DomainTraits<T2>::singleValued && DomainTraits<T3>::singleValued)>::test();
    ;
    setDomain(DomainTraits<T1>::getPointDomain(a, 0));
  }
  template<class T>
  inline
  Loc<1> &operator=(const T &newdom) {
    setDomain(DomainTraits<T>::getPointDomain(newdom, 0));
    return *this;
  }
  inline
  Loc<1> &operator=(const Loc<1> &newdom) {
    setDomain(newdom);
    return *this;
  }
  const OneDomain_t &operator[](int d) const { return *this; }
  OneDomain_t &operator[](int d) { return *this; }
  template<class Out>
  void print(Out &o) const;
};
template<class Out>
void Loc<1>::print(Out &o) const
{
  const Domain_t &d = this->unwrap();
  o << "[";
  o << d[0].first();
  o << "]";
}
template<int Dim>
std::ostream& operator<<(std::ostream &o, const Loc<Dim> &loc)
{
  loc.print(o);
  return o;
}
# 1 "/usr/include/c++/6/vector" 1 3
# 58 "/usr/include/c++/6/vector" 3
       
# 59 "/usr/include/c++/6/vector" 3




# 1 "/usr/include/c++/6/bits/stl_uninitialized.h" 1 3
# 59 "/usr/include/c++/6/bits/stl_uninitialized.h" 3

# 59 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 171 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 234 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 370 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 677 "/usr/include/c++/6/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 64 "/usr/include/c++/6/vector" 2 3
# 1 "/usr/include/c++/6/bits/stl_vector.h" 1 3
# 66 "/usr/include/c++/6/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 213 "/usr/include/c++/6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 278 "/usr/include/c++/6/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 291 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 320 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 337 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 375 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 401 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 425 "/usr/include/c++/6/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 437 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 449 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 470 "/usr/include/c++/6/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 488 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 505 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 533 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 673 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 693 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 725 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 764 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 779 "/usr/include/c++/6/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      { return *(this->_M_impl._M_start + __n); }
# 794 "/usr/include/c++/6/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 822 "/usr/include/c++/6/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 840 "/usr/include/c++/6/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      { return *(end() - 1); }





      const_reference
      back() const noexcept
      { return *(end() - 1); }
# 887 "/usr/include/c++/6/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }


      const _Tp*



      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 913 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 949 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 969 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 984 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1014 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1031 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      { return this->insert(__position, __l.begin(), __l.end()); }
# 1051 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1093 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1145 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1172 "/usr/include/c++/6/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1194 "/usr/include/c++/6/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1243 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1321 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1361 "/usr/include/c++/6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }



      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const
 { return __ptr; }

      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }






    };
# 1507 "/usr/include/c++/6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1524 "/usr/include/c++/6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "/usr/include/c++/6/vector" 2 3
# 1 "/usr/include/c++/6/bits/stl_bvector.h" 1 3
# 63 "/usr/include/c++/6/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 540 "/usr/include/c++/6/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 611 "/usr/include/c++/6/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 677 "/usr/include/c++/6/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 773 "/usr/include/c++/6/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                          ,
     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 989 "/usr/include/c++/6/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>
      void
      emplace_back(_Args&&... __args)
      { push_back(bool(__args...)); }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/include/c++/6/vector" 2 3



# 1 "/usr/include/c++/6/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/6/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   const auto __pos = begin() + (__position - cbegin());
   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__pos, std::move(__x_copy));
     }
   else
     _M_insert_aux(__pos, __x);



 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + (__position - cbegin()),
   std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;



   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = pointer();

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = pointer();

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    __new_finish =
      std::__uninitialized_default_n_a(__new_finish, __n,
           _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/include/c++/6/vector" 2 3
# 5054 "tramp3d-v4.cpp" 2

# 5054 "tramp3d-v4.cpp"
class Pool
{
public:
  Pool(size_t sz);
  Pool();
  ~Pool();
  inline void* alloc()
    {
      outstandingAllocs_m += 1;
      if ( head_m==0 )
 grow();
      Link *p = head_m;
      memcpy(&head_m, &p->next_m, sizeof(head_m));
      return p;
    }
  inline void free(void *b)
    {
      outstandingAllocs_m -= 1;
      Link *p = (Link*)b;
      p->next_m = head_m;
      memcpy(&p->next_m, &head_m, sizeof(head_m));
      head_m = p;
    }
private:
  struct Link { Link *next_m; };
  enum { page=4096-8 };
  enum { align = 8 };
  enum { alignMask = align-1 };
  static inline int blocksInPage(size_t sz)
    {
      return (page>sz)?(page/sz):1;
    }
  static inline size_t roundToAlign(size_t s)
    {
      if (s)
 s = (s & ~alignMask) + ((s&alignMask)?align:0);
      else
 s = align;
      return s;
    }
  void grow();
  Link *head_m;
  int outstandingAllocs_m;
  size_t bsize_m;
  size_t nblock_m;
  std::vector<char*> chunks_m;
};
template<class T>
class Pooled
{
public:
  inline void* operator new(size_t) { return pool_s.alloc(); }
  inline void operator delete(void *p, size_t) { if (p) pool_s.free(p); }
  inline void* operator new(size_t, void* ptr) { return ptr; }
  inline void operator delete(void *, void *) { }
private:
  static Pool pool_s;
};
template<class T>
Pool Pooled<T>::pool_s(sizeof(T));
template<class Dom, class OrigDom = Dom>
class Node : public Pooled<Node<Dom, OrigDom> >
{
public:
  typedef Dom Domain_t;
  typedef OrigDom AllocatedDomain_t;
  typedef int Context_t;
  typedef int ID_t;
  typedef Node<Dom,OrigDom> This_t;
  Node()
    : local_m(-1), global_m(0), context_m(0), affinity_m(-1)
  {
  }
  Node(const Domain_t &owned, const AllocatedDomain_t &allocated,
       Context_t c, ID_t gid, ID_t lid = (-1))
    : domain_m(owned), allocated_m(allocated),
      local_m(lid), global_m(gid),
      context_m(c), affinity_m(-1)
  {
    ;
    ;
    ;
  }
  Node(const Domain_t &d, Context_t c, ID_t gid, ID_t lid = (-1))
    : domain_m(d), allocated_m(d),
      local_m(lid), global_m(gid),
      context_m(c), affinity_m(-1)
  {
    ;
    ;
  }
  Node(int affinity, const Domain_t &owned, const AllocatedDomain_t &allocated,
       Context_t c, ID_t gid, ID_t lid = (-1))
    : domain_m(owned), allocated_m(allocated),
      local_m(lid), global_m(gid), context_m(c),
      affinity_m(affinity)
  {
    ;
    ;
    ;
  }
  Node(int affinity, const Domain_t &d,
       Context_t c, ID_t gid, ID_t lid = (-1))
    : domain_m(d), allocated_m(d),
      local_m(lid), global_m(gid),
      context_m(c), affinity_m(affinity)
  {
    ;
    ;
  }
  Node(const This_t &n)
    : domain_m(n.domain_m), allocated_m(n.allocated_m),
      local_m(n.local_m), global_m(n.global_m),
      context_m(n.context_m), affinity_m(n.affinity_m)
  {
  }
  template<class ODom, class OAlloc>
  Node(const Node<ODom,OAlloc> &n)
    : domain_m(n.domain()), allocated_m(n.allocated()),
      local_m(n.localID()), global_m(n.globalID()),
      context_m(n.context()), affinity_m(n.affinity())
  {
  }
  void initialize(const Domain_t &owned, const AllocatedDomain_t &allocated,
                  Context_t c, ID_t gid, ID_t lid = (-1))
  {
    ;
    ;
    domain_m = owned;
    allocated_m = allocated;
    context_m = c;
    local_m = lid;
    global_m = gid;
  }
  void initialize(const Domain_t &d, Context_t c, ID_t gid, ID_t lid = (-1))
  {
    ;
    ;
    domain_m = d;
    allocated_m = d;
    context_m = c;
    local_m = lid;
    global_m = gid;
  }
  ~Node()
  {
  }
  inline const Domain_t &domain() const { return domain_m; }
  inline const AllocatedDomain_t &allocated() const { return allocated_m; }
  Context_t context() const { return context_m; }
  ID_t localID() const { return local_m; }
  ID_t globalID() const { return global_m; }
  bool isLocal() const { return (local_m >= 0); }
  int affinity() const { return affinity_m; }
  int& affinity() { return affinity_m; }
  int& context() { return context_m; }
  int& localID() { return local_m; }
  void setDomain(const Domain_t &dom) { domain_m = dom; }
  Domain_t &domain() { return domain_m; }
  void setAllocated(const AllocatedDomain_t &dom) { allocated_m = dom; }
  AllocatedDomain_t &allocated() { return allocated_m; }
  This_t &operator=(const This_t &n)
  {
    domain_m = n.domain();
    allocated_m = n.allocated();
    context_m = n.context();
    local_m = n.localID();
    global_m = n.globalID();
    affinity_m = n.affinity();
    return *this;
  }
  template<class ODom, class OAlloc>
  This_t &operator=(const Node<ODom,OAlloc> &n)
  {
    domain_m = n.domain();
    allocated_m = n.allocated();
    context_m = n.context();
    local_m = n.localID();
    global_m = n.globalID();
    affinity_m = n.affinity();
    return *this;
  }
  This_t &operator=(const Domain_t &d)
  {
    domain_m = d;
    return *this;
  }
  template<class Out>
  void print(Out &o) const
  {
    o << "{" << domain();
    o << ": allocated=" << allocated();
    o << ", con=" << context();
    o << ", aff=" << affinity();
    o << ", gid=" << globalID();
    o << ", lid=" << localID();
    o << "}";
  }
private:
  enum { dim = DomainTraits<Dom>::dimensions };
  enum { origDim = DomainTraits<OrigDom>::dimensions };
  Domain_t domain_m;
  AllocatedDomain_t allocated_m;
  ID_t local_m;
  ID_t global_m;
  Context_t context_m;
  int affinity_m;
};
template <class D, class A>
std::ostream &operator<<(std::ostream &o, const Node<D,A> &node)
{
  node.print(o);
  return o;
}
template<int Dim, class Dom, class OrigDom>
inline bool contains(const Interval<Dim> &i, const Node<Dom, OrigDom> &n)
{
  return contains(i, n.domain());
}
template<class Dom, class OrigDom>
struct DomainTraits<Node<Dom, OrigDom> >
{
  enum { singleValued = 0 };
};
template<class Domain, class Sub>
struct TemporaryNewDomain1;
template<class Domain, class OwnedDomain, class AllocatedDomain>
struct TemporaryNewDomain1<Domain, Node<OwnedDomain, AllocatedDomain> >
{
  typedef Node<OwnedDomain,AllocatedDomain> SliceType_t;
  static inline
  const SliceType_t &combineSlice(const Domain &,
    const Node<OwnedDomain,AllocatedDomain> &n)
  {
    return n;
  }
};

class GlobalIDDataBase
{
public:
  typedef int LayoutID_t;
  typedef int GlobalID_t;
  typedef int NodeKey_t;
  typedef std::map<LayoutID_t, GlobalID_t> Shared_t;
  GlobalIDDataBase() { }
  inline static
  NodeKey_t nullNodeKey()
  {
    return -1;
  }
  NodeKey_t push(LayoutID_t layoutID, int context, GlobalID_t globalID);
  NodeKey_t push(LayoutID_t layoutID,
   int context,
   GlobalID_t globalID,
   NodeKey_t parentNode);
  void shared(LayoutID_t idNew, LayoutID_t idOld);
  GlobalID_t globalID(LayoutID_t layoutID, NodeKey_t key) const;
  int context(LayoutID_t layoutID, NodeKey_t key) const;
  int context(NodeKey_t key) const;
  bool contextParticipates(int context, NodeKey_t key) const;
  template<class OSTR>
  inline void print(OSTR &ostr)
  {
    typedef std::vector<Pack> Store_t;
    typedef typename Store_t::const_iterator Iterator_t;
    Iterator_t p = data_m.begin();
    for (; p != data_m.end(); ++p)
    {
      ostr << "(" << (*p).layoutID() << ","
    << (*p).globalID() << ","
    << (*p).context() << ","
    << (*p).parent() << ")";
    }
  }
private:
  struct Pack
  {
    Pack()
      : layoutID_m(0), context_m(0), globalID_m(0), parent_m(0)
    { }
    inline
    Pack(LayoutID_t layoutID, int context, GlobalID_t globalID,
  NodeKey_t parent)
      : layoutID_m(layoutID),
 context_m(context),
 globalID_m(globalID),
 parent_m(parent)
    { }
    inline LayoutID_t layoutID() const { return layoutID_m; }
    inline int context() const { return context_m; }
    inline GlobalID_t globalID() const { return globalID_m; }
    inline NodeKey_t parent() const { return parent_m; }
    LayoutID_t layoutID_m;
    int context_m;
    GlobalID_t globalID_m;
    NodeKey_t parent_m;
  };
  std::vector<Pack> data_m;
  Shared_t shared_m;
};
class Unique
{
public:
  typedef long Value_t;
  Unique()
    {
    }
  ~Unique()
    {
    }
  static inline Value_t get()
    {
      mutex_s.lock();
      Value_t retval = next_s++;
      mutex_s.unlock();
      return retval;
    }
  static inline Value_t lockedGet()
    {
      return get();
    }
private:
  static Value_t next_s;
  static Pooma::Mutex_t mutex_s;
};
struct TouchesConstructNodePtr {
  TouchesConstructNodePtr(){};
  ~TouchesConstructNodePtr(){};
};
struct TouchesConstructNodeObj {
  TouchesConstructNodeObj(){};
  ~TouchesConstructNodeObj(){};
};
template<class Domain>
inline Node<Domain> *
touchesConstruct(const Domain &owned,
   int affinity, int c, int gid, int lid,
   const TouchesConstructNodePtr &)
{
  return new Node<Domain>(affinity, owned, c, gid, lid);
}
template<class Domain, class AllocatedDomain>
inline Node<Domain,AllocatedDomain> *
touchesConstruct(const Domain &owned, const AllocatedDomain &allocated,
   int affinity, int c, int gid, int lid,
   const TouchesConstructNodePtr &)
{
  return new Node<Domain,AllocatedDomain>
             (affinity, owned, allocated, c, gid, lid);
}
template<class Domain>
inline Node<Domain>
touchesConstruct(const Domain &owned,
   int affinity, int c, int gid, int lid,
    const TouchesConstructNodeObj &)
{
  return Node<Domain>(affinity, owned, c, gid, lid);
}
template<class Domain, class AllocatedDomain>
inline Node<Domain,AllocatedDomain>
touchesConstruct(const Domain &owned, const AllocatedDomain &allocated,
   int affinity, int c, int gid, int lid,
   const TouchesConstructNodeObj &)
{
  return Node<Domain,AllocatedDomain>(affinity, owned, allocated, c, gid, lid);
}
template<int Dim> class INode;
template<int Dim>
struct TouchesConstructINode
{
  typedef GlobalIDDataBase::NodeKey_t NodeKey_t;
  typedef Unique::Value_t LayoutID_t;
  TouchesConstructINode(LayoutID_t layoutID,
   NodeKey_t parent,
   GlobalIDDataBase *globalIDDataBase)
    : layoutID_m(layoutID), parent_m(parent),
      globalIDDataBase_m(globalIDDataBase)
  { }
  inline LayoutID_t layoutID() const { return layoutID_m; }
  inline NodeKey_t parent() const { return parent_m; }
  inline GlobalIDDataBase *globalIDDataBase() const
  {
    return globalIDDataBase_m;
  }
  LayoutID_t layoutID_m;
  NodeKey_t parent_m;
  GlobalIDDataBase *globalIDDataBase_m;
};
template <int Dim>
class INode
{
public:
  typedef INode<Dim> This_t;
  typedef Interval<Dim> Domain_t;
  typedef GlobalIDDataBase::LayoutID_t LayoutID_t;
  typedef GlobalIDDataBase::GlobalID_t GlobalID_t;
  typedef GlobalIDDataBase::NodeKey_t NodeKey_t;
  enum { dimensions = Dim };
  inline INode() : domain_m(Pooma::NoInit()) { }
  inline INode(const INode<Dim> &model)
    : domain_m(model.domain_m),
      globalIDDataBase_m(model.globalIDDataBase_m),
      key_m(model.key_m)
  { }
  template<int D2, class Dom>
  inline INode(const INode<D2> &model, const Dom &dom)
    : domain_m(dom),
      globalIDDataBase_m(model.globalIDDataBase()),
      key_m(model.key())
  { }
  inline
  INode(const Interval<Dim> &dom, LayoutID_t layoutID, int context,
 GlobalID_t globalID,
 GlobalIDDataBase *globalIDDataBase, NodeKey_t parent = -1)
    : domain_m(dom),
      globalIDDataBase_m(globalIDDataBase)
  {
    key_m = globalIDDataBase_m->push(layoutID, context, globalID, parent);
  }
  template<class Alloc>
  inline
  INode(const Node<Interval<Dim>, Alloc> &node, LayoutID_t layoutID,
 GlobalIDDataBase *globalIDDataBase)
    : domain_m(node.domain()),
      globalIDDataBase_m(globalIDDataBase)
  {
    key_m = globalIDDataBase_m->push(layoutID, node.context(),
         node.globalID());
  }
  inline
  INode(const Interval<Dim> &dom, int context, GlobalID_t globalID,
 const TouchesConstructINode<Dim> &tcin)
    : domain_m(dom),
      globalIDDataBase_m(tcin.globalIDDataBase())
  {
    key_m = globalIDDataBase_m->push(tcin.layoutID(), context, globalID,
         tcin.parent());
  }
  inline
  INode(const INode<Dim> &inode, int context, GlobalID_t globalID,
 const TouchesConstructINode<Dim> &tcin)
    : domain_m(inode.domain()),
      globalIDDataBase_m(tcin.globalIDDataBase())
  {
    key_m = globalIDDataBase_m->push(tcin.layoutID(), context, globalID,
         tcin.parent());
  }
  template<class Alloc>
  inline
  INode(const Node<Interval<Dim>, Alloc> &node, int context,
 GlobalID_t globalID,
 const TouchesConstructINode<Dim> &tcin)
    : domain_m(node.domain()),
      globalIDDataBase_m(tcin.globalIDDataBase())
  {
    key_m = globalIDDataBase_m->push(tcin.layoutID(), context, globalID,
         tcin.parent());
  }
  inline INode(const Range<Dim> &range, int context, int globalID,
        const TouchesConstructINode<Dim> &tcin)
    : globalIDDataBase_m(tcin.globalIDDataBase())
  {
    key_m = globalIDDataBase_m->push(tcin.layoutID(), context, globalID,
         tcin.parent());
    int i;
    for (i = 0; i < Dim; ++i)
    {
      domain_m[i] = Interval<1>(range[i].first(), range[i].last());
    }
  }
  inline INode<Dim> &operator=(const INode<Dim> &rhs)
  {
    if (&rhs != this)
    {
      domain_m = rhs.domain();
      globalIDDataBase_m = rhs.globalIDDataBase();
      key_m = rhs.key();
    }
    return *this;
  }
  inline ~INode() { }
  inline const Domain_t &domain() const { return domain_m; }
  inline
  GlobalID_t globalID(LayoutID_t id) const
  {
    ;
    return globalIDDataBase_m->globalID(id, key_m);
  }
  inline int context() const
  {
    ;
    return globalIDDataBase_m->context(key_m);
  }
  inline int context(LayoutID_t id) const
  {
    ;
    return globalIDDataBase_m->context(id, key_m);
  }
  inline bool contextParticipates(int context) const
  {
    ;
    return globalIDDataBase_m->contextParticipates(context, key_m);
  }
  inline
  GlobalIDDataBase *globalIDDataBase() const { return globalIDDataBase_m; }
  inline NodeKey_t key() const { return key_m; }
  inline
  TouchesConstructINode<Dim> touchesConstructINode(LayoutID_t layoutID)
  {
    return TouchesConstructINode<Dim>(layoutID, key_m, globalIDDataBase_m);
  }
  template<int Dim2>
  inline static
  TouchesConstructINode<Dim> touchesConstructINode(LayoutID_t layoutID,
         const INode<Dim2> &inode)
  {
    return TouchesConstructINode<Dim>(layoutID, inode.key(),
          inode.globalIDDataBase());
  }
  template<class Out>
  void print(Out &o) const
  {
    o << "{" << domain();
    o << ": key=" << key();
    o << "}";
  }
private:
  Domain_t domain_m;
  GlobalIDDataBase *globalIDDataBase_m;
  NodeKey_t key_m;
};
template<int Dim>
inline INode<Dim> operator+(const INode<Dim> &inode, const Loc<Dim> &loc)
{
  return INode<Dim>(inode, inode.domain() + loc);
}
template <int Dim>
std::ostream &operator<<(std::ostream &o, const INode<Dim> &inode)
{
  inode.print(o);
  return o;
}
template<int Dim>
inline bool contains(const Interval<Dim> &i, const INode<Dim> &n)
{
  return contains(i, n.domain());
}
template<int Dim>
struct DomainTraits<INode<Dim> >
{
  enum { singleValued = 0 };
};
template<class Domain, class Sub>
struct TemporaryNewDomain1;
template<class Domain, int N>
struct TemporaryNewDomain1<Domain, INode<N> >
{
  typedef INode<N> SliceType_t;
  static inline
  const SliceType_t &combineSlice(const Domain &, const INode<N> &i)
  {
    return i;
  }
};
template<class Domain, int Dim>
inline INode<Dim>
touchesConstruct(const Domain &d,
   int, int context, int gid, int,
   const TouchesConstructINode<Dim> &tcin)
{
  return INode<Dim>(d, context, gid, tcin);
}
template<class Domain, class AllocatedDomain, int Dim>
inline INode<Dim>
touchesConstruct(const Domain &d, const AllocatedDomain &,
   int, int context, int gid, int,
   const TouchesConstructINode<Dim> & tcin)
{
  return INode<Dim>(d, context, gid, tcin);
}
template <int Dim>
class GuardLayers
{
public:
  explicit GuardLayers(int gcs = 0)
  {
    ;
    for (int i = 0; i < Dim; ++i)
      {
        lower_m[i] = gcs;
        upper_m[i] = gcs;
      }
  }
  GuardLayers(int lower[Dim], int upper[Dim])
  {
    for (int i = 0; i < Dim; ++i)
      {
        ;
        lower_m[i] = lower[i];
        upper_m[i] = upper[i];
      }
  }
  GuardLayers(const Loc<Dim> &lower, const Loc<Dim> &upper)
  {
    for (int i = 0; i < Dim; ++i)
      {
        ;
        lower_m[i] = lower[i].first();
        upper_m[i] = upper[i].first();
      }
  }
  void initialize(const Loc<Dim> &lower, const Loc<Dim> &upper)
  {
    for (int i = 0; i < Dim; ++i)
      {
        ;
        lower_m[i] = lower[i].first();
        upper_m[i] = upper[i].first();
      }
  }
  void initialize(const GuardLayers<Dim> &gl)
  {
    *this = gl;
  }
  int lower(int i) const
  {
    return lower_m[i];
  }
  int upper(int i) const
  {
    return upper_m[i];
  }
  int &lower(int i)
  {
    return lower_m[i];
  }
  int &upper(int i)
  {
    return upper_m[i];
  }
  bool operator==(const GuardLayers<Dim> &gcs) const
  {
    bool result = true;
    for (int d = 0; d < Dim; ++d)
      {
        result = result && lower_m[d] == gcs.lower_m[d];
        result = result && upper_m[d] == gcs.upper_m[d];
      }
    return result;
  }
  bool operator==(int gcw) const
  {
    bool result = true;
    for (int d = 0; d < Dim; ++d)
      {
        result = result && lower_m[d] == gcw;
        result = result && upper_m[d] == gcw;
      }
    return result;
  }
  bool operator!=(const GuardLayers<Dim> &gcs) const
  {
    return !operator==(gcs);
  }
  bool operator!=(int gcw) const
  {
    return !operator==(gcw);
  }
  GuardLayers<Dim> operator-(const GuardLayers<Dim> &gcs)
  {
    GuardLayers<Dim> result;
    for (int d = 0; d < Dim; ++d)
      {
        result.lower(d) = lower_m[d] - gcs.lower_m[d];
        ;
        result.upper(d) = upper_m[d] - gcs.upper_m[d];
        ;
      }
    return result;
  }
  GuardLayers<Dim> operator-(int dw)
  {
    GuardLayers<Dim> result;
    for (int d = 0; d < Dim; ++d)
      {
        result.lower(d) = lower_m[d] - dw;
        ;
        result.upper(d) = upper_m[d] - dw;
        ;
      }
    return result;
  }
  inline static void
  addGuardLayers(Interval<Dim> &dom, const GuardLayers<Dim> &gcs)
  {
    for (int d = 0; d < Dim; ++d)
      {
        int a = dom[d].first() - gcs.lower(d);
        int b = dom[d].last() + gcs.upper(d);
        dom[d] = Interval<1>(a,b);
      }
  }
  Interval<Dim> addGuardLayersToDomain(const Interval<Dim> &d) const
  {
    Interval<Dim> dom(d);
    addGuardLayers(dom, *this);
    return dom;
  }
  template <class Ostream>
  void print(Ostream &ostr) const
  {
    ostr << "GuardLayers<" << Dim << "> [";
    for (int d = 0; d < Dim; ++d)
      {
        ostr << "l: " << lower_m[d] << ", u: " << upper_m[d];
        if (d != Dim - 1)
          ostr << "; ";
      }
    ostr << "]";
  }
private:
  int lower_m[Dim];
  int upper_m[Dim];
};
template<int Dim>
inline Interval<Dim>
grow(const Interval<Dim> &dom, const GuardLayers<Dim> &gcs)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - gcs.lower(d);
      int b = dom[d].last() + gcs.upper(d);
      ret[d] = Interval<1>(a,b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrink(const Interval<Dim> &dom, const GuardLayers<Dim> &gcs)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + gcs.lower(d);
      int b = dom[d].last() - gcs.upper(d);
      ret[d] = Interval<1>(a,b);
    }
  return ret;
}
template<int Dim>
std::ostream &operator<<(std::ostream &ostr,
  const GuardLayers<Dim> &gl)
{
  gl.print(ostr);
  return ostr;
}
template <int Dim> class Loc;
template <> class Loc<1>;
template <int Dim> class Interval;
template <> class Interval<1>;
template <int Dim> class Range;
template <> class Range<1>;
template<int Dim>
struct DomainTraits< Range<Dim> >
  : public DomainTraitsDomain<Range<Dim>, int, Dim>
{
  typedef DomainTraitsDomain<Range<Dim>, int, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef Range<1> OneDomain_t;
  typedef Range<1> PointDomain_t;
  typedef Interval<Dim> BlockDomain_t;
  typedef Loc<Dim> AskDomain_t;
  typedef Range<Dim> AddResult_t;
  typedef Range<Dim> MultResult_t;
  typedef WrapNoInit<OneDomain_t> Storage_t[Dim];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = Dim };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  enum { wildcard = false };
  static OneDomain_t &getDomain(Domain_t &d, int n) { return d[n]; }
  static const OneDomain_t &getDomain(const Domain_t &d,int n) { return d[n]; }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void initializeStorage(Storage_t &dom) {
    Dom1Initialize<Dim-1>::template apply<DomainTraits<Range<Dim> > >(dom);
  }
};
template<>
struct DomainTraits< Range<1> >
  : public DomainTraitsDomain<Range<1>, int, 1>
{
  typedef Range<1> OneDomain_t;
  typedef Range<1> PointDomain_t;
  typedef Interval<1> BlockDomain_t;
  typedef Loc<1> AskDomain_t;
  typedef Range<1> AddResult_t;
  typedef Range<1> MultResult_t;
  typedef Element_t Storage_t[3];
  enum { dimensions = 1,
         sliceDimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  enum { wildcard = false };
  static Element_t first(const Storage_t &d) { return d[0]; }
  static Element_t last(const Storage_t &d) { return d[0] + (d[1]-1)*d[2]; }
  static Element_t stride(const Storage_t &d) { return d[2]; }
  static Element_t length(const Storage_t &d) { return d[1]; }
  static Element_t min(const Storage_t &d) {
    return (d[2] > 0 ? d[0] : d[0] + (d[1]-1)*d[2]);
  }
  static Element_t max(const Storage_t &d) {
    return (d[2] < 0 ? d[0] : d[0] + (d[1]-1)*d[2]);
  }
  static bool empty(const Storage_t &d) { return (d[1] < 1); }
  static int loop(const Storage_t &) { return 0; }
  static Element_t elem(const Storage_t &d, int n) { return d[0] + n*d[2]; }
  static OneDomain_t &getDomain(Domain_t &d, int) { return d; }
  static const OneDomain_t &getDomain(const Domain_t &d, int) { return d; }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void initializeStorage(Storage_t &dom) {
    dom[0] = 0;
    dom[1] = 0;
    dom[2] = 1;
  }
  template<class T>
  static void setDomain(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    dom[0] = DomainTraits<T>::getFirst(newdom);
    dom[1] = DomainTraits<T>::getLength(newdom);
    dom[2] = DomainTraits<T>::getStride(newdom);
  }
  template<class T1, class T2>
  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T2>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T1>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T2>::singleValued)>::test();
    Element_t strideval = (endval < begval ? -1 : 1);
    dom[0] = begval;
    dom[1] = (endval - begval)/strideval + 1;
    dom[2] = strideval;
  }
  template<class T1, class T2, class T3>
  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval,
   const T3 &strideval) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T2>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T3>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T1>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T2>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T3>::singleValued)>::test();
    dom[0] = begval;
    dom[1] = (endval - begval)/strideval + 1;
    dom[2] = strideval;
  }
  static void setLoop(Storage_t &, int) { }
  template<class UT, class T>
  static void setWildcardDomain(Storage_t &dom, const UT &u, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::wildcard)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<UT>::dimensions == 1)>::test();
    dom[0] = newdom.first(u);
    dom[1] = newdom.length(u);
    dom[2] = newdom.stride(u);
  }
  template<class T>
  static bool isLessThan(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    return (dom[1] < DomainTraits<T>::getLength(newdom) ||
     (dom[1] == DomainTraits<T>::getLength(newdom) &&
      (dom[0] < DomainTraits<T>::getFirst(newdom) ||
       (dom[0] == DomainTraits<T>::getFirst(newdom) &&
        dom[2] < DomainTraits<T>::getStride(newdom)))));
  }
  template<class T>
  static bool isEqualTo(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    return ((dom[1] == 0 && DomainTraits<T>::getLength(newdom) == 0) ||
     (dom[0] == DomainTraits<T>::getFirst(newdom) &&
      dom[1] == DomainTraits<T>::getLength(newdom) &&
      dom[2] == DomainTraits<T>::getStride(newdom)));
  }
  template<class T>
  static void addAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] += DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void subtractAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] -= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void multiplyAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] *= DomainTraits<T>::getFirst(newdom);
    dom[2] *= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void divideAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom[0] /= DomainTraits<T>::getFirst(newdom);
    dom[2] /= DomainTraits<T>::getFirst(newdom);
  }
};
template<int Dim1, int Dim2>
struct DomainChangeDim<Range<Dim1>, Dim2>
{
  typedef Range<Dim1> OldType_t;
  typedef Range<Dim2> NewType_t;
  enum { oldDim = Dim1,
  newDim = Dim2 };
};
template <int Dim> class Range;
template<int Dim>
inline
void fillRangeScalar(Range<Dim> &r, const int &a);
template<int Dim>
class Range : public Domain<Dim, DomainTraits<Range<Dim> > >
{
  typedef DomainTraits< Range<Dim> > DT_t;
  typedef Domain<Dim, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Range() { }
  Range(const Range<Dim> &a)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain1<Range<Dim> >::fill(*this, a);
  }
  Range(const Pooma::NoInit &a)
    : Domain<Dim, DomainTraits<Range<Dim> > >(a)
  { }
  template<class T1>
  explicit Range(const T1 &a)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  template<class T1, class T2>
  Range(const T1 &a, const T2 &b)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain2<T1,T2>::fill(*this, a, b);
  }
  template<class T1, class T2, class T3>
  Range(const T1 &a, const T2 &b, const T3 &c)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain3<T1,T2,T3>::fill(*this, a, b, c);
  }
  template<class T1, class T2, class T3, class T4>
  Range(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain4<T1,T2,T3,T4>::fill(*this, a, b, c, d);
  }
  template<class T1, class T2, class T3, class T4, class T5>
  Range(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain5<T1,T2,T3,T4,T5>::fill(*this, a, b, c, d, e);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  Range(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
 const T6 &f)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain6<T1,T2,T3,T4,T5,T6>::fill(*this, a, b, c, d, e, f);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  Range(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
 const T6 &f, const T7 &g)
    : Domain<Dim, DomainTraits<Range<Dim> > >(Pooma::NoInit()) {
    NewDomain7<T1,T2,T3,T4,T5,T6,T7>::fill(*this, a, b, c, d, e, f, g);
  }
  ~Range() { }
  template<class T>
  Range<Dim> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Range<Dim> &operator=(const Range<Dim> &newdom) {
    return NewDomain1<Range<Dim> >::fill(*this, newdom);
  }
  Range<Dim> &operator=(const int a) {
    fillRangeScalar(*this,a);
    return *this;
  }
protected:
private:
};
template<>
class Range<1> : public Domain<1, DomainTraits<Range<1> > >
{
  typedef DomainTraits< Range<1> > DT_t;
public:
  typedef DT_t::Element_t Element_t;
  typedef DT_t::Domain_t Domain_t;
  typedef DT_t::OneDomain_t OneDomain_t;
  typedef DT_t::BlockDomain_t BlockDomain_t;
  typedef DT_t::AskDomain_t AskDomain_t;
  typedef DT_t::AddResult_t AddResult_t;
  typedef DT_t::MultResult_t MultResult_t;
  typedef DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Range() { }
  Range(const Range<1> &a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    NewDomain1<Range<1> >::fill(*this, a);
  }
  Range(const Pooma::NoInit &a)
    : Domain<1, DomainTraits<Range<1> > >(a)
  { }
  template<class T1>
  explicit Range(const T1 &a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  Range(char a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - 1);
  }
  Range(unsigned char a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - 1);
  }
  Range(short a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    short s = (a < 0 ? -1 : 1);
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - s);
  }
  Range(unsigned short a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - 1);
  }
  Range(int a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    int s = (a < 0 ? -1 : 1);
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - s);
  }
  Range(unsigned int a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - 1);
  }
  Range(long a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    long s = (a < 0 ? -1 : 1);
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - s);
  }
  Range(unsigned long a)
    : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
    ;
    DomainTraits<Range<1> >::setDomain(domain_m, 0, a - 1);
  }
  template<class T1, class T2>
  Range(const T1 &m, const T2 &n);
  template<class T1, class T2, class T3>
  Range(const T1 &m, const T2 &n, const T3 &s);
  template<class T>
  Range<1> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Range<1> &operator=(const Range<1> &newdom) {
    return NewDomain1<Range<1> >::fill(*this, newdom);
  }
  const OneDomain_t &operator[](int d) const { return *this; }
  OneDomain_t &operator[](int d) { return *this; }
};
template <class T1, class T2>
inline
Range<1>::Range(const T1 &m, const T2 &n)
  : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
  DomainTraits<Range<1> >::setDomain(domain_m, m, n);
}
template <class T1, class T2, class T3>
inline
Range<1>::Range(const T1 &m, const T2 &n, const T3 &s)
  : Domain<1, DomainTraits<Range<1> > >(Pooma::NoInit()) {
  DomainTraits<Range<1> >::setDomain(domain_m, m, n, s);
}
template<int Dim>
inline
void fillRangeScalar(Range<Dim> &r, const int &a)
{
  for (int i=0; i < Dim; ++i)
    r[i]=Range<1>(a);
}
class ObserverEvent
{
public:
  typedef Unique::Value_t ID_t;
  ObserverEvent(int event)
    : event_m(event), ID_m(Unique::get())
    {
    }
  ObserverEvent(const ObserverEvent &oe)
    : event_m(oe.event_m), ID_m(oe.ID_m)
    {
    }
  ObserverEvent &operator=(const ObserverEvent &oe)
    {
      event_m = oe.event();
      ID_m = oe.ID();
      return *this;
    }
  virtual ~ObserverEvent()
    {
    }
  inline int event() const
    {
      return event_m;
    }
  inline ID_t ID() const
    {
      return ID_m;
    }
  static inline ID_t nullID()
    {
      return (-1);
    }
private:
  int event_m;
  ID_t ID_m;
};
template<class Obj>
inline bool checkDynamicID(Obj &, ObserverEvent::ID_t)
{
  return true;
}
template<class T>
class Observer
{
public:
  Observer()
    {
    }
  virtual ~Observer()
    {
    }
  virtual void notify(T &observed, const ObserverEvent &event) = 0;
  inline void notify(T &observed, int event)
    {
      notify(observed, ObserverEvent(event));
    }
};
template<class T>
class SingleObserver
{
public:
  SingleObserver() { }
  virtual ~SingleObserver() { }
  virtual void notify(const T &observed, const ObserverEvent &event) = 0;
  inline void notify(const T &observed, int event)
    {
      notify(observed, ObserverEvent(event));
    }
};
template<class T>
class Observable
{
public:
  enum { deleteEvent = 0 };
  Observable(T &o) : observed_m(o), count_m(0)
    {
    }
  ~Observable()
    {
      notify(deleteEvent);
    }
  int observers() const
    {
      return count_m;
    }
  void attach(Observer<T> *o)
    {
      mutex_m.lock();
      observers_m.push_back(o);
      count_m += 1;
      mutex_m.unlock();
    }
  void attach(Observer<T> &o)
    {
      attach(&o);
    }
  void detach(Observer<T> *o)
    {
      mutex_m.lock();
      for (int i=0; i < count_m; ++i) {
 if (observers_m[i] == o) {
   count_m -= 1;
   observers_m.erase(observers_m.begin() + i);
   break;
 }
      }
      mutex_m.unlock();
    }
  void detach(Observer<T> &o)
    {
      detach(&o);
    }
  inline void notify(int event)
    {
      for (int i=0; i < count_m; ++i)
 observers_m[i]->notify(observed_m, event);
    }
  inline void notify(const ObserverEvent &event)
    {
      for (int i=0; i < count_m; ++i)
 observers_m[i]->notify(observed_m, event);
    }
private:
  T &observed_m;
  std::vector<Observer<T> *> observers_m;
  int count_m;
  Pooma::Mutex_t mutex_m;
  Observable();
  Observable(const Observable<T> &);
  Observable<T> &operator=(const Observable<T> &);
};
template<class T>
class SingleObservable
{
public:
  enum { deleteEvent = 0 };
  SingleObservable() : observer_m(0)
    {
    }
  ~SingleObservable()
    {
      notify(T(),0);
    }
  void attach(SingleObserver<T> *o)
    {
      ;
      observer_m = o;
    }
  void attach(SingleObserver<T> &o)
    {
      attach(&o);
    }
  void detach()
    {
      observer_m = 0;
    }
  inline void notify(const T& value, int event)
    {
      if (observer_m != 0)
 observer_m->notify(value, event);
    }
  inline void notify(const T& value, const ObserverEvent &event)
    {
      if (observer_m != 0)
 observer_m->notify(value, event);
    }
private:
  SingleObserver<T> *observer_m;
  SingleObservable(const SingleObservable<T> &);
  SingleObservable<T> &operator=(const SingleObservable<T> &);
};
template <class T>
struct ElementProperties
{
  typedef T This_t;
  enum { hasTrivialDefaultConstructor = false };
  enum { hasTrivialDestructor = false };
  enum { concrete = false };
  enum { basicType = false };
  static void construct(This_t * addr)
  {
    new (addr) This_t();
  }
  static void construct(This_t * addr, const This_t & model)
  {
    new (addr) This_t(model);
  }
  static This_t * clone(const This_t &model)
  {
    return new This_t(model);
  }
  static void destruct(This_t * addr)
  {
    addr->~This_t();
  }
};
template <class T>
struct TrivialElementPropertiesBase
{
  typedef T This_t;
  enum { hasTrivialDefaultConstructor = true };
  enum { hasTrivialDestructor = true };
  enum { concrete = true };
  static void construct(This_t * addr, const This_t & model)
  {
    new (addr) This_t(model);
  }
  static This_t * clone(const This_t &model)
  {
    return new This_t(model);
  }
  static void construct(This_t *addr)
  {
    new (addr) This_t();
  }
  static void destruct(This_t *)
  {
    if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("TrivialElementProperties<T>::destruct(addr) not allowed!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Utilities/ElementProperties.h", 213);
  }
};
template <class T>
struct TrivialElementProperties : public TrivialElementPropertiesBase<T>
{
  enum { basicType = false };
};
template <class T>
struct BasicTypeProperties : public TrivialElementPropertiesBase<T>
{
  enum { basicType = true };
};
template <class T>
struct MakeOwnCopyProperties
{
  typedef T This_t;
  enum { hasTrivialDefaultConstructor = false };
  enum { hasTrivialDestructor = false };
  enum { concrete = false };
  enum { basicType = false };
  static void construct(This_t * addr)
  {
    new (addr) This_t;
    addr->makeOwnCopy();
  }
  static void construct(This_t * addr, const This_t & model)
  {
    new (addr) This_t(model);
    addr->makeOwnCopy();
  }
  static This_t * clone(const This_t &model)
  {
    This_t * temp = new This_t(model);
    temp->makeOwnCopy();
    return temp;
  }
  static void destruct(This_t * addr)
  {
    addr->~This_t();
  }
};
template <>
struct ElementProperties<bool> : public BasicTypeProperties<bool>
{ };
template <>
struct ElementProperties<char> : public BasicTypeProperties<char>
{ };
template <>
struct ElementProperties<unsigned char>
  : public BasicTypeProperties<unsigned char>
{ };
template <>
struct ElementProperties<short> : public BasicTypeProperties<short>
{ };
template <>
struct ElementProperties<unsigned short>
  : public BasicTypeProperties<unsigned short>
{ };
template <>
struct ElementProperties<int> : public BasicTypeProperties<int>
{ };
template <>
struct ElementProperties<unsigned int>
  : public BasicTypeProperties<unsigned int>
{ };
template <>
struct ElementProperties<long> : public BasicTypeProperties<long>
{ };
template <>
struct ElementProperties<long long> : public BasicTypeProperties<long long>
{ };
template <>
struct ElementProperties<unsigned long>
  : public BasicTypeProperties<unsigned long>
{ };
template <>
struct ElementProperties<float> : public BasicTypeProperties<float>
{ };
template <>
struct ElementProperties<double> : public BasicTypeProperties<double>
{ };
template <class FloatType>
struct ElementProperties<std::complex<FloatType> >
  : public TrivialElementProperties<std::complex<FloatType> >
{ };
class RefCounted
{
public:
  RefCounted()
    : count_m(0)
    { }
  RefCounted(const RefCounted &)
    : count_m(0)
    { }
  ~RefCounted() { }
  bool isShared() const;
  void addReference();
  void removeReference();
  bool removeRefAndCheckGarbage();
  void lock() const
  {
    mutex_m.lock();
  }
  void unlock() const
  {
    mutex_m.unlock();
  }
  int count() const;
  int countUnlocked() const;
private:
  RefCounted & operator=(const RefCounted &);
  int count_m;
  mutable Pooma::Mutex_t mutex_m;
};
inline bool
RefCounted::isShared() const
{
  mutex_m.lock();
  bool test = count_m > 1;
  mutex_m.unlock();
  return test;
}
inline void
RefCounted::addReference()
{
  mutex_m.lock();
  ++count_m;
  mutex_m.unlock();
}
inline void
RefCounted::removeReference()
{
  mutex_m.lock();
  --count_m;
  ;
  mutex_m.unlock();
}
inline bool
RefCounted::removeRefAndCheckGarbage()
{
  mutex_m.lock();
  ;
  bool test = --count_m == 0;
  mutex_m.unlock();
  return test;
}
inline int
RefCounted::count() const
{
  mutex_m.lock();
  int count = count_m;
  mutex_m.unlock();
  return count;
}
inline int
RefCounted::countUnlocked() const
{
  return count_m;
}
template <class T>
class Shared : public RefCounted
{
public:
  Shared(const T &d) : data_m(d) {};
  Shared(const Shared<T> & model)
    : data_m(model.data_m)
  { }
  Shared<T> & operator=(const Shared<T> &model)
  {
    if (&model == this) return *this;
    data_m = model.data_m;
    return *this;
  }
  Shared<T> & operator=(const T & d)
  {
    data_m = d;
    return *this;
  }
  inline
  T &data() { return data_m; }
  inline
  const T &data() const { return data_m; }
  bool operator==(const Shared<T> &rhs) const
    { return data_m == rhs.data_m; }
  bool operator!=(const Shared<T> &rhs) const
    { return data_m != rhs.data_m; }
protected:
  T data_m;
};
template <class T>
class RefCountedPtr
{
public:
  typedef RefCountedPtr<T> This_t;
  typedef T Pointee_t;
  RefCountedPtr() : ptr_m(0) { }
  RefCountedPtr(T * const pT)
    : ptr_m(pT)
    { if (isValid()) ptr_m->addReference(); }
  RefCountedPtr(const This_t &model)
    : ptr_m(model.ptr_m)
    { if (isValid()) ptr_m->addReference(); }
  ~RefCountedPtr();
  RefCountedPtr & operator=(const RefCountedPtr &);
  RefCountedPtr & operator=(T *);
  inline T * operator->() const { return ptr_m; }
  inline T & operator*() const { return *ptr_m; }
  bool operator==(const This_t& a) const
  { return ptr_m == a.ptr_m; }
  bool operator!=(const This_t& a) const
  { return ptr_m != a.ptr_m; }
  void invalidate();
  inline bool isValid() const { return ptr_m != 0; }
  inline bool isShared() const { return ptr_m->isShared(); }
  inline int count() const { return ptr_m->count(); }
  RefCountedPtr<T> & makeOwnCopy();
  inline T * rawPointer() { return ptr_m; }
  inline const T * rawPointer() const { return ptr_m; }
private:
  template <class T2, bool val, class Controller>
  friend class RefCountedBlockPtr;
  T * ptr_m;
};
template <class T>
inline void RefCountedPtr<T>::invalidate()
{
  if ( isValid() && ptr_m->removeRefAndCheckGarbage() )
    delete ptr_m;
  ptr_m = 0;
}
template <class T>
inline RefCountedPtr<T>::~RefCountedPtr()
{
  invalidate();
}
template <class T>
inline RefCountedPtr<T> &
RefCountedPtr<T>::operator=(const RefCountedPtr<T>& rhs)
{
  if (ptr_m != rhs.ptr_m)
    {
      if ( isValid() && ptr_m->removeRefAndCheckGarbage() )
 delete ptr_m;
      ptr_m = rhs.ptr_m;
      if ( isValid() ) ptr_m->addReference();
    }
  return *this;
}
template <class T>
inline RefCountedPtr<T> &
RefCountedPtr<T>::operator=(T *pp)
{
  if (ptr_m != pp)
    {
      if ( isValid() && ptr_m->removeRefAndCheckGarbage() )
 delete ptr_m;
      ptr_m = pp;
      if ( isValid() ) ptr_m->addReference();
    }
  return *this;
}
template <class T>
inline RefCountedPtr<T> &
RefCountedPtr<T>::makeOwnCopy()
{
  if ( isValid() && ptr_m->isShared() )
    {
      T * temp = ElementProperties<T>::clone(*ptr_m);
      ptr_m->removeReference();
      ptr_m = temp;
      ptr_m->addReference();
    }
  return *this;
}
template <class T>
class RefBlockController : public RefCounted
{
public:
  struct NoInitTag
  {
     NoInitTag() { }
     NoInitTag(const NoInitTag &) { }
     NoInitTag & operator=(const NoInitTag &) { return *this; }
  };
  explicit
  RefBlockController(size_t size)
    : pBegin_m(0), pEnd_m(0), pEndOfStorage_m(0), dealloc_m(false)
  {
    reallocateStorage(size, false);
    if (!ElementProperties<T>::hasTrivialDefaultConstructor)
      {
 for (T * pt = begin(); pt != end(); ++pt)
   ElementProperties<T>::construct(pt);
      }
  }
  RefBlockController(size_t size, const T & model)
    : pBegin_m(0), pEnd_m(0), pEndOfStorage_m(0), dealloc_m(false)
  {
    reallocateStorage(size, false);
    for (T * pt = begin(); pt != end(); ++pt)
      ElementProperties<T>::construct(pt, model);
  }
  RefBlockController(size_t size, const NoInitTag &)
    : pBegin_m(0), pEnd_m(0), pEndOfStorage_m(0), dealloc_m(false)
  {
    reallocateStorage(size, false);
  }
  RefBlockController(T *p, size_t size)
    : pBegin_m(p), pEnd_m(p+size), pEndOfStorage_m(p+size), dealloc_m(false)
  { }
  RefBlockController(const RefBlockController &model)
    : pBegin_m(0), pEnd_m(0), pEndOfStorage_m(0), dealloc_m(false)
  {
    size_t allocatedSize = model.pEndOfStorage_m - model.pBegin_m;
    size_t size = model.end() - model.begin();
    reallocateStorage(allocatedSize, false);
    pEnd_m = pBegin_m + size;
    T * pOld = model.begin();
    T * pNew = begin();
    while (pNew != end())
      {
 ElementProperties<T>::construct(pNew++,*pOld++);
      }
  }
  ~RefBlockController()
  {
    deleteStorage();
  }
  bool resize(size_t newsize, const NoInitTag &)
  {
    T *pNewEnd = pBegin_m + newsize;
    if (pNewEnd <= pEndOfStorage_m)
      {
        pEnd_m = pNewEnd;
        return true;
      }
    else
      {
        return false;
      }
  }
  bool resize(size_t newsize)
  {
    bool success = resize(newsize,NoInitTag());
    if (!ElementProperties<T>::hasTrivialDefaultConstructor)
      if (success)
 for (T * pt = begin(); pt != end(); ++pt)
          ElementProperties<T>::construct(pt);
    return success;
  }
  bool resize(size_t newsize, const T &model)
  {
    bool success = resize(newsize,NoInitTag());
    if (success)
      for (T * pt = begin(); pt != end(); ++pt)
        ElementProperties<T>::construct(pt, model);
    return success;
  }
  T *resizeAndCopy(size_t newsize)
  {
    size_t oldsize = size();
    if (!resize(newsize, NoInitTag()))
      {
 reallocateStorage(newsize, true);
 if (newsize > oldsize)
   for (T *pt = begin() + oldsize; pt != end(); ++pt)
     ElementProperties<T>::construct(pt);
      }
    return begin();
  }
  T *resizeAndCopy(size_t newsize, const T &model)
  {
    size_t oldsize = size();
    if (!resize(newsize, NoInitTag()))
      {
 reallocateStorage(newsize, true);
 if (newsize > oldsize)
   for (T *pt = begin() + oldsize; pt != end(); ++pt)
     ElementProperties<T>::construct(pt, model);
      }
    return begin();
  }
  T *resizeAndCopy(size_t newsize, const NoInitTag &)
  {
    if (!resize(newsize, NoInitTag()))
      {
 reallocateStorage(newsize, true);
      }
    return begin();
  }
  inline T *begin() const
  {
    return pBegin_m;
  }
  inline T *end() const
  {
    return pEnd_m;
  }
  inline size_t size() const
  {
    return static_cast<size_t>(pEnd_m - pBegin_m);
  }
  inline size_t capacity() const
  {
    return static_cast<size_t>(pEndOfStorage_m - pBegin_m);
  }
  inline bool empty() const
  {
    return pEnd_m == pBegin_m;
  }
  inline bool isMine() const
  {
    return dealloc_m;
  }
  inline bool checkDeref(const T *p) const
  {
    return ((pBegin_m <= p) && (p < pEnd_m));
  }
private:
  void deleteStorage()
  {
    if (isMine() && pBegin_m != 0)
      {
 if (!ElementProperties<T>::hasTrivialDestructor)
   for (T *pt = begin(); pt != end(); ++pt)
     ElementProperties<T>::destruct(pt);
 char *tmp = reinterpret_cast<char *>(pBegin_m);
 delete [] tmp;
      }
  }
  void reallocateStorage(size_t newsize, bool copyold = false)
  {
    T *pBeginNew = 0;
    T *pEndNew = 0;
    T *pEndOfStorageNew = 0;
    if (newsize > 0)
      {
 int nsize = newsize * sizeof(T);
 char *tmp = new char[nsize];
 pBeginNew = reinterpret_cast<T *>(tmp);
 pEndNew = pBeginNew + newsize;
 pEndOfStorageNew = pBeginNew + (nsize / sizeof(T));
 if (copyold)
   {
     T * pOld = begin();
     T * pNew = pBeginNew;
     while (pOld != end() && pNew != pEndNew)
       ElementProperties<T>::construct(pNew++,*pOld++);
   }
      }
    deleteStorage();
    pBegin_m = pBeginNew;
    pEnd_m = pEndNew;
    pEndOfStorage_m = pEndOfStorageNew;
    dealloc_m = true;
  }
  T *pBegin_m;
  T *pEnd_m;
  T *pEndOfStorage_m;
  bool dealloc_m;
};
template <class T,
  bool BoundsChecked=false,
  class Controller=RefBlockController<T> >
class RefCountedBlockPtr
{
public:
  typedef std::random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
  typedef T Element_t;
  typedef T Pointee_t;
  typedef ptrdiff_t Offset_t;
  typedef RefCountedBlockPtr<T,BoundsChecked,Controller> This_t;
  typedef RefCountedBlockPtr<T,!BoundsChecked,Controller> That_t;
  struct NoInitTag
  {
     NoInitTag() { }
     NoInitTag(const NoInitTag &) { }
     NoInitTag & operator=(const NoInitTag &) { return *this; }
  };
  inline RefCountedBlockPtr()
    : offset_m(0)
  { }
  inline explicit RefCountedBlockPtr(size_t size)
    : offset_m(0),
      blockControllerPtr_m(new Controller(size))
  { }
  inline RefCountedBlockPtr(size_t size, const T & model)
    : offset_m(0),
      blockControllerPtr_m(new Controller(size,model))
  { }
  inline RefCountedBlockPtr(size_t size, const NoInitTag &)
    : offset_m(0),
      blockControllerPtr_m(new Controller(size,
       typename Controller::NoInitTag()))
  {
    blockControllerPtr_m->resize(0,typename Controller::NoInitTag());
  }
  inline RefCountedBlockPtr(T *p, size_t size)
    : offset_m(0),
      blockControllerPtr_m(new Controller(p, size))
  { }
  inline RefCountedBlockPtr(const This_t & model)
    : offset_m(model.offset_m),
      blockControllerPtr_m(model.blockControllerPtr_m)
  { }
  inline RefCountedBlockPtr(const That_t & model)
    : offset_m(model.offset_m),
      blockControllerPtr_m(model.blockControllerPtr_m)
  { }
  inline RefCountedBlockPtr(const This_t & model, Offset_t offset)
    : offset_m(model.offset_m + offset),
      blockControllerPtr_m(model.blockControllerPtr_m)
  { }
  inline ~RefCountedBlockPtr() {}
  inline This_t & operator=(const This_t & rhs)
  {
    blockControllerPtr_m = rhs.blockControllerPtr_m;
    offset_m = rhs.offset_m;
    return *this;
  }
  inline This_t & operator=(const That_t & rhs)
  {
    blockControllerPtr_m = rhs.blockControllerPtr_m;
    offset_m = rhs.offset_m;
    return *this;
  }
  template<class T1, bool BoundsChecked1, class Controller1>
  inline bool operator==(
    const RefCountedBlockPtr<T1, BoundsChecked1, Controller1>&) const
  {
    return false;
  }
  template<class T1, bool BoundsChecked1, class Controller1>
  inline bool operator!=(
    const RefCountedBlockPtr<T1, BoundsChecked1, Controller1>&) const
  {
    return true;
  }
  inline bool operator==(const This_t& a) const
  {
    return (beginPointer() == a.beginPointer() && offset() == a.offset());
  }
  inline bool operator!=(const This_t& a) const
  {
    return (beginPointer() != a.beginPointer() || offset() != a.offset());
  }
  inline bool operator<(const This_t& a) const
  {
    ;
    return offset() < a.offset();
  }
  inline bool operator>(const This_t& a) const
  {
    ;
    return offset() > a.offset();
  }
  inline bool operator<=(const This_t& a) const
  {
    ;
    return offset() <= a.offset();
  }
  inline bool operator>=(const This_t& a) const
  {
    ;
    return offset() >= a.offset();
  }
  inline bool operator==(const That_t& a) const
  {
    return (beginPointer() == a.beginPointer() && offset() == a.offset());
  }
  inline bool operator!=(const That_t& a) const
  {
    return (beginPointer() != a.beginPointer() || offset() != a.offset());
  }
  inline T& operator*() const
  {
    T *p = currentPointer();
    boundsAssert(p);
    return *p;
  }
  inline T& operator[](Offset_t i) const
  {
    T *p = currentPointer() + i;
    boundsAssert(p);
    return *p;
  }
  inline T *operator->() const
  {
    T *p = currentPointer();
    boundsAssert(p);
    return p;
  }
  inline This_t & operator++()
  {
    ++offset_m;
    return *this;
  }
  inline This_t & operator--()
  {
    --offset_m;
    return *this;
  }
  inline This_t operator++(int)
  {
    This_t save(*this);
    ++offset_m;
    return save;
  }
  inline This_t operator--(int)
  {
    This_t save(*this);
    --offset_m;
    return save;
  }
  inline void operator+=(Offset_t i)
  {
    offset_m += i;
  }
  inline void operator-=(Offset_t i)
  {
    offset_m -= i;
  }
  inline This_t operator+(Offset_t i) const
  {
    This_t ret(*this);
    ret += i;
    return ret;
  }
  inline This_t operator-(Offset_t i) const
  {
    This_t ret(*this);
    ret -= i;
    return ret;
  }
  inline This_t begin() const
  {
    return This_t(*this, -offset_m);
  }
  inline This_t end() const
  {
    return This_t(*this, size() - offset_m);
  }
  void reserve(size_t size)
  {
    ;
    typedef typename Controller::NoInitTag NoInit_t;
    blockControllerPtr_m = new Controller(size, NoInit_t());
    blockControllerPtr_m->resize(0,NoInit_t());
    offset_m = 0;
  }
  bool resize(size_t size, const NoInitTag &)
  {
    ;
    typedef typename Controller::NoInitTag NoInit_t;
    return blockControllerPtr_m->resize(size, NoInit_t());
  }
  bool resize(size_t size)
  {
    ;
    return blockControllerPtr_m->resize(size);
  }
  bool resize(size_t size, const T &model)
  {
    ;
    return blockControllerPtr_m->resize(size, model);
  }
  void resizeAndCopy(size_t size, const NoInitTag &)
  {
    ;
    typedef typename Controller::NoInitTag NoInit_t;
    blockControllerPtr_m->resizeAndCopy(size, NoInit_t());
  }
  void resizeAndCopy(size_t size)
  {
    ;
    blockControllerPtr_m->resizeAndCopy(size);
  }
  void resizeAndCopy(size_t size, const T &model)
  {
    ;
    blockControllerPtr_m->resizeAndCopy(size, model);
  }
  void invalidate()
  {
    blockControllerPtr_m.invalidate();
    offset_m = 0;
  }
  This_t & makeOwnCopy()
  {
    blockControllerPtr_m.makeOwnCopy();
    return *this;
  }
  inline Offset_t offset() const
  {
    return offset_m;
  }
  inline bool isValid() const
  {
    return blockControllerPtr_m.isValid();
  }
  inline bool isShared() const
  {
    return blockControllerPtr_m.isShared();
  }
  inline int count() const
  {
    return isValid() ? blockControllerPtr_m.count() : 0;
  }
  inline size_t size() const
  {
    return isValid() ? blockControllerPtr_m->size() : 0;
  }
  inline size_t capacity() const
  {
    return isValid() ? blockControllerPtr_m->capacity() : 0;
  }
  inline bool empty() const
  {
    return isValid() ? blockControllerPtr_m->empty() : true;
  }
  inline bool isAtBeginning() const
  {
    return (offset() == 0);
  }
  inline bool isMine() const
  {
    return isValid() ? blockControllerPtr_m->isMine() : true;
  }
  inline T *beginPointer() const
  {
    ;
    return blockControllerPtr_m->begin();
  }
  inline T *endPointer() const
  {
    ;
    return blockControllerPtr_m->end();
  }
  inline T *currentPointer() const
  {
    return beginPointer() + offset();
  }
protected:
  friend class RefCountedBlockPtr<T,!BoundsChecked,Controller>;
  RefCountedBlockPtr(Controller *con)
    : offset_m(0), blockControllerPtr_m(con)
  { }
  inline void boundsAssert(T *p) const
  {
    if (BoundsChecked)
      {
        if (__builtin_expect(!!(isValid() && blockControllerPtr_m->checkDeref(p)), true)) {} else Pooma::toss_cookies("RefCountedBlockPtr: Bounds Violation.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Utilities/RefCountedBlockPtr.h", 1038);
      }
  }
  Offset_t offset_m;
  RefCountedPtr<Controller> blockControllerPtr_m;
};
template <class T, bool C1, bool C2, class Controller>
inline ptrdiff_t
operator-(const RefCountedBlockPtr<T,C1,Controller> &first,
          const RefCountedBlockPtr<T,C2,Controller> &second)
{
  return first.currentPointer() - second.currentPointer();
}
template <class T> class SingleObserver;
template <class T>
class DataBlockController
  : public RefBlockController<T>
{
public:
  typedef Pooma::DataObject_t DataObject_t;
  typedef SingleObservable<int> Observable_t;
  typedef RefBlockController<T> Base_t;
  typedef typename RefBlockController<T>::NoInitTag NoInitTag;
  typedef ObserverEvent::ID_t DynamicID_t;
  explicit
  DataBlockController(size_t size)
    : Base_t(size), dataObjectPtr_m(new DataObject_t(-1)), owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, const T & model)
    : Base_t(size,model), dataObjectPtr_m(new DataObject_t(-1)), owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(T *p, size_t size)
    : Base_t(p,size), dataObjectPtr_m(new DataObject_t(-1)), owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, const NoInitTag &tag)
    : Base_t(size,tag), dataObjectPtr_m(new DataObject_t(-1)), owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  struct WithAffinity
  {
    WithAffinity() { }
    WithAffinity(const WithAffinity&) { }
    WithAffinity &operator=(const WithAffinity &) { return *this; }
  };
  DataBlockController(size_t size, int affinity, const WithAffinity &)
    : Base_t(size), dataObjectPtr_m(new DataObject_t(affinity)), owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, int affinity, const WithAffinity &,
                      const NoInitTag &tag)
    : Base_t(size,tag), dataObjectPtr_m(new DataObject_t(affinity)),
      owned_m(true),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, DataObject_t &dobj)
    : Base_t(size), dataObjectPtr_m(&dobj), owned_m(false),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, const T& model, DataObject_t &dobj)
    : Base_t(size,model), dataObjectPtr_m(&dobj), owned_m(false),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(size_t size, DataObject_t &dobj, const NoInitTag &tag)
    : Base_t(size,tag), dataObjectPtr_m(&dobj), owned_m(false),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(const DataBlockController &model)
    : Base_t(model),
      dataObjectPtr_m(model.dataObjectPtr_m ?
        new DataObject_t(model.affinity()) : 0),
      owned_m(model.dataObjectPtr_m ? true : false),
      observable_m(),
      dynamicID_m(ObserverEvent::nullID())
  { }
  DataBlockController(const DataBlockController &model, DataObject_t &dobj)
    : Base_t(model), observable_m(), owned_m(false),
      dataObjectPtr_m(&dobj),
      dynamicID_m(ObserverEvent::nullID())
  { }
  ~DataBlockController()
  {
    if (owned_m) delete dataObjectPtr_m;
  }
  void attach(SingleObserver<int> *o)
  {
    observable_m.attach(o);
  }
  void detach()
  {
    observable_m.detach();
  }
  inline DataObject_t* dataObject() const
  {
    return dataObjectPtr_m;
  }
  inline void dataObject(DataObject_t *obj)
  {
    if (owned_m) delete dataObjectPtr_m;
    owned_m = false;
    dataObjectPtr_m = obj;
  }
  inline int affinity() const
  {
    return dataObjectPtr_m->affinity();
  }
  inline void affinity(int affin)
  {
    dataObjectPtr_m->affinity(affin);
  }
  enum Notifier { addViewEvent, removeViewEvent };
  inline void notifyOnDestruct()
  {
    observable_m.notify(0,removeViewEvent);
  }
  inline void notifyOnConstruct()
  {
    observable_m.notify(0,addViewEvent);
  }
  DynamicID_t dynamicID() const
  {
    return dynamicID_m;
  }
  void setDynamicID(DynamicID_t id)
  {
    dynamicID_m = id;
  }
private:
  mutable DataObject_t *dataObjectPtr_m;
  bool owned_m;
  Observable_t observable_m;
  DynamicID_t dynamicID_m;
};
template <class T,
          bool BoundsChecked=false>
class DataBlockPtr
  : public RefCountedBlockPtr<T,BoundsChecked,DataBlockController<T> >
{
public:
  typedef T Pointee_t;
  typedef T Element_t;
  typedef DataBlockPtr<T,BoundsChecked> This_t;
  typedef Pooma::DataObject_t DataObject_t;
  typedef SingleObservable<int> Observable_t;
  typedef DataBlockPtr<T,!BoundsChecked> That_t;
  typedef DataBlockController<T> Controller_t;
  typedef RefCountedBlockPtr<T,BoundsChecked,Controller_t> RCBPtr_t;
  typedef typename Controller_t::DynamicID_t DynamicID_t;
  typedef typename RCBPtr_t::NoInitTag NoInitTag;
  DataBlockPtr() : RCBPtr_t()
  { }
  explicit DataBlockPtr(size_t size)
    : RCBPtr_t(size)
  { }
  DataBlockPtr(size_t size, const NoInitTag &tag)
    : RCBPtr_t(size,tag)
  { }
  DataBlockPtr(int size, const T& model)
    : RCBPtr_t(size,model)
  { }
  DataBlockPtr(T* foreignData, int size)
    : RCBPtr_t(foreignData,size)
  { }
  typedef typename Controller_t::WithAffinity WithAffinity_t;
  DataBlockPtr(int size, int affin, const WithAffinity_t&)
    : RCBPtr_t(new Controller_t(size,affin,WithAffinity_t()))
  { }
  DataBlockPtr(int size, int affin, const WithAffinity_t&,
        const NoInitTag &tag)
    : RCBPtr_t(new Controller_t(size,affin,WithAffinity_t(),tag))
  { }
  DataBlockPtr(int size, DataObject_t &dobj)
    : RCBPtr_t(new Controller_t(size,dobj))
  { }
  DataBlockPtr(int size, const T& model, DataObject_t &dobj)
    : RCBPtr_t(new Controller_t(size,model,dobj))
  { }
  DataBlockPtr(int size, DataObject_t &dobj, const NoInitTag &tag)
    : RCBPtr_t(new Controller_t(size,dobj,tag))
  { }
  DataBlockPtr(const This_t& model)
    : RCBPtr_t(model)
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnConstruct();
  }
  DataBlockPtr(const This_t& model, DataObject_t &dobj)
    : RCBPtr_t(new Controller_t(model, dobj))
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnConstruct();
  }
  DataBlockPtr(const That_t& model)
    : RCBPtr_t(model)
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnConstruct();
  }
  DataBlockPtr(const RCBPtr_t& model)
    : RCBPtr_t(model)
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnConstruct();
  }
  DataBlockPtr(const This_t& model, ptrdiff_t offset)
    : RCBPtr_t(model,offset)
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnConstruct();
  }
  ~DataBlockPtr()
  {
    if (this->isValid()) this->blockControllerPtr_m->notifyOnDestruct();
  }
  This_t & operator=(const This_t & rhs)
  {
    if (this != &rhs)
      {
 if (rhs.isValid()) rhs.blockControllerPtr_m->notifyOnConstruct();
 if (this->isValid()) this->blockControllerPtr_m->notifyOnDestruct();
 RCBPtr_t::operator=(rhs);
      }
    return *this;
  }
  This_t & operator=(const That_t & rhs)
  {
    if (this != &rhs)
      {
 if (rhs.isValid()) rhs.blockControllerPtr_m->notifyOnConstruct();
 if (this->isValid()) this->blockControllerPtr_m->notifyOnDestruct();
 RCBPtr_t::operator=(rhs);
      }
    return *this;
  }
  This_t & operator++()
  { RCBPtr_t::operator++(); return *this; }
  This_t & operator--()
  { RCBPtr_t::operator--(); return *this; }
  This_t operator++(int)
  {
    This_t tmp(*this);
    RCBPtr_t::operator++();
    return tmp;
  }
  This_t operator--(int)
  {
    This_t tmp(*this);
    RCBPtr_t::operator--();
    return tmp;
  }
  This_t operator+(ptrdiff_t i) const
  {
    This_t ret(*this);
    ret += i;
    return ret;
  }
  This_t operator-(ptrdiff_t i) const
  {
    This_t ret(*this);
    ret -= i;
    return ret;
  }
  This_t begin() const
  { return RCBPtr_t::begin(); }
  This_t end() const
  { return RCBPtr_t::end(); }
  void attach(SingleObserver<int> *o)
  {
    this->blockControllerPtr_m->attach(o);
  }
  void detach()
  {
    this->blockControllerPtr_m->detach();
  }
  inline DataObject_t* dataObject() const
  {
    return this->blockControllerPtr_m->dataObject();
  }
  inline void dataObject(DataObject_t *obj)
  {
    this->blockControllerPtr_m->dataObject(obj);
  }
  inline int affinity() const
  {
    return this->blockControllerPtr_m->affinity();
  }
  inline void affinity(int affin)
  {
    this->blockControllerPtr_m->affinity(affin);
  }
  bool sameDataObject(const DataBlockPtr<T>& x) const
  {
    return dataObject() == x.dataObject();
  }
  void lockRefCount() const { this->blockControllerPtr_m->lock(); }
  void unlockRefCount() const { this->blockControllerPtr_m->unlock(); }
  DynamicID_t dynamicID() const
  {
    return this->isValid() ?
      this->blockControllerPtr_m->dynamicID() :
      ObserverEvent::nullID();
  }
  void setDynamicID(DynamicID_t id)
  {
    ;
    this->blockControllerPtr_m->setDynamicID(id);
  }
private:
  friend class DataBlockPtr<T,!BoundsChecked>;
};
template <class T, bool C1, bool C2>
ptrdiff_t operator-(const DataBlockPtr<T,C1> &first,
      const DataBlockPtr<T,C2> &second)
{
  return first.currentPointer() - second.currentPointer();
}
template<class T>
class IndirectionList
{
public:
  typedef IndirectionList<T> This_t;
  typedef T Element_t;
  typedef IndirectionList<T> Domain_t;
  typedef DataBlockPtr<T> Storage_t;
  typedef long Size_t;
  enum { dimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  IndirectionList()
    : size_m(0)
    {
    }
  IndirectionList(const This_t &a)
    : iList_m(a.iList_m), size_m(a.size_m)
    {
    }
  IndirectionList(int num) : iList_m(num), size_m(num) { ; }
  IndirectionList(long num) : iList_m(num), size_m(num) { ; }
  IndirectionList(unsigned int num) : iList_m(num), size_m(num) { }
  IndirectionList(unsigned long num) : iList_m(num), size_m(num) { }
  template<class T1>
  IndirectionList(const T1 &first, const T1 &stride, Size_t num)
    : iList_m(num), size_m(num)
    {
      ;
      T1 val = first;
      for (Size_t i=0; i < num; ++i)
 {
   iList_m[i] = val;
   val += stride;
 }
    }
  template<class T1>
  explicit IndirectionList(const T1 &a)
    : iList_m(a.engine().dataBlock()), size_m(a.domain().size())
    {
    }
  ~IndirectionList()
    {
    }
  This_t &operator=(const This_t &newilist)
    {
      iList_m = newilist.iList_m;
      size_m = newilist.size_m;
      return *this;
    }
  template<class T1>
  This_t &operator=(const T1 &a)
    {
      iList_m = a.engine().dataBlock();
      size_m = a.domain().size();
      return *this;
    }
  This_t &operator[](int i)
    {
      ;
      return *this;
    }
  const This_t &operator[](int i) const
    {
      ;
      return *this;
    }
  const T &operator()(Size_t i1) const
    {
      return iList_m[i1];
    }
  T &operator()(Size_t i1)
    {
      return iList_m[i1];
    }
  Size_t length() const
    {
      return size_m;
    }
  T first() const
    {
      return iList_m[0];
    }
  T last() const
    {
      return iList_m[size_m-1];
    }
  T stride() const
    {
      return T(0);
    }
  T min() const
    {
      T result = iList_m[0];
      for (Size_t i=1; i<size_m; ++i)
 result = (iList_m[i] < result) ? iList_m[i] : result;
      return result;
    }
  T max() const
    {
      T result = iList_m[0];
      for (Size_t i=1; i<size_m; ++i)
 result = (result < iList_m[i]) ? iList_m[i] : result;
      return result;
    }
  Size_t size() const
    {
      return size_m;
    }
  bool empty() const
    {
      return (size() == 0);
    }
  bool initialized() const
    {
      return (!empty());
    }
  template<class T1>
  This_t &operator+=(const T1 &val)
    {
      Size_t n = size();
      if (n > 0)
 {
   iList_m.makeOwnCopy();
   for (Size_t i=0; i < n; ++i)
     iList_m[i] += val;
 }
      return *this;
    }
  template<class T1>
  This_t &operator-=(const T1 &val)
    {
      Size_t n = size();
      if (n > 0)
 {
   iList_m.makeOwnCopy();
   for (Size_t i=0; i < n; ++i)
     iList_m[i] -= val;
 }
      return *this;
    }
  template<class T1>
  This_t &operator*=(const T1 &val)
    {
      Size_t n = size();
      if (n > 0)
 {
   iList_m.makeOwnCopy();
   for (Size_t i=0; i < n; ++i)
     iList_m[i] *= val;
 }
      return *this;
    }
  template<class T1>
  This_t &operator/=(const T1 &val)
    {
      Size_t n = size();
      if (n > 0)
 {
   iList_m.makeOwnCopy();
   for (Size_t i=0; i < n; ++i)
     iList_m[i] /= val;
 }
      return *this;
    }
  template<class Out>
  void print(Out &o) const;
private:
  Storage_t iList_m;
  Size_t size_m;
};
template<class T>
template<class Out>
void IndirectionList<T>::print(Out &o) const
{
  o << "[";
  for (Size_t i=0; i < size(); ++i)
    {
      o << (*this)(i);
      if (i < (size() - 1))
 o << ",";
    }
  o << "]";
}
template<class T>
std::ostream& operator<<(std::ostream &o, const IndirectionList<T> &list)
{
  list.print(o);
  return o;
}
namespace Pooma {
template <class Iter>
class IteratorPairDomain
{
public:
  typedef IteratorPairDomain<Iter> This_t;
  typedef Iter iterator;
  typedef std::iterator_traits<Iter> IterTraits_t;
  typedef typename IterTraits_t::value_type Element_t;
  typedef typename IterTraits_t::reference ElementRef_t;
  typedef long Size_t;
  enum { dimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  IteratorPairDomain() : size_m(0) { }
  IteratorPairDomain(Iter begin, Iter end)
    : begin_m(begin), end_m(end)
  {
    size_m = std::distance(begin_m,end_m);
  }
  IteratorPairDomain(const This_t &a)
    : begin_m(a.begin_m), end_m(a.end_m), size_m(a.size_m)
  { }
  template <class OtherIter>
  IteratorPairDomain(const IteratorPairDomain<OtherIter> &a)
    : begin_m(a.begin()), end_m(a.end()), size_m(a.size())
  { }
  This_t &operator=(const This_t &model)
  {
    begin_m = model.begin_m;
    end_m = model.end_m;
    size_m = model.size_m;
    return *this;
  }
  This_t &operator[](int i)
  {
    ;
    return *this;
  }
  const This_t &operator[](int i) const
  {
    ;
    return *this;
  }
  Element_t operator()(Size_t i) const
  {
    ;
    Iter pos = begin_m;
    std::advance(pos,i);
    return *pos;
  }
  ElementRef_t operator()(Size_t i)
  {
    ;
    Iter pos = begin_m;
    std::advance(pos,i);
    return *pos;
  }
  Size_t length() const { return size_m; }
  Size_t size() const { return size_m; }
  bool empty() const { return size_m == 0; }
  bool initialized() const { return size_m != 0; }
  Element_t first() const { return *begin_m; }
  Element_t last() const
  {
    Iter lpos = begin_m;
    std::advance(lpos,size_m-1);
    return *lpos;
  }
  Element_t min() const
  {
    Iter pos = begin_m;
    Element_t result = *pos++;
    for (Size_t i = 1; i < size_m; ++i)
      {
        if (*pos < result) result = *pos;
        ++pos;
      }
    return result;
  }
  Element_t max() const
  {
    Iter pos = begin_m;
    Element_t result = *pos++;
    for (Size_t i = 1; i < size_m; ++i)
      {
        if (result < *pos) result = *pos;
        ++pos;
      }
    return result;
  }
  Iter begin() const { return begin_m; }
  Iter end() const { return end_m; }
  template <class Out>
  void print(Out &o) const;
private:
  Iter begin_m;
  Iter end_m;
  Size_t size_m;
};
template <class Iter>
template <class Out>
void IteratorPairDomain<Iter>::print(Out &o) const
{
  o << "[";
  Iter pos = begin_m;
  o << *pos++;
  for (Size_t i = 1; i < size_m; ++i)
    {
      o << "," << *pos++;
    }
  o << "]";
}
template <class Iter>
std::ostream&
operator<<(std::ostream &o, const IteratorPairDomain<Iter> &list)
{
  list.print(o);
  return o;
}
}
using Pooma::IteratorPairDomain;
struct DynamicEvents
{
  enum EventCode {
         create = 1000,
  extend,
  destroyInterval, destroyRange, destroyList, destroyIterList,
  copyInterval, copyRange, copyList,
  copyPatchList,
  sync,
  unknownEvent };
  static bool isDynamic(int eventcode)
  {
    return eventcode >= DynamicEvents::create &&
           eventcode < DynamicEvents::unknownEvent;
  }
  enum { backfill = 100, shiftup, unknownMethod };
  typedef int PatchID_t;
  typedef int CreateSize_t;
};
struct BackFill
{
  enum { code = DynamicEvents::backfill };
  BackFill(){};
};
struct ShiftUp
{
  enum { code = DynamicEvents::shiftup };
  ShiftUp(){};
};
template<class T>
struct DynamicEventType
{
  enum { destroyCode = DynamicEvents::destroyList };
  enum { copyCode = DynamicEvents::copyList };
  enum { dimensions = 1 };
  typedef IndirectionList<int> Domain_t;
};
template <>
struct DynamicEventType<IteratorPairDomain<const int*> >
{
  enum { destroyCode = DynamicEvents::destroyIterList };
  enum { copyCode = DynamicEvents::copyList };
  enum { dimensions = 1 };
  typedef IteratorPairDomain<const int*> Domain_t;
};
template <>
struct DynamicEventType<IteratorPairDomain<int*> >
{
  enum { destroyCode = DynamicEvents::destroyIterList };
  enum { copyCode = DynamicEvents::copyList };
  enum { dimensions = 1 };
  typedef IteratorPairDomain<const int*> Domain_t;
};
template<>
struct DynamicEventType< IndirectionList< IndirectionList<int> > >
{
  enum { destroyCode = DynamicEvents::unknownEvent };
  enum { copyCode = DynamicEvents::copyPatchList };
  enum { dimensions = 1 };
  typedef IndirectionList< IndirectionList<int> > Domain_t;
};
template<int Dim>
struct DynamicEventType< Interval<Dim> >
{
  enum { destroyCode = DynamicEvents::destroyInterval };
  enum { copyCode = DynamicEvents::copyInterval };
  enum { dimensions = Dim };
  typedef Interval<Dim> Domain_t;
};
template<int Dim>
struct DynamicEventType< Range<Dim> >
{
  enum { destroyCode = DynamicEvents::destroyRange };
  enum { copyCode = DynamicEvents::copyRange };
  enum { dimensions = Dim };
  typedef Range<Dim> Domain_t;
};
template<int Dim>
struct DynamicEventType< Loc<Dim> >
{
  enum { destroyCode = DynamicEvents::destroyInterval };
  enum { copyCode = DynamicEvents::copyInterval };
  enum { dimensions = Dim };
  typedef Interval<Dim> Domain_t;
};
template<>
struct DynamicEventType<int>
{
  enum { destroyCode = DynamicEvents::destroyInterval };
  enum { copyCode = DynamicEvents::copyInterval };
  enum { dimensions = 1 };
  typedef Interval<1> Domain_t;
};
class CreateEvent : public ObserverEvent
{
public:
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  CreateEvent(CreateSize_t num, PatchID_t p)
    : ObserverEvent(DynamicEvents::create),
      amount_m(num), patch_m(p)
    {
    }
  virtual ~CreateEvent()
    {
    }
  inline CreateSize_t amount() const
    {
      return amount_m;
    }
  inline PatchID_t patch() const
    {
      return patch_m;
    }
private:
  CreateSize_t amount_m;
  PatchID_t patch_m;
};
template<class Dom>
class DestroyEvent : public ObserverEvent
{
public:
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef typename DynamicEventType<Dom>::Domain_t Domain_t;
  template<class D>
  DestroyEvent(const D &d, PatchID_t p, int method)
    : ObserverEvent(DynamicEventType<Dom>::destroyCode),
      domain_m(d), patch_m(p), method_m(method)
    {
      PoomaCTAssert<(DynamicEventType<Dom>::dimensions == 1)>::test();
    }
  virtual ~DestroyEvent()
    {
    }
  inline const Domain_t &domain() const
    {
      return domain_m;
    }
  inline PatchID_t patch() const
    {
      return patch_m;
    }
  inline int method() const
    {
      return method_m;
    }
private:
  Domain_t domain_m;
  PatchID_t patch_m;
  int method_m;
};
template<class Dom>
class CopyEvent : public ObserverEvent
{
public:
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef typename DynamicEventType<Dom>::Domain_t Domain_t;
  CopyEvent(const Dom &d, PatchID_t fromp, PatchID_t top)
    : ObserverEvent(DynamicEventType<Dom>::copyCode),
      domain_m(d), from_m(fromp), to_m(top)
    {
      PoomaCTAssert<(DynamicEventType<Dom>::dimensions == 1)>::test();
    }
  template<class D>
  CopyEvent(const D &d, PatchID_t fromp, PatchID_t top)
    : ObserverEvent(DynamicEventType<Dom>::copyCode),
      domain_m(d), from_m(fromp), to_m(top)
    {
      PoomaCTAssert<(DynamicEventType<Dom>::dimensions == 1)>::test();
    }
  virtual ~CopyEvent()
    {
    }
  inline const Domain_t &domain() const
    {
      return domain_m;
    }
  inline PatchID_t fromPatch() const
    {
      return from_m;
    }
  inline PatchID_t toPatch() const
    {
      return to_m;
    }
private:
  Domain_t domain_m;
  PatchID_t from_m;
  PatchID_t to_m;
};
class CopyPatchEvent : public ObserverEvent
{
public:
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef IndirectionList< IndirectionList<int> > Domain_t;
  typedef IndirectionList<int> IDList_t;
  CopyPatchEvent(const Domain_t &domlists, const IDList_t &fromlist,
   PatchID_t top, bool create)
    : ObserverEvent(DynamicEvents::copyPatchList),
      lists_m(domlists), from_m(fromlist), to_m(top), create_m(create)
    {
    }
  virtual ~CopyPatchEvent()
    {
    }
  inline const Domain_t &domainLists() const
    {
      return lists_m;
    }
  inline const IDList_t &fromPatch() const
    {
      return from_m;
    }
  inline PatchID_t toPatch() const
    {
      return to_m;
    }
  inline bool create() const
    {
      return create_m;
    }
private:
  Domain_t lists_m;
  IDList_t from_m;
  PatchID_t to_m;
  bool create_m;
};
class SyncEvent : public ObserverEvent
{
public:
  SyncEvent()
    : ObserverEvent(DynamicEvents::sync)
    {
    }
  virtual ~SyncEvent()
    {
    }
private:
};
template<int Dim>
class ContextMapper
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  ContextMapper(){};
  virtual ~ContextMapper(){};
  virtual void map(const List_t & templist) const = 0;
  void setAffinity(const List_t & templist) const;
};
template<int Dim>
void ContextMapper<Dim>::setAffinity(const List_t & templist) const
{
  int affinityMax = Smarts::concurrency();
  int idMax = 0;
  typename List_t::const_iterator start = templist.begin();
  typename List_t::const_iterator end = templist.end();
  for ( ; start != end ; ++start)
    if((*start)->context()==Pooma::context())
      {
 (*start)->localID()=idMax;
 ++idMax;
      }
  start = templist.begin();
  for ( ; start != end ; ++start)
    {
      if((*start)->context()==Pooma::context())
 (*start)->affinity() = static_cast<int>
   ( affinityMax * ( (*start)->localID()
       / static_cast<double>(idMax) ) );
    }
  return;
}
template<int Dim>
class LocalMapper
  : public ContextMapper<Dim>
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template<class Partitioner>
  LocalMapper(const Partitioner &)
  {}
  LocalMapper()
  {}
  void map(const List_t & templist) const;
};
template<int Dim>
void LocalMapper<Dim>::map(const List_t & templist) const
{
  int idMax = templist.size();
  int naff = Smarts::concurrency();
  for (int i = 0; i< templist.size(); ++i)
    {
      templist[i]->context() = -1;
      templist[i]->localID() = i;
      templist[i]->affinity() = static_cast<int>( ( naff * ( i /
    static_cast<double>(idMax) ) ) );
    }
}
template<int Dim>
class DefaultTPmapper
  : public ContextMapper<Dim>
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template<class Partitioner>
  DefaultTPmapper(const Partitioner & gp)
  {
  }
  void map(const List_t & templist) const;
private:
};
template<int Dim>
void DefaultTPmapper<Dim>::map(const List_t & templist) const
{
  int ncontexts = Pooma::contexts();
  int npc = templist.size()/ncontexts;
  if (templist.size()%ncontexts!=0) ++npc;
  typename List_t::const_iterator start = templist.begin();
  typename List_t::const_iterator end = templist.end();
  int c = 0;
  int p = 0;
  for ( ; start!=end ; ++start)
    {
      (*start)->context() = p;
      if(p == Pooma::context())
 (*start)->localID() = c;
      ++c;
      if (c > npc)
 {
   ++p;
   c = 0;
 }
    }
  int affinityMax = Smarts::concurrency();
  int idMax = 0;
  start = templist.begin();
  for ( ; start != end ; ++start)
    if((*start)->context()==Pooma::context())
      {
 (*start)->localID()=idMax;
 ++idMax;
      }
  start = templist.begin();
  for ( ; start != end ; ++start)
    {
      if((*start)->context()==Pooma::context())
 (*start)->affinity() = static_cast<int>( affinityMax *
       ( (*start)->localID() /
          static_cast<double>(idMax) ) );
    }
}
template<int Dim>
class TilePartition
{
public:
  typedef LocalMapper<Dim> DefaultMapper_t;
  typedef Interval<Dim> Domain_t;
  typedef std::vector<Domain_t> PatchList_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  enum { uniform = false };
  enum { gridded = false };
  enum { tile = true };
  enum { general = true };
  enum { dimensions = Dim };
  TilePartition()
    : hasInternalGuards_m(false),
      hasExternalGuards_m(false),
      num_m(0),
      internalGuards_m(0),
      externalGuards_m(0)
  {
  }
  TilePartition(const PatchList_t &pList)
    : hasInternalGuards_m(false),
      hasExternalGuards_m(false),
      internalGuards_m(0),
      externalGuards_m(0),
      tile_m(pList)
  {
    num_m = pList.size();
  }
  TilePartition(const PatchList_t &pList,
  const GuardLayers<Dim> &gcs)
    : hasInternalGuards_m(true),
      hasExternalGuards_m(false),
      internalGuards_m(gcs),
      externalGuards_m(gcs),
      tile_m(pList)
  {
    num_m = tile_m.size();
  }
  TilePartition(const PatchList_t &pList,
  const GuardLayers<Dim> &igcs,
  const GuardLayers<Dim> &egcs)
    : hasInternalGuards_m(true),
      hasExternalGuards_m(true),
      internalGuards_m(igcs),
      externalGuards_m(egcs),
      tile_m(pList)
  {
    num_m = tile_m.size();
  }
  TilePartition(const TilePartition<Dim> & b)
    : hasInternalGuards_m(b.hasInternalGuards_m),
      hasExternalGuards_m(b.hasExternalGuards_m),
      internalGuards_m(b.internalGuards_m),
      externalGuards_m(b.externalGuards_m),
      tile_m(b.tile_m),
      num_m(b.num_m)
  {
  }
  ~TilePartition() { }
  TilePartition<Dim> &operator=(const TilePartition<Dim> &g)
  {
    if (this != &g)
      {
 hasInternalGuards_m = g.hasInternalGuards_m;
 hasExternalGuards_m = g.hasExternalGuards_m;
 internalGuards_m = g.internalGuards_m;
 externalGuards_m = g.externalGuards_m;
 tile_m = const_cast<TilePartition<Dim>&>(g).tileList();
 num_m = g.maxSize();
 if (!hasInternalGuards_m)
   internalGuards_m = GuardLayers<Dim>(0);
 if (!hasExternalGuards_m)
   externalGuards_m = GuardLayers<Dim>(0);
      }
    return *this;
  }
  int maxSize() const { return num_m; }
  PatchList_t tileList() { return tile_m; }
  bool hasGuards() const { return hasInternalGuards_m||hasExternalGuards_m; }
  bool hasCustomEdgeGuards() const
  {
    if (hasInternalGuards_m&&!hasExternalGuards_m) return true;
    if (!hasInternalGuards_m&&hasExternalGuards_m) return true;
    if (hasInternalGuards_m&&hasExternalGuards_m
       &&(internalGuards_m!=externalGuards_m)) return true;
    return false;
  }
  bool hasInternalGuards() const { return hasInternalGuards_m; }
  bool hasExternalGuards() const { return hasExternalGuards_m;}
  const GuardLayers<Dim> &internalGuards() const
  {
    return internalGuards_m;
  }
  const GuardLayers<Dim> &externalGuards() const
  {
    return externalGuards_m;
  }
  template<class D>
  int partition(const D &bbox,List_t &all,const ContextMapper<Dim> &cmapper) const;
  template<class D>
  int partition(const D &bbox,List_t &all) const
  {
    return partition(bbox,all,LocalMapper<Dim>(*this));
  }
  template<class Out>
  void print(Out &o) const;
private:
  bool hasInternalGuards_m;
  bool hasExternalGuards_m;
  GuardLayers<Dim> internalGuards_m;
  GuardLayers<Dim> externalGuards_m;
  int num_m;
  PatchList_t tile_m;
};
template<int Dim>
template<class D>
int TilePartition<Dim>::partition(const D &bbox, List_t &all,
      const ContextMapper<Dim> &cmapper) const
{
  typedef typename DomainTraits<Domain_t>::Element_t Element_t;
  PoomaCTAssert<(Dim == DomainTraits<Domain_t>::dimensions)>::test();
  typename PatchList_t::const_iterator start = tile_m.begin();
  typename PatchList_t::const_iterator end = tile_m.end();
  while (start!=end)
    {
      Domain_t o = Pooma::NoInit();
      o = * start;
      Domain_t oo = o;
      Domain_t a = Pooma::NoInit();
      a = * start;
      if (hasInternalGuards()||hasExternalGuards())
 {
   for (int i=0;i<Dim;i++)
     {
       if (oo[i].first() == bbox[i].first())
  {
    if (hasExternalGuards())
      {
        o[i]=Interval<1>(o[i].first()-externalGuards().lower(i),
           o[i].last());
        a[i]=Interval<1>(a[i].first()-externalGuards().lower(i),
           a[i].last());
      }
    if (hasInternalGuards() && oo[i].last() != bbox[i].last() )
      a[i]=Interval<1>(a[i].first(),
         a[i].last()+internalGuards().upper(i));
  }
       if (oo[i].last()== bbox[i].last())
  {
    if (hasExternalGuards())
      {
        o[i]=Interval<1>(o[i].first(),
           o[i].last()+externalGuards().upper(i));
        a[i]=Interval<1>(a[i].first(),
           a[i].last()+externalGuards().upper(i));
      }
    if (hasInternalGuards()&&(oo[i].first() != bbox[i].first()))
      a[i]=Interval<1>(a[i].first()-internalGuards().lower(i),
         a[i].last());
  }
       if (oo[i].first()!=bbox[i].first() &&
    oo[i].last() != bbox[i].last() &&
    hasInternalGuards())
  a[i]=Interval<1>(o[i].first()-internalGuards().lower(i),
     o[i].last()+internalGuards().upper(i));
     }
 }
      Value_t * node = new Value_t(o,a,-1,all.size(),-1);
      all.push_back(node);
      ++start;
    }
  cmapper.map(all);
  return all.size();
}
template<int Dim>
template<class Out>
void TilePartition<Dim>::print(Out &o) const
{
  int i;
  o << "TilePartition<" << Dim << ">:" << std::endl;
  o << "  hasInternalGuards_m  hasExternalGuards_m = ";
  o << hasInternalGuards_m<< " "<<hasExternalGuards_m<< std::endl;
  o << "  internalGuards_m:" << std::endl;
  o << "      upper       ";
  for (i=0; i < Dim; ++i)
    o << internalGuards_m.upper(i) << " ";
  o << std::endl;
  o << "      lower       ";
  for (i=0; i < Dim; ++i)
    o << internalGuards_m.lower(i) << " ";
  o << std::endl;
  o << "  externalGuards_m:" << std::endl;
  o << "      upper       ";
  for (i=0; i < Dim; ++i)
    o << externalGuards_m.upper(i) << " ";
  o << std::endl;
  o << "      lower       ";
  for (i=0; i < Dim; ++i)
    o << externalGuards_m.lower(i) << " ";
  o << std::endl;
  o << "  num_m = " << num_m << std::endl;
}
template <int Dim>
std::ostream &operator<<(std::ostream &o, const TilePartition<Dim> &gp)
{
  gp.print(o);
  return o;
}
extern
bool findLeftCommonEndpoint(int a0, int a1, int s, int b0, int b1, int t,
                            int &endpoint);
extern
bool findIntersectionEndpoints(int a0, int a1, int s, int b0, int b1, int t,
                               int &i0, int &i1, int &is);
template<class T1, class T2, class T3, int Dim, bool strided>
struct IntersectDomainSingle {
  static void intersect(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::Element_t E1_t;
    typedef typename DomainTraits<T2>::Element_t E2_t;
    E1_t a0 = a.min();
    E1_t a1 = a.max();
    E2_t b0 = b.min();
    E2_t b1 = b.max();
    if (a1 < b0 || a0 > b1)
      return;
    if (b0 > a0)
      a0 = b0;
    if (b1 < a1)
      a1 = b1;
    typedef typename DomainTraits<T3>::OneDomain_t Dom_t;
    c[Dim-1] = Dom_t(a0, a1);
  }
};
template<class T1, class T2, class T3, int Dim>
struct IntersectDomainSingle<T1,T2,T3,Dim,true> {
  static void intersect(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::Element_t E1_t;
    typedef typename DomainTraits<T2>::Element_t E2_t;
    E1_t s = a.stride();
    E2_t t = b.stride();
    if (s == 1 && t == 1) {
      IntersectDomainSingle<T1,T2,T3,Dim,false>::intersect(a,b,c);
      return;
    }
    E1_t a0 = a.min();
    E1_t a1 = a.max();
    E2_t b0 = b.min();
    E2_t b1 = b.max();
    if (a1 < b0 || a0 > b1)
      return;
    int i1, i2, is;
    if (findIntersectionEndpoints(a0, a1, s, b0, b1, t, i1, i2, is)) {
      typedef typename DomainTraits<T3>::OneDomain_t Dom_t;
      if (s < 0)
        c[Dim-1] = Dom_t(i2, i1, -is);
      else
        c[Dim-1] = Dom_t(i1, i2, is);
    }
  }
};
template<class T1, class T2, class T3, int Dim>
struct IntersectDomain {
  enum { strided =
    !DomainTraits<T1>::unitStride || !DomainTraits<T2>::unitStride };
  static void intersect(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    IntersectDomainSingle<Dom1_t,Dom2_t,T3,Dim,strided>::intersect(
      DomainTraits<T1>::getDomain(a,Dim-1),
      DomainTraits<T2>::getDomain(b,Dim-1), c);
    IntersectDomain<T1,T2,T3,Dim-1>::intersect(a,b,c);
  }
};
template<class T1, class T2, class T3>
struct IntersectDomain<T1,T2,T3,1> {
  enum { strided =
    !DomainTraits<T1>::unitStride || !DomainTraits<T2>::unitStride };
  static void intersect(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    IntersectDomainSingle<Dom1_t,Dom2_t,T3,1,strided>::intersect(
      DomainTraits<T1>::getDomain(a,0), DomainTraits<T2>::getDomain(b,0), c);
  }
};
template<class T1, class T2>
struct IntersectReturnType {
  typedef typename NewDomain2<T1,T2>::Type_t Combine_t;
  typedef typename
    DomainChangeDim<Combine_t,DomainTraits<T1>::dimensions>::NewType_t Type_t;
};
template<class T1, class T2>
inline typename IntersectReturnType<T1,T2>::Type_t
intersect(const T1 &a, const T2 &b)
{
  typedef typename IntersectReturnType<T1,T2>::Type_t T3;
  PoomaCTAssert<((int)DomainTraits<T1>::dimensions == DomainTraits<T2>::dimensions)>::test();
  T3 c;
  IntersectDomain<T1,T2,T3,DomainTraits<T1>::dimensions>::intersect(a, b, c);
  return c;
}
template<int TotalDim, int SliceDim> class SliceRange;
template<int TotalDim, int SliceDim>
struct DomainTraits< SliceRange<TotalDim,SliceDim> >
{
  enum { domain = true };
  enum { dimensions = TotalDim,
  sliceDimensions = SliceDim };
  enum { unitStride = false };
  enum { singleValued = false };
  enum { wildcard = false };
  typedef SliceRange<TotalDim,SliceDim> Domain_t;
  typedef SliceRange<TotalDim,SliceDim> NewDomain1_t;
  typedef Range<SliceDim> SliceDomain_t;
  typedef Range<TotalDim> TotalDomain_t;
  typedef Range<1> OneDomain_t;
  typedef Range<1> PointDomain_t;
  static OneDomain_t &getDomain(Domain_t &d, int n) {
    return d.totalDomain()[n];
  }
  static const OneDomain_t &getDomain(const Domain_t &d,int n) {
    return d.totalDomain()[n];
  }
  static OneDomain_t &getSliceDomain(Domain_t &d, int n) {
    return d.sliceDomain()[n];
  }
  static const OneDomain_t &getSliceDomain(const Domain_t &d, int n) {
    return d.sliceDomain()[n];
  }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void cantIgnoreDomain(Domain_t &d, int n) {
    d.cantIgnoreDomain(n);
  }
  static bool getIgnorable(const Domain_t &d, int n) {
    return d.ignorable(n);
  }
  static void setIgnorable(Domain_t &d, int n, bool i) {
    d.ignorable(n) = i;
  }
};
template<class DT>
class SliceDomain
{
public:
  typedef typename DT::Domain_t Domain_t;
  typedef typename DT::SliceDomain_t SliceDomain_t;
  typedef typename DT::TotalDomain_t TotalDomain_t;
  SliceDomain()
    : slice_m(Pooma::NoInit()),
      domain_m(Pooma::NoInit()) {
    PoomaCTAssert<(DT::sliceDimensions <= DT::dimensions)>::test();
    for (int d = 0; d < DT::dimensions; ++d)
      ignore_m[d] = true;
  }
  SliceDomain(const Pooma::NoInit &e)
    : slice_m(e), domain_m(e) {
    PoomaCTAssert<(DT::sliceDimensions <= DT::dimensions)>::test();
    for (int d = 0; d < DT::dimensions; ++d)
      ignore_m[d] = true;
  }
  SliceDomain(const SliceDomain<DT> &sd)
    : slice_m(sd.slice_m),
      domain_m(sd.domain_m) {
    PoomaCTAssert<(DT::sliceDimensions <= DT::dimensions)>::test();
    for (int d = 0; d < DT::dimensions; ++d)
      ignore_m[d] = sd.ignore_m[d];
  }
  template <class DTO>
  SliceDomain(const SliceDomain<DTO> &sd)
    : slice_m(sd.sliceDomain()),
      domain_m(sd.totalDomain()) {
    PoomaCTAssert<(DT::sliceDimensions <= DT::dimensions)>::test();
    for (int d = 0; d < DT::dimensions; ++d)
      ignore_m[d] = sd.ignorable(d);
  }
  Domain_t &unwrap() { return *static_cast<Domain_t *>(this); }
  const Domain_t &unwrap() const {
    return *static_cast<const Domain_t *>(this);
  }
  ~SliceDomain() { }
  const SliceDomain_t &sliceDomain() const { return slice_m; }
  SliceDomain_t &sliceDomain() { return slice_m; }
  const TotalDomain_t &totalDomain() const { return domain_m; }
  TotalDomain_t &totalDomain() { return domain_m; }
  void cantIgnoreDomain(int d)
  {
    ;
    ignore_m[d] = false;
  }
  bool &ignorable(int d)
  {
    ;
    return ignore_m[d];
  }
  bool ignorable(int d) const
  {
    ;
    return ignore_m[d];
  }
  SliceDomain<DT> &operator=(const SliceDomain<DT> &sd) {
    slice_m = sd.slice_m;
    domain_m = sd.domain_m;
    for (int d = 0; d < DT::dimensions; ++d)
      ignore_m[d] = sd.ignore_m[d];
    return *this;
  }
  void setSliceFromTotal() {
    for (int d = 0, dt = 0; d < DT::dimensions; ++d)
      if (!ignore_m[d])
        slice_m[dt++] = domain_m[d];
  }
  template<class Out>
  void print(Out &o) const;
private:
  SliceDomain_t slice_m;
  TotalDomain_t domain_m;
  bool ignore_m[DT::dimensions];
};
template<class DT>
template<class Out>
void SliceDomain<DT>::print(Out &o) const
{
  o << totalDomain() << "==>" << sliceDomain();
}
template <class T1, class T2> inline typename T1::Domain_t operator+(const SliceDomain<T1> &d1, const DomainBase<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2.unwrap(); ret.setSliceFromTotal(); return ret; } template <class T1, class T2> inline typename T1::Domain_t operator+(const SliceDomain<T1> &d1, const SliceDomain<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2.unwrap().totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, unsigned char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(unsigned char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, unsigned short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(unsigned short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, unsigned int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(unsigned int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, unsigned long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(unsigned long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, float d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(float d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(const SliceDomain<T> &d1, double d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() += d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator+(double d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 + ret.totalDomain(); ret.setSliceFromTotal(); return ret; }
template <class T1, class T2> inline typename T1::Domain_t operator-(const SliceDomain<T1> &d1, const DomainBase<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2.unwrap(); ret.setSliceFromTotal(); return ret; } template <class T1, class T2> inline typename T1::Domain_t operator-(const SliceDomain<T1> &d1, const SliceDomain<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2.unwrap().totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, unsigned char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(unsigned char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, unsigned short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(unsigned short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, unsigned int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(unsigned int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, unsigned long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(unsigned long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, float d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(float d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(const SliceDomain<T> &d1, double d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() -= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator-(double d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 - ret.totalDomain(); ret.setSliceFromTotal(); return ret; }
template <class T1, class T2> inline typename T1::Domain_t operator*(const SliceDomain<T1> &d1, const DomainBase<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2.unwrap(); ret.setSliceFromTotal(); return ret; } template <class T1, class T2> inline typename T1::Domain_t operator*(const SliceDomain<T1> &d1, const SliceDomain<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2.unwrap().totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, unsigned char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(unsigned char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, unsigned short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(unsigned short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, unsigned int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(unsigned int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, unsigned long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(unsigned long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, float d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(float d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(const SliceDomain<T> &d1, double d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() *= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator*(double d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 * ret.totalDomain(); ret.setSliceFromTotal(); return ret; }
template <class T1, class T2> inline typename T1::Domain_t operator/(const SliceDomain<T1> &d1, const DomainBase<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2.unwrap(); ret.setSliceFromTotal(); return ret; } template <class T1, class T2> inline typename T1::Domain_t operator/(const SliceDomain<T1> &d1, const SliceDomain<T2> &d2) { typename T1::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2.unwrap().totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, unsigned char d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(unsigned char d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, unsigned short d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(unsigned short d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, unsigned int d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(unsigned int d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, unsigned long d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(unsigned long d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, float d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(float d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(const SliceDomain<T> &d1, double d2) { typename T::Domain_t ret(d1.unwrap()); ret.totalDomain() /= d2; ret.setSliceFromTotal(); return ret; } template <class T> inline typename T::Domain_t operator/(double d1, const SliceDomain<T> &d2) { typename T::Domain_t ret(d2.unwrap()); ret.totalDomain() = d2 / ret.totalDomain(); ret.setSliceFromTotal(); return ret; }
template<class DT>
std::ostream& operator<<(std::ostream &o, const SliceDomain<DT> &dbase) {
  dbase.print(o);
  return o;
}
template<int Dim, int SliceDim>
class SliceRange
  : public SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > >
{
public:
  SliceRange() { }
  SliceRange(const Pooma::NoInit &e)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > >(e) { }
  SliceRange(const SliceRange<Dim,SliceDim> &nd)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > >(nd) {
  }
  SliceRange(const SliceInterval<Dim,SliceDim> &nd)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > >(nd) {
  }
  template <class Base, class D1>
  SliceRange(const Base &baseDomain, const D1 &d1)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain1<D1> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1);
  }
  template <class Base, class D1, class D2>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain2<D1,D2> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2);
  }
  template <class Base, class D1, class D2, class D3>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2, const D3 &d3)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain3<D1,D2,D3> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3);
  }
  template <class Base, class D1, class D2, class D3,
            class D4>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2, const D3 &d3,
             const D4 &d4)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain4<D1,D2,D3,D4> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2, const D3 &d3,
             const D4 &d4, const D5 &d5)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain5<D1,D2,D3,D4,D5> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5, class D6>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2, const D3 &d3,
             const D4 &d4, const D5 &d5, const D6 &d6)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain6<D1,D2,D3,D4,D5,D6> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5, d6);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5, class D6, class D7>
  SliceRange(const Base &baseDomain, const D1 &d1, const D2 &d2, const D3 &d3,
             const D4 &d4, const D5 &d5, const D6 &d6, const D7 &d7)
    : SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain7<D1,D2,D3,D4,D5,D6,D7> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5, d6, d7);
  }
  ~SliceRange() { }
  SliceRange<Dim,SliceDim> &
    operator=(const SliceRange<Dim,SliceDim> &nd) {
      SliceDomain<DomainTraits<SliceRange<Dim,SliceDim> > >::operator=(nd);
      return *this;
  }
protected:
private:
};
template<class T, int Dim, bool strided>
struct SplitDomainSingle {
  static void split(const T &a, int axis, T &b, T &c) {
    typedef typename DomainTraits<T>::Element_t E1_t;
    typedef typename DomainTraits<T>::OneDomain_t OneDomain_t;
    if (axis != (Dim - 1)) {
      b[Dim-1] = a[Dim-1];
      c[Dim-1] = a[Dim-1];
    } else if (a[Dim-1].length() < 2) {
      b[Dim-1] = a[Dim-1];
    } else {
      E1_t a0 = a[Dim-1].first();
      E1_t a1 = a[Dim-1].last();
      E1_t mid = a0 + a[Dim-1].length()/2;
      b[Dim-1] = OneDomain_t(a0, mid-1);
      c[Dim-1] = OneDomain_t(mid, a1);
    }
  }
  static void split(const T &a, int axis, int leftLength, T &b, T &c) {
    typedef typename DomainTraits<T>::Element_t E1_t;
    typedef typename DomainTraits<T>::OneDomain_t OneDomain_t;
    if (axis != (Dim - 1)) {
      b[Dim-1] = a[Dim-1];
      c[Dim-1] = a[Dim-1];
    } else if (a[Dim-1].length() < 2) {
      b[Dim-1] = a[Dim-1];
    } else {
      E1_t a0 = a[Dim-1].first();
      E1_t a1 = a[Dim-1].last();
      E1_t mid = a0 + leftLength;
      b[Dim-1] = OneDomain_t(a0, mid-1);
      c[Dim-1] = OneDomain_t(mid, a1);
    }
  }
  static void split(const T &a, T &b, T &c) { split(a, Dim-1, b, c); }
};
template<class T, int Dim>
struct SplitDomainSingle<T,Dim,true> {
  static void split(const T &a, int axis, T &b, T &c) {
    typedef typename DomainTraits<T>::Element_t E1_t;
    typedef typename DomainTraits<T>::OneDomain_t OneDomain_t;
    if (axis != (Dim - 1)) {
      b[Dim-1] = a[Dim-1];
      c[Dim-1] = a[Dim-1];
    } else if (a[Dim-1].length() < 2) {
      b[Dim-1] = a[Dim-1];
    } else {
      E1_t a0 = a[Dim-1].first();
      E1_t a1 = a[Dim-1].last();
      E1_t s = a[Dim-1].stride();
      E1_t mid = a0 + (a[Dim-1].length()/2 * s);
      b[Dim-1] = OneDomain_t(a0, mid - s, s);
      c[Dim-1] = OneDomain_t(mid, a1, s);
    }
  }
  static void split(const T &a, int axis, int leftLength, T &b, T &c) {
    typedef typename DomainTraits<T>::Element_t E1_t;
    typedef typename DomainTraits<T>::OneDomain_t OneDomain_t;
    if (axis != (Dim - 1)) {
      b[Dim-1] = a[Dim-1];
      c[Dim-1] = a[Dim-1];
    } else if (a[Dim-1].length() < 2) {
      b[Dim-1] = a[Dim-1];
    } else {
      E1_t a0 = a[Dim-1].first();
      E1_t a1 = a[Dim-1].last();
      E1_t s = a[Dim-1].stride();
      E1_t mid = a0 + (leftLength * s);
      b[Dim-1] = OneDomain_t(a0, mid - s, s);
      c[Dim-1] = OneDomain_t(mid, a1, s);
    }
  }
  static void split(const T &a, T &b, T &c) { split(a, Dim-1, b, c); }
};
template<int Dim, bool strided>
struct SplitDomainSingle<int,Dim,strided> {
  static void split(int a, int, int &b, int &c) {
    b = a;
    c = 0;
  }
  static void split(int a, int, int, int &b, int &c) {
    b = a;
    c = 0;
  }
  static void split(int a, int &b, int &c) {
    b = a;
    c = 0;
  }
};
template<class T, int Dim>
struct SplitDomain {
  enum { strided = !DomainTraits<T>::unitStride };
  static void split(const T &a, T &b, T &c) {
    SplitDomainSingle<T,Dim,strided>::split(a, b, c);
    SplitDomain<T,Dim-1>::split(a, b, c);
  }
  static void split(const T &a, int axis, T &b, T &c) {
    SplitDomainSingle<T,Dim,strided>::split(a, axis, b, c);
    SplitDomain<T,Dim-1>::split(a, axis, b, c);
  }
  static void split(const T &a, int axis, int leftLength, T &b, T &c) {
    SplitDomainSingle<T,Dim,strided>::split(a, axis, leftLength, b, c);
    SplitDomain<T,Dim-1>::split(a, axis, leftLength, b, c);
  }
};
template<class T>
struct SplitDomain<T,1> {
  enum { strided = !DomainTraits<T>::unitStride };
  static void split(const T &a, T &b, T &c) {
    SplitDomainSingle<T,1,strided>::split(a, b, c);
  }
  static void split(const T &a, int axis, T &b, T &c) {
    SplitDomainSingle<T,1,strided>::split(a, axis, b, c);
  }
  static void split(const T &a, int axis, int leftLength, T &b, T &c) {
    SplitDomainSingle<T,1,strided>::split(a, axis, leftLength, b, c);
  }
};
template<class T>
inline void split(const T &a, T &b, T &c)
{
  SplitDomain<T,DomainTraits<T>::dimensions>::split(a, b, c);
}
template<class T>
inline void split(const T &a, int axis, T &b, T &c)
{
  SplitDomain<T,DomainTraits<T>::dimensions>::split(a, axis, b, c);
}
template<class T>
inline void split(const T &a, int axis, int leftLength, T &b, T &c)
{
  SplitDomain<T,DomainTraits<T>::dimensions>::split(a, axis, leftLength, b, c);
}
template<class T1, class T2, bool strided>
struct TouchesDomainSingle {
  static bool touches(const T1 &a, const T2 &b) {
    return (a.min() <= b.max() && a.max() >= b.min());
  }
};
template<class T1, class T2>
struct TouchesDomainSingle<T1,T2,true> {
  static bool touches(const T1 &a, const T2 &b) {
    bool quicktest = TouchesDomainSingle<T1,T2,false>::touches(a, b);
    if (!quicktest || a.stride() == 1 || a.stride() == (-1) ||
 b.stride() == 1 || b.stride() == (-1)) {
      return quicktest;
    }
    int endpoint = 0;
    return findLeftCommonEndpoint(a.min(), a.max(), a.stride(),
      b.min(), b.max(), b.stride(), endpoint);
  }
};
template<class T1, class T2, int Dim>
struct TouchesDomain {
  enum { strided =
    !DomainTraits<T1>::unitStride && !DomainTraits<T2>::unitStride };
  static bool touches(const T1 &a, const T2 &b) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    return TouchesDomainSingle<Dom1_t,Dom2_t,strided>::touches(
      DomainTraits<T1>::getDomain(a,Dim-1),
      DomainTraits<T2>::getDomain(b,Dim-1)) &&
      TouchesDomain<T1,T2,Dim-1>::touches(a,b);
  }
};
template<class T1, class T2>
struct TouchesDomain<T1,T2,1> {
  enum { strided =
    !DomainTraits<T1>::unitStride && !DomainTraits<T2>::unitStride };
  static bool touches(const T1 &a, const T2 &b) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    return TouchesDomainSingle<Dom1_t,Dom2_t,strided>::touches(
      DomainTraits<T1>::getDomain(a,0), DomainTraits<T2>::getDomain(b,0));
  }
};
template<class T1, class T2, int Dim1, int Dim2>
inline bool touches2(const T1 &, const T2 &, const WrappedInt<Dim1> &,
  const WrappedInt<Dim2> &)
{
  return false;
}
template<class T1, class T2, int Dim>
inline bool touches2(const T1 &a, const T2 &b, const WrappedInt<Dim> &,
  const WrappedInt<Dim> &)
{
  return TouchesDomain<T1,T2,Dim>::touches(a, b);
}
template<class T1, class T2>
inline bool touches(const T1 &a, const T2 &b)
{
  if (a.empty() || b.empty())
    return false;
  else
    return touches2(a, b, WrappedInt<DomainTraits<T1>::dimensions>(),
      WrappedInt<DomainTraits<T2>::dimensions>());
}
# 1 "/usr/include/c++/6/list" 1 3
# 58 "/usr/include/c++/6/list" 3
       
# 59 "/usr/include/c++/6/list" 3




# 1 "/usr/include/c++/6/bits/stl_list.h" 1 3
# 63 "/usr/include/c++/6/bits/stl_list.h" 3
# 1 "/usr/include/c++/6/bits/allocated_ptr.h" 1 3
# 40 "/usr/include/c++/6/bits/allocated_ptr.h" 3

# 40 "/usr/include/c++/6/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return _S_raw_ptr(_M_ptr); }

    private:
      value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }

      template<typename _Ptr>
 auto _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
 { return _S_raw_ptr(__ptr.operator->()); }

      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 64 "/usr/include/c++/6/bits/stl_list.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
 
# 80 "/usr/include/c++/6/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };

 
  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      __gnu_cxx::__aligned_membuf<_Tp> _M_storage;
      _Tp* _M_valptr() { return _M_storage._M_ptr(); }
      _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }





    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() noexcept
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) noexcept
      : _M_node(__x) { }

      _Self
      _M_const_cast() const noexcept
      { return *this; }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() noexcept
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      noexcept
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) noexcept
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

namespace __cxx11 {

  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tp_alloc_traits;
      typedef typename _Tp_alloc_traits::template
 rebind<_List_node<_Tp> >::other _Node_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;

      static size_t
      _S_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last)
      {
 size_t __n = 0;
 while (__first != __last)
   {
     __first = __first->_M_next;
     ++__n;
   }
 return __n;
      }

      struct _List_impl
      : public _Node_alloc_type
      {

 _List_node<size_t> _M_node;




 _List_impl() noexcept
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a) noexcept
 : _Node_alloc_type(__a), _M_node()
 { }


 _List_impl(_Node_alloc_type&& __a) noexcept
 : _Node_alloc_type(std::move(__a)), _M_node()
 { }

      };

      _List_impl _M_impl;


      size_t _M_get_size() const { return *_M_impl._M_node._M_valptr(); }

      void _M_set_size(size_t __n) { *_M_impl._M_node._M_valptr() = __n; }

      void _M_inc_size(size_t __n) { *_M_impl._M_node._M_valptr() += __n; }

      void _M_dec_size(size_t __n) { *_M_impl._M_node._M_valptr() -= __n; }

      size_t
      _M_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last) const
      { return _S_distance(__first, __last); }


      size_t _M_node_count() const { return *_M_impl._M_node._M_valptr(); }
# 381 "/usr/include/c++/6/bits/stl_list.h" 3
      typename _Node_alloc_traits::pointer
      _M_get_node()
      { return _Node_alloc_traits::allocate(_M_impl, 1); }

      void
      _M_put_node(typename _Node_alloc_traits::pointer __p) noexcept
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return _M_impl; }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return _M_impl; }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a) noexcept
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      { _M_move_nodes(std::move(__x)); }

      _List_base(_List_base&& __x, _Node_alloc_type&& __a)
      : _M_impl(std::move(__a))
      {
 if (__x._M_get_Node_allocator() == _M_get_Node_allocator())
   _M_move_nodes(std::move(__x));
 else
   _M_init();
      }

      void
      _M_move_nodes(_List_base&& __x)
      {
 auto* const __xnode = std::__addressof(__x._M_impl._M_node);
 if (__xnode->_M_next == __xnode)
   _M_init();
 else
   {
     auto* const __node = std::__addressof(_M_impl._M_node);
     __node->_M_next = __xnode->_M_next;
     __node->_M_prev = __xnode->_M_prev;
     __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;
     _M_set_size(__x._M_get_size());
     __x._M_init();
   }
      }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear() noexcept;

      void
      _M_init() noexcept
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
 _M_set_size(0);
      }
    };
# 502 "/usr/include/c++/6/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Tp_alloc_traits _Tp_alloc_traits;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;
      typedef typename _Base::_Node_alloc_traits _Node_alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_traits::pointer pointer;
      typedef typename _Tp_alloc_traits::const_pointer const_pointer;
      typedef typename _Tp_alloc_traits::reference reference;
      typedef typename _Tp_alloc_traits::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Node_allocator;
# 564 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   auto __p = this->_M_get_node();
   auto& __alloc = _M_get_Node_allocator();
   __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
   _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
     std::forward<_Args>(__args)...);
   __guard = nullptr;
   return __p;
 }


    public:






      list()

      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)

      : _Base() { }





      explicit
      list(const allocator_type& __a) noexcept
      : _Base(_Node_alloc_type(__a)) { }
# 608 "/usr/include/c++/6/bits/stl_list.h" 3
      explicit
      list(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_default_initialize(__n); }
# 621 "/usr/include/c++/6/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 648 "/usr/include/c++/6/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(_Node_alloc_traits::
       _S_select_on_copy(__x._M_get_Node_allocator()))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 661 "/usr/include/c++/6/bits/stl_list.h" 3
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }
# 672 "/usr/include/c++/6/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }

      list(const list& __x, const allocator_type& __a)
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }

      list(list&& __x, const allocator_type& __a)
      noexcept(_Node_alloc_traits::_S_always_equal())
      : _Base(std::move(__x), _Node_alloc_type(__a))
      {


 insert(begin(), std::__make_move_if_noexcept_iterator(__x.begin()),
   std::__make_move_if_noexcept_iterator(__x.end()));
      }
# 703 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 736 "/usr/include/c++/6/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 747 "/usr/include/c++/6/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      noexcept(_Node_alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
          _Node_alloc_traits::_S_propagate_on_move_assign()
          || _Node_alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 765 "/usr/include/c++/6/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 783 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 800 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 824 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_Base::_M_get_Node_allocator()); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return this->_M_node_count(); }


      size_type
      max_size() const noexcept
      { return _Node_alloc_traits::max_size(_M_get_Node_allocator()); }
# 973 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      resize(size_type __new_size);
# 986 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 1008 "/usr/include/c++/6/bits/stl_list.h" 3
      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1055 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
# 1082 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      pop_front() noexcept
      { this->_M_erase(begin()); }
# 1096 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
# 1122 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      pop_back() noexcept
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1139 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 1154 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1184 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1203 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1223 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
# 1262 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last);
# 1306 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator

      erase(const_iterator __position) noexcept;
# 1331 "/usr/include/c++/6/bits/stl_list.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last) noexcept



      {
 while (__first != __last)
   __first = erase(__first);
 return __last._M_const_cast();
      }
# 1352 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      swap(list& __x) noexcept
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
            __x._M_impl._M_node);

 size_t __xsize = __x._M_get_size();
 __x._M_set_size(this->_M_get_size());
 this->_M_set_size(__xsize);

 _Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),
                                       __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1391 "/usr/include/c++/6/bits/stl_list.h" 3
      void

      splice(const_iterator __position, list&& __x) noexcept



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __x.begin(), __x.end());

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }


      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
# 1427 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
# 1442 "/usr/include/c++/6/bits/stl_list.h" 3
      {
 iterator __j = __i._M_const_cast();
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != std::__addressof(__x))
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position._M_const_cast(),
     __i._M_const_cast(), __j);

 this->_M_inc_size(1);
 __x._M_dec_size(1);
      }
# 1469 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
# 1488 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
      const_iterator __last) noexcept
# 1508 "/usr/include/c++/6/bits/stl_list.h" 3
      {
 if (__first != __last)
   {
     if (this != std::__addressof(__x))
       _M_check_equal_allocators(__x);

     size_t __n = this->_M_distance(__first._M_node, __last._M_node);
     this->_M_inc_size(__n);
     __x._M_dec_size(__n);

     this->_M_transfer(__position._M_const_cast(),
         __first._M_const_cast(),
         __last._M_const_cast());
   }
      }
# 1538 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
      const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
# 1555 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1569 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1583 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      unique();
# 1598 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1612 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
# 1637 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
# 1656 "/usr/include/c++/6/bits/stl_list.h" 3
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
# 1734 "/usr/include/c++/6/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
# 1766 "/usr/include/c++/6/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
  this->_M_inc_size(1);
       }



      void
      _M_erase(iterator __position) noexcept
      {
 this->_M_dec_size(1);
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);

 _Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());




        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x) noexcept
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __builtin_abort();
      }


      const_iterator
      _M_resize_pos(size_type& __new_size) const;


      void
      _M_move_assign(list&& __x, true_type) noexcept
      {
 this->_M_clear();
 if (__x.empty())
   this->_M_init();
 else
   {
     this->_M_impl._M_node._M_next = __x._M_impl._M_node._M_next;
     this->_M_impl._M_node._M_next->_M_prev = &this->_M_impl._M_node;
     this->_M_impl._M_node._M_prev = __x._M_impl._M_node._M_prev;
     this->_M_impl._M_node._M_prev->_M_next = &this->_M_impl._M_node;
     this->_M_set_size(__x._M_get_size());
     __x._M_init();
   }
        std::__alloc_on_move(this->_M_get_Node_allocator(),
                             __x._M_get_Node_allocator());
      }

      void
      _M_move_assign(list&& __x, false_type)
      {
 if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())
          _M_move_assign(std::move(__x), true_type{});
        else


   _M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()),
        std::__make_move_if_noexcept_iterator(__x.end()),
        __false_type{});
      }

    };
}
# 1851 "/usr/include/c++/6/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {

      if (__x.size() != __y.size())
 return false;


      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1885 "/usr/include/c++/6/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }







  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_iterator<_Tp> __first,
        std::_List_iterator<_Tp> __last,
        input_iterator_tag __tag)
    {
      typedef std::_List_const_iterator<_Tp> _CIter;
      return std::__distance(_CIter(__first), _CIter(__last), __tag);
    }

  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_const_iterator<_Tp> __first,
        std::_List_const_iterator<_Tp> __last,
        input_iterator_tag)
    {
      typedef std::_List_node<size_t> _Sentinel;
      std::_List_const_iterator<_Tp> __beyond = __last;
      ++__beyond;
      bool __whole = __first == __beyond;
      if (__builtin_constant_p (__whole) && __whole)
 return *static_cast<const _Sentinel*>(__last._M_node)->_M_valptr();

      ptrdiff_t __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }



}
# 64 "/usr/include/c++/6/list" 2 3
# 1 "/usr/include/c++/6/bits/list.tcc" 1 3
# 59 "/usr/include/c++/6/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() noexcept
    {
      typedef _List_node<_Tp> _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = static_cast<_Node*>(__cur);
   __cur = __tmp->_M_next;
   _Tp* __val = __tmp->_M_valptr();

   _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_const_cast()._M_node);
 this->_M_inc_size(1);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      this->_M_inc_size(1);
      return iterator(__tmp);
    }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
 {
   list __tmp(__n, __x, get_allocator());
   iterator __it = __tmp.begin();
   splice(__position, __tmp);
   return __it;
 }
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)
      {
 list __tmp(__first, __last, get_allocator());
 if (!__tmp.empty())
   {
     iterator __it = __tmp.begin();
     splice(__position, __tmp);
     return __it;
   }
 return __position._M_const_cast();
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    erase(const_iterator __position) noexcept



    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }
# 172 "/usr/include/c++/6/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::const_iterator
    list<_Tp, _Alloc>::
    _M_resize_pos(size_type& __new_size) const
    {
      const_iterator __i;

      const size_type __len = size();
      if (__new_size < __len)
 {
   if (__new_size <= __len / 2)
     {
       __i = begin();
       std::advance(__i, __new_size);
     }
   else
     {
       __i = end();
       ptrdiff_t __num_erase = __len - __new_size;
       std::advance(__i, -__num_erase);
     }
   __new_size = 0;
   return __i;
 }
      else
 __i = end();





      __new_size -= __len;
      return __i;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
 _M_default_append(__new_size);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
        insert(end(), __new_size, __x);
      else
        erase(__i, end());
    }
# 264 "/usr/include/c++/6/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != std::__addressof(__x))
 {

   if (_Node_alloc_traits::_S_propagate_on_copy_assign())
     {
              auto& __this_alloc = this->_M_get_Node_allocator();
              auto& __that_alloc = __x._M_get_Node_allocator();
              if (!_Node_alloc_traits::_S_always_equal()
           && __this_alloc != __that_alloc)
         {

    clear();
  }
       std::__alloc_on_copy(__this_alloc, __that_alloc);
            }

   _M_assign_dispatch(__x.begin(), __x.end(), __false_type());
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != std::__addressof(__x))
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);

   this->_M_inc_size(__x._M_get_size());
   __x._M_set_size(0);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != std::__addressof(__x))
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = __tmp;
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = __tmp;
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = __tmp + 1; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = __tmp;
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = __tmp;
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = __tmp + 1; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
# 65 "/usr/include/c++/6/list" 2 3
# 8891 "tramp3d-v4.cpp" 2

# 8891 "tramp3d-v4.cpp"
template<class Dom, class T>
class DomainMapNode : public Pooled<DomainMapNode<Dom,T> >
{
public:
  typedef Dom Domain_t;
  typedef T Data_t;
  typedef std::pair<Domain_t,Data_t> Value_t;
  typedef std::list<Value_t> List_t;
  typedef DomainMapNode<Dom,T> Node_t;
  typedef typename List_t::iterator iterator;
  DomainMapNode(const Domain_t &d, Node_t *p = 0)
    : domain_m(d), left_m(0), right_m(0), parent_m(p) {
  }
  ~DomainMapNode() {
    if (left_m != 0)
      delete left_m;
    if (right_m != 0)
      delete right_m;
  }
  const Domain_t &domain() const { return domain_m; }
  iterator begin() { return list_m.begin(); }
  iterator end() { return list_m.end(); }
  void insert(const Value_t &v) {
    ;
    if (left_m == 0)
      {
 Domain_t leftdom, rightdom;
 split(domain_m, leftdom, rightdom);
 left_m = new Node_t(leftdom, this);
 right_m = new Node_t(rightdom, this);
      }
    if (contains(v.first, domain_m))
      {
 list_m.push_back(v);
      }
    else if (contains(left_m->domain_m, v.first))
      {
 left_m->insert(v);
      }
    else if (contains(right_m->domain_m, v.first))
      {
 right_m->insert(v);
      }
    else
      {
 list_m.push_back(v);
      }
  }
  Node_t *nextRightNode() {
    Node_t *y, *p = this;
    if (p->right_m != 0) {
      p = p->right_m;
      while (p->left_m != 0)
        p = p->left_m;
    } else {
      for (y=p->parent_m; y != 0 && p == y->right_m; y=y->parent_m)
        p = y;
      p = y;
    }
    return p;
  }
  Node_t *nextRightTouchNode(const Domain_t &d) {
    Node_t *p = this;
    Node_t *y = right_m;
    if (y != 0 && touches(d, y->domain_m)) {
      p = y;
      for (y=y->left_m; y != 0 && touches(d, y->domain_m); y=y->left_m)
        p = y;
    } else {
      for (y=p->parent_m; y != 0 && p == y->right_m; y=y->parent_m)
        p = y;
      p = y;
    }
    return p;
  }
  Node_t *findLeftNode() {
    Node_t *p = this;
    while (p->left_m != 0)
      p = p->left_m;
    while (p != 0 && p->begin() == p->end())
      p = p->nextRightNode();
    return p;
  }
  Node_t *findLeftTouchNode(const Domain_t &d) {
    Node_t *y, *p = this;
    for (y=p->left_m; y != 0 && touches(d, y->domain_m); y=y->left_m)
      p = y;
    return p;
  }
private:
  Domain_t domain_m;
  Node_t *left_m, *right_m, *parent_m;
  List_t list_m;
};
template<class Dom, class T>
class DomainMapIterator
{
public:
  typedef Dom Domain_t;
  typedef DomainMapNode<Dom,T> Node_t;
  typedef typename Node_t::Data_t Value_t;
  typedef typename Node_t::iterator NodeIter_t;
  DomainMapIterator() : node_m(0) { }
  DomainMapIterator(Node_t *n, NodeIter_t i) : node_m(n), iter_m(i) { }
  ~DomainMapIterator() { }
  Node_t *getNode() const { return node_m; }
  NodeIter_t getIter() const { return iter_m; }
  bool operator==(const DomainMapIterator<Dom,T> &dmi) {
    return (node_m == dmi.node_m && (node_m == 0 || iter_m == dmi.iter_m));
  }
  bool operator!=(const DomainMapIterator<Dom,T> &dmi) {
    return !(*this == dmi);
  }
  Value_t &operator*() {
    ;
    return (*iter_m).second;
  }
  Domain_t &domain() {
    ;
    return (*iter_m).first;
  }
  DomainMapIterator<Dom,T> &operator++() {
    ;
    if ((++iter_m) == node_m->end()) {
      do {
        node_m = node_m->nextRightNode();
      } while (node_m != 0 && (iter_m=node_m->begin()) == node_m->end());
    }
    return *this;
  }
private:
  Node_t *node_m;
  NodeIter_t iter_m;
};
template<class Dom, class T>
class DomainMapConstIterator
{
public:
  typedef Dom Domain_t;
  typedef DomainMapNode<Dom,T> Node_t;
  typedef typename Node_t::Data_t Value_t;
  typedef typename Node_t::iterator NodeIter_t;
  DomainMapConstIterator() : node_m(0) { }
  DomainMapConstIterator(Node_t *n, NodeIter_t i)
    : node_m(n), iter_m(i) { }
  DomainMapConstIterator(const DomainMapIterator<Dom,T> &dmi)
    : node_m(dmi.getNode()), iter_m(dmi.getIter()) { }
  ~DomainMapConstIterator() { }
  bool operator==(const DomainMapConstIterator<Dom,T> &dmi) {
    return (node_m == dmi.node_m && (node_m == 0 || iter_m == dmi.iter_m));
  }
  bool operator!=(const DomainMapConstIterator<Dom,T> &dmi) {
    return !(*this == dmi);
  }
  Value_t operator*() {
    ;
    return (*iter_m).second;
  }
  Domain_t domain() {
    ;
    return (*iter_m).first;
  }
  DomainMapConstIterator<Dom,T> &operator++() {
    ;
    if ((++iter_m) == node_m->end()) {
      do {
        node_m = node_m->nextRightNode();
      } while (node_m != 0 && (iter_m=node_m->begin()) == node_m->end());
    }
    return *this;
  }
private:
  Node_t *node_m;
  NodeIter_t iter_m;
};
template<class Dom, class T>
class DomainMapTouchIterator
{
public:
  typedef Dom Domain_t;
  typedef DomainMapNode<Dom,T> Node_t;
  typedef typename Node_t::Data_t Value_t;
  typedef typename Node_t::iterator NodeIter_t;
  DomainMapTouchIterator() : node_m(0) { }
  DomainMapTouchIterator(Node_t *n, NodeIter_t i, const Domain_t &d)
    : node_m(n), iter_m(i), domain_m(d) { }
  ~DomainMapTouchIterator() { }
  bool operator==(const DomainMapTouchIterator<Dom,T> &dmi) {
    return (node_m == dmi.node_m && (node_m == 0 || iter_m == dmi.iter_m));
  }
  bool operator!=(const DomainMapTouchIterator<Dom,T> &dmi) {
    return !(*this == dmi);
  }
  Value_t &operator*() {
    ;
    return (*iter_m).second;
  }
  Domain_t &domain() {
    ;
    return (*iter_m).first;
  }
  DomainMapTouchIterator<Dom,T> &operator++() {
    ;
    while ((++iter_m) != node_m->end()) {
      if (touches(domain_m, (*iter_m).first))
        return *this;
    }
    do {
      if ((node_m = node_m->nextRightTouchNode(domain_m)) != 0)
        for (iter_m = node_m->begin(); iter_m != node_m->end(); ++iter_m)
          if (touches(domain_m, (*iter_m).first))
            return *this;
    } while (node_m != 0);
    return *this;
  }
private:
  Node_t *node_m;
  NodeIter_t iter_m;
  Domain_t domain_m;
};
template<class Dom, class T>
class DomainMap
{
public:
  typedef Dom Domain_t;
  typedef Dom key_type;
  typedef T Data_t;
  typedef T mapped_type;
  typedef std::pair<Domain_t,Data_t> Value_t;
  typedef std::pair<Domain_t,Data_t> value_type;
  typedef DomainMapIterator<Domain_t,Data_t> iterator;
  typedef DomainMapConstIterator<Domain_t,Data_t> const_iterator;
  typedef DomainMapTouchIterator<Domain_t,Data_t> touch_iterator;
  typedef std::pair<touch_iterator,touch_iterator> Touch_t;
  typedef std::pair<touch_iterator,touch_iterator> touch_type;
  typedef long Size_t;
  typedef long size_type;
  DomainMap() : size_m(0), root_m(0) { }
  DomainMap(const Domain_t &d) : size_m(0), root_m(0) {
    initialize(d);
  }
  void initialize(const Domain_t &d) {
    ;
    root_m = new Node_t(d);
  }
  ~DomainMap() {
    if (root_m != 0)
      delete root_m;
  }
  iterator begin() { return left_m; }
  iterator end() { return iterator(); }
  const_iterator begin() const { return const_iterator(left_m); }
  const_iterator end() const { return const_iterator(); }
  Size_t size() const { return size_m; }
  Touch_t touch(const Domain_t &d) const {
    Node_t *p = root_m;
    if (p != 0)
    {
      p = p->findLeftTouchNode(d);
      do
      {
 for (NodeIter_t a = p->begin(); a != p->end(); ++a)
   if (touches(d, (*a).first))
     return Touch_t(touch_iterator(p, a, d), touch_iterator());
 p = p->nextRightTouchNode(d);
      } while (p != 0);
    }
    return Touch_t(touch_iterator(), touch_iterator());
  }
  void insert(const Value_t &v) {
    ;
    root_m->insert(v);
    size_m++;
  }
  void update() {
    Node_t *leftnode;
    if (root_m != 0 && size_m > 0 && (leftnode=root_m->findLeftNode()) != 0)
      left_m = iterator(leftnode, leftnode->begin());
    else
      left_m = iterator();
  }
  void clear() {
    if (root_m != 0) {
      Node_t *newroot = new Node_t(root_m->domain());
      delete root_m;
      root_m = newroot;
      size_m = 0;
      update();
    }
  }
  void zap() {
    if (root_m != 0)
      delete root_m;
    size_m = 0;
    root_m = 0;
  }
  template<class Out>
  void print(Out &o) const;
  void print() const;
private:
  typedef DomainMapNode<Domain_t,Data_t> Node_t;
  typedef typename Node_t::iterator NodeIter_t;
  Size_t size_m;
  Node_t *root_m;
  iterator left_m;
  DomainMap(const DomainMap<Domain_t,Data_t> &);
  DomainMap<Domain_t,Data_t> &operator=(const DomainMap<Domain_t,Data_t> &);
};
template<class Dom, class T>
template<class Out>
void DomainMap<Dom, T>::print(Out &o) const
{
  if (size() < 1 || root_m == 0)
    {
      o << "DomainMap: empty.";
    }
  else
    {
      o << "DomainMap: Total domain = " << root_m->domain();
      o << ", touching domains:\n";
      Touch_t touchiters = touch(root_m->domain());
      while (touchiters.first != touchiters.second)
 {
   o << "  " << touchiters.first.domain() << " ==> ";
   o << *(touchiters.first) << "\n";
   ++(touchiters.first);
 }
    }
}
template<class Dom, class T>
void DomainMap<Dom, T>::print() const
{
  if (size() < 1 || root_m == 0)
    {
      std::cout << "DomainMap: empty.";
    }
  else
    {
      std::cout << "DomainMap: Total domain = " << root_m->domain();
      std::cout << ", touching domains:\n";
      Touch_t touchiters = touch(root_m->domain());
      while (touchiters.first != touchiters.second)
 {
   std::cout << "  " << touchiters.first.domain() << " ==> ";
   std::cout << *(touchiters.first) << "\n";
   ++(touchiters.first);
 }
    }
}
template <class Dom, class T>
std::ostream &operator<<(std::ostream &o, const DomainMap<Dom, T> &dmap)
{
  dmap.print(o);
  return o;
}
template <class T>
class ConstDerefIterator;
template <class T>
class DerefIterator
{
public:
  typedef T Value_t;
  typedef std::vector<T*> List_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef std::random_access_iterator_tag iterator_category;
  typedef Value_t value_type;
  typedef ptrdiff_t difference_type;
  typedef Value_t* pointer;
  typedef Value_t& reference;
  friend class ConstDerefIterator<T>;
  friend iterator operator+ (const difference_type n, const iterator &iter)
  {
    return iterator(iter.p_m + n);
  }
protected:
  typename List_t::iterator p_m;
public:
  inline DerefIterator() { }
  inline DerefIterator(typename List_t::iterator x) : p_m(x) { }
  inline reference operator*() const {
    return **p_m;
  }
  inline pointer operator->() const {
    return *p_m;
  }
  inline iterator &operator++() {
    ++p_m;
    return *this;
  }
  inline iterator operator++(int) {
    iterator tmp = *this;
    ++p_m;
    return tmp;
  }
  inline iterator &operator--() {
    --p_m;
    return *this;
  }
  inline iterator operator--(int) {
    iterator tmp = *this;
    --p_m;
    return tmp;
  }
  inline iterator &operator+=(const difference_type i) {
    p_m += i;
    return *this;
  }
  inline iterator &operator-=(const difference_type i) {
    p_m -= i;
    return *this;
  }
  inline iterator operator+(const difference_type i) const {
    return iterator(p_m + i);
  }
  inline iterator operator-(const difference_type i) const {
    return iterator(p_m - i);
  }
  inline difference_type operator-(const iterator &x) const {
    return p_m - x.p_m;
  }
  inline difference_type operator-(const const_iterator &x) const {
    return p_m - x.p_m;
  }
  inline reference operator[](const difference_type i) const {
    return **(p_m + i);
  }
  inline bool operator==(const iterator &x) const {
    return p_m == x.p_m;
  }
  inline bool operator==(const const_iterator &x) const {
    return p_m == x.p_m;
  }
  inline bool operator<(const iterator &x) const {
    return p_m < x.p_m;
  }
  inline bool operator<(const const_iterator &x) const {
    return p_m < x.p_m;
  }
  inline bool operator!= (const iterator &y) const
  { return ! (*this == y); }
  inline bool operator> (const iterator &y) const
  { return (y < *this); }
  inline bool operator<= (const iterator &y) const
  { return ! (y < *this); }
  inline bool operator>= (const iterator &y) const
  { return ! (*this < y); }
  inline bool operator!= (const const_iterator &y) const
  { return ! (*this == y); }
  inline bool operator> (const const_iterator &y) const
  { return (y < *this); }
  inline bool operator<= (const const_iterator &y) const
  { return ! (y < *this); }
  inline bool operator>= (const const_iterator &y) const
  { return ! (*this < y); }
};
template <class T>
class ConstDerefIterator
{
public:
  typedef T Value_t;
  typedef std::vector<T*> List_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef std::random_access_iterator_tag iterator_category;
  typedef Value_t value_type;
  typedef ptrdiff_t difference_type;
  typedef const Value_t* pointer;
  typedef const Value_t& reference;
  friend class DerefIterator<T>;
  friend const_iterator operator+ (const difference_type n,
    const const_iterator &iter)
  {
    return const_iterator(iter.p_m + n);
  }
protected:
  typename List_t::const_iterator p_m;
public:
  inline ConstDerefIterator() { }
  inline ConstDerefIterator(const typename List_t::const_iterator &x) : p_m(x) { }
  inline ConstDerefIterator(const typename List_t::iterator &x) : p_m(x) { }
  inline ConstDerefIterator(const iterator &x) : p_m(x.p_m) { }
  inline ConstDerefIterator(const const_iterator &x) : p_m(x.p_m) { }
  inline reference operator*() const {
    return **p_m;
  }
  inline pointer operator->() const {
    return *p_m;
  }
  inline const_iterator &operator++() {
    ++p_m;
    return *this;
  }
  inline const_iterator operator++(int) {
    const_iterator tmp = *this;
    ++p_m;
    return tmp;
  }
  inline const_iterator &operator--() {
    --p_m;
    return *this;
  }
  inline const_iterator operator--(int) {
    const_iterator tmp = *this;
    --p_m;
    return tmp;
  }
  inline const_iterator &operator+=(const difference_type i) {
    p_m += i;
    return *this;
  }
  inline const_iterator &operator-=(const difference_type i) {
    p_m -= i;
    return *this;
  }
  inline const_iterator operator+(const difference_type i) const {
    return const_iterator(p_m + i);
  }
  inline const_iterator operator-(const difference_type i) const {
    return const_iterator(p_m - i);
  }
  inline difference_type operator-(const const_iterator &x) const {
    return p_m - x.p_m;
  }
  inline difference_type operator-(const iterator &x)
    const {
    return p_m - x.p_m;
  }
  inline reference operator[](const difference_type i) const {
    return **(p_m + i);
  }
  inline bool operator==(const const_iterator &x) const {
    return p_m == x.p_m;
  }
  inline bool operator==(const iterator &x) const {
    return p_m == x.p_m;
  }
  inline bool operator<(const const_iterator &x) const {
    return p_m < x.p_m;
  }
  inline bool operator<(const iterator &x) const {
    return p_m < x.p_m;
  }
  inline bool operator!= (const const_iterator &y) const
  { return ! (*this == y); }
  inline bool operator> (const const_iterator &y) const
  { return (y < *this); }
  inline bool operator<= (const const_iterator &y) const
  { return ! (y < *this); }
  inline bool operator>= (const const_iterator &y) const
  { return ! (*this < y); }
  inline bool operator!= (const iterator &y) const
  { return ! (*this == y); }
  inline bool operator> (const iterator &y) const
  { return (y < *this); }
  inline bool operator<= (const iterator &y) const
  { return ! (y < *this); }
  inline bool operator>= (const iterator &y) const
  { return ! (*this < y); }
};
template<int Dim, int Dim2>
class ViewIndexer
{
public:
  typedef ViewIndexer<Dim, Dim2> This_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim2> BaseDomain_t;
  typedef Loc<Dim2> Mask_t;
  ViewIndexer() { }
  template<class DT>
  ViewIndexer(const SliceDomain<DT> &dom)
  : domain_m(Pooma::NoInit()), baseDomain_m(dom.totalDomain())
  {
    PoomaCTAssert<(Dim == DT::sliceDimensions)>::test();
    PoomaCTAssert<(Dim2 == DT::dimensions)>::test();
    int dt, d;
    const typename DT::TotalDomain_t &domain = dom.totalDomain();
    for (d = 0, dt = 0; dt < Dim2; ++dt)
      {
        if (!dom.ignorable(dt))
          {
            ;
            offset_m[d] = domain[dt].first();
            stride_m[d] = domain[dt].stride();
            domain_m[d] = Interval<1>(domain[dt].length());
            ind_m[d] = dt;
            ++d;
          }
        else
          {
            ;
            mask_m[dt] = domain[dt].first();
          }
      }
  }
  template<class DT>
  ViewIndexer(const ViewIndexer<Dim, Dim2> &orig,
    const Domain<Dim, DT> &dom)
  : domain_m(Pooma::NoInit()),
    baseDomain_m(Pooma::NoInit()),
    mask_m(orig.mask())
  {
    baseDomain_m = orig.baseDomain();
    const typename DT::Domain_t &domain = dom.unwrap();
    for (int d = 0; d < Dim; ++d)
      {
        offset_m[d] = orig.offset(d) + orig.stride(d) *
          domain[d].first();
        stride_m[d] = orig.stride(d) * domain[d].stride();
        domain_m[d] = Interval<1>(domain[d].length());
        ind_m[d] = orig.indirection(d);
      }
    localToBase(domain_m, baseDomain_m);
  }
  template<int OrigDim, class DT>
  ViewIndexer(const ViewIndexer<OrigDim, Dim2> &orig,
    const SliceDomain<DT> &dom)
  : domain_m(Pooma::NoInit()),
    baseDomain_m(orig.baseDomain()), mask_m(orig.mask())
  {
    PoomaCTAssert<(DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<(DT::dimensions == OrigDim)>::test();
    int dt, d;
    const typename DT::TotalDomain_t &domain = dom.totalDomain();
    for (d = 0, dt = 0; dt < OrigDim; ++dt)
      {
        if (!dom.ignorable(dt))
          {
            ;
            offset_m[d] = orig.offset(dt) + orig.stride(dt) *
              domain[dt].first();
            stride_m[d] = orig.stride(dt) * domain[dt].stride();
            domain_m[d] = Interval<1>(domain[dt].length());
            ind_m[d] = orig.indirection(dt);
            baseDomain_m[ind_m[d]] = Range<1>(
              offset_m[d],
              offset_m[d] + stride_m[d] * domain_m[d].last(),
              stride_m[d]);
            ++d;
          }
        else
          {
            ;
            int m = orig.offset(dt) + orig.stride(dt) *
              domain[dt].first();
            mask_m[orig.indirection(dt)] = m;
            baseDomain_m[orig.indirection(dt)] =
              Range<1>(m, m, 1);
          }
      }
  }
  ViewIndexer(const This_t &model)
  : domain_m(model.domain()), baseDomain_m(model.baseDomain()),
    mask_m(model.mask())
  {
    for (int d = 0; d < Dim; d++)
      {
        ind_m[d] = model.indirection(d);
        offset_m[d] = model.offset(d);
        stride_m[d] = model.stride(d);
      }
  }
  This_t &operator=(const This_t &rhs)
  {
    domain_m = rhs.domain();
    baseDomain_m = rhs.baseDomain();
    mask_m = rhs.mask();
    for (int d = 0; d < Dim; d++)
      {
        ind_m[d] = rhs.indirection(d);
        offset_m[d] = rhs.offset(d);
        stride_m[d] = rhs.stride(d);
      }
    return *this;
  }
  const Domain_t &domain() const { return domain_m; }
  const Domain_t &innerDomain() const { return domain_m; }
  const BaseDomain_t &baseDomain() const { return baseDomain_m; }
  int indirection(int i) const { return ind_m[i]; }
  const Mask_t &mask() const { return mask_m; }
  int offset(int i) const { return offset_m[i]; }
  int stride(int i) const { return stride_m[i]; }
  void translate(const Loc<Dim> &loc, Loc<Dim2> &oloc) const
  {
    oloc = mask_m;
    for (int d = 0; d < Dim; d++)
      oloc[ind_m[d]] = Loc<1>(offset_m[d] + stride_m[d] * loc[d].first());
  }
  void translate(int i0, Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
  }
  void translate(int i0, int i1, Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
  }
  void translate(int i0, int i1, int i2,
    Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
    loc[ind_m[2]] = offset_m[2] + stride_m[2] * i2;
  }
  void translate(int i0, int i1, int i2, int i3,
    Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
    loc[ind_m[2]] = offset_m[2] + stride_m[2] * i2;
    loc[ind_m[3]] = offset_m[3] + stride_m[3] * i3;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
    loc[ind_m[2]] = offset_m[2] + stride_m[2] * i2;
    loc[ind_m[3]] = offset_m[3] + stride_m[3] * i3;
    loc[ind_m[4]] = offset_m[4] + stride_m[4] * i4;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, int i5, Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
    loc[ind_m[2]] = offset_m[2] + stride_m[2] * i2;
    loc[ind_m[3]] = offset_m[3] + stride_m[3] * i3;
    loc[ind_m[4]] = offset_m[4] + stride_m[4] * i4;
    loc[ind_m[5]] = offset_m[5] + stride_m[5] * i5;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, int i5, int i6, Loc<Dim2> &loc) const
  {
    loc = mask_m;
    loc[ind_m[0]] = offset_m[0] + stride_m[0] * i0;
    loc[ind_m[1]] = offset_m[1] + stride_m[1] * i1;
    loc[ind_m[2]] = offset_m[2] + stride_m[2] * i2;
    loc[ind_m[3]] = offset_m[3] + stride_m[3] * i3;
    loc[ind_m[4]] = offset_m[4] + stride_m[4] * i4;
    loc[ind_m[5]] = offset_m[5] + stride_m[5] * i5;
    loc[ind_m[6]] = offset_m[6] + stride_m[6] * i6;
  }
  template<class DT>
  BaseDomain_t &localToBase(const Domain<Dim, DT> &dlocal,
    BaseDomain_t &base) const
  {
    base = baseDomain_m;
    const typename DT::Domain_t &local = dlocal.unwrap();
    for (int d = 0; d < Dim; d++)
      {
        base[ind_m[d]] = Range<1>(
          offset_m[d] + stride_m[d] * local[d].first(),
          offset_m[d] + stride_m[d] * local[d].last(),
          stride_m[d] * local[d].stride());
      }
    return base;
  }
  template<class DT>
  SliceRange<Dim2, Dim> &localToBase(const Domain<Dim, DT> &dlocal,
    SliceRange<Dim2, Dim> &base) const
  {
    base.totalDomain() = baseDomain_m;
    const typename DT::Domain_t &local = dlocal.unwrap();
    for (int d = 0; d < Dim; d++)
      {
        Range<1> r(
          offset_m[d] + stride_m[d] * local[d].first(),
          offset_m[d] + stride_m[d] * local[d].last(),
          stride_m[d] * local[d].stride());
        base.totalDomain()[ind_m[d]] = r;
        base.sliceDomain()[d] = r;
        base.cantIgnoreDomain(ind_m[d]);
      }
    return base;
  }
  Interval<Dim> &baseToLocal(const BaseDomain_t &base,
    Interval<Dim> &local) const
  {
    int j;
    for (int d = 0; d < Dim; d++)
      {
        j = ind_m[d];
        local[d] = Interval<1>(
          (base[j].first() - offset_m[d]) / stride_m[d],
          (base[j].last() - offset_m[d]) / stride_m[d]);
        ;
      }
    return local;
  }
  Range<Dim> &baseToLocal(const BaseDomain_t &base,
    Range<Dim> &local) const
  {
    int j;
    for (int d = 0; d < Dim; d++)
      {
        j = ind_m[d];
        local[d] = Range<1>(
          (base[j].first() - offset_m[d]) / stride_m[d],
          (base[j].last() - offset_m[d]) / stride_m[d],
          base[j].stride() / stride_m[d]);
      }
    return local;
  }
  Interval<Dim> &baseToLocalInterval(const Interval<Dim2> &base,
          Interval<Dim> &local) const
  {
    int j;
    for (int d = 0; d < Dim; d++)
    {
      j = ind_m[d];
      local[d] = Interval<1>((base[j].first() - offset_m[d]) / stride_m[d],
        (base[j].last() - offset_m[d]) / stride_m[d]);
      ;
      ;
    }
    return local;
  }
private:
  Domain_t domain_m;
  BaseDomain_t baseDomain_m;
  int stride_m[Dim], offset_m[Dim];
  int ind_m[Dim];
  Mask_t mask_m;
};
template<int Dim>
class ViewIndexer<Dim, Dim>
{
public:
  typedef ViewIndexer<Dim, Dim> This_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim> BaseDomain_t;
  typedef Loc<Dim> Mask_t;
  ViewIndexer() { }
  template<class DT>
  ViewIndexer(const Domain<Dim, DT> &dom)
  : domain_m(Pooma::NoInit()), baseDomain_m(dom.unwrap())
  {
    const typename DT::Domain_t &domain = dom.unwrap();
    for (int d = 0; d < Dim; ++d)
      {
        offset_m[d] = domain[d].first();
        stride_m[d] = domain[d].stride();
        domain_m[d] = Interval<1>(domain[d].length());
      }
  }
  template<class DT>
  ViewIndexer(const ViewIndexer<Dim, Dim> &orig,
    const Domain<Dim, DT> &dom)
  : domain_m(Pooma::NoInit()),
    baseDomain_m(dom.unwrap()),
    mask_m(orig.mask())
  {
    const typename DT::Domain_t &domain = dom.unwrap();
    for (int d = 0; d < Dim; ++d)
      {
        offset_m[d] = orig.offset(d) + orig.stride(d) *
          domain[d].first();
        stride_m[d] = orig.stride(d) * domain[d].stride();
        domain_m[d] = Interval<1>(domain[d].length());
      }
    localToBase(domain_m, baseDomain_m);
}
  ViewIndexer(const This_t &model)
  : domain_m(model.domain()), baseDomain_m(model.baseDomain()),
    mask_m(model.mask())
  {
    for (int d = 0; d < Dim; d++)
      {
        offset_m[d] = model.offset(d);
        stride_m[d] = model.stride(d);
      }
  }
  This_t &operator=(const This_t &rhs)
  {
    domain_m = rhs.domain();
    baseDomain_m = rhs.baseDomain();
    mask_m = rhs.mask();
    for (int d = 0; d < Dim; d++)
      {
        offset_m[d] = rhs.offset(d);
        stride_m[d] = rhs.stride(d);
      }
    return *this;
  }
  const Domain_t &domain() const { return domain_m; }
  const Domain_t &innerDomain() const { return domain_m; }
  const BaseDomain_t &baseDomain() const { return baseDomain_m; }
  int indirection(int i) const { return i; }
  const Mask_t &mask() const { return mask_m; }
  int offset(int i) const { return offset_m[i]; }
  int stride(int i) const { return stride_m[i]; }
  void translate(const Loc<Dim> &loc, Loc<Dim> &oloc) const
  {
    for (int d = 0; d < Dim; d++)
      oloc[d] = Loc<1>(offset_m[d] + stride_m[d] * loc[d].first());
  }
  void translate(int i0, Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
  }
  void translate(int i0, int i1, Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
  }
  void translate(int i0, int i1, int i2,
    Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
    loc[2] = offset_m[2] + stride_m[2] * i2;
  }
  void translate(int i0, int i1, int i2, int i3,
    Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
    loc[2] = offset_m[2] + stride_m[2] * i2;
    loc[3] = offset_m[3] + stride_m[3] * i3;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
    loc[2] = offset_m[2] + stride_m[2] * i2;
    loc[3] = offset_m[3] + stride_m[3] * i3;
    loc[4] = offset_m[4] + stride_m[4] * i4;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, int i5, Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
    loc[2] = offset_m[2] + stride_m[2] * i2;
    loc[3] = offset_m[3] + stride_m[3] * i3;
    loc[4] = offset_m[4] + stride_m[4] * i4;
    loc[5] = offset_m[5] + stride_m[5] * i5;
  }
  void translate(int i0, int i1, int i2, int i3,
    int i4, int i5, int i6, Loc<Dim> &loc) const
  {
    loc[0] = offset_m[0] + stride_m[0] * i0;
    loc[1] = offset_m[1] + stride_m[1] * i1;
    loc[2] = offset_m[2] + stride_m[2] * i2;
    loc[3] = offset_m[3] + stride_m[3] * i3;
    loc[4] = offset_m[4] + stride_m[4] * i4;
    loc[5] = offset_m[5] + stride_m[5] * i5;
    loc[6] = offset_m[6] + stride_m[6] * i6;
  }
  template<class DT>
  BaseDomain_t &localToBase(const Domain<Dim, DT> &dlocal,
    BaseDomain_t &base) const
  {
    const typename DT::Domain_t &local = dlocal.unwrap();
    for (int d = 0; d < Dim; d++)
      {
        base[d] = Range<1>(
          offset_m[d] + stride_m[d] * local[d].first(),
          offset_m[d] + stride_m[d] * local[d].last(),
          stride_m[d] * local[d].stride());
      }
    return base;
  }
  template<class DT>
  SliceRange<Dim, Dim> &localToBase(const Domain<Dim, DT> &dlocal,
    SliceRange<Dim, Dim> &base) const
  {
    base.totalDomain() = baseDomain_m;
    const typename DT::Domain_t &local = dlocal.unwrap();
    for (int d = 0; d < Dim; d++)
      {
        Range<1> r(
          offset_m[d] + stride_m[d] * local[d].first(),
          offset_m[d] + stride_m[d] * local[d].last(),
          stride_m[d] * local[d].stride());
        base.totalDomain()[d] = r;
        base.sliceDomain()[d] = r;
        base.cantIgnoreDomain(d);
      }
    return base;
  }
  Interval<Dim> &baseToLocal(const BaseDomain_t &base,
    Interval<Dim> &local) const
  {
    for (int d = 0; d < Dim; d++)
      {
        local[d] = Interval<1>(
          (base[d].first() - offset_m[d]) / stride_m[d],
          (base[d].last() - offset_m[d]) / stride_m[d]);
        ;
      }
    return local;
  }
  Range<Dim> &baseToLocal(const BaseDomain_t &base,
    Range<Dim> &local) const
  {
    for (int d = 0; d < Dim; d++)
      {
        local[d] = Range<1>(
          (base[d].first() - offset_m[d]) / stride_m[d],
          (base[d].last() - offset_m[d]) / stride_m[d],
          base[d].stride() / stride_m[d]);
      }
    return local;
  }
  Interval<Dim> &baseToLocalInterval(const Interval<Dim> &base,
         Interval<Dim> &local) const
  {
    for (int d = 0; d < Dim; d++)
    {
      local[d] = Interval<1>((base[d].first() - offset_m[d]) / stride_m[d],
        (base[d].last() - offset_m[d]) / stride_m[d]);
      ;
      ;
    }
    return local;
  }
private:
  Domain_t domain_m;
  BaseDomain_t baseDomain_m;
  int stride_m[Dim], offset_m[Dim];
  Mask_t mask_m;
};
template<int Dim>
class ContiguousMapper
  : public ContextMapper<Dim>
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template<class Partitioner>
  ContiguousMapper(const Partitioner & gp,
     const Loc<Dim> &nblocks)
    : blocks_m(gp.blocks())
  {
  }
  template<class Partitioner>
  ContiguousMapper(const Partitioner & gp)
     : blocks_m(gp.blocks())
  {
  }
  ContiguousMapper(const Loc<Dim> & blocks)
     : blocks_m(blocks)
  {
  }
  void map(const List_t & templist) const;
  Loc<Dim> blocks_m;
};
template<int Dim>
void ContiguousMapper<Dim>::map(const List_t & templist) const
{
  int idx[Dim];
  for (int i = 0;i<Dim;++i)
    idx[i]=0;
  int strides[Dim];
  strides[Dim-1] = 1;
  for ( int i=Dim-2; i>=0; --i)
    strides[i] = strides[i+1]*blocks_m[i+1].last();
  int npatch = 1;
  for (int i=0; i<Dim; ++i)
    npatch *= blocks_m[i].first();
  int ncontexts = Pooma::contexts();
  int npc = npatch/ncontexts;
  int remainder = npatch - (npc*ncontexts);
  int pcontext = 0;
  int c = 0;
  int patchdone = 0;
  int patchleft = npatch;
  int incriment[Dim];
  for (int i =0 ; i<Dim; ++i) incriment[i] = 1;
  while ( true )
    {
      int allIdx = 0;
      for ( int i = 0 ; i < Dim ; ++i)
 allIdx += idx[i]*strides[i];
      (*templist[allIdx]).context() = pcontext;
      ++c;
      ++patchdone;
      --patchleft;
      if(c >= npc )
 {
   if (c == npc && remainder >0 &&
       ((idx[0]-1 >= 0 && idx[0]+1<=(blocks_m[0].first()-1)) ||
        (patchleft - ((npc+1)*(ncontexts-(pcontext+1))) >=0 )) )
     --remainder;
   else
     {
       c = 0;
       ++pcontext;
     }
 }
      bool t = true;
      for ( int i = 0 ; i < Dim ; ++i)
 {
   t = t && (
      idx[i] == (blocks_m[i]-1) && incriment[i] == 1
      ||
      idx[i] == 0 && incriment[i] == -1);
 }
      if (t)
 break;
      idx[0] += incriment[0];
      for ( int i = 0 ; i < Dim ; ++i)
 {
   if ( idx[i] > blocks_m[i].last()-1)
     {
       idx[i+1]+=incriment[i+1];
       idx[i]=blocks_m[i].last()-1;
       incriment[i] *= -1;
     }
   else if (idx[i]<0)
     {
       idx[i+1]+=incriment[i+1];
       idx[i]=0;
       incriment[i] *= -1;
     }
   else
     break;
 }
    }
  ContextMapper<Dim>::setAffinity(templist);
}
template <int Dim>
class BisectionMapper
  : public ContextMapper<Dim>
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template<class Partitioner>
  BisectionMapper(const Partitioner & gp,
     const Loc<Dim> &nblocks)
    : blocks_m(gp.blocks())
  {
  }
  template<class Partitioner>
  BisectionMapper(const Partitioner & gp)
     : blocks_m(gp.blocks())
  {
  }
  BisectionMapper(const Loc<Dim>& blocks)
     : blocks_m(blocks)
  {
  }
  void map(const List_t & templist) const;
  Loc<Dim> blocks_m;
};
template <int Dim>
void BisectionMapper<Dim>::map(const List_t & templist) const
{
  int ncontexts = Pooma::contexts();
  int npatch = 1;
  for (int i =0;i<Dim; ++i)
    npatch*=blocks_m[i].first();
  std::list<Domain_t> bvec;
  Domain_t allb;
  for (int i = 0; i<Dim; ++i)
    allb[i]=Interval<1>(0,blocks_m[i].first()-1);
  bvec.push_back(allb);
  while ( bvec.size() < ncontexts )
    {
      int s = 0;
      typename std::list<Domain_t>::iterator bstart = bvec.begin();
      typename std::list<Domain_t>::iterator bend = bvec.end();
      typename std::list<Domain_t>::iterator bpatch;
      for ( ; bstart != bend ; ++bstart)
 {
   if (s < (*bstart).size() )
     {
       bpatch = bstart;
       s = (*bstart).size();
     }
 }
      int d = 0;
      int sd = 0;
      for (int i = 0; i<Dim; ++i)
 {
   if ( sd < (*bpatch)[i].size() )
     {
       d = i;
       sd = (*bpatch)[i].size();
     }
 }
      Domain_t hi(*bpatch),lo(*bpatch);
      int lopoint = hi[d].first();
      int hipoint = hi[d].last();
      int mid = lopoint + ( (hipoint - lopoint)/2);
      if (lopoint<=mid)
 lo[d] = Interval<1>(lopoint,mid);
      else
 lo[d] = Interval<1>(lopoint,lopoint);
      if ( hipoint>=mid+1)
 hi[d] = Interval<1>(mid+1,hipoint);
      else
 hi[d] = Interval<1>(hipoint,hipoint);
      bvec.erase(bpatch++);
      bvec.insert(bpatch,lo);
      bvec.insert(bpatch,hi);
    }
  int strides[Dim];
  strides[0] = 1;
  for ( int i=1; i<Dim; ++i)
    strides[i] = strides[i-1]*blocks_m[i-1].first();
  typename std::list<Domain_t>::iterator start = bvec.begin();
  typename std::list<Domain_t>::iterator end = bvec.end();
  int pcontext = 0;
  for ( ; start != end ; ++start)
    {
      int idx[Dim],mi[Dim],mx[Dim];
      for ( int i = 0 ; i < Dim ; ++i)
 {
   idx[i] = mi[i] = (*start)[i].first();
   mx[i] = (*start)[i].last();
 }
      while ( idx[Dim-1] <= mx[Dim-1] )
 {
   int allIdx = 0;
   for ( int i = 0 ; i < Dim ; ++i)
     allIdx += idx[i]*strides[i];
   (*templist[allIdx]).context() = pcontext;
   ++idx[0];
   for ( int i = 0 ; i < Dim ; ++i)
     {
       if ( idx[i] > mx[i] )
  {
    if ( i!=(Dim-1) )
      {
        ++idx[i+1];
        idx[i]=mi[i];
      }
    else
      ++idx[i];
  }
       else
  break;
     }
 }
      ++pcontext;
    }
  this->setAffinity(templist);
}
class UniformMapper
  : public ContextMapper<1>
{
public:
  typedef Interval<1> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template <class Partitioner>
  inline
  UniformMapper(const Partitioner& gp)
    : blocks_m(gp.blocks())
  {
  }
  inline
  UniformMapper(const Loc<1>& blocks)
    : blocks_m(blocks)
  {
  }
  inline
  UniformMapper(int blocks = 1)
    : blocks_m(blocks)
  {
  }
  virtual ~UniformMapper(){}
  void map(const List_t&) const;
private:
  Loc<1> blocks_m;
};
template<int Dim>
class DistributedMapper
  : public ContextMapper<Dim>
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  template<class Partitioner>
  DistributedMapper(const Partitioner & gp)
    : blocks_m(gp.blocks())
  {
  }
  void map(const List_t & templist) const;
  void uniformMap(const Loc<1> &blocks,
    const List_t &templist,
    const WrappedInt<1>&) const
  {
    UniformMapper(blocks).map(templist);
  }
  template <int D>
  void uniformMap(const Loc<D> &,
    const List_t &,
    const WrappedInt<D>&) const
  {
    ;
  }
private:
  Loc<Dim> blocks_m;
};
template<int Dim>
void DistributedMapper<Dim>::map(const List_t & templist) const
{
  int ncontexts = Pooma::contexts();
  int npc = templist.size()/ncontexts;
  if(ncontexts> templist.size())
    {
      npc = 1;
      ncontexts = templist.size();
    }
  if (Dim == 1)
    {
      uniformMap(blocks_m,templist,WrappedInt<Dim>());
    }
  else if(npc<3)
    {
      ContiguousMapper<Dim>(blocks_m).map(templist);
    }
  else
    {
      BisectionMapper<Dim>(blocks_m).map(templist);
    }
  return;
}
template<int Dim>
class UniformGridPartition
{
public:
  typedef LocalMapper<Dim> DefaultMapper_t;
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  enum { uniform = true };
  enum { gridded = true };
  enum { tile = false };
  enum { general = false };
  enum { dimensions = Dim };
  UniformGridPartition();
  UniformGridPartition(const GuardLayers<Dim> &gcs);
  UniformGridPartition(const Loc<Dim> &a);
  UniformGridPartition(const Loc<Dim> &a,
                       const GuardLayers<Dim> &gcs );
  UniformGridPartition(const Loc<Dim> &a,
                       const GuardLayers<Dim> &igcs,
                       const GuardLayers<Dim> &egcs);
  UniformGridPartition(const UniformGridPartition<Dim> &b);
  ~UniformGridPartition() { }
  UniformGridPartition<Dim> &
  operator=(const UniformGridPartition<Dim> &g)
  {
    if (this != &g)
      {
 blocks_m = g.blocks();
 hasGuards_m = g.hasGuards_m;
 hasCustomEdgeGuards_m = g.hasCustomEdgeGuards_m;
 internalGuards_m = g.internalGuards_m;
 externalGuards_m = g.externalGuards_m;
 num_m = g.maxSize();
      }
    return *this;
  }
  int maxSize() const { return num_m; }
  const Loc<Dim> &blocks() const { return blocks_m; }
  bool hasGuards() const
  {
    ;
    return hasGuards_m;
  }
  bool hasInternalGuards() const
  {
    return hasGuards_m && internalGuards_m != 0;
  }
  bool hasExternalGuards() const
  {
    return hasGuards_m && externalGuards_m != 0;
  }
  const GuardLayers<Dim> &internalGuards() const
  {
    return internalGuards_m;
  }
  const GuardLayers<Dim> &externalGuards() const
  {
    return externalGuards_m;
  }
  template<class D>
  int partition(const D &domain,
  List_t & all,
  const ContextMapper<Dim>& cmapper) const;
  template<class D>
  int partition(const D &domain, List_t & list) const
  {
    return partition(domain,list,DefaultMapper_t(*this));
  }
protected:
  Loc<Dim> blocks_m;
  bool hasGuards_m;
  bool hasCustomEdgeGuards_m;
  GuardLayers<Dim> internalGuards_m;
  GuardLayers<Dim> externalGuards_m;
  int num_m;
  void calcNum()
  {
    num_m = blocks_m[0].first();
    for (int d = 1; d < Dim; ++d)
      {
 num_m *= blocks_m[d].first();
      }
  }
};
template<int Dim>
template<class D>
int UniformGridPartition<Dim>::partition(const D &domain,
      List_t & all,
      const ContextMapper<Dim>& cmapper) const
{
  typedef typename DomainTraits<Domain_t>::Element_t Element_t;
  PoomaCTAssert<(Dim == DomainTraits<D>::dimensions)>::test();
  PoomaCTAssert<(Dim == DomainTraits<Domain_t>::dimensions)>::test();
  PoomaCTAssert<(DomainTraits<D>::unitStride == 1)>::test();
  PoomaCTAssert<(DomainTraits<Domain_t>::unitStride == 1)>::test();
  ;
  Element_t origin[Dim];
  Element_t sizes[Dim];
  Interval<Dim> bdomain = Pooma::NoInit();
  int i;
  for (i = 0; i < Dim; ++i)
    {
      if (!domain.empty())
 {
   int gcwidth =
     (internalGuards_m.lower(i) > internalGuards_m.upper(i)) ?
     internalGuards_m.lower(i) : internalGuards_m.upper(i);
   if (__builtin_expect(!!((domain[i].length() % blocks()[i].first()) == 0), true)) {} else Pooma::toss_cookies("All the blocks in a grid must be the same size.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Partition/UniformGridPartition.h", 369);
   origin[i] = domain[i].first();
   sizes[i] = domain[i].length() / blocks()[i].first();
   if (__builtin_expect(!!(sizes[i] >= gcwidth), true)) {} else Pooma::toss_cookies("Block sizes too small for guard layer specification.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Partition/UniformGridPartition.h", 375);
 }
      bdomain[i] = Interval<1>(blocks()[i].first());
    }
  typename Interval<Dim>::const_iterator it = bdomain.begin();
  while (it != bdomain.end())
    {
      Domain_t owned;
      GuardLayers<Dim> iguards(0);
      GuardLayers<Dim> eguards(0);
      if (!domain.empty())
 {
   Loc<Dim> pos = *it;
   for (i = 0; i < Dim; ++i)
     {
       int position = pos[i].first();
       Element_t a = origin[i] + sizes[i]*position;
       Element_t b = a + sizes[i] - 1;
       typedef typename
  DomainTraits<Domain_t>::OneDomain_t OneDomain_t;
       owned[i] = OneDomain_t(a, b);
     }
   if (hasGuards_m)
     {
       iguards = internalGuards_m;
       for (int d = 0; d < Dim; ++d)
  {
    int position = pos[d].first();
    if ( position == bdomain[d].first() )
      {
        eguards.lower(d) = externalGuards_m.lower(d);
        iguards.lower(d) = 0;
      }
    if ( position == bdomain[d].last() )
      {
        eguards.upper(d) = externalGuards_m.upper(d);
        iguards.upper(d) = 0;
      }
  }
     }
 }
      typename Value_t::ID_t gid = all.size();
      typename Value_t::ID_t lid = (-1);
      GuardLayers<Dim>::addGuardLayers(owned,eguards);
      Domain_t allocated = owned;
      GuardLayers<Dim>::addGuardLayers(allocated,iguards);
      Value_t *node = new Value_t(owned, allocated, -1, gid, lid);
      all.push_back(node);
      ++it;
    }
  cmapper.map(all);
  return num_m;
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition()
: hasGuards_m(false),
  hasCustomEdgeGuards_m(false),
  num_m(1)
{
  blocks_m = 1;
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition(const GuardLayers<Dim> &gcs)
: hasGuards_m(gcs != 0),
  hasCustomEdgeGuards_m(gcs != 0),
  externalGuards_m(gcs),
  num_m(1)
{
  blocks_m = 1;
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition(const Loc<Dim> &a)
: blocks_m(a),
  hasGuards_m(false),
  hasCustomEdgeGuards_m(false)
{
  calcNum();
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition(const Loc<Dim> &a,
                     const GuardLayers<Dim> &gcs)
: blocks_m(a),
  hasGuards_m(gcs != 0),
  hasCustomEdgeGuards_m(false),
  internalGuards_m(gcs),
  externalGuards_m(gcs)
{
  calcNum();
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition(const Loc<Dim> &a,
                     const GuardLayers<Dim> &igcs,
                     const GuardLayers<Dim> &egcs)
: blocks_m(a),
  hasGuards_m(igcs != 0 || egcs != 0),
  hasCustomEdgeGuards_m(igcs != egcs),
  internalGuards_m(igcs),
  externalGuards_m(egcs)
{
  calcNum();
}
template <int Dim>
inline UniformGridPartition<Dim>::
UniformGridPartition(const UniformGridPartition<Dim> &b)
: blocks_m(b.blocks_m),
  hasGuards_m(b.hasGuards_m),
  hasCustomEdgeGuards_m(b.hasCustomEdgeGuards_m),
  internalGuards_m(b.internalGuards_m),
  externalGuards_m(b.externalGuards_m),
  num_m(b.num_m)
{ }
struct ReplicatedTag {};
struct DistributedTag {};
template <class LayoutTag, int Dim>
struct MultiPatchLayoutTraits {};
template <int Dim>
class LayoutBaseData
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Interval<Dim> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  struct GCFillInfo
  {
    GCFillInfo(const Domain_t &dom, int ownedID, int guardID, int face=-1)
    : domain_m(dom), ownedID_m(ownedID), guardID_m(guardID), face_m(face) { }
    GCFillInfo() { if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Shouldn't get here!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Layout/LayoutBase.h", 126); }
    Domain_t domain_m;
    int ownedID_m;
    int guardID_m;
    int face_m;
    Domain_t & domain() { return domain_m;}
    int & ownedID() { return ownedID_m;}
    int & guardID() { return guardID_m;}
  };
  typedef GCFillInfo GCFillInfo_t;
  typedef typename std::vector<GCFillInfo>::const_iterator FillIterator_t;
  LayoutBaseData()
    :
    ID_m(Unique::get()),
    domain_m(Interval<Dim>()),
    innerdomain_m(Interval<Dim>()),
    hasInternalGuards_m(false),
    hasExternalGuards_m(false),
    internalGuards_m(0),
    externalGuards_m(0)
  {
  }
  LayoutBaseData(bool hasIG, bool hasEG,
   GuardLayers_t eg, GuardLayers_t ig,
   Domain_t d, Domain_t id)
    :
    ID_m(Unique::get()),
    domain_m(d),
    innerdomain_m(id),
    hasInternalGuards_m(hasIG),
    hasExternalGuards_m(hasEG),
    internalGuards_m(ig),
    externalGuards_m(eg)
  {
  }
  ~LayoutBaseData()
  {
  }
  inline const Domain_t & domain(int i) const
  {
    ;
    return all_m[i]->allocated();
  }
  inline const Domain_t & ownedDomain(int i) const
  {
    ;
    return all_m[i]->domain();
  }
  inline const Domain_t & allocatedDomain(int i) const
  {
    ;
    return all_m[i]->allocated();
  }
  inline const GuardLayers_t& internalGuards() const
  {
    return internalGuards_m;
  }
  inline const GuardLayers_t& externalGuards() const
  {
    return externalGuards_m;
  }
  inline List_t &nodeListGlobal()
  {
    return all_m;
  }
  inline List_t &nodeListLocal()
  {
    return local_m;
  }
  inline List_t &nodeListRemote()
  {
    return remote_m;
  }
  inline bool initialized() const { return all_m.size() > 0; }
  inline int first(int d) const { return firsti_m[d]; }
  inline int firsts(int d) const { return firste_m[d]; }
  inline const Loc<Dim>& blocks() const { return blocks_m; }
  FillIterator_t beginFillList() const
  {
    return gcFillList_m.begin();
  }
  FillIterator_t endFillList() const
  {
    return gcFillList_m.end();
  }
  ID_t ID_m;
  Domain_t domain_m;
  Domain_t innerdomain_m;
  List_t all_m;
  List_t local_m;
  List_t remote_m;
  bool hasInternalGuards_m;
  bool hasExternalGuards_m;
  GuardLayers_t internalGuards_m;
  GuardLayers_t externalGuards_m;
  std::vector<GCFillInfo> gcFillList_m;
  int firste_m[Dim];
  int firsti_m[Dim];
  Loc<Dim> blocks_m;
};
template <int Dim, class LBD>
class LayoutBase
{
public:
  typedef LayoutBaseData<Dim> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef LayoutBase<Dim,LBD> This_t;
  typedef Observable<This_t> Observable_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef typename LayoutData_t::GCFillInfo_t GCFillInfo_t;
  typedef typename
  std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  enum { supportsGuards = true };
  LayoutBase(LBD * Ldata)
    : pdata_m(Ldata)
  {
  }
   LayoutBase(RefCountedPtr<LBD> pdata)
    : pdata_m(pdata)
  {
  }
  ~LayoutBase()
  {
  }
  inline ID_t ID() const
  {
    return pdata_m->ID_m;
  }
  inline ID_t baseID() const
  {
    return pdata_m->ID_m;
  }
  inline bool initialized() const
  {
    return (sizeGlobal() > 0);
  }
  template <class DT>
  BaseDomain_t &localToBase(const Domain<Dim, DT> &dlocal,
    BaseDomain_t &base) const
  {
    return pdata_m->indexer_m.localToBase(dlocal,base);
  }
  inline const Domain_t &domain() const
  {
    return pdata_m->domain_m;
  }
  inline const Domain_t &innerDomain() const
  {
    return pdata_m->innerdomain_m;
  }
  inline const Domain_t &baseDomain() const
  {
    return pdata_m->domain_m;
  }
  inline const Domain_t &domain(int i) const
  {
    return pdata_m->domain(i);
  }
  inline const Domain_t &ownedDomain(int i) const
  {
    return pdata_m->ownedDomain(i);
  }
  inline const Domain_t &allocatedDomain(int i) const
  {
    return pdata_m->allocatedDomain(i);
  }
  inline const List_t & nodeListGlobal() const
  {
    return pdata_m->nodeListGlobal();
  }
  inline const List_t &nodeListLocal() const
  {
    return pdata_m->nodeListLocal();
  }
  inline const List_t &nodeListRemote() const
  {
    return pdata_m->nodeListRemote();
  }
  inline GuardLayers_t internalGuards() const
  {
    return pdata_m->internalGuards();
  }
  inline GuardLayers_t externalGuards() const
  {
    return pdata_m->externalGuards();
  }
  inline int first(int d) const { return pdata_m->first(d); }
  inline Loc<Dim> blocks() const { return pdata_m->blocks(); }
  inline const Domain_t patchDomain(int lid) const
  {
    return nodeListLocal()[lid]->domain();
  }
  inline int localToGlobalPatchID(int lid) const
  {
    return nodeListLocal()[lid]->globalID();
  }
  int globalID(const Loc<Dim> &loc) const
  { return pdata_m->globalID(loc); }
  int globalID(int i0) const
  { return pdata_m->globalID(i0); }
  int globalID(int i0, int i1) const
  { return pdata_m->globalID(i0,i1); }
  int globalID(int i0, int i1, int i2) const
  { return pdata_m->globalID(i0,i1,i2); }
  int globalID(int i0, int i1, int i2, int i3) const
  { return pdata_m->globalID(i0,i1,i2,i3); }
  int globalID(int i0, int i1, int i2, int i3, int i4) const
  { return pdata_m->globalID(i0,i1,i2,i3,i4); }
  int globalID(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return pdata_m->globalID(i0,i1,i2,i3,i4,i5); }
  int globalID(int i0, int i1, int i2,int i3, int i4, int i5, int i6) const
  { return pdata_m->globalID(i0,i1,i2,i3,i4,i5,i6); }
  template <class Partitioner>
  bool repartition(const Partitioner &gp,const ContextMapper<Dim> &cmap)
  {
    return pdata_m->repartition(gp,cmap);
  }
  template <class Partitioner>
  bool repartition(const Partitioner &gp)
  {
    typename Partitioner::DefaultMapper_t cmap(gp);
    return pdata_m->repartition(gp,cmap);
  }
  template <class L>
  inline bool operator==(const L &layout) const
  {
    return (baseID() == layout.baseID() &&
            baseDomain() == layout.baseDomain());
  }
  template <class L>
  inline bool operator!=(const L &layout) const
  {
    return !(*this == layout);
  }
  inline iterator beginGlobal()
  {
    return iterator(pdata_m->all_m.begin());
  }
  inline iterator endGlobal()
  {
    return iterator(pdata_m->all_m.end());
  }
  inline const_iterator beginGlobal() const
  {
    return const_iterator(pdata_m->all_m.begin());
  }
  inline const_iterator endGlobal() const
  {
    return const_iterator(pdata_m->all_m.end());
  }
  inline int sizeGlobal() const
  {
    return pdata_m->all_m.size();
  }
  inline iterator beginLocal()
  {
    return iterator(pdata_m->local_m.begin());
  }
  inline iterator endLocal()
  {
    return iterator(pdata_m->local_m.end());
  }
  inline const_iterator beginLocal() const
  {
    return const_iterator(pdata_m->local_m.begin());
  }
  inline const_iterator endLocal() const
  {
    return const_iterator(pdata_m->local_m.end());
  }
  inline int sizeLocal() const
  {
    return pdata_m->local_m.size();
  }
  inline iterator beginRemote()
  {
    return iterator(pdata_m->remote_m.begin());
  }
  inline iterator endRemote()
  {
    return iterator(pdata_m->remote_m.end());
  }
  inline const_iterator beginRemote() const
  {
    return const_iterator(pdata_m->remote_m.begin());
  }
  inline const_iterator endRemote() const
  {
    return const_iterator(pdata_m->remote_m.end());
  }
  inline int sizeRemote() const
  {
    return pdata_m->remote_m.size();
  }
  FillIterator_t beginFillList() const
  {
    return pdata_m->beginFillList();
  }
  FillIterator_t endFillList() const
  {
    return pdata_m->endFillList();
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o, const ConstructTag &ctag) const
  {
    return pdata_m->touches(d,o,ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAlloc(const OtherDomain &d, OutIter o,
                   const ConstructTag &ctag) const
  {
    return pdata_m->touchesAlloc(d, o, ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesLocal(const OtherDomain &d, OutIter o,
     const ConstructTag &ctag) const
  {
    return pdata_m->touchesLocal(d, o, ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesAllocLocal(const OtherDomain &d, OutIter o,
          const ConstructTag &ctag) const
  {
    return pdata_m->touchesAllocLocal(d, o, ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesRemote(const OtherDomain & d, OutIter o,
      const ConstructTag &ctag) const
  {
    return pdata_m->touchesRemote(d,o,ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesAllocRemote(const OtherDomain &d, OutIter o,
           const ConstructTag & ctag) const
  {
    return pdata_m->touchesAllocRemote(d,o,ctag);
  }
  template <class OtherDomain, class OutIter>
  inline int touches(const OtherDomain &d, OutIter o) const
  {
    return touches(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  inline int touchesLocal(const OtherDomain &d, OutIter o) const
  {
    return touchesLocal(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  inline int touchesRemote(const OtherDomain &d, OutIter o) const
  {
    return touchesRemote(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  int touchesAlloc(const OtherDomain &d, OutIter o) const
  {
    return touchesAlloc(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  int touchesAllocLocal(const OtherDomain &d, OutIter o) const
  {
    return touchesAllocLocal(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  int touchesAllocRemote(const OtherDomain &d, OutIter o) const
  {
    return touchesAllocRemote(d, o, TouchesConstructNodeObj());
  }
  template <int Dim1, int Dim2, class lbd>
  friend class LayoutBaseView;
  friend class LayoutBaseData<Dim>;
  RefCountedPtr<LBD> pdata_m;
};
template <int Dim, int Dim2, class L>
class LayoutBaseViewData
{
public:
  typedef L Layout_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim2> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef typename Layout_t::Domain_t AllocatedDomain_t;
  typedef ViewIndexer<Dim,Dim2> Indexer_t;
  typedef Node<Domain_t,AllocatedDomain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  LayoutBaseViewData()
   : id_m(Unique::get())
  { }
  template<class DT>
  LayoutBaseViewData(const L & layout, const Domain<Dim,DT> & dom)
    : id_m(Unique::get()), layout_m(layout),
      internalGuards_m(layout.internalGuards()),
      externalGuards_m(layout.externalGuards()),
      indexer_m(dom),
      subdomainsComputed_m(false)
  {
    PoomaCTAssert<(Dim == Dim2)>::test();
    ;
    ;
  }
  template <class DT>
  LayoutBaseViewData(const L &layout, const SliceDomain<DT> &dom)
  : id_m(Unique::get()), layout_m(layout), indexer_m(dom),
    subdomainsComputed_m(false)
  {
    PoomaCTAssert<(Dim == DT::sliceDimensions)>::test();
    PoomaCTAssert<(Dim2 == DT::dimensions)>::test();
    ;
    ;
    int dt, d;
    for (d = 0, dt = 0; dt < Dim2; ++dt)
      {
        if (!dom.ignorable(dt))
          {
            internalGuards_m.lower(d) = layout_m.internalGuards().lower(dt);
            internalGuards_m.upper(d) = layout_m.internalGuards().upper(dt);
            externalGuards_m.lower(d) = layout_m.externalGuards().lower(dt);
            externalGuards_m.upper(d) = layout_m.externalGuards().upper(dt);
            ;
            ++d;
          }
      }
  }
   template <class DT,class LV>
   LayoutBaseViewData(const L &layout,
        const LV & viewLayout,
        const Indexer_t & indexer,
        const Domain<Dim, DT> &dom,
        GuardLayers_t ig,
        GuardLayers_t eg)
  :
    id_m(Unique::get()),
    layout_m(layout),
    internalGuards_m(ig),
    externalGuards_m(eg),
    indexer_m(indexer, dom),
    subdomainsComputed_m(false)
  {
    ;
    ;
  }
   template <class DT,class LV>
   LayoutBaseViewData(const L &layout,
        const LV &viewLayout,
        const Indexer_t indexer,
        const SliceDomain<DT> &dom)
     : id_m(Unique::get()), layout_m(layout),
     indexer_m(indexer),
     subdomainsComputed_m(false)
  {
    PoomaCTAssert<((int)DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<((int)DT::dimensions == LV::dimensions)>::test();
    ;
    ;
    int dt, d;
    for (d = 0, dt = 0; dt < LV::dimensions ; ++dt)
      {
        if (!dom.ignorable(dt))
          {
            internalGuards_m.lower(d) = viewLayout.internalGuards().lower(dt);
            internalGuards_m.upper(d) = viewLayout.internalGuards().upper(dt);
            externalGuards_m.lower(d) = viewLayout.externalGuards().lower(dt);
            externalGuards_m.upper(d) = viewLayout.externalGuards().upper(dt);
            ;
            ++d;
          }
      }
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o,
              const ConstructTag &ctag) const
  {
    BaseDomain_t bd = Pooma::NoInit();
    indexer_m.localToBase(d, bd);
    std::vector<Node<BaseDomain_t,AllocatedDomain_t> > tnodes;
    int count = layout_m.touches(bd, std::back_inserter(tnodes));
    Range<Dim> ld = Pooma::NoInit();
    for (int i = 0; i < count; i++)
      {
        *o++ =
          touchesConstruct(indexer_m.baseToLocal(tnodes[i].domain(), ld),
                           tnodes[i].allocated(),
                           tnodes[i].affinity(), tnodes[i].context(),
                           tnodes[i].globalID(), tnodes[i].localID(), ctag);
      }
    return count;
  }
  void computeSubdomains() const
  {
    if (subdomainsComputed_m)
      return;
    std::vector<Node<BaseDomain_t,AllocatedDomain_t> > tnodes;
    int count = layout_m.touches(indexer_m.baseDomain(),
                                 std::back_inserter(tnodes));
    Domain_t ld = Pooma::NoInit();
    for (int i = 0; i < count; ++i)
      {
        Value_t *pt =
          touchesConstruct(indexer_m.baseToLocal(tnodes[i].domain(), ld),
                           tnodes[i].allocated(),
                           tnodes[i].affinity(),tnodes[i].context(),
                           tnodes[i].globalID(),tnodes[i].localID(),
                           TouchesConstructNodePtr());
        all_m.push_back(pt);
        if (pt->context() == Pooma::context()
     ||pt->context() == -1 )
          local_m.push_back(pt);
        else
          remote_m.push_back(pt);
      }
    subdomainsComputed_m = true;
  }
  ID_t id_m;
  L layout_m;
  GuardLayers_t internalGuards_m;
  GuardLayers_t externalGuards_m;
  Indexer_t indexer_m;
  mutable List_t all_m;
  mutable List_t local_m;
  mutable List_t remote_m;
  mutable bool subdomainsComputed_m;
};
template <int Dim, int Dim2, class lvd>
class LayoutBaseView
{
public:
  enum { dimensions = Dim };
  typedef lvd LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Layout_t Layout_t;
  typedef typename LayoutData_t::AllocatedDomain_t AllocatedDomain_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef typename LayoutData_t::Indexer_t Indexer_t;
  typedef typename LayoutData_t::GuardLayers_t GuardLayers_t;
  typedef LayoutBaseView<Dim, Dim2, lvd> This_t;
  typedef LayoutBaseView<Dim, Dim2, lvd> ViewLayout_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  LayoutBaseView(LayoutData_t * lvdp)
    : pdata_m(lvdp)
  {}
  LayoutBaseView(const RefCountedPtr<LayoutData_t> & pdata)
    : pdata_m(pdata)
  {}
  inline ID_t ID() const { return pdata_m->id_m; }
  inline ID_t baseID() const { return pdata_m->layout_m.baseID(); }
  inline bool initialized() const { return true; }
  inline const Domain_t &domain() const
  {
    return pdata_m->indexer_m.domain();
  }
  inline const Domain_t &innerDomain() const
  {
    return pdata_m->indexer_m.innerDomain();
  }
  inline const BaseDomain_t &baseDomain() const
  {
    return pdata_m->indexer_m.baseDomain();
  }
  inline const Layout_t &baseLayout() const
  {
    return pdata_m->layout_m;
  }
  template <class DT>
  BaseDomain_t &localToBase(const Domain<Dim, DT> &dlocal,
    BaseDomain_t &base) const
  {
    return pdata_m->indexer_m.localToBase(dlocal,base);
  }
  template <class DT>
  SliceRange<Dim2, Dim> &localToBase(const Domain<Dim, DT> &dlocal,
    SliceRange<Dim2, Dim> &base) const
  {
    return pdata_m->indexer_m.localToBase(dlocal,base);
  }
  inline GuardLayers_t internalGuards() const
  {
    return pdata_m->internalGuards_m;
  }
  inline GuardLayers_t externalGuards() const
  {
    return pdata_m->externalGuards_m;
  }
  inline int first(int) const { return 0; }
  template <class L>
  inline bool operator==(const L &layout) const
  {
    return (baseID() == layout.baseID() &&
            baseDomain() == layout.baseDomain());
  }
  template <class L>
  inline bool operator!=(const L &layout) const
  {
    return !(*this == layout);
  }
  inline int
  globalID(const Loc<Dim> &loc, Loc<Dim2> &oloc) const
  {
    pdata_m->indexer_m.translate(loc,oloc);
    return pdata_m->layout_m.globalID(oloc);
  }
  inline int
  globalID(int i0, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, int i2, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,i2,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, int i2, int i3,
           Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,i2,i3,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, int i2, int i3,
           int i4, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,i2,i3,i4,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, int i2, int i3,
           int i4, int i5, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,i2,i3,i4,i5,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  inline int
  globalID(int i0, int i1, int i2, int i3,
           int i4, int i5, int i6, Loc<Dim2> &loc) const
  {
    pdata_m->indexer_m.translate(i0,i1,i2,i3,i4,i5,i6,loc);
    return pdata_m->layout_m.globalID(loc);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o,
    const ConstructTag &ctag) const
  {
    return pdata_m->touches(d,o,ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesLocal(const OtherDomain &d, OutIter o,
    const ConstructTag &ctag) const {
    return pdata_m->touches(d, o, ctag);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesRemote(const OtherDomain &, OutIter,
    const ConstructTag &) const {
    return 0;
  }
  template <class OtherDomain, class OutIter>
  inline int touches(const OtherDomain &d, OutIter o) const {
    return touches(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  inline int touchesLocal(const OtherDomain &d, OutIter o) const {
    return touchesLocal(d, o, TouchesConstructNodeObj());
  }
  template <class OtherDomain, class OutIter>
  inline int touchesRemote(const OtherDomain &d, OutIter o) const {
    return touchesRemote(d, o, TouchesConstructNodeObj());
  }
  inline iterator beginGlobal() {
    computeSubdomains();
    return iterator(pdata_m->all_m.begin());
  }
  inline iterator endGlobal() {
    computeSubdomains();
    return iterator(pdata_m->all_m.end());
  }
  inline const_iterator beginGlobal() const {
    computeSubdomains();
    return const_iterator(pdata_m->all_m.begin());
  }
  inline const_iterator endGlobal() const {
    computeSubdomains();
    return const_iterator(pdata_m->all_m.end());
  }
  inline int sizeGlobal() const {
    computeSubdomains();
    return pdata_m->all_m.size();
  }
  inline iterator beginLocal() {
    computeSubdomains();
    return iterator(pdata_m->local_m.begin());
  }
  inline iterator endLocal() {
    computeSubdomains();
    return iterator(pdata_m->local_m.end());
  }
  inline const_iterator beginLocal() const {
    computeSubdomains();
    return const_iterator(pdata_m->local_m.begin());
  }
  inline const_iterator endLocal() const {
    computeSubdomains();
    return const_iterator(pdata_m->local_m.end());
  }
  inline int sizeLocal() const {
    computeSubdomains();
    return pdata_m->local_m.size();
  }
  inline iterator beginRemote() {
    computeSubdomains();
    return iterator(pdata_m->remote_m.begin());
  }
  inline iterator endRemote() {
    computeSubdomains();
    return iterator(pdata_m->remote_m.end());
  }
  inline const_iterator beginRemote() const {
    computeSubdomains();
    return const_iterator(pdata_m->remote_m.begin());
  }
  inline const_iterator endRemote() const {
    computeSubdomains();
    return const_iterator(pdata_m->remote_m.end());
  }
  inline int sizeRemote() const {
    computeSubdomains();
    return pdata_m->remote_m.size();
  }
  template <int OtherDim, int OtherDim2, class OtherLayoutData>
  friend class LayoutBaseView;
  template <int OtherDim, int OtherDim2, class OtherLayout>
  friend class LayoutBaseViewData;
  void computeSubdomains() const { pdata_m->computeSubdomains(); }
  RefCountedPtr<LayoutData_t> pdata_m;
};
template <int Dim> class SparseTileLayoutData;
template <int Dim> class SparseTileLayout;
template <int Dim, int Dim2> class SparseTileLayoutViewData;
template <int Dim, int Dim2> class SparseTileLayoutView;
struct SparseTileTag { };
template <int Dim>
struct MultiPatchLayoutTraits<SparseTileTag,Dim>
{
  typedef SparseTileLayout<Dim> Layout_t;
  template <int ViewDim>
  struct View
  {
    typedef SparseTileLayoutView<ViewDim,Dim> Layout_t;
  };
};
template<int Dim>
class SparseTileLayoutData
 : public LayoutBaseData<Dim>,
   public RefCounted,
   public Observable< SparseTileLayoutData<Dim> >
{
public:
  typedef SparseTileLayoutData<Dim> This_t;
  typedef Observable<This_t> Observable_t;
  typedef Interval<Dim> Domain_t;
  typedef Interval<Dim> BaseDomain_t;
  typedef Interval<Dim> AllocatedDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef Node<Domain_t,AllocatedDomain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef std::map<int,Value_t> Map_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef std::pair<int,int> pidx_t;
  typedef typename DynamicEvents::PatchID_t PatchID_t;
  typedef typename DynamicEvents::CreateSize_t CreateSize_t;
  typedef BaseDomain_t SubPatch_t;
  typedef std::vector<SubPatch_t> PatchList_t;
  typedef typename LayoutBaseData<Dim>::GCFillInfo_t GCFillInfo_t;
  typedef typename std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  struct GCBorderFillInfo
  {
    GCBorderFillInfo(const Domain_t &dom, int patchID)
      : domain_m(dom), patchID_m(patchID)
      {
      }
    GCBorderFillInfo()
      {
 if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Shouldn't get here!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Layout/SparseTileLayout.h", 173);
      }
    Domain_t domain_m;
    int patchID_m;
    inline const Domain_t& domain() const { return domain_m; }
    int patchID() const { return patchID_m;}
  };
  typedef GCBorderFillInfo GCBorderFillInfo_t;
  typedef typename std::vector<GCBorderFillInfo>::const_iterator
                                               BorderFillIterator_t;
  enum { dimensions = Dim };
  enum { repartitionEvent = 1 };
  enum { dynamic = false };
  SparseTileLayoutData();
  SparseTileLayoutData(const Domain_t &,
         const PatchList_t &,
         const ContextMapper<Dim> &);
  SparseTileLayoutData(const Domain_t &boundingbox,
         const GuardLayers_t & globalGL,
         const PatchList_t & PatchList,
         const ContextMapper<Dim> &);
  SparseTileLayoutData(const Domain_t &boundingbox,
         const GuardLayers_t & internalGL,
         const GuardLayers_t & externalGL,
         const PatchList_t & PatchList,
         const ContextMapper<Dim> &);
  SparseTileLayoutData(const Domain_t &boundingbox);
  SparseTileLayoutData(const Domain_t &boundingbox,
         const GuardLayers_t & globalGL);
  SparseTileLayoutData(const Domain_t &boundingbox,
         const GuardLayers_t & internalGL,
         const GuardLayers_t & externalGL);
template <class Partitioner>
SparseTileLayoutData(const Domain_t &bbox,
       const Partitioner & gpar,
       const ContextMapper<Dim> &cmap);
  ~SparseTileLayoutData() ;
  void initialize(const Domain_t &bbox);
  void initialize(const Domain_t &bbox,
    const GuardLayers_t & globalGL);
  void initialize(const Domain_t &bbox,
    const GuardLayers_t & internalGL,
    const GuardLayers_t & externalGL);
  void initialize(const Domain_t &bbox,
    const PatchList_t &plist,
    const ContextMapper<Dim> &cmap);
  void initialize(const Domain_t &bbox,
    const GuardLayers_t & globalGL,
    const PatchList_t &plist,
    const ContextMapper<Dim> &cmap);
  void initialize(const Domain_t &bbox,
    const GuardLayers_t & internalGL,
    const GuardLayers_t & externalGL,
    const PatchList_t &plist,
    const ContextMapper<Dim> &cmap);
  template <class Partitioner>
  void initialize(const Domain_t &bbox,
    const Partitioner &gpar,
    const ContextMapper<Dim> &cmap);
  void syncPatch();
  void calcMaps();
  void calcAllocMaps() ;
  BorderFillIterator_t beginBorderFillList() const
  {
    return gcBorderFillList_m.begin();
  }
  BorderFillIterator_t endBorderFillList() const
  {
    return gcBorderFillList_m.end();
  }
  int globalID(const Loc<Dim> &loc) const;
  int globalID(int) const;
  int globalID(int,int) const;
  int globalID(int,int,int) const;
  int globalID(int,int,int,int) const;
  int globalID(int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int,int) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d,
       OutIter o,
       const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAlloc(const OtherDomain &d,
     OutIter o,
     const ConstructTag &ctag) const;
  template<class Out>
  void print(Out & o) const;
private:
  void calcGCFillList();
  void calcDomains();
  void calcMaps() const;
  void calcAllocMaps() const;
  std::vector<GCBorderFillInfo> gcBorderFillList_m;
  mutable DomainMap<Interval<Dim>,pidx_t> map_m;
  mutable DomainMap<Interval<Dim>,pidx_t> mapAloc_m;
};
template <int Dim>
class SparseTileLayout : public LayoutBase<Dim,SparseTileLayoutData<Dim> >,
                         public Observable<SparseTileLayout<Dim> >,
                         public Observer<SparseTileLayoutData<Dim> >
{
public:
  enum { dimensions = Dim };
  enum { repartitionEvent = 1 };
  enum { dynamic = true };
  typedef SparseTileLayout<Dim> This_t;
  typedef Observable<This_t> Observable_t;
  typedef SparseTileLayoutData<Dim> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef typename LayoutData_t::SubPatch_t SubPatch_t;
  typedef typename LayoutData_t::PatchList_t PatchList_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef typename LayoutData_t::GCFillInfo_t GCFillInfo_t;
  typedef typename LayoutData_t::FillIterator_t FillIterator_t;
  typedef typename LayoutData_t::BorderFillIterator_t BorderFillIterator_t;
  SparseTileLayout();
  SparseTileLayout(const Domain_t &boundingbox);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL);
  SparseTileLayout(Domain_t & boundingbox,
     const PatchList_t &patchlist,
     const ReplicatedTag &);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL,
     const PatchList_t & PatchList,
     const ReplicatedTag &);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL,
     const PatchList_t & PatchList,
     const ReplicatedTag &);
  template<class Partitioner>
  SparseTileLayout(const Domain_t &bbox,
     const Partitioner &gpar,
     const ReplicatedTag &);
  SparseTileLayout(Domain_t & boundingbox,
     const PatchList_t &patchlist,
     const DistributedTag &);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL,
     const PatchList_t & PatchList,
     const DistributedTag &);
  SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL,
     const PatchList_t & PatchList,
     const DistributedTag &);
  template<class Partitioner>
  SparseTileLayout(const Domain_t &bbox,
     const Partitioner &gpar,
     const DistributedTag &);
  template<class Partitioner>
  SparseTileLayout(const Domain_t &bbox,
     const Partitioner &gpar,
     const ContextMapper<Dim> &cmap);
  SparseTileLayout(const This_t &);
  This_t &
  operator=(const This_t &model)
  {
    if (this != &model)
      {
 this->pdata_m->detach(*this);
 this->pdata_m = model.pdata_m;
 this->pdata_m->attach(*this);
      }
    return *this;
  }
  ~SparseTileLayout()
  {
    this->pdata_m->detach(*this);
  }
  void initialize(const Domain_t & a);
  void initialize(const Domain_t &,
              const GuardLayers_t &);
  void initialize(const Domain_t &,
              const GuardLayers_t &,
     const PatchList_t & );
  template<class Partitioner>
  void initialize(const Domain_t &bbox,
      const Partitioner &gpar);
  BorderFillIterator_t beginBorderFillList() const
    {
      return this->pdata_m->beginBorderFillList();
    }
  BorderFillIterator_t endBorderFillList() const
    {
      return this->pdata_m->endBorderFillList();
    }
  void syncPatch();
  virtual void notify(LayoutData_t &d, const ObserverEvent &event)
    {
      ;
      Observable_t::notify(event);
    }
  template <class Ostream>
  void print(Ostream &ostr) const {
    this->pdata_m->print(ostr);
  }
  template <int Dim1, int Dim2>
  friend class SparseTileLayoutView;
  friend class SparseTileLayoutData<Dim>;
};
template <int Dim, int Dim2>
class SparseTileLayoutViewData
: public LayoutBaseViewData<Dim, Dim2, SparseTileLayout<Dim2> >,
  public RefCounted
{
public:
  typedef SparseTileLayout<Dim2> Layout_t;
  typedef SparseTileLayoutView<Dim, Dim2> ViewLayout_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim2> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef typename Layout_t::Domain_t AllocatedDomain_t;
  typedef ViewIndexer<Dim,Dim2> Indexer_t;
  typedef Node<Domain_t,AllocatedDomain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef SparseTileLayoutViewData<Dim,Dim2> LayoutData_t;
  SparseTileLayoutViewData() { }
  template <class DT>
  inline SparseTileLayoutViewData(const Layout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,SparseTileLayout<Dim2> >(layout,dom)
  {
    PoomaCTAssert<(Dim == Dim2)>::test();
    ;
    ;
  }
  template <class DT>
  inline SparseTileLayoutViewData(const Layout_t &layout, const SliceDomain<DT> &dom)
  :LayoutBaseViewData<Dim,Dim2,SparseTileLayout<Dim2> >(layout,dom)
  {
    PoomaCTAssert<(Dim == DT::sliceDimensions)>::test();
    PoomaCTAssert<(Dim2 == DT::dimensions)>::test();
    ;
    ;
    int dt, d;
    for (d = 0, dt = 0; dt < Dim2; ++dt)
      {
 if (!dom.ignorable(dt))
   {
     this->internalGuards_m.lower(d) = this->layout_m.internalGuards().lower(dt);
     this->internalGuards_m.upper(d) = this->layout_m.internalGuards().upper(dt);
     this->externalGuards_m.lower(d) = this->layout_m.externalGuards().lower(dt);
     this->externalGuards_m.upper(d) = this->layout_m.externalGuards().upper(dt);
     ;
     ++d;
   }
      }
  }
  template <class DT>
  SparseTileLayoutViewData(const ViewLayout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,SparseTileLayout<Dim2> >(
           layout.pdata_m->layout_m,
           layout,
           layout.pdata_m->indexer_m,
           dom,
           layout.internalGuards(),
           layout.externalGuards())
  {
    ;
    ;
  }
  template <int OrigDim, class DT>
  SparseTileLayoutViewData(const SparseTileLayoutView<OrigDim, Dim2> &layout,
      const SliceDomain<DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,SparseTileLayout<Dim2> >(
        layout.pdata_m->layout_m,
        layout,
        Indexer_t(layout.pdata_m->indexer_m,dom),
        dom)
  {
    PoomaCTAssert<(DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<(DT::dimensions == OrigDim)>::test();
    ;
    ;
    int dt, d;
    for (d = 0, dt = 0; dt < OrigDim; ++dt)
      {
 if (!dom.ignorable(dt))
   {
     this->internalGuards_m.lower(d) = layout.internalGuards().lower(dt);
     this->internalGuards_m.upper(d) = layout.internalGuards().upper(dt);
     this->externalGuards_m.lower(d) = layout.externalGuards().lower(dt);
     this->externalGuards_m.upper(d) = layout.externalGuards().upper(dt);
     ;
     ++d;
   }
      }
  }
  ~SparseTileLayoutViewData()
  {
    typename List_t::iterator a;
    for (a = this->all_m.begin(); a != this->all_m.end(); ++a)
      delete (*a);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o,
       const ConstructTag &ctag) const
  {
    BaseDomain_t bd = Pooma::NoInit();
    this->indexer_m.localToBase(d, bd);
    std::vector<Node<BaseDomain_t,AllocatedDomain_t> > tnodes;
    int count = this->layout_m.touches(bd, std::back_inserter(tnodes));
    Range<Dim> ld = Pooma::NoInit();
    for (int i = 0; i < count; i++)
      {
 *o++ =
   touchesConstruct(this->indexer_m.baseToLocal(tnodes[i].domain(), ld),
      tnodes[i].allocated(),
      tnodes[i].affinity(),tnodes[i].context(),
      tnodes[i].globalID(), tnodes[i].localID(), ctag);
      }
    return count;
  }
  void computeSubdomains() const
  {
    if (this->subdomainsComputed_m)
      return;
    std::vector<Node<BaseDomain_t,AllocatedDomain_t> > tnodes;
    int count = this->layout_m.touches(this->indexer_m.baseDomain(),
           std::back_inserter(tnodes));
    Domain_t ld = Pooma::NoInit();
    for (int i = 0; i < count; i++)
      {
 Value_t *pt =
   touchesConstruct(this->indexer_m.baseToLocal(tnodes[i].domain(), ld),
      tnodes[i].allocated(),
      tnodes[i].affinity(),tnodes[i].context(),
      tnodes[i].globalID(),tnodes[i].localID(),
      TouchesConstructNodePtr());
 this->all_m.push_back(pt);
      }
    this->subdomainsComputed_m = true;
  }
};
template <int Dim, int Dim2>
class SparseTileLayoutView
: public LayoutBaseView<Dim, Dim2, SparseTileLayoutViewData<Dim,Dim2> >
{
public:
  enum { dimensions = Dim };
  typedef SparseTileLayoutViewData<Dim, Dim2> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Layout_t Layout_t;
  typedef typename LayoutData_t::AllocatedDomain_t AllocatedDomain_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef typename LayoutData_t::Indexer_t Indexer_t;
  typedef typename LayoutData_t::GuardLayers_t GuardLayers_t;
  typedef SparseTileLayoutView<Dim, Dim2> This_t;
  typedef SparseTileLayoutView<Dim, Dim2> ViewLayout_t;
  typedef LayoutBaseView<Dim,Dim2,LayoutData_t> Base_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  SparseTileLayoutView()
  : Base_t(new LayoutData_t())
  { }
  template <class DT>
  SparseTileLayoutView(const Layout_t &layout, const Domain<Dim2, DT> &dom)
  : LayoutBaseView<Dim,Dim2,SparseTileLayoutViewData<Dim,Dim2> >
    (new SparseTileLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  SparseTileLayoutView(const Layout_t &layout, const SliceDomain<DT> &dom)
  : LayoutBaseView<Dim,Dim2,SparseTileLayoutViewData<Dim,Dim2> >
    (new SparseTileLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  SparseTileLayoutView(const ViewLayout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseView<Dim,Dim2,SparseTileLayoutViewData<Dim,Dim2> >
    (new SparseTileLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <int OldViewDim, class DT>
  SparseTileLayoutView(const SparseTileLayoutView<OldViewDim, Dim2> &layout,
                        const SliceDomain<DT> &dom)
  : LayoutBaseView<Dim,Dim2,SparseTileLayoutViewData<Dim,Dim2> >
    (new SparseTileLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  inline SparseTileLayoutView(const This_t &model)
    : LayoutBaseView<Dim,Dim2,SparseTileLayoutViewData<Dim,Dim2> >
  (model.pdata_m)
  { }
  inline This_t &operator=(const This_t &model)
  {
    if (this != &model)
      {
        this->pdata_m = model.pdata_m;
      }
    return *this;
  }
  inline ~SparseTileLayoutView()
  { }
  template <class Ostream>
  void print(Ostream &ostr) const
  {
    ostr << "SparseTileLayoutView " << this->ID() << " on global domain "
      << this->domain() << ":" << '\n';
    ostr << "   Base ID:          " << this->baseID() << '\n';
    ostr << "   Base domain:      " << this->baseDomain() << '\n';
    ostr << "   Total subdomains: " << this->sizeGlobal() << '\n';
    ostr << "   Local subdomains: " << this->sizeLocal() << '\n';
    ostr << "  Remote subdomains: " << this->sizeRemote() << '\n';
    const_iterator a;
    for (a = this->beginGlobal(); a != this->endGlobal(); ++a)
      ostr << "  Global subdomain = " << *a << '\n';
    for (a = this->beginLocal(); a != this->endLocal(); ++a)
      ostr << "   Local subdomain = " << *a << '\n';
    for (a = this->beginRemote(); a != this->endRemote(); ++a)
      ostr << "  Remote subdomain = " << *a << '\n';
  }
  template <int OtherDim, int OtherDim2>
  friend class SparseTileLayoutView;
  template <int OtherDim, int OtherDim2>
  friend class SparseTileLayoutViewData;
  void computeSubdomains() const { this->pdata_m->computeSubdomains(); }
};
template <int Dim>
struct NewDomain1<SparseTileLayout<Dim> >
{
  typedef SparseTileLayout<Dim> &Type_t;
  inline static Type_t combine(const SparseTileLayout<Dim> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim, int Dim2>
struct NewDomain1<SparseTileLayoutView<Dim, Dim2> >
{
  typedef SparseTileLayoutView<Dim, Dim2> &Type_t;
  inline static Type_t combine(const SparseTileLayoutView<Dim, Dim2> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim>
std::ostream &operator<<(std::ostream &ostr,
    const SparseTileLayout<Dim> &layout)
{
  layout.print(ostr);
  return ostr;
}
template <int Dim, int Dim2>
std::ostream &operator<<(std::ostream &ostr,
    const SparseTileLayoutView<Dim, Dim2> &layout)
{
  layout.print(ostr);
  return ostr;
}
template<int Dim> struct IsValid;
template<class LayoutTag, class PatchTag> struct MultiPatch;
template<class LayoutTag, class PatchTag, int Dim2> struct MultiPatchView;
template<class Expr> struct ExpressionTag;
template<class Eng, class Tag> struct EngineFunctor;
template<class Object,class Dom,class PatchTag>
inline bool isValidLocation(const Object & e,
       Dom & domain,
       MultiPatch<SparseTileTag,PatchTag> &)
{
  typedef typename Object::Domain_t domain_t;
  typedef Node<domain_t,domain_t> node_t;
  std::vector<node_t> v;
  int count = e.engine().layout().touches(domain,std::back_inserter(v));
  return (count!=0);
}
template<class Object,class Dom,class PatchTag,int Dim2>
inline bool isValidLocation(const Object & e,
       Dom & domain,
       MultiPatchView<SparseTileTag,
                      PatchTag,
                      Dim2> &)
{
  typedef typename Object::Domain_t domain_t;
  typedef Node<domain_t,domain_t> node_t;
  std::vector<node_t> v;
  int count = e.engine().layout().touches(domain,std::back_inserter(v));
  return (count!=0);
}
template<class Object,class Dom,class expr>
inline bool isValidLocation(const Object & e,
       Dom & domain,
       ExpressionTag<expr> &)
{
  typedef typename Object::Domain_t domain_t;
  typedef Node<domain_t,domain_t> node_t;
  std::vector<node_t> v;
  typedef typename Object::Engine_t Engine_t;
  IsValid<Engine_t::dimensions> l(domain);
  EngineFunctor<Engine_t, IsValid<Engine_t::dimensions> > ef;
  return ef.apply(e.engine(),l);
}
template <int Dim> class Loc;
template <> class Loc<1>;
template <int Dim> class Interval;
template <> class Interval<1>;
template <int Dim> class Grid;
template <> class Grid<1>;
template<int Dim>
struct DomainTraits< Grid<Dim> >
  : public DomainTraitsDomain<Grid<Dim>, int, Dim>
{
  typedef DomainTraitsDomain<Grid<Dim>, int, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef Grid<1> OneDomain_t;
  typedef Grid<1> PointDomain_t;
  typedef Interval<Dim> BlockDomain_t;
  typedef Loc<Dim> AskDomain_t;
  typedef Grid<Dim> AddResult_t;
  typedef Grid<Dim> MultResult_t;
  typedef OneDomain_t Storage_t[Dim];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = Dim };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  enum { wildcard = false };
  static OneDomain_t &getDomain(Domain_t &d, int n) { return d[n]; }
  static const OneDomain_t &getDomain(const Domain_t &d,int n) { return d[n]; }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void initializeStorage(Storage_t &dom) { }
};
template<>
struct DomainTraits< Grid<1> >
  : public DomainTraitsDomain<Grid<1>, int, 1>
{
  typedef Grid<1> OneDomain_t;
  typedef Grid<1> PointDomain_t;
  typedef Interval<1> BlockDomain_t;
  typedef Loc<1> AskDomain_t;
  typedef Grid<1> AddResult_t;
  typedef Grid<1> MultResult_t;
  typedef IndirectionList<Element_t> Storage_t;
  enum { dimensions = 1,
         sliceDimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = false };
  enum { wildcard = false };
  static Element_t first(const Storage_t &d) { return d.first(); }
  static Element_t last(const Storage_t &d) { return d.last(); }
  static Element_t stride(const Storage_t &d) { return d.stride(); }
  static Element_t length(const Storage_t &d) { return d.length(); }
  static Element_t min(const Storage_t &d) { return d.min(); }
  static Element_t max(const Storage_t &d) { return d.max(); }
  static bool empty(const Storage_t &d) { return d.empty(); }
  static int loop(const Storage_t &) { return 0; }
  static Element_t elem(const Storage_t &d, int n) { return d(n); }
  static OneDomain_t &getDomain(Domain_t &d, int) { return d; }
  static const OneDomain_t &getDomain(const Domain_t &d, int) { return d; }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void initializeStorage(Storage_t &) { }
  template<class T>
  static void setDomain(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    dom = Storage_t(DomainTraits<T>::getFirst(newdom),
      DomainTraits<T>::getStride(newdom),
      DomainTraits<T>::getLength(newdom));
  }
  template<int Dim>
  static void setDomain(Storage_t &dom, const Grid<Dim> &newdom) {
    PoomaCTAssert<(Dim == 1)>::test();
    dom = newdom.storage();
  }
  template<class T1, class T2>
  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T2>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T1>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T2>::singleValued)>::test();
    Element_t strideval = (endval < begval ? -1 : 1);
    dom = Storage_t(begval, strideval, (endval - begval)/strideval + 1);
  }
  template<class T1, class T2, class T3>
  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval,
   const T3 &strideval) {
    PoomaCTAssert<(DomainTraits<T1>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T2>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T3>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<T1>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T2>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<T3>::singleValued)>::test();
    dom = Storage_t(begval, strideval, (endval - begval)/strideval + 1);
  }
  static void setDomain(Storage_t &dom, const Storage_t &newdom) {
    dom = newdom;
  }
  static void setLoop(Storage_t &, int) { }
  template<class UT, class T>
  static void setWildcardDomain(Storage_t &dom, const UT &u, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::wildcard)>::test();
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<UT>::dimensions == 1)>::test();
    dom = Storage_t(newdom.first(u), newdom.stride(u), newdom.length(u));
  }
  template<class T>
  static bool isLessThan(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    ;
    return (dom.first() < DomainTraits<T>::getFirst(newdom) ||
     (dom.first() == DomainTraits<T>::getFirst(newdom) &&
      (dom.last() < DomainTraits<T>::getLast(newdom) ||
       (dom.last() == DomainTraits<T>::getLast(newdom) &&
        dom.length() < DomainTraits<T>::getLength(newdom)))));
  }
  template<class T>
  static bool isEqualTo(const Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::dimensions == 1)>::test();
    return ((dom.empty() && DomainTraits<T>::getEmpty(newdom)) ||
     (dom.first() == DomainTraits<T>::getFirst(newdom) &&
      dom.last() == DomainTraits<T>::getLast(newdom) &&
      dom.length() == DomainTraits<T>::getLength(newdom)));
  }
  template<class T>
  static void addAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom += DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void subtractAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom -= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void multiplyAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom *= DomainTraits<T>::getFirst(newdom);
  }
  template<class T>
  static void divideAccum(Storage_t &dom, const T &newdom) {
    PoomaCTAssert<(DomainTraits<T>::singleValued && DomainTraits<T>::dimensions == 1)>::test();
    dom /= DomainTraits<T>::getFirst(newdom);
  }
};
template<int Dim1, int Dim2>
struct DomainChangeDim<Grid<Dim1>, Dim2>
{
  typedef Grid<Dim1> OldType_t;
  typedef Grid<Dim2> NewType_t;
  enum { oldDim = Dim1,
  newDim = Dim2 };
};
template<int Dim>
class Grid : public Domain<Dim, DomainTraits<Grid<Dim> > >
{
  typedef DomainTraits< Grid<Dim> > DT_t;
  typedef Domain<Dim, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Grid() { }
  Grid(const Grid<Dim> &a) {
    NewDomain1<Grid<Dim> >::fill(*this, a);
  }
  template<class T1>
  explicit Grid(const T1 &a) {
    NewDomain1<T1>::fill(*this, a);
  }
  template<class T1, class T2>
  Grid(const T1 &a, const T2 &b) {
    NewDomain2<T1,T2>::fill(*this, a, b);
  }
  template<class T1, class T2, class T3>
  Grid(const T1 &a, const T2 &b, const T3 &c) {
    NewDomain3<T1,T2,T3>::fill(*this, a, b, c);
  }
  template<class T1, class T2, class T3, class T4>
  Grid(const T1 &a, const T2 &b, const T3 &c, const T4 &d) {
    NewDomain4<T1,T2,T3,T4>::fill(*this, a, b, c, d);
  }
  template<class T1, class T2, class T3, class T4, class T5>
  Grid(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e) {
    NewDomain5<T1,T2,T3,T4,T5>::fill(*this, a, b, c, d, e);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  Grid(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
       const T6 &f) {
    NewDomain6<T1,T2,T3,T4,T5,T6>::fill(*this, a, b, c, d, e, f);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  Grid(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
       const T6 &f, const T7 &g) {
    NewDomain7<T1,T2,T3,T4,T5,T6,T7>::fill(*this, a, b, c, d, e, f, g);
  }
  ~Grid() { }
  template<class T>
  Grid<Dim> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Grid<Dim> &operator=(const Grid<Dim> &newdom) {
    return NewDomain1<Grid<Dim> >::fill(*this, newdom);
  }
  template<class Out>
  void print(Out &o) const;
protected:
private:
};
template<int Dim>
template<class Out>
void Grid<Dim>::print(Out &o) const
{
  iterator p = this->begin();
  iterator pend = this->end();
  o << "[";
  while (p != pend)
    {
      o << *p;
      ++p;
      if (p != pend)
 o << ",";
    }
  o << "]";
}
template<>
class Grid<1> : public Domain<1, DomainTraits<Grid<1> > >
{
  typedef DomainTraits< Grid<1> > DT_t;
public:
  typedef DT_t::Element_t Element_t;
  typedef DT_t::Domain_t Domain_t;
  typedef DT_t::OneDomain_t OneDomain_t;
  typedef DT_t::BlockDomain_t BlockDomain_t;
  typedef DT_t::AskDomain_t AskDomain_t;
  typedef DT_t::AddResult_t AddResult_t;
  typedef DT_t::MultResult_t MultResult_t;
  typedef DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Grid() { }
  Grid(const Grid<1> &a) {
    NewDomain1<Grid<1> >::fill(*this, a);
  }
  template<class T1>
  explicit Grid(const T1 &a) {
    NewDomain1<T1>::fill(*this, a);
  }
  Grid(char a) {
    ;
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - 1);
  }
  Grid(unsigned char a) {
    ;
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - 1);
  }
  Grid(short a) {
    ;
    short s = (a < 0 ? -1 : 1);
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - s);
  }
  Grid(unsigned short a) {
    ;
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - 1);
  }
  Grid(int a) {
    ;
    int s = (a < 0 ? -1 : 1);
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - s);
  }
  Grid(unsigned int a) {
    ;
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - 1);
  }
  Grid(long a) {
    ;
    long s = (a < 0 ? -1 : 1);
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - s);
  }
  Grid(unsigned long a) {
    ;
    DomainTraits<Grid<1> >::setDomain(domain_m, 0, a - 1);
  }
  template<class T1, class T2>
  Grid(const T1 &m, const T2 &n);
  template<class T1, class T2, class T3>
  Grid(const T1 &m, const T2 &n, const T3 &s);
  ~Grid() { }
  template<class T>
  Grid<1> &operator=(const T &newdom) {
    return NewDomain1<T>::fill(*this, newdom);
  }
  Grid<1> &operator=(const Grid<1> &newdom) {
    return NewDomain1<Grid<1> >::fill(*this, newdom);
  }
  template<class Out>
  void print(Out &o) const;
};
template <class T1, class T2>
inline
Grid<1>::Grid(const T1 &m, const T2 &n) {
  DomainTraits<Grid<1> >::setDomain(domain_m, m, n);
}
template <class T1, class T2, class T3>
inline
Grid<1>::Grid(const T1 &m, const T2 &n, const T3 &s) {
  DomainTraits<Grid<1> >::setDomain(domain_m, m, n, s);
}
template<class Out>
void Grid<1>::print(Out &o) const
{
  iterator p = begin();
  iterator pend = end();
  o << "[";
  while (p != pend)
    {
      o << *p;
      ++p;
      if (p != pend)
 o << ",";
    }
  o << "]";
}
template<int Dim>
std::ostream& operator<<(std::ostream &o, const Grid<Dim> &grid)
{
  grid.print(o);
  return o;
}
template <int Dim, class T> class Region;
template <class T> class Region<1,T>;
template<int Dim, class T>
struct DomainTraits< Region<Dim,T> >
  : public DomainTraitsDomain<Region<Dim,T>, T, Dim>
{
  typedef DomainTraitsDomain<Region<Dim,T>, T, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef Region<1,T> OneDomain_t;
  typedef Region<1,T> PointDomain_t;
  typedef Region<Dim,T> BlockDomain_t;
  typedef Region<Dim,T> AskDomain_t;
  typedef Region<Dim,T> AddResult_t;
  typedef Region<Dim,T> MultResult_t;
  typedef WrapNoInit<OneDomain_t> Storage_t[Dim];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = Dim };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = true };
  enum { wildcard = false };
  static OneDomain_t &getDomain(Domain_t &d, int n) { return d[n]; }
  static const OneDomain_t &getDomain(const Domain_t &d,int n) { return d[n]; }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void initializeStorage(Storage_t &dom) {
    Dom1Initialize<Dim-1>::template apply<DomainTraits<Region<Dim, T> > >(dom);
  }
};
template<class T>
struct DomainTraits< Region<1,T> >
  : public DomainTraitsDomain<Region<1,T>, T, 1>
{
  typedef DomainTraitsDomain<Region<1,T>, T, 1> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef Region<1,T> OneDomain_t;
  typedef Region<1,T> BlockDomain_t;
  typedef Region<1,T> AskDomain_t;
  typedef Region<1,T> AddResult_t;
  typedef Region<1,T> MultResult_t;
  typedef Element_t Storage_t[2];
  typedef Element_t IteratorStorage_t[2];
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = 1 };
  enum { loopAware = false };
  enum { singleValued = false };
  enum { unitStride = true };
  enum { wildcard = false };
  static Element_t first(const Storage_t &d) { return d[0]; }
  static Element_t last(const Storage_t &d) { return d[0] + d[1]; }
  static Element_t stride(const Storage_t &d) { return d[1]; }
  static Element_t length(const Storage_t &d) { return d[1]; }
  static Element_t min(const Storage_t &d) {
    return (length(d) >= 0 ? first(d) : last(d));
  }
  static Element_t max(const Storage_t &d) {
    return (length(d) >= 0 ? last(d) : first(d));
  }
  static bool empty(const Storage_t &d) { return false; }
  static int loop(const Storage_t &) { return 0; }
  static Element_t elem(const Storage_t &d, int n) { return d[0] + n*d[1]; }
  static OneDomain_t &getDomain(Domain_t &d, int) { return d; }
  static const OneDomain_t &getDomain(const Domain_t &d, int) { return d; }
  static void initializeStorage(Storage_t &dom) {
    dom[0] = 0;
    dom[1] = 0;
  }
  template<class DT>
  static void setDomain(Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    dom[0] = DomainTraits<DT>::getFirst(newdom);
    dom[1] = DomainTraits<DT>::getLast(newdom) - dom[0];
  }
  static void setDomain(Storage_t &dom, Element_t begval, Element_t endval) {
    dom[0] = begval;
    dom[1] = (endval - begval);
  }
  static void setLoop(Storage_t &, int) { }
  template<class UT, class DT>
  static void setWildcardDomain(Storage_t &dom, const UT &u, const DT &newdom)
  {
    PoomaCTAssert<(DomainTraits<DT>::wildcard)>::test();
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    PoomaCTAssert<(DomainTraits<UT>::dimensions == 1)>::test();
    dom[0] = newdom.first(u);
    dom[1] = newdom.last(u) - dom[0];
  }
  template<class DT>
  static bool isLessThan(const Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    return (dom[1] < DomainTraits<DT>::getLength(newdom) ||
     (dom[1] == DomainTraits<DT>::getLength(newdom) &&
      dom[0] < DomainTraits<DT>::getFirst(newdom)));
  }
  template<class DT>
  static bool isEqualTo(const Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    return (dom[0] == DomainTraits<DT>::getFirst(newdom) &&
     dom[1] == DomainTraits<DT>::getLength(newdom));
  }
  template<class DT>
  static void addAccum(Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    dom[0] += DomainTraits<DT>::getFirst(newdom);
  }
  template<class DT>
  static void subtractAccum(Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::singleValued)>::test();
    PoomaCTAssert<(DomainTraits<DT>::dimensions == 1)>::test();
    dom[0] -= DomainTraits<DT>::getFirst(newdom);
  }
  template<class DT>
  static void multiplyAccum(Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::singleValued && DomainTraits<DT>::dimensions == 1)>::test();
    dom[0] *= DomainTraits<DT>::getFirst(newdom);
    dom[1] *= DomainTraits<DT>::getFirst(newdom);
  }
  template<class DT>
  static void divideAccum(Storage_t &dom, const DT &newdom) {
    PoomaCTAssert<(DomainTraits<DT>::singleValued && DomainTraits<DT>::dimensions == 1)>::test();
    dom[0] /= DomainTraits<DT>::getFirst(newdom);
    dom[1] /= DomainTraits<DT>::getFirst(newdom);
  }
  static void initializeIterator(const Storage_t &d, IteratorStorage_t &i) {
    i[0] = d[0];
    i[1] = d[1];
  }
  static void initializeIterator(const Storage_t &d1, const Storage_t &d2,
     IteratorStorage_t &i) {
    i[0] = d1[0] + d2[1] + d2[1];
    i[1] = d2[1];
  }
  static void copyIterator(IteratorStorage_t d, IteratorStorage_t &i) {
    i[0] = d[0];
    i[1] = d[1];
  }
  static Element_t currentIterator(IteratorStorage_t i) { return i[0]; }
  static bool compareIterator(IteratorStorage_t a, IteratorStorage_t b) {
    return (a[0] == b[0] && a[1] == b[1]);
  }
  static void incrementIterator(IteratorStorage_t &i) { i[0] += i[1]; }
  static void decrementIterator(IteratorStorage_t &i) { i[0] -= i[1]; }
};
template<int Dim1, int Dim2, class T>
struct DomainChangeDim<Region<Dim1,T>, Dim2>
{
  typedef Region<Dim1,T> OldType_t;
  typedef Region<Dim2,T> NewType_t;
  enum { oldDim = Dim1,
  newDim = Dim2 };
};
template<int Dim, class T = double>
class Region : public Domain<Dim, DomainTraits<Region<Dim,T> > >
{
  typedef DomainTraits< Region<Dim,T> > DT_t;
  typedef Domain<Dim, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Region() { }
  Region(const Pooma::NoInit &e)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(e) {
  }
  Region(const Region<Dim,T> &a)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain1<Region<Dim,T> >::fill(*this, a);
  }
  template<class T1>
  explicit Region(const T1 &a)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  template<class T1, class T2>
  Region(const T1 &a, const T2 &b)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain2<T1,T2>::fill(*this, a, b);
  }
  template<class T1, class T2, class T3>
  Region(const T1 &a, const T2 &b, const T3 &c)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain3<T1,T2,T3>::fill(*this, a, b, c);
  }
  template<class T1, class T2, class T3, class T4>
  Region(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain4<T1,T2,T3,T4>::fill(*this, a, b, c, d);
  }
  template<class T1, class T2, class T3, class T4, class T5>
  Region(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain5<T1,T2,T3,T4,T5>::fill(*this, a, b, c, d, e);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  Region(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
 const T6 &f)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain6<T1,T2,T3,T4,T5,T6>::fill(*this, a, b, c, d, e, f);
  }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  Region(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
 const T6 &f, const T7 &g)
    : Domain<Dim, DomainTraits<Region<Dim,T> > >(Pooma::NoInit()) {
    NewDomain7<T1,T2,T3,T4,T5,T6,T7>::fill(*this, a, b, c, d, e, f, g);
  }
  ~Region() { }
  template<class T1>
  Region<Dim,T> &operator=(const T1 &newdom) {
    return NewDomain1<T1>::fill(*this, newdom);
  }
  Region<Dim,T> &operator=(const Region<Dim,T> &newdom) {
    return NewDomain1<Region<Dim,T> >::fill(*this, newdom);
  }
protected:
private:
};
template<class T>
class Region<1,T> : public Domain<1, DomainTraits<Region<1,T> > >
{
  typedef DomainTraits< Region<1,T> > DT_t;
  typedef Domain<1, DT_t> Base_t;
public:
  typedef typename Base_t::iterator iterator;
  typedef typename Base_t::const_iterator const_iterator;
  typedef typename Base_t::blockIterator blockIterator;
  typedef typename Base_t::const_blockIterator const_blockIterator;
  typedef typename DT_t::Element_t Element_t;
  typedef typename DT_t::Domain_t Domain_t;
  typedef typename DT_t::OneDomain_t OneDomain_t;
  typedef typename DT_t::BlockDomain_t BlockDomain_t;
  typedef typename DT_t::AskDomain_t AskDomain_t;
  typedef typename DT_t::AddResult_t AddResult_t;
  typedef typename DT_t::MultResult_t MultResult_t;
  typedef typename DT_t::Storage_t Storage_t;
  enum { domain = DT_t::domain };
  enum { dimensions = DT_t::dimensions,
  sliceDimensions = DT_t::sliceDimensions };
  enum { loopAware = DT_t::loopAware };
  enum { singleValued = DT_t::singleValued };
  enum { unitStride = DT_t::unitStride };
  enum { wildcard = DT_t::wildcard };
  Region() { }
  Region(const Pooma::NoInit &e)
    : Domain<1, DomainTraits<Region<1,T> > >(e) {
  }
  Region(const Region<1,T> &a)
    : Domain<1, DomainTraits<Region<1,T> > >(Pooma::NoInit()) {
    NewDomain1<Region<1,T> >::fill(*this, a);
  }
  template<class T1>
  explicit Region(const T1 &a)
    : Domain<1, DomainTraits<Region<1,T> > >(Pooma::NoInit()) {
    NewDomain1<T1>::fill(*this, a);
  }
  Region(Element_t n)
    : Domain<1, DomainTraits<Region<1,T> > >(Pooma::NoInit()) {
    DomainTraits<Region<1,T> >::setDomain(this->domain_m, 0, n);
  }
  Region(Element_t m, Element_t n)
    : Domain<1, DomainTraits<Region<1,T> > >(Pooma::NoInit()) {
    DomainTraits<Region<1,T> >::setDomain(this->domain_m, m, n);
  }
  Region(Element_t m, Element_t n, Element_t)
    : Domain<1, DomainTraits<Region<1,T> > >(Pooma::NoInit()) {
    DomainTraits<Region<1,T> >::setDomain(this->domain_m, m, n);
  }
  template<class T1>
  Region<1,T> &operator=(const T1 &newdom) {
    return NewDomain1<T1>::fill(*this, newdom);
  }
  Region<1,T> &operator=(const Region<1,T> &newdom) {
    return NewDomain1<Region<1,T> >::fill(*this, newdom);
  }
  const OneDomain_t &operator[](int d) const { return *this; }
  OneDomain_t &operator[](int d) { return *this; }
};
template <int Dim, int C>
struct DomainDelta;
struct DomainDeltaStorage {};
template <int Dim, int C>
struct DomainTraits< DomainDelta<Dim, C> >
  : public DomainTraitsDomain<DomainDelta<Dim, C>, int, Dim>
{
  typedef DomainTraitsDomain<DomainDelta<Dim, C>, int, Dim> Base_t;
  typedef typename Base_t::Element_t Element_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef typename Base_t::NewDomain1_t NewDomain1_t;
  typedef DomainDelta<1, C> OneDomain_t;
  typedef DomainDelta<1, C> PointDomain_t;
  typedef DomainDelta<Dim, C> BlockDomain_t;
  typedef DomainDelta<Dim, C> AskDomain_t;
  typedef Loc<Dim> AddResult_t;
  typedef Loc<Dim> MultResult_t;
  typedef DomainDeltaStorage Storage_t;
  enum { domain = Base_t::domain };
  enum { dimensions = Base_t::dimensions,
  sliceDimensions = 0 };
  enum { loopAware = false };
  enum { singleValued = true };
  enum { unitStride = true };
  enum { wildcard = false };
  inline static void initializeStorage(Storage_t &dom) { }
  inline static OneDomain_t getDomain(const Domain_t &d, int) { return OneDomain_t(); }
  inline static PointDomain_t getPointDomain(const Domain_t &d, int) { return PointDomain_t(); }
};
template <int Dim, int C>
class DomainDelta : public Domain<Dim, DomainTraits<DomainDelta<Dim, C> > > {
 public:
  enum { component = C };
  inline DomainDelta()
    : Domain<Dim, DomainTraits<DomainDelta<Dim, C> > >(Pooma::NoInit()) {}
  inline DomainDelta(const DomainDelta<Dim, C>&)
    : Domain<Dim, DomainTraits<DomainDelta<Dim, C> > >(Pooma::NoInit()) {}
  inline DomainDelta(const Pooma::NoInit &a)
    : Domain<Dim, DomainTraits<DomainDelta<Dim, C> > >(a) {}
  inline ~DomainDelta() {}
  inline DomainDelta<Dim, C> &operator=(const DomainDelta<Dim, C>&) { return *this; }
};
template<class T, int Dim, int C>
inline typename T::AddResult_t
operator+(const DomainBase<T> &d1, const DomainDelta<Dim, C> &d2) {
  typename T::AddResult_t retval(d1.unwrap());
  return (retval += d2);
}
template<class T, int Dim, int C>
inline typename T::AddResult_t
operator-(const DomainBase<T> &d1, const DomainDelta<Dim, C> &d2) {
  typename T::AddResult_t retval(d1.unwrap());
  return (retval -= d2);
}
template<int Dim>
class AllDomain
{
public:
  typedef AllDomain<Dim> Domain_t;
  typedef AllDomain<Dim> NewDomain1_t;
  typedef AllDomain<1> OneDomain_t;
  typedef int Element_t;
  enum { dimensions = Dim };
  AllDomain() {
    PoomaCTAssert<(Dim > 0)>::test();
  }
  AllDomain(const AllDomain<Dim> &) {
    PoomaCTAssert<(Dim > 0)>::test();
  }
  ~AllDomain() { }
  OneDomain_t operator[](int) const { return OneDomain_t(); }
  void setDomain(const AllDomain<Dim> &) { }
  template<class T>
  typename DomainTraits<T>::Element_t first(const T &u) const {
    return u.first();
  }
  int first(int u) const { return u; }
  template<class T>
  typename DomainTraits<T>::Element_t length(const T &u) const {
    return u.length();
  }
  int length(int) const { return 1; }
  template<class T>
  typename DomainTraits<T>::Element_t stride(const T &u) const {
    return u.stride();
  }
  int stride(int) const { return 1; }
  AllDomain<Dim> &operator=(const AllDomain<Dim> &) { return *this; }
protected:
private:
};
template<int Dim>
struct DomainTraits< AllDomain<Dim> >
{
  typedef AllDomain<Dim> Domain_t;
  typedef AllDomain<Dim> NewDomain1_t;
  typedef AllDomain<1> OneDomain_t;
  typedef AllDomain<1> PointDomain_t;
  typedef AllDomain<Dim> AskDomain_t;
  enum { domain = true };
  enum { dimensions = Dim,
  sliceDimensions = Dim };
  enum { wildcard = true };
  enum { singleValued = false };
  static OneDomain_t getDomain(const Domain_t &, int) {
    return OneDomain_t();
  }
  static PointDomain_t getPointDomain(const Domain_t &, int) {
    return PointDomain_t();
  }
};
template<int Dim>
class LeftDomain
{
public:
  typedef LeftDomain<Dim> Domain_t;
  typedef LeftDomain<1> OneDomain_t;
  typedef int Element_t;
  enum { dimensions = Dim };
  LeftDomain() : endpoints_m(Pooma::NoInit()) { PoomaCTAssert<(Dim > 0)>::test(); }
  LeftDomain(const LeftDomain<Dim> &d) : endpoints_m(d.endpoints_m) {
    PoomaCTAssert<(Dim > 0)>::test();
  }
  template<class T1>
  explicit LeftDomain(const T1 &a)
    : endpoints_m(a) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2>
  LeftDomain(const T1 &a, const T2 &b)
    : endpoints_m(a,b) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3>
  LeftDomain(const T1 &a, const T2 &b, const T3 &c)
    : endpoints_m(a,b,c) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4>
  LeftDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : endpoints_m(a,b,c,d) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5>
  LeftDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : endpoints_m(a,b,c,d,e) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  LeftDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f)
    : endpoints_m(a,b,c,d,e,f) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  LeftDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f, const T7 &g)
    : endpoints_m(a,b,c,d,e,f,g) { PoomaCTAssert<(Dim > 0)>::test(); }
  ~LeftDomain() { }
  OneDomain_t operator[](int n) const { return OneDomain_t(endpoints_m[n]); }
  void setDomain(const LeftDomain<Dim> &d) { endpoints_m = d.endpoints_m; }
  template<class T>
  typename DomainTraits<T>::Element_t first(const T &u) const {
    return u.first();
  }
  int first(int u) const { return u; }
  template<class T>
  typename DomainTraits<T>::Element_t length(const T &u) const {
    PoomaCTAssert<(Dim == 1)>::test();
    T dom(u.first(), endpoints_m[0].first(), u.stride());
    return dom.length();
  }
  int length(int u) const {
    PoomaCTAssert<(Dim == 1)>::test();
    Interval<1> dom(u, endpoints_m[0].first());
    return dom.length();
  }
  template<class T>
  typename DomainTraits<T>::Element_t stride(const T &u) const {
    return u.stride();
  }
  int stride(int) const { return 1; }
  LeftDomain<Dim> &operator=(const LeftDomain<Dim> &d) {
    endpoints_m = d.endpoints_m;
    return *this;
  }
protected:
private:
  Loc<Dim> endpoints_m;
};
template<int Dim>
struct DomainTraits< LeftDomain<Dim> >
{
  typedef LeftDomain<Dim> Domain_t;
  typedef LeftDomain<1> OneDomain_t;
  typedef LeftDomain<1> PointDomain_t;
  typedef LeftDomain<Dim> AskDomain_t;
  enum { domain = true };
  enum { dimensions = Dim,
  sliceDimensions = Dim };
  enum { wildcard = true };
  enum { singleValued = false };
  static OneDomain_t getDomain(const Domain_t &d, int n) {
    return d[n];
  }
  static PointDomain_t getPointDomain(const Domain_t &d, int n) {
    return d[n];
  }
};
template<int Dim>
class RightDomain
{
public:
  typedef RightDomain<Dim> Domain_t;
  typedef RightDomain<1> OneDomain_t;
  typedef int Element_t;
  enum { dimensions = Dim };
  RightDomain() : endpoints_m(Pooma::NoInit()) { PoomaCTAssert<(Dim > 0)>::test(); }
  RightDomain(const RightDomain<Dim> &d) : endpoints_m(d.endpoints_m) {
    PoomaCTAssert<(Dim > 0)>::test();
  }
  template<class T1>
  explicit RightDomain(const T1 &a)
    : endpoints_m(a) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2>
  RightDomain(const T1 &a, const T2 &b)
    : endpoints_m(a,b) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3>
  RightDomain(const T1 &a, const T2 &b, const T3 &c)
    : endpoints_m(a,b,c) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4>
  RightDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d)
    : endpoints_m(a,b,c,d) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5>
  RightDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e)
    : endpoints_m(a,b,c,d,e) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6>
  RightDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f)
    : endpoints_m(a,b,c,d,e,f) { PoomaCTAssert<(Dim > 0)>::test(); }
  template<class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  RightDomain(const T1 &a, const T2 &b, const T3 &c, const T4 &d, const T5 &e,
      const T6 &f, const T7 &g)
    : endpoints_m(a,b,c,d,e,f,g) { PoomaCTAssert<(Dim > 0)>::test(); }
  ~RightDomain() { }
  OneDomain_t operator[](int n) const { return OneDomain_t(endpoints_m[n]); }
  void setDomain(const RightDomain<Dim> &d) { endpoints_m = d.endpoints_m; }
  template<class T>
  typename DomainTraits<T>::Element_t first(const T &u) const {
    return endpoints_m[0].first();
  }
  int first(int u) const { return u; }
  template<class T>
  typename DomainTraits<T>::Element_t length(const T &u) const {
    PoomaCTAssert<(Dim == 1)>::test();
    T dom(endpoints_m[0].first(), u.last(), u.stride());
    return dom.length();
  }
  int length(int u) const {
    PoomaCTAssert<(Dim == 1)>::test();
    Interval<1> dom(endpoints_m[0].first(), u);
    return dom.length();
  }
  template<class T>
  typename DomainTraits<T>::Element_t stride(const T &u) const {
    return u.stride();
  }
  int stride(int) const { return 1; }
  RightDomain<Dim> &operator=(const RightDomain<Dim> &d) {
    endpoints_m = d.endpoints_m;
    return *this;
  }
protected:
private:
  Loc<Dim> endpoints_m;
};
template<int Dim>
struct DomainTraits< RightDomain<Dim> >
{
  typedef RightDomain<Dim> Domain_t;
  typedef RightDomain<1> OneDomain_t;
  typedef RightDomain<1> PointDomain_t;
  typedef RightDomain<Dim> AskDomain_t;
  enum { domain = true };
  enum { dimensions = Dim,
  sliceDimensions = Dim };
  enum { wildcard = true };
  enum { singleValued = false };
  static OneDomain_t getDomain(const Domain_t &d, int n) {
    return d[n];
  }
  static PointDomain_t getPointDomain(const Domain_t &d, int n) {
    return d[n];
  }
};
template<class T1, class T2, class T3, int Dim, bool strided>
struct EquivSubsetDomainSingle {
  static void equiv(const T1 &a, const T2 &b, T3 &d) {
    d[Dim-1] += (b.first() - a.first());
  }
};
template<class T1, class T2, class T3, int Dim>
struct EquivSubsetDomainSingle<T1,T2,T3,Dim,true> {
  static void equiv(const T1 &a, const T2 &b, T3 &d) {
    typedef typename DomainTraits<T3>::Element_t E3_t;
    E3_t m = b.stride() / a.stride();
    ;
    E3_t k = b.first() - m * a.first();
    d[Dim-1] *= m;
    d[Dim-1] += k;
  }
};
template<class T1, class T2, class T3, int Dim>
struct EquivSubsetDomain {
  enum { strided = !DomainTraits<T3>::unitStride };
  static void equiv(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    EquivSubsetDomainSingle<Dom1_t,Dom2_t,T3,Dim,strided>::equiv(
      DomainTraits<T1>::getDomain(a,Dim-1),
      DomainTraits<T2>::getDomain(b,Dim-1), c);
    EquivSubsetDomain<T1,T2,T3,Dim-1>::equiv(a,b,c);
  }
};
template<class T1, class T2, class T3>
struct EquivSubsetDomain<T1,T2,T3,1> {
  enum { strided = !DomainTraits<T3>::unitStride };
  static void equiv(const T1 &a, const T2 &b, T3 &c) {
    typedef typename DomainTraits<T1>::OneDomain_t Dom1_t;
    typedef typename DomainTraits<T2>::OneDomain_t Dom2_t;
    EquivSubsetDomainSingle<Dom1_t,Dom2_t,T3,1,strided>::equiv(
      DomainTraits<T1>::getDomain(a,0), DomainTraits<T2>::getDomain(b,0), c);
  }
};
template<class T1, class T2, class T3>
struct EquivSubsetReturnType {
  typedef typename NewDomain3<T1,T2,T3>::Type_t Combine_t;
  typedef typename
    DomainChangeDim<Combine_t,DomainTraits<T1>::dimensions>::NewType_t Type_t;
};
template<class T1, class T2, class T3>
inline typename EquivSubsetReturnType<T1,T2,T3>::Type_t
equivSubset(const T1 &a, const T2 &b, const T3 &c)
{
  typedef typename EquivSubsetReturnType<T1,T2,T3>::Type_t T4;
  PoomaCTAssert<((int)DomainTraits<T1>::dimensions == DomainTraits<T2>::dimensions)>::test();
  PoomaCTAssert<((int)DomainTraits<T1>::dimensions == DomainTraits<T3>::dimensions)>::test();
  T4 d = c;
  EquivSubsetDomain<T1,T2,T4,DomainTraits<T1>::dimensions>::equiv(a, b, d);
  return d;
}
namespace Pooma {
class Tester
{
public:
  Tester();
  Tester(int argc, char **argv);
  ~Tester();
  inline Inform &out()
    {
      return inform_m;
    }
  inline bool ok() const
    {
      return ok_m;
    }
  inline int returnValue() const
    {
      return (ok() ? 0 : 1);
    }
  inline bool check(bool val)
    {
      ok_m = (ok_m && val);
      if (!ok_m && abort_m)
        {
          if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Check failed!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Utilities/Tester.h", 163);
        }
      return val;
    }
  inline bool check(const char *str, bool val)
    {
      check(val);
      if (str != 0)
 out() << "Checking " << str;
      else
 out() << "Checking";
      out() << ": check = " << val << ", updated status = " << ok_m;
      out() << std::endl;
      return val;
    }
  template<class T>
  bool check(const char *str, const T &val, const T &correct)
    {
      bool res = check(val == correct);
      if (str != 0)
 out() << "Checking " << str;
      else
 out() << "Checking";
      out() << ": val = " << val << ", correct = " << correct
            << ", updated status = " << ok_m;
      out() << std::endl;
      return res;
    }
  template<class T>
  bool check(const char *str, const T &val, const T &correct,
    const T &tol)
    {
      bool res = check(std::abs(val - correct) < tol);
      if (str != 0)
 out() << "Checking " << str;
      else
 out() << "Checking";
      out() << ": val = " << val << ", correct = " << correct
            << ", updated status = " << ok_m;
      out() << std::endl;
      return res;
    }
  inline void set(bool val)
    {
      ok_m = val;
    }
  inline void setQuiet(bool quiet) {
    quiet_m = quiet;
    if (!verbose_m || quiet_m) {
      out().setOutputLevel(Inform::off);
    } else {
      out().setOutputLevel(Inform::on);
    }
  }
  inline void setVerbose(bool verbose) {
    verbose_m = verbose;
    if (!verbose_m || quiet_m) {
      out().setOutputLevel(Inform::off);
    } else {
      out().setOutputLevel(Inform::on);
    }
  }
  inline bool verbose() { return verbose_m; }
  inline void setPrefix(char *prefix) { out().setPrefix(prefix); }
  int results(const char *msg = 0) const;
  void exceptionHandler(const char *msg = 0);
  void exceptionHandler(const Assertion &asrt);
private:
  bool ok_m;
  bool quiet_m;
  Inform inform_m;
  bool verbose_m;
  bool abort_m;
  void parse(int argc, char **argv);
};
}
template <int Dim>
std::vector<Interval<Dim> >
DomainRemoveOverlap(const Interval<Dim> & s,const Interval<Dim> &r)
{
  typedef Interval<Dim> Domain_t;
  typedef std::vector<Domain_t> DomainList_t;
  DomainList_t result,temp;
  result.push_back(s);
  for (int i=0;i<Dim;++i)
    {
      typename DomainList_t::iterator start = result.begin();
      typename DomainList_t::iterator end = result.end();
      for ( ; start!=end; ++start)
 {
   if (touches( (*start)[i], Loc<1>(r[i].min())))
     {
       Domain_t lower=*start,upper=*start;
       if(r[i].min()-1>=lower[i].min())
  {
    lower[i] = Interval<1>(lower[i].min(),r[i].min()-1);
    temp.push_back(lower);
  } upper[i] = Interval<1>(r[i].min(),upper[i].max());
       temp.push_back(upper);
     }
   else
     temp.push_back(*start);
 }
      result = temp;
      temp.clear();
      start = result.begin();
      end = result.end();
      for ( ; start!=end; ++start)
 {
   if (touches( (*start)[i], Loc<1>(r[i].max())))
     {
       Domain_t lower=*start,upper=*start;
       lower[i] = Interval<1>(lower[i].min(),r[i].max());
       temp.push_back(lower);
       if( r[i].max()+1 <= upper[i].max())
  {
    upper[i] = Interval<1>(r[i].max()+1,upper[i].max());
    temp.push_back(upper);
  }
     }
   else
     temp.push_back(*start);
 }
      result=temp;
      temp.clear();
    }
  typename DomainList_t::iterator start = result.begin();
  typename DomainList_t::iterator end = result.end();
  for ( ; start!=end ; ++start)
    {
      if (!touches(*start,r ) )
 temp.push_back(*start);
    }
  return temp;
}
template <int Dim>
Grid<Dim> makeRGrid(const Interval<Dim> & gdom, const Loc<Dim> & blocks);
template<int Dim>
class UniformGridPartition;
template<int Dim>
class GridPartition
{
public:
  typedef LocalMapper<Dim> DefaultMapper_t;
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  enum { uniform = false };
  enum { gridded = true };
  enum { tile = false };
  enum { general = false };
  enum { dimensions = Dim };
  GridPartition(const Grid<Dim> &g)
    : hasInternalGuards_m(false),
      hasExternalGuards_m(false),
      internalGuards_m(0),
      externalGuards_m(0),
      grid_m(g)
  {
    num_m=1;
    for (int i=0;i<Dim;i++)
      {
 blocks_m[i] = Loc<1>(grid_m[i].size()-1);
 num_m*=blocks_m[i].first();
      }
  }
  GridPartition(const Grid<Dim> &g,
  const GuardLayers<Dim> &gcs)
    : hasInternalGuards_m(true),
      hasExternalGuards_m(true),
      internalGuards_m(gcs),
      externalGuards_m(gcs),
      grid_m(g)
  {
    num_m=1;
    for (int i=0;i<Dim;i++)
      {
 blocks_m[i] = Loc<1>(grid_m[i].size()-1);
 num_m*=blocks_m[i].first();
      }
  }
  GridPartition(const Grid<Dim> &g,
  const GuardLayers<Dim> &igcs,
  const GuardLayers<Dim> &egcs)
    : hasInternalGuards_m(true),
      hasExternalGuards_m(true),
      internalGuards_m(igcs),
      externalGuards_m(egcs),
      grid_m(g)
  {
    num_m=1;
    for (int i=0;i<Dim;i++)
      {
 blocks_m[i] = Loc<1>(grid_m[i].size()-1);
 num_m*=(grid_m[i].size()-1);
      }
  }
  GridPartition()
    : hasInternalGuards_m(false),
      hasExternalGuards_m(false),
      internalGuards_m(0),
      externalGuards_m(0),
      num_m(1)
  {
    for (int i=0;i<Dim;++i)
      blocks_m[i]=Loc<1>(1);
  }
  GridPartition(const Loc<Dim> &a)
    : blocks_m(a),
      hasInternalGuards_m(false),
      hasExternalGuards_m(false),
      internalGuards_m(0),
      externalGuards_m(0)
  {
    num_m = blocks_m[0].first();
    for (int d=1; d < Dim; ++d)
      num_m *= blocks_m[d].first();
  }
  GridPartition(const Loc<Dim> &a,
  const GuardLayers<Dim> &gcs)
    : blocks_m(a),
      hasInternalGuards_m(true),
      hasExternalGuards_m(true),
      internalGuards_m(gcs),
      externalGuards_m(gcs)
  {
    num_m = blocks_m[0].first();
    for (int d=1; d < Dim; ++d)
      num_m *= blocks_m[d].first();
  }
  GridPartition(const Loc<Dim> &a,
  const GuardLayers<Dim> &igcs,
  const GuardLayers<Dim> &egcs)
    : blocks_m(a),
      hasInternalGuards_m(true),
      hasExternalGuards_m(true),
      internalGuards_m(igcs),
      externalGuards_m(egcs)
  {
    num_m = blocks_m[0].first();
    for (int d=1; d < Dim; ++d)
      num_m *= blocks_m[d].first();
  }
  GridPartition(const GridPartition<Dim> & b)
    : blocks_m(b.blocks_m),
      hasInternalGuards_m(b.hasInternalGuards_m),
      hasExternalGuards_m(b.hasExternalGuards_m),
      internalGuards_m(b.internalGuards_m),
      externalGuards_m(b.externalGuards_m),
      num_m(b.num_m),
      grid_m(b.grid_m)
  {
  }
 GridPartition(const UniformGridPartition<Dim> & b)
   : blocks_m(b.blocks_m),
     hasInternalGuards_m(b.hasInternalGuards_m),
     hasExternalGuards_m(b.hasExternalGuards_m),
     internalGuards_m(b.internalGuards_m),
     externalGuards_m(b.externalGuards_m),
     num_m(b.num_m)
  {}
  ~GridPartition() { }
  GridPartition<Dim> &operator=(const GridPartition<Dim> &g)
  {
    if (this != &g)
      {
 hasInternalGuards_m = g.hasInternalGuards_m;
 hasExternalGuards_m = g.hasExternalGuards_m;
 internalGuards_m = g.internalGuards_m;
 externalGuards_m = g.externalGuards_m;
 blocks_m = g.blocks();
 num_m = g.maxSize();
 grid_m = g.grid();
 if (!hasInternalGuards_m)
   internalGuards_m = GuardLayers<Dim>(0);
 if (!hasExternalGuards_m)
   externalGuards_m = GuardLayers<Dim>(0);
      }
    return *this;
  }
  int maxSize() const { return num_m; }
  const Loc<Dim> &blocks() const { return blocks_m; }
  bool hasGuards() const { return hasInternalGuards_m||hasExternalGuards_m; }
  bool hasCustomEdgeGuards() const
  {
    if (hasInternalGuards_m&&!hasExternalGuards_m) return true;
    if (!hasInternalGuards_m&&hasExternalGuards_m) return true;
    if (hasInternalGuards_m&&hasExternalGuards_m
       &&(internalGuards_m!=externalGuards_m)) return true;
    return false;
  }
  bool hasInternalGuards() const { return hasInternalGuards_m; }
  bool hasExternalGuards() const { return hasExternalGuards_m;}
  const Grid<Dim> &grid() const { return grid_m;}
  const GuardLayers<Dim> &internalGuards() const
  {
    return internalGuards_m;
  }
  const GuardLayers<Dim> &externalGuards() const
  {
    return externalGuards_m;
  }
  template<class D>
  int partition(const D &domain,
  List_t & all,
  const ContextMapper<Dim> &cmapper ) const;
  template<class D>
  int partition(const D &domain,
  List_t & all) const
  {
    return partition(domain,all,DefaultMapper_t(*this));
  }
  template<class Out>
  void print(Out &o) const;
private:
  Loc<Dim> blocks_m;
  bool hasInternalGuards_m;
  bool hasExternalGuards_m;
  GuardLayers<Dim> internalGuards_m;
  GuardLayers<Dim> externalGuards_m;
  int num_m;
  Grid<Dim> grid_m;
};
template<int Dim>
template<class D>
int GridPartition<Dim>::partition(const D &domain,
      List_t & all,
      const ContextMapper<Dim> &cmapper ) const
{
  typedef typename DomainTraits<Domain_t>::Element_t Element_t;
  PoomaCTAssert<(Dim == DomainTraits<D>::dimensions)>::test();
  PoomaCTAssert<(Dim == DomainTraits<Domain_t>::dimensions)>::test();
  Grid<Dim> tgrid = grid();
  if (domain.empty())
    {
      int np = 1;
      for (int i=0;i<Dim;++i)
 np*=blocks()[i].first();
      int start=0;
      Domain_t o;
      Domain_t a;
      while (start<np)
 {
   int gid = all.size();
   int lid = -1;
   Value_t *node = new Value_t(o, a, -1, gid, lid);
   all.push_back(node);
   ++start;
 }
      cmapper.map(all);
      return maxSize();
    }
  if (tgrid.empty()&&!domain.empty() )
    {
      tgrid = makeRGrid(domain,blocks_m);
    }
  typename Grid<Dim>::blockIterator start = tgrid.beginBlock();
  typename Grid<Dim>::blockIterator end = tgrid.endBlock();
  while (start!=end)
    {
      Loc<Dim> idx = start.point();
      Domain_t o = Pooma::NoInit();
      o = * start;
      Domain_t a = Pooma::NoInit();
      a = * start;
      if (hasInternalGuards()||hasExternalGuards())
 {
   for (int i=0;i<Dim;i++)
     {
       if (idx[i]==0)
  {
    if (hasExternalGuards())
      {
        o[i]=Interval<1>(o[i].first()-externalGuards().lower(i),
           o[i].last());
        a[i]=Interval<1>(a[i].first()-externalGuards().lower(i),
           a[i].last());
      }
    if (hasInternalGuards() && idx[i]!=(blocks()[i].first()-1))
      a[i]=Interval<1>(a[i].first(),
         a[i].last()+internalGuards().upper(i));
  }
       if (idx[i]==blocks()[i].first()-1)
  {
    if (hasExternalGuards())
      {
        o[i]=Interval<1>(o[i].first(),
           o[i].last()+externalGuards().upper(i));
        a[i]=Interval<1>(a[i].first(),
           a[i].last()+externalGuards().upper(i));
      }
    if (hasInternalGuards()&&(idx[i]!=0))
      a[i]=Interval<1>(a[i].first()-internalGuards().lower(i),
         a[i].last());
  }
       if (idx[i]!=0&&
    idx[i]!=(blocks()[i].first()-1)&&
    hasInternalGuards())
  a[i]=Interval<1>(o[i].first()-internalGuards().lower(i),
     o[i].last()+internalGuards().upper(i));
     }
 }
      int gid = all.size();
      int lid = -1;
      Value_t *node = new Value_t(o, a, -1, gid, lid);
      all.push_back(node);
      ++start;
    }
  cmapper.map(all);
  return maxSize();
}
template<int Dim>
template<class Out>
void GridPartition<Dim>::print(Out &o) const
{
  int i;
  o << "GridPartition<" << Dim << ">:" << std::endl;
  o << "  blocks_m = " << blocks_m << std::endl;
  o << "  hasInternalGuards_m  hasExternalGuards_m = ";
  o << hasInternalGuards_m<< " "<<hasExternalGuards_m<< std::endl;
  o << "  internalGuards_m:" << std::endl;
  o << "      upper       ";
  for (i=0; i < Dim; ++i)
    o << internalGuards_m.upper(i) << " ";
  o << std::endl;
  o << "      lower       ";
  for (i=0; i < Dim; ++i)
    o << internalGuards_m.lower(i) << " ";
  o << std::endl;
  o << "  externalGuards_m:" << std::endl;
  o << "      upper       ";
  for (i=0; i < Dim; ++i)
    o << externalGuards_m.upper(i) << " ";
  o << std::endl;
  o << "      lower       ";
  for (i=0; i < Dim; ++i)
    o << externalGuards_m.lower(i) << " ";
  o << std::endl;
  o << "  num_m = " << num_m << std::endl;
  o << "  grid_m = ";
  if (grid_m.empty() )
    o << "(empty)" << std::endl;
  else
    o << grid_m << std::endl;
}
template <int Dim>
std::ostream &operator<<(std::ostream &o, const GridPartition<Dim> &gp)
{
  gp.print(o);
  return o;
}
template <int Dim>
Grid<Dim> makeRGrid(const Interval<Dim> &gdom, const Loc<Dim> &blocks)
{
  Grid<Dim> ret;
  for (int i=0;i<Dim;++i)
    {
      if (gdom[i].size()%blocks[i].first()==0&& !gdom[i].empty())
 {
   ret[i]=Grid<1>(Range<1>(gdom[i].first(),
      gdom[i].last()+1,
      (int) gdom[i].size()/blocks[i].first()));
 }
      else if (!gdom[i].empty() )
 {
   IndirectionList<int> rret(blocks[i].first()+1);
   rret(0) = gdom[i].first();
   for (int j = 1;j<blocks[i].first()+1;++j)
     {
       int temp = (int) gdom[i].size()/blocks[i].first();
       rret(j)= rret(j-1) + temp ;
       rret(j) += (j > (blocks[i].first() -
          (gdom[i].size()- temp*blocks[i].first()) ) );
     }
   ret[i]=Grid<1>(rret);
 }
      else
 {
 }
    }
  return ret;
}
template <typename T>
std::vector<T> makeRBlocksFactor(T number)
{
  std::vector<T> factors;
  for (T f=2; f<number; f++) {
    while (number % f == 0) {
      factors.push_back(f);
      number /= f;
    }
  }
  if (number != 1)
    factors.push_back(number);
  return factors;
}
template <int Dim>
Loc<Dim> makeRBlocks(const Interval<Dim>& domain, int nodes)
{
  typedef typename std::vector<int>::reverse_iterator riterator_t;
  std::vector<int> df[Dim];
  std::vector<int> nf;
  for (int i=0; i<Dim; i++)
    df[i] = makeRBlocksFactor<int>(domain[i].size());
  nf = makeRBlocksFactor<int>(nodes);
  int setup[Dim];
  for (int i=0; i<Dim; i++)
    setup[i] = 1;
  int sdi[Dim];
  for (int i=0; i<Dim; i++)
    sdi[i] = i;
  for (riterator_t ni = nf.rbegin(); ni < nf.rend(); ni++) {
    bool changed;
    do {
      changed = false;
      for (int i=0; i<Dim-1; i++)
 if (domain[sdi[i]].size()/setup[sdi[i]]
     < domain[sdi[i+1]].size()/setup[sdi[i+1]]) {
   std::swap(sdi[i+1], sdi[i]);
   changed = true;
 }
    } while (changed);
    int i = sdi[0];
    riterator_t di;
    for (di = df[i].rbegin(); di < df[i].rend(); di++) {
      if ((*di) == (*ni)) {
 setup[i] *= (*ni);
 break;
      }
    }
    if (di == df[i].rend())
      setup[i] *= (*ni);
  }
  Loc<Dim> result;
  for (int i=0; i<Dim; i++)
    result[i] = setup[i];
  return result;
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData()
  : Observable<SparseTileLayoutData>(*this)
{
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &boundingbox,
      const PatchList_t & PatchList,
      const ContextMapper<Dim> &cmap)
 : LayoutBaseData<Dim>(false,false,
         GuardLayers_t(0),GuardLayers_t(0),
         boundingbox,boundingbox),
   Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  initialize(boundingbox,PatchList,cmap);
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &boundingbox,
      const GuardLayers_t & globalGL,
      const PatchList_t & PatchList,
      const ContextMapper<Dim> &cmap)
  : LayoutBaseData<Dim>(true,true,
   globalGL,globalGL,
   boundingbox,boundingbox),
  Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  initialize(boundingbox,globalGL,PatchList,cmap);
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &boundingbox,
      const GuardLayers_t & internalGL,
      const GuardLayers_t & externalGL,
      const PatchList_t & PatchList,
      const ContextMapper<Dim> &cmap)
 : LayoutBaseData<Dim>(true,true,
   internalGL,externalGL,
         boundingbox,boundingbox),
  Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  initialize(boundingbox,internalGL,externalGL,PatchList,cmap );
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &boundingbox)
  : LayoutBaseData<Dim>(false, false,
   GuardLayers_t(),GuardLayers_t(),
   boundingbox,boundingbox),
  Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  initialize(boundingbox);
}
template<int Dim>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &boundingbox,
      const GuardLayers_t & internalGL,
      const GuardLayers_t & externalGL)
  : LayoutBaseData<Dim>(true, true,
   internalGL,externalGL,
   boundingbox,boundingbox),
  Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  initialize(boundingbox,internalGL,externalGL);
}
template<int Dim>
template<class Partitioner>
SparseTileLayoutData<Dim>::SparseTileLayoutData(const Domain_t &bbox,
      const Partitioner &gpar,
      const ContextMapper<Dim> &cmap)
   : LayoutBaseData<Dim>(false,false,
     GuardLayers_t(0),GuardLayers_t(0),
     bbox,bbox),
    Observable<SparseTileLayoutData>(*this)
{
  this->blocks_m = Loc<Dim>();
  if (gpar.hasInternalGuards() && gpar.maxSize() > 1)
    {
      this->hasInternalGuards_m = true;
      this->internalGuards_m = gpar.internalGuards();
    }
  if (gpar.hasExternalGuards())
    {
      this->hasExternalGuards_m = true;
      this->externalGuards_m = gpar.externalGuards();
      GuardLayers<Dim>::addGuardLayers(this->domain_m,this->externalGuards_m);
    }
  initialize(bbox, gpar,cmap);
}
template<int Dim>
SparseTileLayoutData<Dim>::~SparseTileLayoutData()
{
  for (typename List_t::iterator a = this->all_m.begin(); a != this->all_m.end(); ++a)
    delete (*a);
}
template<int Dim>
void SparseTileLayoutData<Dim>::syncPatch()
{
  typename List_t::iterator start = this->all_m.begin();
  typename List_t::iterator end = this->all_m.end();
  for ( ; start != end ; ++start)
    if ( (*start)->context() == Pooma::context()
  ||(*start)->context() == -1 )
      this->local_m.push_back(*start);
    else
      this->remote_m.push_back(*start);
   calcMaps();
   calcAllocMaps();
   calcGCFillList();
}
template<int Dim>
void SparseTileLayoutData<Dim>::calcMaps()
{
  if (!this->initialized())
    return;
  map_m.zap();
  map_m.initialize(this->domain_m);
  typename List_t::const_iterator start = this->all_m.begin();
  typename List_t::const_iterator end = this->all_m.end();
  int i=0;
  for ( ; start != end ; ++start, ++i )
    {
      pidx_t tmp((*start)->globalID(),i);
      typename DomainMap<Domain_t,pidx_t>::Value_t val((*start)->domain(),tmp);
      map_m.insert(val);
    }
  map_m.update();
}
template<int Dim>
void SparseTileLayoutData<Dim>::calcAllocMaps()
{
  if (!this->initialized())
    return;
  mapAloc_m.zap();
  mapAloc_m.initialize(this->domain_m);
  typename List_t::const_iterator start = this->all_m.begin();
  typename List_t::const_iterator end = this->all_m.end();
  int i=0;
  for ( ; start!=end ; ++start , ++i)
    {
      pidx_t tmp((*start)->globalID(),i);
      typename DomainMap<Domain_t,pidx_t>::Value_t val((*start)->allocated(),tmp);
      mapAloc_m.insert(val);
    }
  mapAloc_m.update();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &gdom)
{
  this->blocks_m = Loc<Dim>();
  int i;
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  for(i=0;i<Dim;++i)
    this->firste_m[i] = this->firsti_m[i] = this->domain_m[i].first();
  this->domain_m = gdom;
  this->innerdomain_m = gdom;
  this->hasInternalGuards_m = this->hasExternalGuards_m = false;
  this->internalGuards_m = this->externalGuards_m = GuardLayers_t();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &gdom,
        const GuardLayers_t & globalGL)
{
  this->blocks_m = Loc<Dim>();
  int i;
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  this->domain_m = gdom;
  this->innerdomain_m = gdom;
  for(i=0;i<Dim;++i)
    this->firsti_m[i] = this->domain_m[i].first();
  this->hasInternalGuards_m = this->hasExternalGuards_m=true;
  this->internalGuards_m = this->externalGuards_m = globalGL;
  GuardLayers<Dim>::addGuardLayers(this->domain_m, this->externalGuards_m);
  for(i=0;i<Dim;++i)
    this->firste_m[i]=this->domain_m[i].first();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &gdom,
         const GuardLayers_t & internalGL,
         const GuardLayers_t & externalGL)
{
  this->blocks_m = Loc<Dim>();
  int i;
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  this->domain_m = gdom;
  this->innerdomain_m = gdom;
  for(i=0;i<Dim;++i)
    this->firsti_m[i]=this->domain_m[i].first();
  this->hasInternalGuards_m = this->hasExternalGuards_m = true;
  this->internalGuards_m = internalGL;
  this->externalGuards_m = externalGL;
  GuardLayers<Dim>::addGuardLayers(this->domain_m, this->externalGuards_m);
  for(i=0;i<Dim;++i)
    this->firste_m[i] = this->domain_m[i].first();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &bbox,
        const PatchList_t &plist,
        const ContextMapper<Dim> &cmap)
{
  this->blocks_m = Loc<Dim>();
  initialize(bbox);
  TilePartition<Dim> gpar(plist);
  gpar.partition(bbox,this->all_m,cmap);
  syncPatch();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &bbox,
        const GuardLayers_t & globalGL,
        const PatchList_t &plist,
        const ContextMapper<Dim> &cmap)
{
  this->blocks_m = Loc<Dim>();
  initialize(bbox,globalGL);
  TilePartition<Dim> gpar(bbox,plist,globalGL);
  gpar.partition(bbox,this->all_m,cmap);
  syncPatch();
}
template<int Dim>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &bbox,
        const GuardLayers_t & internalGL,
        const GuardLayers_t & externalGL,
        const PatchList_t &plist,
        const ContextMapper<Dim> &cmap)
{
  this->blocks_m = Loc<Dim>();
  initialize(bbox,internalGL,externalGL);
  TilePartition<Dim> gpar(bbox,plist,internalGL,externalGL);
  gpar.partition(bbox,this->all_m,cmap);
  syncPatch();
}
template<int Dim>
template<class Partitioner>
void SparseTileLayoutData<Dim>::initialize(const Domain_t &bbox,
        const Partitioner &gpar,
        const ContextMapper<Dim> &cmap)
{
  this->blocks_m = Loc<Dim>();
  initialize(bbox,gpar.internalGuards(),gpar.externalGuards());
  gpar.partition(bbox,this->all_m,cmap);
  syncPatch();
}
template<int Dim>
void SparseTileLayoutData<Dim>::calcGCFillList()
{
  if(!this->initialized() || !this->hasInternalGuards_m)
    return;
  this->gcFillList_m.clear();
  gcBorderFillList_m.clear();
  typedef Node<Domain_t,AllocatedDomain_t> NNode_t;
  typedef std::vector<NNode_t> TouchList_t;
  TouchList_t tlist;
  typename List_t::iterator start = this->all_m.begin();
  typename List_t::iterator end = this->all_m.end();
  for ( ; start!=end; ++start)
    {
      touches((*start)->allocated(),
       std::back_inserter(tlist),
       TouchesConstructNodeObj());
      typename TouchList_t::iterator GCLstart = tlist.begin();
      typename TouchList_t::iterator GCLend = tlist.end();
      for( ; GCLstart != GCLend ;++GCLstart)
 {
   if(GCLstart->globalID() == (*start)->globalID())
     {
       tlist.erase(GCLstart);
       break;
     }
 }
      GCLstart = tlist.begin();
      GCLend = tlist.end();
      for ( ; GCLstart!=GCLend ; ++GCLstart )
 {
   this->gcFillList_m.push_back(GCFillInfo_t((*GCLstart).domain(),
          (*GCLstart).globalID(),
          (*start)->globalID()));
 }
      tlist.clear();
    }
  std::vector<GCBorderFillInfo> bfv;
  start = this->all_m.begin();
  for ( ; start!=this->all_m.end(); ++start)
    {
      for(int d=0;d<Dim;++d)
 {
   Domain_t gcdom( (*start)->allocated());
   int max = (*start)->allocated()[d].last();
   int min = max - this->internalGuards_m.upper(d) + 1;
   gcdom[d] = Interval<1>(min, max);
   gcdom = intersect(this->innerdomain_m,gcdom);
   if (gcdom.size()>0)
     {
       bfv.push_back(GCBorderFillInfo(gcdom, (*start)->globalID() ));
     }
   gcdom = (*start)->allocated();
   min = (*start)->allocated()[d].first();
   max = min + this->internalGuards_m.lower(d) -1;
    gcdom[d] = Interval<1>(min, max);
   gcdom = intersect(this->innerdomain_m,gcdom);
   if (gcdom.size() > 0)
   {
     bfv.push_back(GCBorderFillInfo(gcdom,(*start)->globalID()));
   }
 }
    }
  std::vector<Domain_t> temp2,temp3,temp4;
  std::vector<GCBorderFillInfo> temp;
  BorderFillIterator_t bst = bfv.begin();
  BorderFillIterator_t ben = bfv.end();
  for ( ; bst != ben ; ++bst)
    {
      FillIterator_t gst = this->beginFillList();
      FillIterator_t gen = this->endFillList();
      temp2.clear();
      temp2.push_back(bst->domain());
      for ( ; gst!=gen ; ++gst )
 {
   typename std::vector<Domain_t>::iterator ts = temp2.begin();
   for ( ; ts != temp2.end() ; ++ts )
     {
       temp3 = DomainRemoveOverlap(*ts,gst->domain_m);
       temp4.insert(temp4.end(),temp3.begin(),temp3.end());
     }
   temp2 = temp4;
   temp4.clear();
 }
      typename std::vector<Domain_t>::iterator ts = temp2.begin();
      for( ; ts != temp2.end(); ++ts)
 temp.push_back(GCBorderFillInfo(*ts, bst->patchID() ));
    }
  gcBorderFillList_m = temp;
}
template<int Dim>
int SparseTileLayoutData<Dim>::globalID(const Loc<Dim> &loc) const
{
  ;
  DomainMapTouchIterator<Interval<Dim>,pidx_t> dmti =
 (map_m.touch(Interval<Dim>(loc))).first;
  DomainMapTouchIterator<Interval<Dim>,pidx_t> baditerator;
  if (__builtin_expect(!!(dmti!=baditerator), true)) {} else Pooma::toss_cookies("Bad location requested in SparseTileLayout", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Layout/SparseTileLayout.cpp", 538);
  return (*dmti).first;
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1, int i2) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4, int i5) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  loc[5] = i5;
  return globalID(loc);
}
template <int Dim>
int SparseTileLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4, int i5, int i6) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  loc[5] = i5;
  loc[6] = i6;
  return globalID(loc);
}
template<int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int SparseTileLayoutData<Dim>::touches(const OtherDomain &fulld,
           OutIter o,
           const ConstructTag &ctag) const
{
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t d = intersect(this->domain_m, fulld);
  if (d.empty())
    return 0;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename DomainMap<Interval<Dim>,pidx_t>::Touch_t dmti =
    map_m.touch(Interval<Dim>(d));
  typename DomainMap<Interval<Dim>,pidx_t>::touch_iterator a;
  int count = 0;
  for( a = dmti.first ;a != dmti.second; ++a)
    {
      int nodeListIndex = (*a).second;
      outDomain = intersect(a.domain(), fulld);
      ;
      *o = touchesConstruct(outDomain,
       this->all_m[nodeListIndex]->allocated(),
       this->all_m[nodeListIndex]->affinity(),
       this->all_m[nodeListIndex]->context(),
       this->all_m[nodeListIndex]->globalID(),
       this->all_m[nodeListIndex]->localID(),
       ctag);
      ++count;
    }
  return count;
}
template<int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int SparseTileLayoutData<Dim>::touchesAlloc(const OtherDomain &fulld,
         OutIter o,
         const ConstructTag &ctag) const
{
  int i;
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t d = intersect(this->domain_m, fulld);
  if (d.empty())
    return 0;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename DomainMap<Interval<Dim>,pidx_t>::Touch_t dmti = map_m.touch(d);
  typename DomainMap<Interval<Dim>,pidx_t>::touch_iterator a;
  int count = 0;
  for( a = dmti.first ;a != dmti.second; ++a)
    {
      int nodeListIndex = (*a).second;
      outDomain = intersect(a.domain(), fulld);
      ;
      *o = touchesConstruct(outDomain,
       this->all_m[nodeListIndex]->allocated(),
       this->all_m[nodeListIndex]->affinity(),
       this->all_m[nodeListIndex]->context(),
       this->all_m[nodeListIndex]->globalID(),
       this->all_m[nodeListIndex]->localID(),
       ctag);
      ++count;
    }
  return count;
}
template<int Dim>
template<class Out>
void SparseTileLayoutData<Dim>::print(Out & o) const
{
  int i;
  o<< " SparseTileLayoutData<"<<Dim<<">: "<<std::endl;
  o<< " ID_m " << this->ID_m << std::endl;
  o<< " domain_m " << this->domain_m <<std::endl;
  o<< " innerdomain_m " << this->innerdomain_m <<std::endl;
  o<< " all_m : " << std::endl;
  typename List_t::const_iterator start = this->all_m.begin();
  typename List_t::const_iterator end = this->all_m.end();
  for ( ; start!=end ; ++start)
    o<< (*start)->globalID()<<" "<<
      (*start)->domain()<<" "<<
      (*start)->allocated()<<" "
     <<std::endl;
  o<< " local_m : " << std::endl;
  start = this->local_m.begin();
  end = this->local_m.end();
  for ( ; start!=end ; ++start)
    o<< (*start)->globalID()<<" "<<
      (*start)->localID()<<" " <<
      (*start)->domain()<<" "<<
      (*start)->allocated()<<" "
     <<std::endl;
  o<< " firste_m[Dim] " ;
  for ( i=0;i<Dim;++i) o<< this->firste_m[i]<<" ";
  o<< std::endl;
  o<< " firsti_m[Dim] " ;
  for ( i=0;i<Dim;++i) o<< this->firsti_m[i]<<" ";
  o<< std::endl;
  o<< " hasInternalGuards_m, hasExternalGuards_m " <<
    this->hasInternalGuards_m <<" " << this->hasExternalGuards_m <<std::endl;
  o<< " internalGuards_m " ;
   for ( i=0;i<Dim;++i)
     o<< this->internalGuards_m.upper(i)<<"-"<<this->internalGuards_m.lower(i)<<" ";
   o<<std::endl;
  o<< " externalGuards_m " ;
   for ( i=0;i<Dim;++i)
     o<< this->externalGuards_m.upper(i)<<"-"<<this->externalGuards_m.lower(i)<<" ";
   o<<std::endl;
   FillIterator_t gstart = this->gcFillList_m.begin();
   FillIterator_t gend = this->gcFillList_m.end();
   o<< " gcFillList_m " <<std::endl;
   for( ; gstart!=gend ; ++gstart)
     o<<"       "
      <<gstart->domain_m<<" "
      <<gstart->ownedID_m<<" "
      <<gstart->guardID_m<<std::endl;
   BorderFillIterator_t bgstart = gcBorderFillList_m.begin();
   BorderFillIterator_t bgend = gcBorderFillList_m.end();
   o<< " gcBorderFillList_m " <<std::endl;
   for( ; bgstart!=bgend ; ++bgstart)
     o<<"       "
      <<bgstart->domain()<<" "
      <<bgstart->patchID()<<std::endl;
}
template<int Dim>
void SparseTileLayout<Dim>::syncPatch()
{
  this->pdata_m->syncPatch();
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout()
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >(new LayoutData_t()),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(Domain_t & boundingbox,
     const PatchList_t &patchlist,
     const ReplicatedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(boundingbox,patchlist,LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(Domain_t & boundingbox,
     const PatchList_t &patchlist,
     const DistributedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(boundingbox,patchlist,DistributedMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
  template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL,
     const PatchList_t & patchlist,
     const DistributedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
  (new LayoutData_t(boundingbox,globalGL,patchlist,DistributedMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL,
     const PatchList_t & patchlist,
     const ReplicatedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
  (new LayoutData_t(boundingbox,globalGL,patchlist,LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL,
     const PatchList_t & patchlist,
     const DistributedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
              (new LayoutData_t(boundingbox,
    internalGL,
    externalGL,
    patchlist,
    DistributedMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL,
     const PatchList_t & patchlist,
     const ReplicatedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
              (new LayoutData_t(boundingbox,
    internalGL,
    externalGL,
    patchlist,
    LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(boundingbox)),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
 template<int Dim>
SparseTileLayout<Dim>:: SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & globalGL)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(boundingbox,globalGL)),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &boundingbox,
     const GuardLayers_t & internalGL,
     const GuardLayers_t & externalGL)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(boundingbox,internalGL,externalGL)),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &bbox,
     const Partitioner &gpar,
     const DistributedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(bbox, gpar,DistributedMapper<Dim>(gpar))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
SparseTileLayout<Dim>::SparseTileLayout(const Domain_t &bbox,
     const Partitioner &gpar,
     const ReplicatedTag &)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >
    (new LayoutData_t(bbox, gpar,LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template<int Dim>
SparseTileLayout<Dim>::SparseTileLayout(const This_t &model)
  : LayoutBase<Dim,SparseTileLayoutData<Dim> >(model.pdata_m),
  Observable<This_t>(*this)
{
   this->pdata_m->attach(*this);
}
template<int Dim >
struct IsValid
{
  IsValid(Loc<Dim> loc) : loc_m(loc) { }
  typedef AndCombine Combine_t;
  Loc<Dim> loc_m;
};
template<class T, int Dim>
struct EngineFunctorScalar<T, IsValid<Dim> >
{
  typedef bool Type_t;
  static inline
  Type_t apply(const T &, const IsValid<Dim> &)
  {
    return true;
  }
};
template<class Engine, int Dim>
struct EngineFunctorDefault<Engine, IsValid<Dim> >
{
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine &, const IsValid<Dim> &)
  {
    return true;
  }
};
template<int Dim,class T,class ptag>
struct EngineFunctor<Engine<Dim, T,MultiPatch<SparseTileTag,ptag> >, IsValid<Dim> >
{
  typedef Engine<Dim,T,MultiPatch<SparseTileTag,ptag> > Engine_t;
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine_t &e, const IsValid<Dim> &f)
  {
    typedef typename Engine_t::Domain_t domain_t;
    typedef Node<domain_t,domain_t> node_t;
    std::vector<node_t> v;
    int count = e.layout().touches(f.loc_m,std::back_inserter(v));
    return (count!=0);
  }
};
template<class Object,class Dom,class tag>
inline bool isValidLocation(const Object &,
       const Dom &,
       const tag &)
{
 return true;
}
# 1 "/usr/include/c++/6/iomanip" 1 3
# 36 "/usr/include/c++/6/iomanip" 3
       
# 37 "/usr/include/c++/6/iomanip" 3






# 1 "/usr/include/c++/6/locale" 1 3
# 36 "/usr/include/c++/6/locale" 3
       
# 37 "/usr/include/c++/6/locale" 3




# 1 "/usr/include/c++/6/bits/locale_facets_nonio.h" 1 3
# 37 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
       
# 38 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3

# 1 "/usr/include/c++/6/ctime" 1 3
# 39 "/usr/include/c++/6/ctime" 3
       
# 40 "/usr/include/c++/6/ctime" 3
# 58 "/usr/include/c++/6/ctime" 3

# 58 "/usr/include/c++/6/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "/usr/include/c++/6/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/time_members.h" 1 3
# 37 "/usr/include/c++/6/x86_64-suse-linux/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 345 "/usr/include/c++/6/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __cxx11 {
# 365 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 386 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 403 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 427 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 452 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 480 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 509 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 535 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 556 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 583 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 603 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 621 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 640 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 659 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 678 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 697 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 720 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 794 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 815 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 834 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 854 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 881 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 926 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1021 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1050 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1063 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1078 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1092 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1105 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1135 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1148 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1165 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1182 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1198 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1234 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1256 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1268 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1281 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1294 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1307 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1320 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1334 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1348 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1362 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1465 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1487 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1517 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1548 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1572 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1584 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1596 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1618 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1639 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1659 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1682 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1717 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1741 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1753 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1796 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1824 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1838 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1851 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1869 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1887 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1898 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1918 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1937 "/usr/include/c++/6/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/messages_members.h" 1 3
# 36 "/usr/include/c++/6/x86_64-suse-linux/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) throw ();



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) throw ();



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) throw ();
# 121 "/usr/include/libintl.h" 3 4
}
# 37 "/usr/include/c++/6/x86_64-suse-linux/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    messages<_CharT>::messages(size_t __refs)
    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
      _M_name_messages(_S_get_c_name())
    { }

  template<typename _CharT>
    messages<_CharT>::messages(__c_locale __cloc, const char* __s,
          size_t __refs)
    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_messages = __tmp;
 }
      else
 _M_name_messages = _S_get_c_name();


      _M_c_locale_messages = _S_clone_c_locale(__cloc);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


  template<typename _CharT>
    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
    : messages<_CharT>(__refs)
    {
      if (this->_M_name_messages != locale::facet::_S_get_c_name())
 {
   delete [] this->_M_name_messages;
   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
     {
       const size_t __len = __builtin_strlen(__s) + 1;
       char* __tmp = new char[__len];
       __builtin_memcpy(__tmp, __s, __len);
       this->_M_name_messages = __tmp;
     }
   else
     this->_M_name_messages = locale::facet::_S_get_c_name();
 }

      if (__builtin_strcmp(__s, "C") != 0
   && __builtin_strcmp(__s, "POSIX") != 0)
 {
   this->_S_destroy_c_locale(this->_M_c_locale_messages);
   this->_S_create_c_locale(this->_M_c_locale_messages, __s);
 }
    }


  template<>
    typename messages<char>::catalog
    messages<char>::do_open(const basic_string<char>&,
       const locale&) const;

  template<>
    void
    messages<char>::do_close(catalog) const;


  template<>
    typename messages<wchar_t>::catalog
    messages<wchar_t>::do_open(const basic_string<char>&,
          const locale&) const;

  template<>
    void
    messages<wchar_t>::do_close(catalog) const;



}
# 2009 "/usr/include/c++/6/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/include/c++/6/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/6/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/6/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/include/c++/6/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/include/c++/6/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/include/c++/6/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/include/c++/6/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/include/c++/6/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/usr/include/c++/6/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "/usr/include/c++/6/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 2012 "/usr/include/c++/6/bits/locale_facets_nonio.h" 2 3

# 1 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 1 3
# 33 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 3
       
# 34 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 367 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 573 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 605 "/usr/include/c++/6/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2014 "/usr/include/c++/6/bits/locale_facets_nonio.h" 2 3
# 42 "/usr/include/c++/6/locale" 2 3

# 1 "/usr/include/c++/6/bits/locale_conv.h" 1 3
# 38 "/usr/include/c++/6/bits/locale_conv.h" 3
# 1 "/usr/include/c++/6/bits/stringfwd.h" 1 3
# 39 "/usr/include/c++/6/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/6/bits/allocator.h" 1 3
# 40 "/usr/include/c++/6/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/6/bits/codecvt.h" 1 3
# 41 "/usr/include/c++/6/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/6/bits/unique_ptr.h" 1 3
# 39 "/usr/include/c++/6/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 99 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
# 182 "/usr/include/c++/6/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 194 "/usr/include/c++/6/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 248 "/usr/include/c++/6/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 263 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;


    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 444 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      explicit
      unique_ptr(_Up __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 461 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 477 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 516 "/usr/include/c++/6/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 531 "/usr/include/c++/6/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 42 "/usr/include/c++/6/bits/locale_conv.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 return false;

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 195 "/usr/include/c++/6/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
# 333 "/usr/include/c++/6/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && _M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes == 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "/usr/include/c++/6/locale" 2 3
# 44 "/usr/include/c++/6/iomanip" 2 3

# 1 "/usr/include/c++/6/bits/quoted_string.h" 1 3
# 33 "/usr/include/c++/6/bits/quoted_string.h" 3
       
# 34 "/usr/include/c++/6/bits/quoted_string.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail {
 




    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };







    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto& __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }

 
  }
}
# 46 "/usr/include/c++/6/iomanip" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 65 "/usr/include/c++/6/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 95 "/usr/include/c++/6/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "/usr/include/c++/6/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 163 "/usr/include/c++/6/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 194 "/usr/include/c++/6/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 224 "/usr/include/c++/6/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 257 "/usr/include/c++/6/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 304 "/usr/include/c++/6/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 356 "/usr/include/c++/6/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 411 "/usr/include/c++/6/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
# 459 "/usr/include/c++/6/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }
# 496 "/usr/include/c++/6/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 14111 "tramp3d-v4.cpp" 2

# 14111 "tramp3d-v4.cpp"
class PrintArray;
template<class S, class A, int Dim, class DomainType>
struct PerformPrintArray
{
  static void print(const PrintArray &, S &, const A &, const DomainType &);
};
template<class S, class A, class DomainType>
struct PerformPrintArray<S, A, 1, DomainType>
{
  static void print(const PrintArray &, S &, const A &, const DomainType &);
};
class PrintArray
{
public:
  PrintArray(int domainWidth = 3, int dataWidth = 10,
      int dataPrecision = 4, int carReturn = -1,
      bool scientific = false, int spacing = 1)
    : domainwidth_m(domainWidth), datawidth_m(dataWidth),
      dataprecision_m(dataPrecision), carreturn_m(carReturn),
      spacing_m(spacing), scientific_m(scientific)
    {
      ;
      ;
      ;
      ;
    }
  PrintArray(const PrintArray &a)
    : domainwidth_m(a.domainwidth_m), datawidth_m(a.datawidth_m),
      dataprecision_m(a.dataprecision_m), carreturn_m(a.carreturn_m),
      scientific_m(a.scientific_m)
    {
    }
  ~PrintArray()
    {
    }
  template<class S, class A, class DomainType>
  void print(S &s, const A &a, const DomainType &d) const
  {
    Pooma::blockAndEvaluate();
    PerformPrintArray<S,A,A::dimensions,DomainType>::print(*this, s, a, d);
  }
  template<class S, class A>
  void print(S &s, const A &a) const
  {
    Pooma::blockAndEvaluate();
    PerformPrintArray<S, A, A::dimensions, typename A::Domain_t>::
      print(*this, s, a, a.totalDomain());
  }
  int domainWidth() const
    {
      return domainwidth_m;
    }
  void setDomainWidth(int val)
    {
      domainwidth_m = val;
      ;
    }
  int dataWidth() const
    {
      return datawidth_m;
    }
  void setDataWidth(int val)
    {
      datawidth_m = val;
      ;
    }
  int dataPrecision() const
    {
      return dataprecision_m;
    }
  void setDataPrecision(int val)
    {
      dataprecision_m = val;
      ;
    }
  int carReturn() const
    {
      return carreturn_m;
    }
  void setCarReturn(int val)
    {
      carreturn_m = val;
    }
  bool scientific() const
    {
      return scientific_m;
    }
  void setScientific(bool val)
    {
      scientific_m = val;
    }
  int spacing() const
    {
      return spacing_m;
    }
  void setSpacing(int val)
    {
      spacing_m = val;
      ;
    }
  void setFormatParameters(PrintArray &pa) {
    domainwidth_m = pa.domainWidth();
    datawidth_m = pa.dataWidth();
    dataprecision_m = pa.dataPrecision();
    carreturn_m = pa.carReturn();
    spacing_m = pa.spacing();
    scientific_m = pa.scientific();
  }
private:
  int domainwidth_m;
  int datawidth_m;
  int dataprecision_m;
  int carreturn_m;
  int spacing_m;
  bool scientific_m;
};
template<class S, class A, class DomainType>
void
PerformPrintArray<S,A,1,DomainType>::print(const PrintArray &p, S &s,
                                           const A &a, const DomainType &d)
{
  PoomaCTAssert<(A::dimensions == 1)>::test();
  typedef DomainType Domain_t;
  typedef typename Domain_t::const_iterator Iterator_t;
  Domain_t domain(d);
  Iterator_t griditer = domain.begin();
  Iterator_t enditer = domain.end();
  if (domain.size() == 1) {
    s << "(";
    if (domain[0].first() < 0)
      s.fill(' ');
    else
      s.fill('0');
    s.width(p.domainWidth());
    s << domain[0].first();
    s << ")";
    s.fill(' ');
    s << " = ";
    if (p.scientific())
      s.setf(std::ios::scientific);
    s.precision(p.dataPrecision());
    s.width(p.dataWidth());
    s << a.read(*griditer);
    s << std::endl;
    return;
  }
  s << "(";
  if (domain[0].first() < 0)
    s.fill(' ');
  else
    s.fill('0');
  s.width(p.domainWidth());
  s << domain[0].first() << ":";
  if (domain[0].last() < 0)
    s.fill(' ');
  else
    s.fill('0');
  s.width(p.domainWidth());
  s << domain[0].last() << ":";
  if (domain[0].stride() < 0)
    s.fill(' ');
  else
    s.fill('0');
  s.width(p.domainWidth());
  s << domain[0].stride() << ") = ";
  s.fill(' ');
  int i, printed = 0;
  while (griditer != enditer)
    {
      int spacing = 0;
      if (printed > 0)
 {
   spacing = p.spacing();
   if (p.carReturn() >= 0 && printed >= p.carReturn())
     {
       s << std::endl;
       spacing = 3*p.domainWidth() + 7;
       printed = 0;
     }
 }
      for (i=0; i < spacing; ++i)
 s << " ";
      if (p.scientific())
 s.setf(std::ios::scientific);
      s.precision(p.dataPrecision());
      s.width(p.dataWidth());
      s << a.read(*griditer);
      ++griditer;
      ++printed;
    }
  s << std::endl;
}
template<class S, class A, int Dim, class DomainType>
void
PerformPrintArray<S,A,Dim,DomainType>::print(const PrintArray &p, S &s,
                                             const A &a, const DomainType &d)
{
  int i, j, k;
  PoomaCTAssert<(A::dimensions == Dim && Dim > 1)>::test();
  typedef DomainType Domain_t;
  typedef typename Domain_t::Element_t Element_t;
  typedef typename Domain_t::const_iterator Iterator_t;
  Domain_t domain(d);
  Iterator_t griditer = domain.begin();
  Iterator_t enditer = domain.end();
  if (domain.size() == 1) {
    s << "(";
    if (domain[0].first() < 0)
      s.fill(' ');
    else
      s.fill('0');
    s.width(p.domainWidth());
    s << domain[0].first();
    for (int d = 1; d < Dim; d++) {
      s << ",";
      if (domain[d].first() < 0)
        s.fill(' ');
      else
        s.fill('0');
      s.width(p.domainWidth());
      s << domain[d].first();
    }
    s << ")";
    s.fill(' ');
    s << " = ";
    if (p.scientific())
      s.setf(std::ios::scientific);
    s.precision(p.dataPrecision());
    s.width(p.dataWidth());
    s << a.read(*griditer);
    s << std::endl;
    return;
  }
  Element_t x0 = domain[0].first();
  Element_t x1 = domain[0].last();
  Element_t xs = domain[0].stride();
  Element_t y0 = domain[1].first();
  Element_t y1 = domain[1].last();
  Element_t ys = domain[1].stride();
  if (Dim > 2) {
    s << std::endl << "~~~~~~~~~~~~~~ ";
    s << "(" << domain[0].first() << ":" << domain[0].last()
      << ":" << domain[0].stride();
    for (int d = 1; d < Dim; d++) {
      s << "," << domain[d].first() << ":" << domain[d].last() << ":"
        << domain[d].stride();
    }
    s << ")" << " ~~~~~~~~~~~~~~" << std::endl;
  }
  while (griditer != enditer)
    {
      if (Dim > 2) {
        s << std::endl << "(" << domain[0].first() << ":" << domain[0].last()
          << ":" << domain[0].stride() << "," << domain[1].first() << ":"
          << domain[1].last() << ":" << domain[1].stride();
        for (i=2; i < Dim; ++i)
          s << "," << (*griditer)[i].first();
        s << "):" << std::endl;
        s << "----------------------------------------------------"
          << std::endl;
      }
      for (j=y0; j <= y1; j += ys)
 {
   s << "(";
          if (x0 < 0)
            s.fill(' ');
          else
            s.fill('0');
          s.width(p.domainWidth());
          s << x0 << ":";
          if (x1 < 0)
            s.fill(' ');
          else
            s.fill('0');
          s.width(p.domainWidth());
   s << x1 << ":";
          if (xs < 0)
            s.fill(' ');
          else
            s.fill('0');
          s.width(p.domainWidth());
   s << xs;
   for (i=1; i < Dim; ++i)
     {
              s.fill(' ');
              s << ",";
              if ((*griditer)[i].first() < 0)
                s.fill(' ');
              else
                s.fill('0');
              s.width(p.domainWidth());
       s << (*griditer)[i].first();
     }
          s << ")";
   s.fill(' ');
          s << " = ";
   int printed = 0;
   for (i=x0; i <= x1; i += xs)
     {
       int spacing = 0;
       if (printed > 0)
  {
    spacing = p.spacing();
    if (p.carReturn() >= 0 && printed >= p.carReturn())
      {
        s << std::endl;
        spacing = (Dim + 2)*p.domainWidth() + 2 + Dim + 4;
        printed = 0;
      }
  }
       for (k=0; k < spacing; ++k)
  s << ' ';
       if (p.scientific())
  s.setf(std::ios::scientific);
       s.precision(p.dataPrecision());
       s.width(p.dataWidth());
       typedef typename A::Engine_t::Tag_t Etag_t;
       Etag_t tag;
        if(isValidLocation(a,*griditer,tag))
  s << a.read(*griditer);
        else
   s<< ".";
       ++griditer;
       ++printed;
     }
   s << std::endl;
 }
    }
}
template<class NewDomain, bool sv>
struct CombineDomainOpt;
template<class NewDomain>
struct CombineDomainOpt<NewDomain, true>
{
  typedef typename NewDomain::SliceType_t Type_t;
  template<class Array, class Sub1>
  inline static
  Type_t make(const Array &, const Sub1 &s1)
  {
    return Type_t(s1);
  }
  template<class Array, class Sub1, class Sub2>
  inline static
  Type_t make(const Array &, const Sub1 &s1, const Sub2 &s2)
  {
    return Type_t(s1, s2);
  }
  template<class Array, class Sub1, class Sub2, class Sub3>
  inline static
  Type_t make(const Array &,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3)
  {
    return Type_t(s1, s2, s3);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4>
  inline static
  Type_t make(const Array &,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4)
  {
    return Type_t(s1, s2, s3, s4);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5>
  inline static
  Type_t make(const Array &,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5)
  {
    return Type_t(s1, s2, s3, s4, s5);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5, class Sub6>
  inline static
  Type_t make(const Array &,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5, const Sub6 &s6)
  {
    return Type_t(s1, s2, s3, s4, s5, s6);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5, class Sub6, class Sub7>
  inline static
  Type_t make(const Array &,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5, const Sub6 &s6,
       const Sub7 &s7)
  {
    return Type_t(s1, s2, s3, s4, s5, s6, s7);
  }
};
template<class NewDomain>
struct CombineDomainOpt<NewDomain, false>
{
  typedef typename NewDomain::SliceType_t Type_t;
  template<class Array, class Sub1>
  inline static
  Type_t make(const Array &a, const Sub1 &s1)
  {
    return NewDomain::combineSlice(a.totalDomain(), s1);
  }
  template<class Array, class Sub1, class Sub2>
  inline static
  Type_t make(const Array &a, const Sub1 &s1, const Sub2 &s2)
  {
    return NewDomain::combineSlice(a.totalDomain(), s1, s2);
  }
  template<class Array, class Sub1, class Sub2, class Sub3>
  inline static
  Type_t make(const Array &a,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3)
  {
    return NewDomain::combineSlice(a.totalDomain(), s1, s2, s3);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4>
  inline static
  Type_t make(const Array &a,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4)
  {
    return NewDomain::combineSlice(a.totalDomain(), s1, s2, s3, s4);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5>
  inline static
  Type_t make(const Array &a,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5)
  {
    return NewDomain::combineSlice(a.totalDomain(), s1, s2, s3, s4, s5);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5, class Sub6>
  inline static
  Type_t make(const Array &a,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5, const Sub6 &s6)
  {
    return NewDomain::combineSlice(a.totalDomain(),
      s1, s2, s3, s4, s5, s6);
  }
  template<class Array, class Sub1, class Sub2, class Sub3,
    class Sub4, class Sub5, class Sub6, class Sub7>
  inline static
  Type_t make(const Array &a,
       const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
       const Sub4 &s4, const Sub5 &s5, const Sub6 &s6,
       const Sub7 &s7)
  {
    return NewDomain::combineSlice(a.totalDomain(),
      s1, s2, s3, s4, s5, s6, s7);
  }
};
template <class Tag>
struct Remote;
template<bool Block>
struct DataObjectApply
{ };
template<>
struct DataObjectApply<false>
{
  template<class Engine,class Functor>
  inline static
  typename Functor::Type_t
  apply(const Engine&, const Functor& functor)
  {
    return functor.defaultValue();
  }
};
template<>
struct DataObjectApply<true>
{
  template<class Engine, class Functor>
  inline static
  typename Functor::Type_t
  apply(const Engine& engine, const Functor& functor)
  {
    return functor(engine.dataObject());
  }
  template<int Dim, class T, class Tag, class Functor>
  inline static
  typename Functor::Type_t
  apply(const Engine<Dim, T, Remote<Tag> >& engine, const Functor& functor)
  {
    if (engine.engineIsLocal())
      return functor(engine.localEngine().dataObject());
    else
      return functor.defaultValue();
  }
};
template<class RequestType>
class DataObjectRequest
{};
template<class Eng, class RequestType>
struct EngineFunctorDefault<Eng, DataObjectRequest<RequestType> >
{
  enum { hasDataObject = Eng::hasDataObject };
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  static inline
  Type_t apply(const Eng &e, const DataObjectRequest<RequestType> &request)
  {
    return DataObjectApply<hasDataObject>::apply(e, request);
  }
};
template<class RequestType,class T>
struct EngineFunctorScalar<T, DataObjectRequest<RequestType> >
{
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  inline static
  Type_t apply(const T &, const DataObjectRequest<RequestType> &tag)
  {
    return tag.defaultValue();
  }
};
struct BlockAffinity { };
struct AffinityCombine
{
  AffinityCombine() { }
  AffinityCombine(const AffinityCombine &) { }
};
template<class Op>
struct Combine2<int, int, Op, AffinityCombine>
{
  typedef int Type_t;
  inline static
  Type_t combine(int a, int b, AffinityCombine)
  {
    return a;
  }
};
template<>
class DataObjectRequest<BlockAffinity>
{
public:
  typedef int Type_t;
  typedef AffinityCombine Combine_t;
  DataObjectRequest() { }
  inline Type_t operator()(Pooma::DataObject_t* obj) const
  {
    return obj->affinity();
  }
  inline Type_t defaultValue() const
  {
    return (-1);
  }
};
template<int TotalDim, int SliceDim> class SliceInterval;
template<int TotalDim, int SliceDim>
struct DomainTraits< SliceInterval<TotalDim,SliceDim> >
{
  enum { domain = true };
  enum { dimensions = TotalDim,
  sliceDimensions = SliceDim };
  enum { unitStride = true };
  enum { singleValued = false };
  enum { wildcard = false };
  typedef SliceInterval<TotalDim,SliceDim> Domain_t;
  typedef SliceInterval<TotalDim,SliceDim> NewDomain1_t;
  typedef Interval<SliceDim> SliceDomain_t;
  typedef Interval<TotalDim> TotalDomain_t;
  typedef Interval<1> OneDomain_t;
  typedef Interval<1> PointDomain_t;
  static OneDomain_t &getDomain(Domain_t &d, int n) {
    return d.totalDomain()[n];
  }
  static const OneDomain_t &getDomain(const Domain_t &d,int n) {
    return d.totalDomain()[n];
  }
  static OneDomain_t &getSliceDomain(Domain_t &d, int n) {
    return d.sliceDomain()[n];
  }
  static const OneDomain_t &getSliceDomain(const Domain_t &d, int n) {
    return d.sliceDomain()[n];
  }
  static PointDomain_t &getPointDomain(Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static const PointDomain_t &getPointDomain(const Domain_t &d, int n) {
    return getDomain(d, n);
  }
  static void cantIgnoreDomain(Domain_t &d, int n) {
    d.cantIgnoreDomain(n);
  }
  static bool getIgnorable(const Domain_t &d, int n) {
    return d.ignorable(n);
  }
  static void setIgnorable(Domain_t &d, int n, bool i) {
    d.ignorable(n) = i;
  }
};
template<int Dim, int SliceDim>
class SliceInterval
  : public SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > >
{
public:
  SliceInterval() { }
  SliceInterval(const Pooma::NoInit &d)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > >(d) { }
  SliceInterval(const SliceInterval<Dim,SliceDim> &nd)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > >(nd) {
  }
  template <class Base, class D1, class D2>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain2<D1,D2> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2);
  }
  template <class Base, class D1, class D2, class D3>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2,
                const D3 &d3)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain3<D1,D2,D3> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3);
  }
  template <class Base, class D1, class D2, class D3,
            class D4>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2,
                const D3 &d3, const D4 &d4)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain4<D1,D2,D3,D4> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2,
                const D3 &d3, const D4 &d4, const D5 &d5)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain5<D1,D2,D3,D4,D5> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5, class D6>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2,
                const D3 &d3, const D4 &d4, const D5 &d5, const D6 &d6)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain6<D1,D2,D3,D4,D5,D6> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5, d6);
  }
  template <class Base, class D1, class D2, class D3,
            class D4, class D5, class D6, class D7>
  SliceInterval(const Base &baseDomain, const D1 &d1, const D2 &d2,
                const D3 &d3, const D4 &d4, const D5 &d5, const D6 &d6,
                const D7 &d7)
    : SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > > (
        Pooma::NoInit())
  {
      typedef NewDomain7<D1,D2,D3,D4,D5,D6,D7> NewDomain_t;
      typedef typename NewDomain_t::SliceType_t SliceType_t;
      PoomaCTAssert<(DomainTraits<SliceType_t>::dimensions == Dim)>::test();
      PoomaCTAssert<(DomainTraits<SliceType_t>::sliceDimensions == SliceDim)>::test();
      NewDomain_t::fillSlice(*this, baseDomain, d1, d2, d3, d4, d5, d6, d7);
  }
  ~SliceInterval() { }
  SliceInterval<Dim,SliceDim> &
    operator=(const SliceInterval<Dim,SliceDim> &nd) {
      SliceDomain<DomainTraits<SliceInterval<Dim,SliceDim> > >::operator=(nd);
      return *this;
  }
protected:
private:
};
struct DomainTag { };
template<int Dim>
class DomainLayout
{
public:
  typedef DomainLayout<Dim> This_t;
  typedef Interval<Dim> Domain_t;
  typedef Node<Domain_t> Value_t;
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef Value_t *iterator;
  typedef const Value_t *const_iterator;
  enum { dimensions = Dim };
  enum { dynamic = false };
  inline DomainLayout()
    {
    }
  explicit DomainLayout(const Domain_t &dom)
    : node_m(0, dom, Pooma::context(), 0, 0)
    {
    }
  DomainLayout(const Domain_t &dom, const GuardLayers_t &g)
    : node_m(0, dom, grow(dom, g), Pooma::context(), 0, 0)
    {
    }
  explicit DomainLayout(const Value_t &node)
    : node_m(node)
    {
    }
  DomainLayout(const This_t &layout)
    : node_m(layout.node_m)
    {
    }
  void initialize(const Domain_t &dom)
    {
      node_m = Value_t(0, dom, Pooma::context(), 0, 0);
    }
  void initialize(const Domain_t &dom, const GuardLayers_t &g)
    {
      node_m = Value_t(0, dom, grow(dom, g), Pooma::context(), 0, 0);
    }
  void initialize(const This_t &layout)
  {
    node_m = layout.node_m;
  }
  inline ~DomainLayout()
    {
    }
  inline bool initialized() const
    {
      return domain().initialized();
    }
  inline int first(int d) const { return innerDomain()[d].first(); }
  inline Value_t &node()
    {
      return node_m;
    }
  inline const Value_t &node() const
    {
      return node_m;
    }
  inline Loc<Dim> blocks() const { return Loc<Dim>(1); }
  inline const Domain_t &domain() const
    {
      return node_m.allocated();
    }
  inline const Domain_t &innerDomain() const
  {
    return node_m.domain();
  }
  inline const Domain_t &allocated() const
    {
      return node_m.allocated();
    }
  inline GuardLayers_t internalGuards() const
  {
    return GuardLayers_t(0);
  }
  inline GuardLayers_t externalGuards() const
  {
    GuardLayers_t gl;
    for (int i = 0; i < Dim; i++)
      {
        gl.lower(i) = node_m.domain()[i].min() - node_m.allocated()[i].min();
        gl.upper(i) = node_m.allocated()[i].max() - node_m.domain()[i].max();
      }
    return gl;
  }
  inline const Domain_t &domain(int i) const
  {
    ;
    return node_m.allocated();
  }
 inline const Domain_t &ownedDomain(int i) const
  {
    ;
    return node_m.domain();
  }
  inline const Domain_t &allocatedDomain(int i) const
    {
      ;
      return node_m.allocated();
    }
  template<class L>
  inline bool operator==(const L &layout) const
    {
      return (domain() == layout.domain());
    }
  template<class L>
  inline bool operator!=(const L &layout) const
    {
      return !(*this == layout);
    }
  inline iterator begin()
    {
      return &node_m;
    }
  inline iterator end()
    {
      return &node_m + 1;
    }
  inline const_iterator begin() const
    {
      return &node_m;
    }
  inline const_iterator end() const
    {
      return &node_m + 1;
    }
  inline long size() const
    {
      return 1;
    }
  inline iterator beginLocal()
    {
      return begin();
    }
  inline iterator endLocal()
    {
      return end();
    }
  inline const_iterator beginLocal() const
    {
      return begin();
    }
  inline const_iterator endLocal() const
    {
      return end();
    }
  inline long sizeLocal() const
    {
      return size();
    }
  inline iterator beginGlobal()
    {
      return begin();
    }
  inline iterator endGlobal()
    {
      return end();
    }
  inline const_iterator beginGlobal() const
    {
      return begin();
    }
  inline const_iterator endGlobal() const
    {
      return end();
    }
  inline long sizeGlobal() const
    {
      return size();
    }
  inline iterator beginRemote()
    {
      return iterator(0);
    }
  inline iterator endRemote()
    {
      return iterator(0);
    }
  inline const_iterator beginRemote() const
    {
      return const_iterator(0);
    }
  inline const_iterator endRemote() const
    {
      return const_iterator(0);
    }
  inline long sizeRemote() const
    {
      return 0;
    }
  inline int globalID(const Loc<Dim> &loc) const
    {
      ;
      return 0;
    }
  inline int globalID(int i1) const
    {
      return globalID(Loc<1>(i1));
    }
  inline int globalID(int i1, int i2) const
    {
      return globalID(Loc<2>(i1, i2));
    }
  inline int globalID(int i1, int i2, int i3) const
    {
      return globalID(Loc<3>(i1, i2, i3));
    }
  inline int globalID(int i1, int i2, int i3, int i4) const
    {
      return globalID(Loc<4>(i1, i2, i3, i4));
    }
  inline int globalID(int i1, int i2, int i3, int i4, int i5) const
    {
      return globalID(Loc<5>(i1, i2, i3, i4, i5));
    }
  inline int globalID(int i1, int i2, int i3, int i4, int i5,
        int i6) const
    {
      return globalID(Loc<6>(i1, i2, i3, i4, i5, i6));
    }
  inline int globalID(int i1, int i2, int i3, int i4, int i5,
        int i6, int i7) const
    {
      return globalID(Loc<7>(i1, i2, i3, i4, i5, i6, i7));
    }
  template<class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o, ConstructTag ctag) const;
  template<class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesLocal(const OtherDomain &d, OutIter o,
                          const ConstructTag &ctag) const
    {
      return touches(d, o, ctag);
    }
  template<class OtherDomain, class OutIter, class ConstructTag>
  inline int touchesRemote(const OtherDomain &, OutIter,
      const ConstructTag &) const
    {
      return 0;
    }
  template<class OtherDomain, class OutIter>
  inline int touches(const OtherDomain &d, OutIter o) const
    {
      return touches(d, o, TouchesConstructNodeObj());
    }
  template<class OtherDomain, class OutIter>
  inline int touchesLocal(const OtherDomain &d, OutIter o) const
    {
      return touchesLocal(d, o, TouchesConstructNodeObj());
    }
  template<class OtherDomain, class OutIter>
  inline int touchesRemote(const OtherDomain &d, OutIter o) const
    {
      return touchesRemote(d, o, TouchesConstructNodeObj());
    }
  template<class Out>
  void print(Out &o) const
    {
      o << "DomainLayout: Node = " << node_m;
    }
private:
  Value_t node_m;
};
template<int Dim>
template<class OtherDomain, class OutIter, class ConstructTag>
int DomainLayout<Dim>::touches(const OtherDomain &d, OutIter o,
          ConstructTag ctag) const
{
  int i, count = 0;
  typedef typename IntersectReturnType<Domain_t,OtherDomain>::Type_t
    OutDomain_t;
  typedef Node<OutDomain_t> OutNode_t;
  OutDomain_t outDomain = intersect(d, domain());
  if (!outDomain.empty())
    {
      ++count;
      *o = touchesConstruct(outDomain,
       node().affinity(),
       node().context(),
       node().globalID(),
       node().localID(),
       ctag);
    }
  return count;
}
template <int Dim>
std::ostream &operator<<(std::ostream &o, const DomainLayout<Dim> &layout)
{
  layout.print(o);
  return o;
}
template<int Dim>
struct NewDomain1< DomainLayout<Dim> >
{
  typedef DomainLayout<Dim> &Type_t;
  inline static Type_t combine(const DomainLayout<Dim> &a)
    {
      return const_cast<Type_t>(a);
    }
};
namespace Pooma {
template <int Dim> class BrickViewBase;
template <int pos, int max>
struct OffsetCalc
{
 template <class Dom>
 static inline int apply(const Dom& dom, const int *strides_m)
 {
  return dom[pos].first()*strides_m[pos]
   + OffsetCalc<pos+1,max>::apply(dom, strides_m);
 }
};
template <int end>
struct OffsetCalc<end, end>
{
 template <class Dom>
 static inline int apply(const Dom& dom, const int *strides_m)
 {
  return dom[end].first()*strides_m[end];
 }
};
template <>
struct OffsetCalc<1, 0>
{
 template <class Dom>
 static inline int apply(const Dom& dom, const int *strides_m)
 {
  return 0;
 }
};
template <int Dim>
class BrickBase
{
public:
  typedef Interval<Dim> Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef BrickBase<Dim> This_t;
  enum { dimensions = Dim };
  enum { brick = true };
  enum { zeroBased = false };
  explicit BrickBase(bool compressible = false)
    : compressibleBase_m(compressible)
  { }
  explicit BrickBase(const Domain_t &dom, bool compressible = false)
    : layout_m(dom), compressibleBase_m(compressible)
  {
    init();
  }
  explicit BrickBase(const Node<Domain_t> &node, bool compressible = false)
    : layout_m(node), compressibleBase_m(compressible)
  {
    init();
  }
  explicit BrickBase(const Layout_t &layout, bool compressible = false)
    : layout_m(layout), compressibleBase_m(compressible)
  {
    init();
  }
  ~BrickBase() {}
  inline const Domain_t &domain() const { return layout_m.domain(); }
  inline const Layout_t &layout() const { return layout_m; }
  inline const int *strides() const { return &strides_m[0]; }
  inline const int *originalStrides() const { return &ostrides_m[0]; }
  int first(int i) const { return layout_m.domain()[i].first(); }
  bool compressibleBase() const { return compressibleBase_m; }
  template <class Domain>
  inline int offset(const Domain &dom) const
  { return off_m + offset0(dom); }
  template <class Domain>
  inline int offset0(const Domain &dom) const
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
    return dom[0].first() + OffsetCalc<1, Dim-1>::apply(dom, strides_m);
  }
  template <class Domain>
  inline int offsetC(const Domain &dom) const
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
    return OffsetCalc<0, Dim-1>::apply(dom, strides_m);
  }
  inline int offset() const
  { return off_m; }
  inline int baseOffset() const
  { return off_m; }
  inline int offset(int i0) const
  { return off_m + i0; }
  inline int offset(int i0, int i1) const
  { return off_m + i0 + i1*strides_m[1]; }
  inline int offset(int i0, int i1, int i2) const
  { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2]; }
  inline int offset(int i0, int i1, int i2, int i3) const
  { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4) const
  { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
                      + i4*strides_m[4]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
                      + i4*strides_m[4] + i5*strides_m[5]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
  const
  { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
                      + i4*strides_m[4] + i5*strides_m[5] + i6*strides_m[6]; }
  inline int offset0(int i0) const
  { return i0; }
  inline int offset0(int i0, int i1) const
  { return i0 + i1*strides_m[1]; }
  inline int offset0(int i0, int i1, int i2) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]; }
  inline int offset0(int i0, int i1, int i2, int i3) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]; }
  inline int offset0(int i0, int i1, int i2, int i3, int i4) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
              + i4*strides_m[4]; }
  inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
              + i4*strides_m[4] + i5*strides_m[5]; }
  inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
  const
  { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
              + i4*strides_m[4] + i5*strides_m[5] + i6*strides_m[6]; }
  inline int offsetC(int i0) const
  { return i0*strides_m[0]; }
  inline int offsetC(int i0, int i1) const
  { return i0*strides_m[0] + i1*strides_m[1]; }
  inline int offsetC(int i0, int i1, int i2) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]; }
  inline int offsetC(int i0, int i1, int i2, int i3) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3]; }
  inline int offsetC(int i0, int i1, int i2, int i3, int i4) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4]; }
  inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]; }
  inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
  const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]
         + i6*strides_m[6]; }
protected:
  void init()
  {
    strides_m[0] = 1;
    ostrides_m[0] = 1;
    off_m = -domain()[0].first();
    for (int d = 1; d < Dim; ++d) {
      strides_m[d] = strides_m[d-1]*domain()[d-1].length();
      ostrides_m[d] = strides_m[d];
      off_m -= domain()[d].first()*strides_m[d];
    }
  }
  void zeroStrides()
  { for (int d = 0; d < Dim; ++d) strides_m[d] = 0; }
  void restoreStrides()
  { for (int d = 0; d < Dim; ++d) strides_m[d] = ostrides_m[d]; }
  Layout_t layout_m;
  int strides_m[Dim];
  int ostrides_m[Dim];
  int off_m;
  bool compressibleBase_m;
};
template <int Dim>
class BrickViewBase
{
public:
  enum { dimensions = Dim };
  enum { zeroBased = true };
  typedef Interval<Dim> Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  BrickViewBase() {}
  typedef BrickViewBase<Dim> This_t;
  BrickViewBase(const This_t &bvbase, bool compressible)
  {
    *this = bvbase;
    compressibleBase_m = compressible;
    if (!compressible) restoreStrides();
  }
  BrickViewBase(const BrickBase<Dim> &base, bool compressible)
  {
    *this = BrickViewBase<Dim>(base, base.domain());
    compressibleBase_m = compressible;
    if (!compressible) restoreStrides();
  }
  BrickViewBase(const BrickBase<Dim> &bbase, const Interval<Dim> &dom)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bbase.offset()),
      compressibleBase_m(bbase.compressibleBase())
  {
    viewInit(bbase, dom);
  }
  BrickViewBase(const BrickBase<Dim> &bbase, const Range<Dim> &dom)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bbase.offset()),
      compressibleBase_m(bbase.compressibleBase())
  {
    viewInit(bbase, dom);
  }
  BrickViewBase(const This_t &bvbase, const Interval<Dim> &domain)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bvbase.baseOffset()),
      compressibleBase_m(bvbase.compressibleBase())
  {
    viewInit(bvbase, domain);
  }
  BrickViewBase(const This_t &bvbase, const Range<Dim> &domain)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bvbase.baseOffset()),
      compressibleBase_m(bvbase.compressibleBase())
  {
    viewInit(bvbase, domain);
  }
  template<int BaseDim>
  BrickViewBase(const BrickBase<BaseDim> &bbase,
  const SliceRange<BaseDim,Dim> &dom)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bbase.offset()),
      compressibleBase_m(bbase.compressibleBase())
  {
    sliceInit(bbase.originalStrides(), dom);
  }
  template<int BaseDim>
  BrickViewBase(const BrickBase<BaseDim> &bbase,
  const SliceInterval<BaseDim,Dim> &dom)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bbase.offset()),
      compressibleBase_m(bbase.compressibleBase())
  {
    sliceInit(bbase.originalStrides(), SliceRange<BaseDim,Dim>(dom));
  }
  template<int SliceDim>
  BrickViewBase(const BrickBase<SliceDim> &bbase,
  const SliceInterval<Dim,SliceDim> &dom,
  const Interval<Dim> &totalDomain)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bbase.offset()),
      compressibleBase_m(bbase.compressibleBase())
  {
    sliceInit(bbase.originalStrides(), dom, totalDomain);
  }
  template<int SliceDim>
  BrickViewBase(const BrickViewBase<SliceDim> &bvbase,
  const SliceInterval<Dim,SliceDim> &dom,
  const Interval<Dim> &totalDomain)
    : domain_m(Pooma::NoInit()),
      baseOffset_m(bvbase.baseOffset())
  {
    sliceInit(bvbase, dom, totalDomain);
  }
  template <int BaseDim>
  BrickViewBase(const BrickViewBase<BaseDim> &bvbase,
                const SliceRange<BaseDim,Dim> &dom)
  : domain_m(Pooma::NoInit()),
    baseOffset_m(bvbase.baseOffset())
  {
    sliceInit(bvbase, dom);
  }
  template <int BaseDim>
  BrickViewBase(const BrickViewBase<BaseDim> &bvbase,
                const SliceInterval<BaseDim,Dim> &dom)
  : domain_m(Pooma::NoInit()),
    baseOffset_m(bvbase.baseOffset())
  {
    sliceInit(bvbase, SliceRange<BaseDim,Dim>(dom));
  }
  ~BrickViewBase() {}
  inline const Domain_t &domain() const { return domain_m; }
  inline Layout_t layout() const { return Layout_t(domain_m); }
  inline const int *strides() const { return &strides_m[0]; }
  inline const int *originalStrides() const { return &ostrides_m[0]; }
  inline int first(int) const { return 0; }
  bool compressibleBase() const { return compressibleBase_m; }
  int baseOffset() const { return baseOffset_m; }
  template <class Domain>
  inline int offset(const Domain &dom) const
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
    return OffsetCalc<0, Dim-1>::apply(dom, strides_m);
  }
  inline int offset(int i0) const
  { return i0*strides_m[0]; }
  inline int offset(int i0, int i1) const
  { return i0*strides_m[0] + i1*strides_m[1]; }
  inline int offset(int i0, int i1, int i2) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]; }
  inline int offset(int i0, int i1, int i2, int i3) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]; }
  inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    const
  { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]
         + i6*strides_m[6]; }
  template <class Domain>
  inline int offsetU(const Domain &dom) const
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
    return dom[0].first() + OffsetCalc<1, Dim-1>::apply(dom, strides_m);
  }
  inline int offsetU(int i0) const
  { return i0; }
  inline int offsetU(int i0, int i1) const
  { return i0 + i1*strides_m[1]; }
  inline int offsetU(int i0, int i1, int i2) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]; }
  inline int offsetU(int i0, int i1, int i2, int i3) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3]; }
  inline int offsetU(int i0, int i1, int i2, int i3, int i4) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4]; }
  inline int offsetU(int i0, int i1, int i2, int i3, int i4, int i5) const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]; }
  inline int offsetU(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    const
  { return i0 + i1*strides_m[1] + i2*strides_m[2]
         + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]
         + i6*strides_m[6]; }
protected:
  void zeroStrides()
  { for (int d = 0; d < Dim; ++d) strides_m[d] = 0; }
  void restoreStrides()
  { for (int d = 0; d < Dim; ++d) strides_m[d] = ostrides_m[d]; }
  template<int BaseDim>
  void sliceInit(const int *baseStrides,
   const SliceRange<BaseDim,Dim> &dom);
  template<int SliceDim>
  void sliceInit(const int *baseStrides,
   const SliceInterval<Dim,SliceDim> &dom,
   const Interval<Dim> &totalDomain);
  template<int BaseDim>
  void sliceInit(const BrickViewBase<BaseDim>&, const SliceRange<BaseDim, Dim>&);
  template<int SliceDim>
  void sliceInit(const BrickViewBase<SliceDim>&, const SliceInterval<Dim, SliceDim>&,
   const Interval<Dim> &totalDomain);
  void viewInit(const This_t &, const Range<Dim> &domain);
  void viewInit(const BrickBase<Dim> &bbase, const Range<Dim> &domain);
  void viewInit(const This_t &bvbase, const Interval<Dim> &domain)
  {
    for (int d = 0; d < Dim; ++d)
    {
      domain_m[d] = Interval<1>(domain[d].length());
      strides_m[d] = bvbase.ostrides_m[d];
      ostrides_m[d] = strides_m[d];
      baseOffset_m += domain[d].first() * bvbase.ostrides_m[d];
    }
  }
  void viewInit(const BrickBase<Dim> &bbase, const Interval<Dim> &domain)
  {
    for (int d = 0; d < Dim; ++d)
    {
      domain_m[d] = Interval<1>(domain[d].length());
      strides_m[d] = bbase.originalStrides()[d];
      ostrides_m[d] = strides_m[d];
      baseOffset_m += domain[d].first() * bbase.originalStrides()[d];
    }
  }
  Domain_t domain_m;
  int strides_m[Dim];
  int ostrides_m[Dim];
  int baseOffset_m;
  bool compressibleBase_m;
};
template <int Dim>
void
BrickViewBase<Dim>::
viewInit(const This_t &bvbase, const Range<Dim> &domain)
{
  for (int d = 0; d < Dim; ++d)
    {
      domain_m[d] = Interval<1>(domain[d].length());
      strides_m[d] = bvbase.ostrides_m[d] * domain[d].stride();
      baseOffset_m += domain[d].first() * bvbase.ostrides_m[d];
    }
  for (int d = 0; d < Dim; ++d)
    ostrides_m[d] = strides_m[d];
}
template <int Dim>
void
BrickViewBase<Dim>::
viewInit(const BrickBase<Dim> &bbase, const Range<Dim> &domain)
{
  for (int d = 0; d < Dim; ++d)
  {
    domain_m[d] = Interval<1>(domain[d].length());
    strides_m[d] = bbase.originalStrides()[d] * domain[d].stride();
    ostrides_m[d] = strides_m[d];
    baseOffset_m += domain[d].first() * bbase.originalStrides()[d];
  }
}
template <int Dim>
template<int BaseDim>
void
BrickViewBase<Dim>::
sliceInit(const int *baseStrides,
   const SliceRange<BaseDim,Dim> &dom)
{
  typedef typename SliceRange<BaseDim,Dim>::TotalDomain_t TotalDomain_t;
  const TotalDomain_t &domain = dom.totalDomain();
  int d = 0;
  for (int dt = 0; dt < BaseDim; ++dt)
  {
    if (!dom.ignorable(dt))
    {
      ;
      domain_m[d] = Interval<1>(domain[dt].length());
      strides_m[d] = baseStrides[dt] * domain[dt].stride();
      ++d;
    }
    baseOffset_m += domain[dt].first() * baseStrides[dt];
  }
  ;
  for (int d = 0; d < Dim; ++d)
    ostrides_m[d] = strides_m[d];
}
template <int Dim>
template<int SliceDim>
void
BrickViewBase<Dim>::
sliceInit(const int *baseStrides,
   const SliceInterval<Dim,SliceDim> &dom,
   const Interval<Dim> &domain)
{
  int dt = 0;
  for (int d = 0; d < Dim; ++d)
  {
    domain_m[d] = Interval<1>(domain[d].length());
    if (!dom.ignorable(d))
    {
      ;
      strides_m[d] = baseStrides[dt];
      baseOffset_m += domain[dt].first() * baseStrides[dt];
      ++dt;
    } else {
      strides_m[d] = 0;
    }
  }
  ;
  for (int d = 0; d < Dim; ++d)
    ostrides_m[d] = strides_m[d];
}
template <int Dim>
template<int SliceDim>
void
BrickViewBase<Dim>::
sliceInit(const BrickViewBase<SliceDim>& bvbase,
   const SliceInterval<Dim,SliceDim> &dom,
   const Interval<Dim> &domain)
{
  int dt = 0;
  for (int d = 0; d < Dim; ++d)
  {
    domain_m[d] = Interval<1>(domain[d].length());
    if (!dom.ignorable(d))
    {
      ;
      strides_m[d] = bvbase.originalStrides()[dt];
      baseOffset_m += domain[dt].first() * bvbase.originalStrides()[dt];
      ++dt;
    } else {
      strides_m[d] = 0;
    }
  }
  ;
  for (int d = 0; d < Dim; ++d)
    ostrides_m[d] = strides_m[d];
}
template <int Dim>
template<int BaseDim>
void
BrickViewBase<Dim>::
sliceInit(const BrickViewBase<BaseDim>& bvbase, const SliceRange<BaseDim, Dim>& dom)
{
  typedef typename SliceRange<BaseDim,Dim>::TotalDomain_t TotalDomain_t;
  const TotalDomain_t &totDomain = dom.totalDomain();
  int d, dt;
  for (dt = 0, d = 0; dt < BaseDim; ++dt)
    {
      if (!dom.ignorable(dt))
        {
          ;
          domain_m[d] = Interval<1>(totDomain[dt].length());
          strides_m[d] = bvbase.originalStrides()[dt] * totDomain[dt].stride();
          ++d;
        }
      baseOffset_m += totDomain[dt].first() * bvbase.originalStrides()[dt];
    }
  ;
  for (int d = 0; d < Dim; ++d)
    ostrides_m[d] = strides_m[d];
}
}
class Inform;
namespace Pooma {
class StatisticsData
{
  friend class Statistics;
public:
  const std::string &description() const { return data_m.first; }
  long value() const { return data_m.second; }
  void increment(long val = 1) { data_m.second += val; }
private:
  StatisticsData(const char *description, long initialValue = 0)
  : data_m(description, initialValue)
  { }
  ~StatisticsData() { }
  std::pair<std::string, long> data_m;
};
class Statistics {
private:
  static long defaultFilter(long val);
public:
  Statistics();
  ~Statistics();
  void print(Inform &, long (*filter)(long) = defaultFilter);
  StatisticsData *add(const char *description, long initval = 0)
  {
    StatisticsData *sd = new StatisticsData(description, initval);
    statList_m.push_back(sd);
    return sd;
  }
private:
  std::vector<StatisticsData *> statList_m;
};
}
template <class T> class SingleObserver;
template <class T>
class CompressibleBlock
{
public:
  typedef CompressibleBlock<T> This_t;
  typedef T Element_t;
  typedef Pooma::DataObject_t DataObject_t;
  enum Notifier
  {
    notifyDestruct = 0,
    notifyUncompress = 1,
    notifyCompress = 2
  };
  CompressibleBlock()
    : controller_m(0)
  { }
  explicit CompressibleBlock(int size)
    : controller_m(new CompressibleBlockController(size))
  { }
  CompressibleBlock(int size, int affinity)
    : controller_m(new CompressibleBlockController(size,affinity))
  { }
  CompressibleBlock(int size, int affinity, const T& model)
    : controller_m(new CompressibleBlockController(size,affinity,model))
  { }
  CompressibleBlock(const CompressibleBlock &block)
    : controller_m(block.controller_m)
  { }
  ~CompressibleBlock()
  {
    ;
  }
  inline int size() const
  {
    return controller_m.size();
  }
  inline int capacity() const
  {
    return controller_m.capacity();
  }
  inline bool resize(int newsize,
       const typename DataBlockPtr<T>::NoInitTag &)
  {
    return controller_m->resize(newsize,DataBlockPtr<T>::NoInitTag());
  }
  inline void setSize(int newsize)
  {
    controller_m->setSize(newsize);
  }
  inline DataObject_t* dataObject() const
  {
    ;
    return controller_m->dataObject();
  }
  inline int affinity() const
  {
    ;
    return controller_m->dataObject()->affinity();
  }
  inline bool compressed() const
  {
    ;
    return controller_m->compressed();
  }
  inline T* data()
  {
    ;
    return controller_m->data();
  }
  inline void uncompress() const
  {
    ;
    controller_m->uncompress();
  }
  void tryCompress()
  {
    ;
    controller_m->tryCompress();
  }
  inline DataBlockPtr<T> view() const
  {
    ;
    return controller_m->view();
  };
  DataBlockPtr<T> dataBlock() const
  {
    ;
    return controller_m->dataBlock();
  }
  void makeOwnCopy()
  {
    controller_m.makeOwnCopy();
  }
  void invalidate()
  {
    controller_m.invalidate();
  }
  inline bool isControllerPtrValid() const
  {
    return controller_m.isValid();
  }
  inline bool isControllerValid() const
  {
    return controller_m.isValid() && controller_m->isValid();
  }
  inline bool isControllerValidUnlocked() const
  {
    return controller_m.isValid() && controller_m->isValidUnlocked();
  }
  inline bool isShared() const
  {
    return controller_m.isShared();
  }
  bool operator!=(const This_t& a) const
  {
    return controller_m != a.controller_m;
  }
  bool operator==(const This_t& a) const
  {
    return controller_m == a.controller_m;
  }
  void attach(Observer<T*> *o)
  {
    ;
    controller_m->attach(o);
  }
  void detach(Observer<T*> *o)
  {
    ;
    controller_m->detach(o);
  }
  void lock() const
  {
    controller_m->lock();
  }
  void unlock() const
  {
    controller_m->unlock();
  }
  static int randomTries() { return CompressibleBlockController::randomTries(); }
private:
  class CompressibleBlockController
    : public SingleObserver<int>,
      public Observable<T*>,
      public RefCounted
  {
  public:
    typedef CompressibleBlockController This_t;
    typedef T Element_t;
    typedef Pooma::DataObject_t DataObject_t;
    CompressibleBlockController()
      : Observable<T*>(ptr_m),
        size_m(0),
 compressible_m(true),
 ptr_m(0),
 dataObject_m(-1),
 ucOffset_m(-1),
 viewcount_m(0),
 countUncompressed_m(0)
    {
      ElementProperties<T>::construct(&compressedData_m);
      if (Pooma::neverCompress())
        {
          compressible_m = false;
        }
    }
    explicit
    CompressibleBlockController(int size)
      : Observable<T*>(ptr_m),
        compressible_m(true),
        countUncompressed_m(0),
 viewcount_m(0),
 dataObject_m(-1),
        size_m(size),
 ptr_m(&compressedData_m),
 ucOffset_m(-1)
    {
      ElementProperties<T>::construct(&compressedData_m);
      if (Pooma::neverCompress())
        {
          viewcount_m = 1;
          compressible_m = false;
          countUncompressed_m = 1;
          block_m = DataBlockPtr<T>(size_m,dataObject_m);
          ptr_m = block_m.currentPointer();
          block_m.attach(this);
        }
    }
    CompressibleBlockController(int size, int affinity)
      : Observable<T*>(ptr_m),
 compressible_m(true),
        countUncompressed_m(0),
 viewcount_m(0),
 dataObject_m(affinity),
        size_m(size),
 ptr_m(&compressedData_m),
 ucOffset_m(-1)
    {
      ElementProperties<T>::construct(&compressedData_m);
      if (Pooma::neverCompress())
        {
          viewcount_m = 1;
          compressible_m = false;
          countUncompressed_m = 1;
          block_m = DataBlockPtr<T>(size_m,dataObject_m);
          ptr_m = block_m.currentPointer();
          block_m.attach(this);
        }
    }
    CompressibleBlockController(int size, int affinity, const T& value)
      : Observable<T*>(ptr_m),
 compressible_m(true),
        countUncompressed_m(0),
 viewcount_m(0),
 dataObject_m(affinity),
        size_m(size),
 ptr_m(&compressedData_m),
 ucOffset_m(-1)
    {
      ElementProperties<T>::construct(&compressedData_m,value);
      if (Pooma::neverCompress())
        {
          viewcount_m = 1;
          compressible_m = false;
          countUncompressed_m = 1;
          block_m = DataBlockPtr<T>(size_m,value,dataObject_m);
          ptr_m = block_m.currentPointer();
          block_m.attach(this);
        }
    }
    CompressibleBlockController(const CompressibleBlockController& model)
      : Observable<T*>(ptr_m),
        compressible_m(!Pooma::neverCompress()),
 viewcount_m(0),
        dataObject_m(model.dataObject_m.affinity()),
        size_m(model.size_m),
 ucOffset_m(model.ucOffset_m)
    {
      model.lock();
      bool modelCompressed = model.compressed();
      compressedData_m = model.compressedData_m;
      block_m = model.block_m;
      if (!modelCompressed)
 {
   --model.viewcount_m;
 }
      model.unlock();
      if (modelCompressed)
 {
          ;
   ptr_m = &compressedData_m;
   countUncompressed_m = 0;
 }
      else
 {
   block_m.makeOwnCopy();
   ptr_m = block_m.currentPointer();
   block_m.dataObject(&dataObject_m);
   countUncompressed_m = 1;
   ++viewcount_m;
   block_m.attach(this);
 }
      ;
    }
    ~CompressibleBlockController()
    {
      ;
      ;
      ;
      if (!compressed())
 {
   block_m.detach();
 }
    }
    inline size_t size() const
    {
      return block_m.size();
    }
    inline size_t capacity() const
    {
      return block_m.capacity();
    }
    inline void setSize(size_t size)
    {
      size_m = size;
    }
    inline bool resize(size_t newsize,
         const typename DataBlockPtr<T>::NoInitTag &)
    {
      ;
      if (block_m.capacity() >= newsize)
 {
   block_m.resize(newsize, DataBlockPtr<T>::NoInitTag());
   size_m = block_m.size();
 }
      else
 {
   size_t nsize = newsize * sizeof(T);
   size_t n_ext = nsize/sizeof(T);
   DataBlockPtr<T> newdata(n_ext,dataObject_m);
   newdata.resize(newsize, DataBlockPtr<T>::NoInitTag());
          T * pOld = block_m.beginPointer();
          T * pNew = newdata.beginPointer();
          const T * const pEnd = pNew + block_m.size();
          while (pNew != pEnd)
            {
       ElementProperties<T>::construct(pNew++,*pOld++);
            }
   block_m = newdata;
          ptr_m = block_m.currentPointer();
   size_m = newsize;
 }
      return true;
    }
    inline void uncompress()
    {
      lock();
      uncompressUnlocked();
      unlock();
    }
    void uncompressUnlocked()
    {
      if (compressed())
        {
          ;
          ;
   ++countUncompressed_m;
          block_m = DataBlockPtr<T>(size_m,dataObject_m);
   ++viewcount_m;
   ;
          ptr_m = block_m.currentPointer();
          block_m.attach(this);
          T *ptr = block_m.beginPointer();
          const T *const end = block_m.endPointer();
          while (ptr != end)
        {
       ElementProperties<T>::construct(ptr++,compressedData_m);
     }
          Observable<T*>::notify(notifyUncompress);
          ;
        }
    }
    inline void tryCompress()
    {
      if (!Pooma::neverCompress())
        {
          lock();
          tryCompressUnlocked();
          unlock();
        }
    }
    void tryCompressUnlocked()
    {
      if (!compressed() && compressible_m && !Pooma::neverCompress())
        {
          ;
          int size = block_m.size();
          bool failed = false;
          ;
          if (ucOffset_m > -1 && ucOffset_m < size)
            {
              if (block_m[ucOffset_m] != block_m[0]) failed = true;
            }
          if (!failed)
            {
              for (int i = 0; i < randomTries(); ++i)
                {
                  int elem = rand() % size;
                  if (block_m[elem] != block_m[0])
                    {
                      failed = true;
                      ucOffset_m = elem;
                      break;
                    }
                }
            }
          if (!failed)
            {
              const T *const begin = block_m.beginPointer();
              const T *const end = block_m.endPointer();
              const T * ptr;
              for (ptr = begin; ptr != end; ++ptr)
         {
           if (*ptr != *begin) break;
         }
              if (ptr == end)
         {
           block_m.detach();
           block_m.invalidate();
           --viewcount_m;
           ;
           compressedData_m = *begin;
           ptr_m = &compressedData_m;
           Observable<T*>::notify(notifyCompress);
           ;
           return;
         }
       else
         {
           ucOffset_m = ptr - begin;
         }
            }
          ;
        }
    }
    DataBlockPtr<T> view()
    {
      lock();
      if (compressed())
 {
   uncompressUnlocked();
 }
      compressible_m = false;
      unlock();
      return block_m;
    }
    DataBlockPtr<T> dataBlock()
    {
      return block_m;
    }
    inline T* data()
    {
      return ptr_m;
    }
    bool compressed() const
    {
      return ptr_m == &compressedData_m;
    }
    DataObject_t* dataObject()
    {
      return &dataObject_m;
    }
    void lock() const
    {
      mutex_m.lock();
    }
    void unlock() const
    {
      mutex_m.unlock();
    }
    bool isValidUnlocked()
    {
      return compressed() || block_m.isValid();
    }
    bool isValid()
    {
      lock();
      bool valid = isValidUnlocked();
      unlock();
      return valid;
    }
  static int randomTries() { return randomTries_s; }
  private:
    virtual void notify(const int& , const ObserverEvent &event)
    {
      switch (event.event())
      {
        case DataBlockController<T>::addViewEvent:
   viewmutex_m.lock();
   ++viewcount_m;
   viewmutex_m.unlock();
   break;
        case DataBlockController<T>::removeViewEvent:
   viewmutex_m.lock();
   --viewcount_m;
   if (viewcount_m == 1 && !Pooma::neverCompress())
     {
       lock();
       compressible_m = true;
       tryCompressUnlocked();
       unlock();
            }
   viewmutex_m.unlock();
          break;
        default:
          if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Invalid event code sent to CompressibleBlockController::notify()", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/CompressibleBlock.h", 954);
      }
    }
    bool compressible_m;
    int countUncompressed_m;
    DataBlockPtr<T> block_m;
    mutable int viewcount_m;
    mutable Pooma::Mutex_t viewmutex_m;
    DataObject_t dataObject_m;
    int size_m;
    T compressedData_m;
    T *ptr_m;
    int ucOffset_m;
    mutable Pooma::Mutex_t mutex_m;
    enum { randomTries_s = 20 };
  };
  RefCountedPtr<CompressibleBlockController> controller_m;
};
struct CompressibleBrick { };
struct CompressibleBrickView { };
template <int Dim, class T>
class Engine<Dim, T, CompressibleBrickView>;
template <int D1, int D2> class SliceInterval;
template <int D1, int D2> class SliceRange;
template <int Dim, class T>
class Engine<Dim, T, CompressibleBrick>
  : public Pooma::BrickBase<Dim>, public Observer<T*>
{
public:
  typedef Engine<Dim,T,CompressibleBrick> This_t;
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef Pooma::BrickBase<Dim> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef T& ElementRef_t;
  typedef CompressibleBrick Tag_t;
  enum { brick = true };
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = false };
  Engine() : data0_m(0) { }
  explicit Engine(const Domain_t &domain);
  Engine(const Domain_t &domain, const T &elementModel);
  explicit Engine(const Layout_t &layout);
  explicit Engine(const Node<Domain_t> &node);
  Engine(const Engine_t &model);
  ~Engine();
  Engine_t &operator=(const Engine_t &model);
  ElementRef_t operator()(int) const;
  ElementRef_t operator()(int, int) const;
  ElementRef_t operator()(int, int, int) const;
  ElementRef_t operator()(int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int, int) const;
  Element_t read(int) const;
  Element_t read(int, int) const;
  Element_t read(int, int, int) const;
  Element_t read(int, int, int, int) const;
  Element_t read(int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int, int) const;
  ElementRef_t operator()(const Loc<Dim> &) const;
  Element_t read(const Loc<Dim> &) const;
  inline const Domain_t &domain() const
  {
    return this->layout_m.domain();
  }
  Engine_t &makeOwnCopy();
  Pooma::DataObject_t *dataObject() const { return cblock_m.dataObject(); }
  DataBlockPtr<T> dataBlock() const { return cblock_m.view(); }
  CompressibleBlock<T> cblock() const { return cblock_m; }
  bool compressed() const;
  long elementsCompressed() const;
  void tryCompress() { cblock_m.tryCompress(); }
  void uncompress() { cblock_m.uncompress(); }
  T compressedRead() const;
  T& compressedReadWrite() const;
  bool compressedBrickIsWholeView() const { return true; }
private:
  CompressibleBlock<T> cblock_m;
  T *data0_m;
  mutable Pooma::Mutex_t mutex_m;
  inline void lock() const { mutex_m.lock(); }
  inline void unlock() const { mutex_m.unlock(); }
  virtual void notify(T* &data, const ObserverEvent &event);
  void resetDataAndStrides();
  void init();
};
template <int Dim, class T>
class Engine<Dim,T,CompressibleBrickView>
  : public Pooma::BrickViewBase<Dim>, public Observer<T*>
{
public:
  typedef Engine<Dim,T,CompressibleBrickView> This_t;
  typedef Engine<Dim,T,CompressibleBrickView> Engine_t;
  typedef Pooma::BrickViewBase<Dim> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef T& ElementRef_t;
  typedef CompressibleBrickView Tag_t;
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = true };
  enum { multiPatch = false };
  Engine() : data0_m(0) { }
  Engine(const Engine_t &model);
  Engine(const Engine_t &model, const EngineConstructTag &);
  template <class DT>
  Engine(const Engine<Dim,T,CompressibleBrick> &e, const Domain<Dim, DT> &dom)
  : Base_t(e, dom.unwrap()), cblock_m(e.cblock()),
    entire_m(e.domain() == dom.unwrap())
  {
    init();
  }
  template <class Domain>
  Engine(const Engine<Dim,T,CompressibleBrick> &e, const Node<Domain> &node)
    : Base_t(e, node.domain()), cblock_m(e.cblock()),
      entire_m(e.domain() == node.domain())
  {
    init();
  }
  Engine(const Engine<Dim,T,CompressibleBrick> &e, const INode<Dim> &inode)
  : Base_t(e, inode.domain()), cblock_m(e.cblock()),
    entire_m(e.domain() == inode.domain())
  {
    init();
  }
  template <class DT, int Dim2>
  Engine(const Engine<Dim2,T,CompressibleBrick> &e, const SliceDomain<DT> &dom)
  : Base_t(e, dom.unwrap()), cblock_m(e.cblock()),
    entire_m(e.domain() == dom.totalDomain())
  {
    init();
  }
  template <class DT>
  Engine(const This_t &e, const Domain<Dim, DT> &dom)
  : Base_t(e, dom.unwrap()), cblock_m(e.cblock()),
    entire_m(e.entire_m && e.domain() == dom.unwrap())
  {
    init();
  }
  Engine(const This_t &e, const INode<Dim> &inode)
  : Base_t(e, inode.domain()), cblock_m(e.cblock()),
    entire_m(e.entire_m && e.domain() == inode.domain())
  {
    init();
  }
  template <int OrigDim, class DT>
  Engine(const Engine<OrigDim,T,CompressibleBrickView> &e,
  const SliceDomain<DT> &dom)
  : Base_t(e, dom.unwrap()), cblock_m(e.cblock()),
    entire_m(e.entire_m && e.domain() == dom.totalDomain())
  {
    init();
  }
  ~Engine();
  Engine_t &operator=(const Engine_t &model);
  ElementRef_t operator()(int) const;
  ElementRef_t operator()(int, int) const;
  ElementRef_t operator()(int, int, int) const;
  ElementRef_t operator()(int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int, int) const;
  Element_t read(int) const;
  Element_t read(int, int) const;
  Element_t read(int, int, int) const;
  Element_t read(int, int, int, int) const;
  Element_t read(int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int, int) const;
  ElementRef_t operator()(const Loc<Dim> &) const;
  Element_t read(const Loc<Dim> &) const;
  inline const Domain_t &domain() const
  {
    return this->domain_m;
  }
  DataBlockPtr<T> dataBlock() const { return cblock_m.view(); }
  inline
  Pooma::DataObject_t *dataObject() const { return cblock_m.dataObject(); }
  CompressibleBlock<T> cblock() const { return cblock_m; }
  bool compressed() const { return cblock_m.compressed(); }
  T compressedRead() const;
  T& compressedReadWrite() const;
  bool compressedBrickIsWholeView() const { return entire_m; }
  long elementsCompressed() const;
private:
  void lock() const { mutex_m.lock(); }
  void unlock() const { mutex_m.unlock(); }
  virtual void notify(T* &data, const ObserverEvent &event)
  {
    switch (event.event())
      {
      default:
      case CompressibleBlock<T>::notifyDestruct:
 ;
 break;
      case CompressibleBlock<T>::notifyUncompress:
        lock();
        this->restoreStrides();
 data0_m = data + this->baseOffset();
 unlock();
 break;
      case CompressibleBlock<T>::notifyCompress:
        lock();
        this->zeroStrides();
 data0_m = data;
 unlock();
 break;
      }
  }
  void init()
  {
    cblock_m.lock();
    resetDataAndStrides();
    ;
    cblock_m.attach(this);
    cblock_m.unlock();
  }
  void resetDataAndStrides()
  {
    if (cblock_m.compressed())
      {
        this->zeroStrides();
 data0_m = cblock_m.data();
      }
    else
      {
        this->restoreStrides();
 data0_m = cblock_m.data() + this->baseOffset();
      }
  }
  CompressibleBlock<T> cblock_m;
  T *data0_m;
  bool entire_m;
  mutable Pooma::Mutex_t mutex_m;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrick>, Interval<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrick>, Range<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrick>,Node<Interval<Dim> > >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrick>,INode<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>, Interval<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>, Range<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>,
                 Node<Interval<Dim> > >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>,INode<Dim> >
{
  typedef Engine<Dim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,CompressibleBrick>,SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,CompressibleBrick>,SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>,
                 SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,CompressibleBrickView>,
                 SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,CompressibleBrickView> Type_t;
};
template <int Dim, class T>
struct ElementProperties<Engine<Dim, T, CompressibleBrick> >
  : public MakeOwnCopyProperties<Engine<Dim, T, CompressibleBrick> >
{ };
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(const Loc<Dim> &loc) const
{
  return data0_m[this->offsetC(loc)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1) const
{
  ;
  return data0_m[this->offsetC(i1)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2) const
{
  ;
  return data0_m[this->offsetC(i1,i2)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2, int i3) const
{
  ;
  return data0_m[this->offsetC(i1,i2,i3)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2, int i3, int i4) const
{
  ;
  return data0_m[this->offsetC(i1,i2,i3,i4)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  return data0_m[this->offsetC(i1,i2,i3,i4,i5)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  return data0_m[this->offsetC(i1,i2,i3,i4,i5,i6)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrick>::
read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  return data0_m[this->offsetC(i1,i2,i3,i4,i5,i6,i7)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(const Loc<Dim> &loc) const
{
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(loc)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2, int i3) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2,i3)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2, int i3, int i4) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2,i3,i4)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2,i3,i4,i5)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2,i3,i4,i5,i6)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrick>::
operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offsetC(i1,i2,i3,i4,i5,i6,i7)];
}
template <int Dim, class T>
inline bool
Engine<Dim,T,CompressibleBrick>::
compressed() const
{
  ;
  return cblock_m.compressed();
}
template <int Dim, class T>
inline T
Engine<Dim,T,CompressibleBrick>::
compressedRead() const
{
  ;
  ;
  return *data0_m;
}
template <int Dim, class T>
inline T&
Engine<Dim,T,CompressibleBrick>::
compressedReadWrite() const
{
  ;
  ;
  return *data0_m;
}
template <int Dim, class T>
inline bool compressed(const Engine<Dim, T, CompressibleBrick> &e)
{
  return e.compressed();
}
template <int Dim, class T>
inline long elementsCompressed(const Engine<Dim, T, CompressibleBrick> &e)
{
  return e.elementsCompressed();
}
template <int Dim, class T>
inline void compress(Engine<Dim, T, CompressibleBrick> &e)
{
  e.tryCompress();
}
template <int Dim, class T>
inline void uncompress(Engine<Dim, T, CompressibleBrick> &e)
{
  e.uncompress();
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(const Loc<Dim> &loc) const
{
  return data0_m[this->offset(loc)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1) const
{
  ;
  return data0_m[this->offset(i1)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2) const
{
  ;
  return data0_m[this->offset(i1,i2)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2, int i3) const
{
  ;
  return data0_m[this->offset(i1,i2,i3)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2, int i3, int i4) const
{
  ;
  return data0_m[this->offset(i1,i2,i3,i4)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  return data0_m[this->offset(i1,i2,i3,i4,i5)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  return data0_m[this->offset(i1,i2,i3,i4,i5,i6)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  return data0_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(const Loc<Dim> &loc) const
{
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(loc)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2, int i3) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2,i3)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2, int i3, int i4) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2,i3,i4)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2,i3,i4,i5)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2,i3,i4,i5,i6)];
}
template <int Dim, class T>
inline T & Engine<Dim,T,CompressibleBrickView>::
operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  if (cblock_m.compressed()) cblock_m.uncompress();
  return data0_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
}
template <int Dim, class T>
inline T Engine<Dim,T,CompressibleBrickView>::
compressedRead() const
{
  ;
  return *data0_m;
}
template <int Dim, class T>
inline T& Engine<Dim,T,CompressibleBrickView>::
compressedReadWrite() const
{
  ;
  return *data0_m;
}
template <int Dim, class T>
inline
bool compressed(const Engine<Dim,T,CompressibleBrickView> &e)
{
  return e.compressed();
}
template <int Dim, class T>
inline
long elementsCompressed(const Engine<Dim,T,CompressibleBrickView> &e)
{
  return e.elementsCompressed();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::Engine(const Domain_t &domain)
  : Base_t(domain), cblock_m(domain.size())
{
  init();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::Engine(const Node<Domain_t> &node)
  : Base_t(node.allocated()),
    cblock_m(node.allocated().size(), node.affinity())
{
  init();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::Engine(const Layout_t &layout)
  : Base_t(layout.domain()), cblock_m(layout.domain().size())
{
  init();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::Engine(const Domain_t &domain, const T& model)
  : Base_t(domain), cblock_m(domain.size(),-1,model)
{
  init();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::
Engine(const Engine<Dim,T,CompressibleBrick> &modelEngine)
  : cblock_m(modelEngine.cblock_m)
{
  cblock_m.lock();
  data0_m = modelEngine.data0_m;
  Base_t::operator=(modelEngine);
  if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
  cblock_m.unlock();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick> &
Engine<Dim,T,CompressibleBrick>::
operator=(const Engine<Dim,T,CompressibleBrick> &modelEngine)
{
  if (this != &modelEngine)
    {
      ;
      modelEngine.cblock_m.lock();
      if (cblock_m.isControllerPtrValid())
        {
          cblock_m.lock();
          if (cblock_m.isControllerValidUnlocked())
            {
              cblock_m.detach(this);
            }
          cblock_m.unlock();
        }
      cblock_m = modelEngine.cblock_m;
      lock();
      data0_m = modelEngine.data0_m;
      Base_t::operator=(modelEngine);
      unlock();
      if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
      cblock_m.unlock();
    }
  return *this;
}
template <int Dim, class T>
void Engine<Dim,T,CompressibleBrick>::init()
{
  resetDataAndStrides();
  ;
  cblock_m.attach(this);
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick>::~Engine()
{
  if (data0_m)
    {
      cblock_m.lock();
      if (cblock_m.isControllerValidUnlocked())
        {
          cblock_m.detach(this);
        }
      cblock_m.unlock();
    }
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrick> &Engine<Dim,T,CompressibleBrick>::makeOwnCopy()
{
  if (cblock_m.isControllerValidUnlocked() && cblock_m.isShared())
    {
      cblock_m.detach(this);
      cblock_m.makeOwnCopy();
      cblock_m.attach(this);
      data0_m = cblock_m.data() + (cblock_m.compressed() ? 0 : this->baseOffset());
    }
  return *this;
}
template <int Dim, class T>
void Engine<Dim,T,CompressibleBrick>::
notify(T* &data, const ObserverEvent &event)
{
  switch (event.event())
    {
    default:
    case CompressibleBlock<T>::notifyDestruct:
      ;
      break;
    case CompressibleBlock<T>::notifyUncompress:
      lock();
      this->restoreStrides();
      data0_m = data + this->baseOffset();
      unlock();
      break;
    case CompressibleBlock<T>::notifyCompress:
      lock();
      this->zeroStrides();
      data0_m = data;
      unlock();
      break;
    }
}
template <int Dim, class T>
void Engine<Dim,T,CompressibleBrick>::resetDataAndStrides()
{
  if (cblock_m.compressed())
    {
      this->zeroStrides();
      data0_m = cblock_m.data();
    }
  else
    {
      this->restoreStrides();
      data0_m = cblock_m.data() + this->baseOffset();
    }
}
template <int Dim, class T>
long Engine<Dim,T,CompressibleBrick>::
elementsCompressed() const
{
  if (compressed())
    return domain().size();
  else
    return 0L;
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrickView>::
~Engine()
{
  cblock_m.lock();
  if (cblock_m.isControllerValidUnlocked())
    {
      cblock_m.detach(this);
    }
  cblock_m.unlock();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrickView> &
Engine<Dim,T,CompressibleBrickView>::
operator=(const Engine<Dim,T,CompressibleBrickView> &modelEngine)
{
  if (this != &modelEngine)
    {
      ;
      modelEngine.cblock_m.lock();
      if (cblock_m.isControllerPtrValid())
        {
          cblock_m.lock();
          if (cblock_m.isControllerValidUnlocked())
            {
              cblock_m.detach(this);
            }
          cblock_m.unlock();
        }
      cblock_m = modelEngine.cblock_m;
      entire_m = modelEngine.entire_m;
      lock();
      data0_m = modelEngine.data0_m;
      Base_t::operator=(modelEngine);
      unlock();
      if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
      cblock_m.unlock();
    }
  return *this;
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrickView>::
Engine(const Engine<Dim,T,CompressibleBrickView> &modelEngine)
  : cblock_m(modelEngine.cblock_m),
    entire_m(modelEngine.entire_m)
{
  cblock_m.lock();
  data0_m = modelEngine.data0_m;
  Base_t::operator=(modelEngine);
  if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
  cblock_m.unlock();
}
template <int Dim, class T>
Engine<Dim,T,CompressibleBrickView>::
Engine(const Engine<Dim,T,CompressibleBrickView> &modelEngine,
       const EngineConstructTag &)
  : cblock_m(modelEngine.cblock_m),
    entire_m(modelEngine.entire_m)
{
  cblock_m.lock();
  data0_m = modelEngine.data0_m;
  Base_t::operator=(modelEngine);
  if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
  cblock_m.unlock();
}
template <int Dim, class T>
long Engine<Dim,T,CompressibleBrickView>::
elementsCompressed() const
{
  if (compressed())
    return domain().size();
  else
    return 0L;
}
template <int Dim> class Range;
struct Brick {};
struct BrickView {};
struct BrickViewU {};
template <int Dim, class T>
class Engine<Dim,T,BrickView>;
template <int Dim, class T>
class Engine<Dim,T,Brick> : public Pooma::BrickBase<Dim>
{
public:
  typedef Engine<Dim,T,Brick> This_t;
  typedef Engine<Dim,T,Brick> Engine_t;
  typedef Pooma::BrickBase<Dim> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef T& ElementRef_t;
  typedef Brick Tag_t;
  enum { brick = true };
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = false };
  Engine() { }
  explicit Engine(const Domain_t &domain);
  Engine(const Domain_t &domain, const T &elementModel);
  explicit Engine(const Layout_t &layout);
  explicit Engine(const Node<Domain_t> &node);
  Engine(T * foreignData, const Domain_t &domain);
  Engine(const This_t &model)
    : Base_t(model), dataBlock_m(model.dataBlock_m),
      data_m(model.data_m)
  {}
  ~Engine() {}
  This_t &operator=(const This_t &model)
  {
    if (this == &model)
      return *this;
    Base_t::operator=(model);
    dataBlock_m = model.dataBlock_m;
    data_m = model.data_m;
    ;
    return *this;
  }
  Element_t read(const Loc<Dim> &loc) const
  {
    return data_m[this->offset(loc)];
  }
  ElementRef_t operator()(const Loc<Dim> &loc) const
  {
    return data_m[this->offset(loc)];
  }
  Element_t read(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offset(i1)];
  }
  Element_t read(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offset(i1,i2)];
  }
  Element_t read(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offset(i1,i2,i3)];
  }
  Element_t read(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offset(i1,i2,i3,i4)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  ElementRef_t operator()(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offset(i1)];
  }
  ElementRef_t operator()(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offset(i1,i2)];
  }
  ElementRef_t operator()(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offset(i1,i2,i3)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offset(i1,i2,i3,i4)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  Engine_t &makeOwnCopy();
  inline
  Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
  DataBlockPtr<T> dataBlock() { return dataBlock_m; }
  const DataBlockPtr<T> & dataBlock() const { return dataBlock_m; }
  bool isShared() const { return dataBlock_m.isValid() && dataBlock_m.count() > 1; }
private:
  DataBlockPtr<T> dataBlock_m;
  T *data_m;
};
template <int Dim, class T>
Engine<Dim,T,Brick>::Engine(const Domain_t &dom)
  : Base_t(dom), dataBlock_m(dom.size()), data_m(dataBlock_m.currentPointer())
{ }
template <int Dim, class T>
Engine<Dim,T,Brick>::Engine(const Node<Domain_t> &node)
  : Base_t(node),
    dataBlock_m(node.allocated().size(), node.affinity(),
           typename DataBlockPtr<T>::WithAffinity_t()),
    data_m(dataBlock_m.currentPointer())
{ }
template <int Dim, class T>
Engine<Dim,T,Brick>::Engine(const Layout_t &layout)
  : Base_t(layout), dataBlock_m(layout.domain().size()),
    data_m(dataBlock_m.currentPointer())
{ }
template <int Dim, class T>
Engine<Dim,T,Brick>::Engine(const Domain_t &dom, const T& model)
  : Base_t(dom), dataBlock_m(dom.size(), model),
    data_m(dataBlock_m.currentPointer())
{ }
template <int Dim, class T>
Engine<Dim,T,Brick>::Engine(T * foreignData, const Domain_t &dom)
  : Base_t(dom), dataBlock_m(foreignData, dom.size()),
    data_m(dataBlock_m.currentPointer())
{ }
template <int Dim, class T>
Engine<Dim,T,Brick> &Engine<Dim,T,Brick>::makeOwnCopy()
{
  if (dataBlock_m.isValid() && dataBlock_m.count() > 1)
    {
      ;
      dataBlock_m.makeOwnCopy();
      data_m = dataBlock_m.currentPointer();
    }
  return *this;
}
template <int Dim, class T>
class Engine<Dim,T,BrickView>
 : public Pooma::BrickViewBase<Dim>
{
public:
  typedef Engine<Dim,T,BrickView> This_t;
  typedef Engine<Dim,T,BrickView> Engine_t;
  typedef Pooma::BrickViewBase<Dim> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef T& ElementRef_t;
  typedef BrickView Tag_t;
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = true };
  enum { multiPatch = false };
  Engine()
    : Base_t(), dataBlock_m(), data_m(0)
  {}
  Engine(const This_t &model)
    : Base_t(model), dataBlock_m(model.dataBlock_m),
      data_m(dataBlock_m.currentPointer())
  {}
  Engine(const This_t &model, const EngineConstructTag &)
    : Base_t(model), dataBlock_m(model.dataBlock_m),
      data_m(dataBlock_m.currentPointer())
  {}
  template <class DT>
  Engine(const Engine<Dim,T,Brick> &e, const Domain<Dim, DT> &dom)
  : Base_t(e, dom.unwrap()), dataBlock_m(e.dataBlock(), e.offset(dom.unwrap())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template<int Dim2>
  Engine(const Engine<Dim2,T,Brick> &e, const SliceRange<Dim2,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template<int Dim2>
  Engine(const Engine<Dim2,T,Brick> &e, const SliceInterval<Dim2,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template <int Dim2>
  Engine(const Engine<Dim2,T,Brick> &e, const SliceInterval<Dim,Dim2> &dom,
  const Interval<Dim> &totalDomain)
    : Base_t(e, dom, totalDomain), dataBlock_m(e.dataBlock(), e.offset(dom.sliceDomain())),
      data_m(dataBlock_m.currentPointer())
  {
  }
  template <int Dim2>
  Engine(const Engine<Dim2,T,BrickView> &e, const SliceInterval<Dim,Dim2> &dom,
  const Interval<Dim> &totalDomain)
    : Base_t(e, dom, totalDomain), dataBlock_m(e.dataBlock(), e.offset(dom.sliceDomain())),
      data_m(dataBlock_m.currentPointer())
  {
  }
  template <int Dim2>
  Engine(const Engine<Dim2,T,BrickViewU> &e, const SliceInterval<Dim,Dim2> &dom,
  const Interval<Dim> &totalDomain)
    : Base_t(e, dom, totalDomain), dataBlock_m(e.dataBlock(), e.offset(dom.sliceDomain())),
      data_m(dataBlock_m.currentPointer())
  {
  }
  template <class DT>
  Engine(const This_t &e, const Domain<Dim, DT> &d)
    : Base_t(e, d.unwrap()), dataBlock_m(e.dataBlock(), e.offset(d.unwrap())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <class DT>
  Engine(const Engine<Dim,T,BrickViewU> &e, const Domain<Dim, DT> &d)
    : Base_t(e, d.unwrap()), dataBlock_m(e.dataBlock(), e.offset(d.unwrap())),
    data_m(dataBlock_m.currentPointer())
  { }
  Engine(const This_t &e, const INode<Dim> &inode)
    : Base_t(e,inode.domain()), dataBlock_m(e.dataBlock(), e.offset(inode.domain())),
    data_m(dataBlock_m.currentPointer())
  { }
  Engine(const Engine<Dim,T,BrickViewU> &e, const INode<Dim> &inode)
    : Base_t(e,inode.domain()), dataBlock_m(e.dataBlock(), e.offset(inode.domain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickView> &e,
         const SliceRange<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickViewU> &e,
         const SliceRange<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickView> &e,
  const SliceInterval<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickViewU> &e,
    const SliceInterval<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  explicit Engine(const Engine<Dim,T,CompressibleBrick> &);
  explicit Engine(const Engine<Dim,T,CompressibleBrickView> &);
  ~Engine() {}
  This_t &operator=(const This_t &model)
  {
    if (this == &model)
      return *this;
    Base_t::operator=(model);
    dataBlock_m = model.dataBlock_m;
    data_m = model.data_m;
    return *this;
  }
  Element_t read(const Loc<Dim> &loc) const
  {
    return data_m[this->offset(loc)];
  }
  ElementRef_t operator()(const Loc<Dim> &loc) const
  {
    return data_m[this->offset(loc)];
  }
  Element_t read(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offset(i1)];
  }
  Element_t read(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offset(i1,i2)];
  }
  Element_t read(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offset(i1,i2,i3)];
  }
  Element_t read(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offset(i1,i2,i3,i4)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  ElementRef_t operator()(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offset(i1)];
  }
  ElementRef_t operator()(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offset(i1,i2)];
  }
  ElementRef_t operator()(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offset(i1,i2,i3)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offset(i1,i2,i3,i4)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  DataBlockPtr<T> dataBlock() { return dataBlock_m; }
  const DataBlockPtr<T> &dataBlock() const { return dataBlock_m; }
  inline
  Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
private:
  DataBlockPtr<T> dataBlock_m;
  T *data_m;
};
template <int Dim, class T>
Engine<Dim,T,BrickView>::
Engine(const Engine<Dim,T,CompressibleBrick> &model)
  : Base_t(model, false)
{
  dataBlock_m = DataBlockPtr<T>(model.dataBlock(),this->baseOffset());
  data_m = dataBlock_m.currentPointer();
}
template <int Dim, class T>
Engine<Dim,T,BrickView>::
Engine(const Engine<Dim,T,CompressibleBrickView> &model)
  : Base_t(model, false)
{
  dataBlock_m = DataBlockPtr<T>(model.dataBlock(),this->baseOffset());
  data_m = dataBlock_m.currentPointer();
}
template <int Dim, class T>
class Engine<Dim,T,BrickViewU>
 : public Pooma::BrickViewBase<Dim>
{
public:
  typedef Engine<Dim,T,BrickViewU> This_t;
  typedef Engine<Dim,T,BrickViewU> Engine_t;
  typedef Pooma::BrickViewBase<Dim> Base_t;
  typedef typename Base_t::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef T& ElementRef_t;
  typedef BrickViewU Tag_t;
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = true };
  enum { multiPatch = false };
  Engine()
    : Base_t(), dataBlock_m(), data_m(0)
  {}
  Engine(const This_t &model)
    : Base_t(model), dataBlock_m(model.dataBlock_m),
      data_m(dataBlock_m.currentPointer())
  {}
  Engine(const This_t &model, const EngineConstructTag &)
    : Base_t(model), dataBlock_m(model.dataBlock_m),
      data_m(dataBlock_m.currentPointer())
  {}
  template <class ETag, class DT>
  Engine(const Engine<Dim,T,ETag> &e, const Domain<Dim, DT> &dom)
  : Base_t(e, dom.unwrap()), dataBlock_m(e.dataBlock(), e.offset(dom.unwrap())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template<int Dim2>
  Engine(const Engine<Dim2,T,Brick> &e, const SliceRange<Dim2,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template<int Dim2>
  Engine(const Engine<Dim2,T,Brick> &e, const SliceInterval<Dim2,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  {
    ;
  }
  template <class DT>
  Engine(const This_t &e, const Domain<Dim, DT> &d)
    : Base_t(e, d.unwrap()), dataBlock_m(e.dataBlock(), e.offset(d.unwrap())),
    data_m(dataBlock_m.currentPointer())
  { }
  Engine(const This_t &e, const INode<Dim> &inode)
    : Base_t(e,inode.domain()), dataBlock_m(e.dataBlock(), e.offset(inode.domain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickView> &e,
         const SliceRange<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  template <int ODim>
  Engine(const Engine<ODim,T,BrickViewU> &e,
    const SliceInterval<ODim,Dim> &dom)
    : Base_t(e, dom), dataBlock_m(e.dataBlock(), e.offset(dom.totalDomain())),
    data_m(dataBlock_m.currentPointer())
  { }
  explicit Engine(const Engine<Dim,T,CompressibleBrick> &);
  explicit Engine(const Engine<Dim,T,CompressibleBrickView> &);
  ~Engine() {}
  This_t &operator=(const This_t &model)
  {
    if (this == &model)
      return *this;
    Base_t::operator=(model);
    dataBlock_m = model.dataBlock_m;
    data_m = model.data_m;
    return *this;
  }
  Element_t read(const Loc<Dim> &loc) const
  {
    return data_m[this->offsetU(loc)];
  }
  ElementRef_t operator()(const Loc<Dim> &loc) const
  {
    return data_m[this->offsetU(loc)];
  }
  Element_t read(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offsetU(i1)];
  }
  Element_t read(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offsetU(i1,i2)];
  }
  Element_t read(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offsetU(i1,i2,i3)];
  }
  Element_t read(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5,i6)];
  }
  Element_t read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5,i6,i7)];
  }
  ElementRef_t operator()(int i1) const
  {
    PoomaCTAssert<(Dim == 1)>::test();
    return data_m[this->offsetU(i1)];
  }
  ElementRef_t operator()(int i1, int i2) const
  {
    PoomaCTAssert<(Dim == 2)>::test();
    return data_m[this->offsetU(i1,i2)];
  }
  ElementRef_t operator()(int i1, int i2, int i3) const
  {
    PoomaCTAssert<(Dim == 3)>::test();
    return data_m[this->offsetU(i1,i2,i3)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4) const
  {
    PoomaCTAssert<(Dim == 4)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5) const
  {
    PoomaCTAssert<(Dim == 5)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PoomaCTAssert<(Dim == 6)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5,i6)];
  }
  ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PoomaCTAssert<(Dim == 7)>::test();
    return data_m[this->offsetU(i1,i2,i3,i4,i5,i6,i7)];
  }
  DataBlockPtr<T> dataBlock() { return dataBlock_m; }
  const DataBlockPtr<T> &dataBlock() const { return dataBlock_m; }
  inline
  Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
private:
  DataBlockPtr<T> dataBlock_m;
  T *data_m;
};
template <int Dim, class T>
Engine<Dim,T,BrickViewU>::
Engine(const Engine<Dim,T,CompressibleBrick> &model)
  : Base_t(model, false)
{
  dataBlock_m = DataBlockPtr<T>(model.dataBlock(),this->baseOffset());
  data_m = dataBlock_m.currentPointer();
}
template <int Dim, class T>
Engine<Dim,T,BrickViewU>::
Engine(const Engine<Dim,T,CompressibleBrickView> &model)
  : Base_t(model, false)
{
  dataBlock_m = DataBlockPtr<T>(model.dataBlock(),this->baseOffset());
  data_m = dataBlock_m.currentPointer();
}
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,Brick>, Interval<Dim> >
{
  typedef Engine<Dim,T,BrickViewU> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,Brick>, Range<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,Brick>, Node<Interval<Dim> > >
{
  typedef Engine<Dim,T,BrickViewU> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,Brick>, INode<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,Brick>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,Brick>, SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<SliceDim,T,Brick>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<SliceDim,T,BrickView>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<SliceDim,T,BrickViewU>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickView>, Interval<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickView>, Range<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickView>, Node<Interval<Dim> > >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickView>, INode<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,BrickView>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,BrickView>, SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickViewU>, Interval<Dim> >
{
  typedef Engine<Dim,T,BrickViewU> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickViewU>, Range<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickViewU>, Node<Interval<Dim> > >
{
  typedef Engine<Dim,T,BrickViewU> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim,T,BrickViewU>, INode<Dim> >
{
  typedef Engine<Dim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,BrickViewU>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,BrickViewU>, SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,BrickView> Type_t;
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,Brick>, Node<Interval<Dim> > >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,Brick> &,
   const Node<Interval<Dim> > &node)
  {
    return node.domain();
  }
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,Brick>, INode<Dim> >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,Brick> &,
   const INode<Dim> &inode)
  {
    return inode.domain();
  }
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,BrickView>, Node<Interval<Dim> > >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,BrickView> &,
   const Node<Interval<Dim> > &node)
  {
    return node.domain();
  }
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,BrickView>, INode<Dim> >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,BrickView> &,
   const INode<Dim> &inode)
  {
    return inode.domain();
  }
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,BrickViewU>, Node<Interval<Dim> > >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,BrickViewU> &,
   const Node<Interval<Dim> > &node)
  {
    return node.domain();
  }
};
template <int Dim, class T>
struct NewEngineDomain<Engine<Dim,T,BrickViewU>, INode<Dim> >
{
  typedef Interval<Dim> Type_t;
  typedef const Interval<Dim> &Return_t;
  static inline
  Return_t apply(const Engine<Dim,T,BrickViewU> &,
   const INode<Dim> &inode)
  {
    return inode.domain();
  }
};
template <int Dim, class T>
struct ElementProperties<Engine<Dim, T, Brick> >
  : public MakeOwnCopyProperties<Engine<Dim, T, Brick> >
{ };
template <class Expr>
inline bool compressed(const Expr &expr)
{
  return false;
}
template <class Expr>
double compressedFraction(const Expr &expr)
{
  return static_cast<double>(elementsCompressed(expr)) / expr.domain().size();
}
template <class Expr>
inline long elementsCompressed(const Expr &expr)
{
  return 0L;
}
template <class Expr>
inline void compress(Expr &)
{ }
template <class Expr>
inline void uncompress(Expr &)
{ }
struct ConstantFunction
{ };
template<int Dim, class T>
class Engine<Dim, T, ConstantFunction>
{
public:
  typedef ConstantFunction Tag_t;
  typedef Engine<Dim, T, ConstantFunction> This_t;
  typedef This_t Engine_t;
  typedef Interval<Dim> Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  enum { dimensions = Dim };
  enum { hasDataObject = false };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = false };
  Engine() { }
  explicit Engine(const Domain_t &domain, T val = T())
  : val_m(val), domain_m(domain)
  {
    for (int d = 0; d < Dim; ++d)
      firsts_m[d] = domain[d].first();
  }
  template<class Layout>
  explicit Engine(const Layout &layout, T val = T())
  : val_m(val), domain_m(layout.domain())
  {
    for (int d = 0; d < Dim; ++d)
      firsts_m[d] = domain_m[d].first();
  }
  Engine(const Engine<Dim, T, ConstantFunction> &model)
  : val_m(model.constant()), domain_m(model.domain())
  {
    for (int d = 0; d < Dim; ++d)
      {
        firsts_m[d] = model.firsts_m[d];
      }
  }
  template<class DT>
  Engine(const Engine<Dim, T, ConstantFunction> &e, const Domain<Dim, DT> &dom)
  : val_m(e.constant()), domain_m(Pooma::NoInit())
  {
    const typename DT::Domain_t &domain = dom.unwrap();
    for (int d = 0; d < Dim; ++d)
      {
        domain_m[d] = Interval<1>(domain[d].length());
        firsts_m[d] = 0;
      }
  }
  template<int Dim2, class DT>
  Engine(const Engine<Dim2, T, ConstantFunction> &e,
    const SliceDomain<DT> &dom)
  : val_m(e.constant()), domain_m(Pooma::NoInit())
  {
    PoomaCTAssert<(DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<(DT::dimensions == Dim2)>::test();
    const typename DT::SliceDomain_t &domain = dom.sliceDomain();
    for (int d = 0; d < Dim; ++d)
      {
        domain_m[d] = Interval<1>(domain[d].length());
        firsts_m[d] = 0;
      }
  }
  template<class Domain>
  Engine(const Engine<Dim, T, ConstantFunction> &e, const Node<Domain> &node)
  : val_m(e.constant()), domain_m(Pooma::NoInit())
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
    const Domain &domain = node.domain();
    for (int d = 0; d < Dim; ++d)
      {
        domain_m[d] = Interval<1>(domain[d].length());
        firsts_m[d] = 0;
      }
  }
  Engine(const Engine<Dim, T, ConstantFunction> &e, const INode<Dim> &inode)
  : val_m(e.constant()), domain_m(Pooma::NoInit())
  {
    const typename INode<Dim>::Domain_t &domain = inode.domain();
    for (int d = 0; d < Dim; ++d)
      {
        domain_m[d] = Interval<1>(domain[d].length());
        firsts_m[d] = 0;
      }
  }
  inline Element_t read(int) const
    {
      return val_m;
    }
  inline Element_t read(int, int) const
    {
      return val_m;
    }
  inline Element_t read(int, int, int) const
    {
      return val_m;
    }
  inline Element_t read(int, int, int, int) const
    {
      return val_m;
    }
  inline Element_t read(int, int, int, int, int) const
    {
      return val_m;
    }
  inline Element_t read(int, int, int, int, int, int) const
    {
      return val_m;
    }
  inline Element_t read(int, int, int, int, int, int, int) const
    {
      return val_m;
    }
  inline Element_t read(const Loc<Dim> &) const
    {
      return val_m;
    }
  const Domain_t &domain() const { return domain_m; }
  inline Layout_t layout() const { return Layout_t(domain_m); }
  inline int first(int i) const
  {
    ;
    return firsts_m[i];
  }
  T constant() const { return val_m; }
  void setConstant(T val) { val_m = val; }
private:
  T val_m;
  Domain_t domain_m;
  int firsts_m[Dim];
};
template <int Dim, class T>
struct NewEngine<Engine<Dim, T, ConstantFunction>, Interval<Dim> >
{
  typedef Engine<Dim, T, ConstantFunction> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim, T, ConstantFunction>, Range<Dim> >
{
  typedef Engine<Dim, T, ConstantFunction> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,ConstantFunction>, SliceInterval<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,ConstantFunction> Type_t;
};
template <int Dim, class T, int SliceDim>
struct NewEngine<Engine<Dim,T,ConstantFunction>, SliceRange<Dim,SliceDim> >
{
  typedef Engine<SliceDim,T,ConstantFunction> Type_t;
};
template <int Dim, class T, class Domain>
struct NewEngine<Engine<Dim, T, ConstantFunction>, Node<Domain> >
{
  typedef Engine<Dim, T, ConstantFunction> Type_t;
};
template <int Dim, class T>
struct NewEngine<Engine<Dim, T, ConstantFunction>, INode<Dim> >
{
  typedef Engine<Dim, T, ConstantFunction> Type_t;
};
struct ErrorDomain
{
};
struct NullDomain
{
};
template<class D>
bool contains(const NullDomain &, const D &)
{
  return true;
}
template<class Inter>
struct IntersectorTag
{
  inline IntersectorTag(Inter &i) : intersector_m(i) { }
  Inter &intersector_m;
};
template<class Eng, class Intersect>
struct DefaultExpressionApply<Eng, IntersectorTag<Intersect> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const Eng &,
        const ExpressionApply<IntersectorTag<Intersect> > &)
  {
    PoomaCTAssert<(!(Eng::multiPatch))>::test();
    return true;
  }
};
struct AssertEquals
{
  AssertEquals(int ignore = 0) : ignore_m(ignore) { }
  int ignore_m;
};
template<class Op>
struct Combine2<int, int, Op, AssertEquals>
{
  typedef int Type_t;
  inline static
  Type_t combine(const int &a, const int &b, const AssertEquals &ae)
  {
    int ret = a;
    if ((a != ae.ignore_m) && (b != ae.ignore_m))
    {
      ;
    }
    else
    {
      if (b != ae.ignore_m) return ret = b;
    }
    return ret;
  }
};
template<class Thing>
struct View0
{
};
template<class Thing, class Sub>
struct View1
{
};
template<class Thing, class Sub1, class Sub2>
struct View2
{
};
template<class Thing, class Sub1, class Sub2, class Sub3>
struct View3
{
};
template<class Thing, class Sub1, class Sub2, class Sub3, class Sub4>
struct View4
{
};
template<class Thing, class Sub1, class Sub2, class Sub3, class Sub4,
  class Sub5>
struct View5
{
};
template<class Thing, class Sub1, class Sub2, class Sub3, class Sub4,
  class Sub5, class Sub6>
struct View6
{
};
template<class Thing, class Sub1, class Sub2, class Sub3, class Sub4,
  class Sub5, class Sub6, class Sub7>
struct View7
{
};
template<class Components, class Object>
struct ComponentView;
struct EnginePatch
{
  typedef TreeCombine Combine_t;
  typedef int PatchID_t;
  explicit EnginePatch(PatchID_t patch) : patch_m(patch) { }
  PatchID_t patch_m;
};
template<class Eng>
struct EngineFunctorDefault<Eng, EnginePatch>
{
  typedef Eng Type_t;
  inline static
  const Type_t &apply(const Eng &e, const EnginePatch &)
  {
    PoomaCTAssert<(!(Eng::multiPatch))>::test();
    return e;
  }
};
template<class T>
struct LeafFunctor<Scalar<T>, EnginePatch>
{
  typedef Scalar<T> Type_t;
  inline static
  Type_t apply(const Scalar<T> &scalar, const EnginePatch &)
  {
    return scalar;
  }
};
template<class Container>
struct Patch
{
};
template<class Container>
struct PatchView
{
  typedef typename Patch<Container>::Type_t Patch_t;
  typedef typename Patch_t::Domain_t Dom_t;
  typedef typename View1<Patch_t, Dom_t>::Type_t Type_t;
  inline static
  Type_t make(const Container &subject, int i)
  {
    return subject.patchLocal(i)();
  }
};
template<class Node>
struct LeafFunctor<Node, EnginePatch>
{
  typedef typename PatchView<Node>::Type_t Type_t;
  inline static
  Type_t apply(const Node &node, const EnginePatch &tag)
  {
    return node.patchLocal(tag.patch_m)();
  }
};
struct EngineNumPatches
{
  typedef AssertEquals Combine_t;
};
template<class Eng>
struct EngineFunctorDefault<Eng, EngineNumPatches>
{
  typedef int Type_t;
  inline static
  Type_t apply(const Eng &, const EngineNumPatches &)
  {
    PoomaCTAssert<(!(Eng::multiPatch))>::test();
    return 1;
  }
};
template<class T>
struct EngineFunctorScalar<T, EngineNumPatches>
{
  typedef int Type_t;
  inline static
  Type_t apply(const T &, const EngineNumPatches &)
  {
    return 0;
  }
};
template <int Dim>
class DomainLayout;
template<int Dim>
struct EvalLeaf { };
template<class T, int Dim>
struct LeafFunctor<Scalar<T>, EvalLeaf<Dim> >
{
  typedef T Type_t;
  inline static
  Type_t apply(const Scalar<T> &s, const EvalLeaf<Dim> &)
    {
      return s.value();
    }
};
template<int Dim, class T, class E>
struct LeafFunctor<Engine<Dim, T, E>, EvalLeaf<Dim> >
{
  typedef T Type_t;
  inline static
  Type_t apply(const Engine<Dim, T, E> &e, const EvalLeaf<Dim> &t)
  {
    return t.eval(e);
  }
};
template<>
struct EvalLeaf<1>
{
  int i1_m;
  inline EvalLeaf(int i1)
    : i1_m(i1)
  { }
  inline EvalLeaf(const Loc<1> &loc)
    : i1_m(loc[0].first())
  { }
  inline int val1() const { return i1_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1());
  }
};
template<>
struct EvalLeaf<2>
{
  int i1_m, i2_m;
  inline EvalLeaf(int i1, int i2)
    : i1_m(i1), i2_m(i2)
  { }
  inline EvalLeaf(const Loc<2> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2());
  }
};
template<>
struct EvalLeaf<3>
{
  int i1_m, i2_m, i3_m;
  inline EvalLeaf(int i1, int i2, int i3)
    : i1_m(i1), i2_m(i2), i3_m(i3)
  { }
  inline EvalLeaf(const Loc<3> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first()), i3_m(loc[2].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2(), val3());
  }
};
template<>
struct EvalLeaf<4>
{
  int i1_m, i2_m, i3_m, i4_m;
  inline EvalLeaf(int i1, int i2, int i3, int i4)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4)
  { }
  inline EvalLeaf(const Loc<4> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first()), i3_m(loc[2].first()),
      i4_m(loc[3].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2(), val3(), val4());
  }
};
template<>
struct EvalLeaf<5>
{
  int i1_m, i2_m, i3_m, i4_m, i5_m;
  inline EvalLeaf(int i1, int i2, int i3, int i4, int i5)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5)
  { }
  inline EvalLeaf(const Loc<5> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first()), i3_m(loc[2].first()),
      i4_m(loc[3].first()), i5_m(loc[4].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2(), val3(), val4(), val5());
  }
};
template<>
struct EvalLeaf<6>
{
  int i1_m, i2_m, i3_m, i4_m, i5_m, i6_m;
  inline EvalLeaf(int i1, int i2, int i3, int i4, int i5, int i6)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5), i6_m(i6)
  { }
  inline EvalLeaf(const Loc<6> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first()), i3_m(loc[2].first()),
      i4_m(loc[3].first()), i5_m(loc[4].first()), i6_m(loc[5].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
  inline int val6() const { return i6_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2(), val3(), val4(), val5(), val6());
  }
};
template<>
struct EvalLeaf<7>
{
  int i1_m, i2_m, i3_m, i4_m, i5_m, i6_m, i7_m;
  inline EvalLeaf(int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    : i1_m(i1), i2_m(i2), i3_m(i3), i4_m(i4), i5_m(i5), i6_m(i6), i7_m(i7)
  { }
  inline EvalLeaf(const Loc<7> &loc)
    : i1_m(loc[0].first()), i2_m(loc[1].first()), i3_m(loc[2].first()),
      i4_m(loc[3].first()), i5_m(loc[4].first()), i6_m(loc[5].first()),
      i7_m(loc[6].first())
  { }
  inline int val1() const { return i1_m; }
  inline int val2() const { return i2_m; }
  inline int val3() const { return i3_m; }
  inline int val4() const { return i4_m; }
  inline int val5() const { return i5_m; }
  inline int val6() const { return i6_m; }
  inline int val7() const { return i7_m; }
  template<class Engine>
  inline typename Engine::Element_t eval(const Engine &e) const
  {
    return e.read(val1(), val2(), val3(), val4(), val5(), val6(), val7());
  }
};
template<class Domain>
struct ViewFunctorTag
{
  const Domain &domain_m;
  inline ViewFunctorTag(const Domain &domain) : domain_m(domain) { }
};
template<class T, class Domain>
struct LeafFunctor<Scalar<T>, ViewFunctorTag<Domain> >
{
  typedef Scalar<T> Type_t;
  inline static
  Type_t apply(const Scalar<T> &s, const ViewFunctorTag<Domain> &)
  {
    return s;
  }
};
struct DomainFunctorTag { };
template<class T>
struct LeafFunctor<Scalar<T>, DomainFunctorTag>
{
  typedef NullDomain Type_t;
  inline static
  Type_t apply(const Scalar<T> &, const DomainFunctorTag &)
  {
    return NullDomain();
  }
};
template<class T>
struct LeafFunctor<T, DomainFunctorTag>
{
  typedef typename T::Domain_t Type_t;
  inline static
  Type_t apply(const T &leaf, const DomainFunctorTag &)
  {
    return leaf.domain();
  }
};
template<class Domain1, class Domain2, class Op>
struct Combine2<Domain1, Domain2, Op, DomainFunctorTag>
{
  typedef ErrorDomain Type_t;
  inline static
  Type_t combine(const Domain1 &, const Domain2 &, const DomainFunctorTag &)
  {
    return ErrorDomain();
  }
};
template<class Domain, class Op>
struct Combine2<Domain, Domain, Op, DomainFunctorTag>
{
  typedef Domain Type_t;
  inline static
  Type_t combine(const Domain &a, const Domain &, const DomainFunctorTag &)
  {
    return a;
  }
};
template<class Domain, class Op>
struct Combine2<Domain, NullDomain, Op, DomainFunctorTag>
{
  typedef Domain Type_t;
  inline static
  Type_t combine(const Domain &a, const NullDomain &,
   const DomainFunctorTag &)
  {
    return a;
  }
};
template<class Domain,class Op>
struct Combine2<NullDomain, Domain, Op, DomainFunctorTag>
{
  typedef Domain Type_t;
  inline static
  Type_t combine(const NullDomain &, const Domain &b,
   const DomainFunctorTag &)
    {
      return b;
    }
};
template<class Tag>
struct EngineFunctorTag
{
  EngineFunctorTag() : tag_m() { }
  EngineFunctorTag(const Tag &tag) : tag_m(tag) { }
  inline const Tag &tag() const
  {
    return tag_m;
  }
  Tag tag_m;
};
template<class Expr>
struct ExpressionTag
{
  typedef Expr Expression_t;
};
template<int Dim, class T, class Expr>
class Engine<Dim, T, ExpressionTag<Expr> >
{
public:
  typedef Engine<Dim, T, ExpressionTag<Expr> > Engine_t;
  typedef ExpressionTag<Expr> Tag_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  typedef typename ForEach<Expr, DomainFunctorTag, DomainFunctorTag>::Type_t
    Domain_t;
  typedef Expr Expression_t;
  typedef DomainLayout<Dim> Layout_t;
  enum { dimensions = Dim };
  enum { multiPatch = true };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = true };
  inline Engine(const Expr &expr) : expr_m(expr),
    domain_m(forEach(expr_m, DomainFunctorTag(), DomainFunctorTag())) { }
  inline Engine(const Engine_t &engine) : expr_m(engine.expression()),
    domain_m(engine.domain()) { }
  template<int Dim2, class T2, class Expr2, class Initializer>
  inline Engine(const Engine<Dim2, T2, ExpressionTag<Expr2> > &e,
    const Initializer &i)
  : expr_m(e.expression(), i),
    domain_m(forEach(expr_m, DomainFunctorTag(), DomainFunctorTag()))
    { }
  template<int Dim2, class T2, class Expr2, class I1, class I2>
  inline Engine(const Engine<Dim2, T2, ExpressionTag<Expr2> > &e,
                const I1 &i1, const I2 &i2)
    : expr_m(e.expression(), i1, i2),
      domain_m(forEach(expr_m, DomainFunctorTag(), DomainFunctorTag()))
  { }
  template<class Expr2>
  explicit inline Engine(const Engine<Dim,T,ExpressionTag<Expr2> > &e)
    : expr_m(e.expression()),
      domain_m(forEach(expr_m, DomainFunctorTag(), DomainFunctorTag()))
  { }
  inline const Expression_t &expression() const { return expr_m; }
  inline Expression_t &expression() { return expr_m; }
  Engine_t &makeOwnCopy();
  inline Element_t read(int i0) const
    {
      return forEach(expr_m, EvalLeaf<1>(i0), OpCombine());
    }
  inline Element_t read(int i0, int i1) const
    {
      return forEach(expr_m, EvalLeaf<2>(i0, i1), OpCombine());
    }
  inline Element_t read(int i0, int i1, int i2) const
    {
      return forEach(expr_m, EvalLeaf<3>(i0, i1, i2), OpCombine());
    }
  inline Element_t read(int i0, int i1, int i2, int i3) const
    {
      return forEach(expr_m, EvalLeaf<4>(i0, i1, i2, i3),
        OpCombine());
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4) const
    {
      return forEach(expr_m, EvalLeaf<5>(i0, i1, i2, i3, i4),
        OpCombine());
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4, int i5) const
    {
      return forEach(expr_m, EvalLeaf<6>(i0, i1, i2, i3, i4, i5),
        OpCombine());
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4, int i5,
    int i6) const
    {
      return forEach(expr_m, EvalLeaf<7>(i0, i1, i2, i3, i4, i5, i6),
        OpCombine());
    }
  inline Element_t read(const Loc<Dim> &loc) const
  {
    return forEach(expr_m, EvalLeaf<Dim>(loc), OpCombine());
  }
  inline const Domain_t& domain() const
    {
      return domain_m;
    }
  inline Layout_t layout() const { return Layout_t(domain()); }
  inline int first(int) const
  {
    return 0;
  }
  template<class RequestType>
  inline
  typename DataObjectRequest<RequestType>::Type_t
  dataObjectRequest(const DataObjectRequest<RequestType>& f) const
  {
    typedef DataObjectRequest<RequestType> Tag_t;
    typedef EngineFunctorTag<Tag_t> Functor_t;
    typedef typename Tag_t::Combine_t Combine_t;
    return forEach(expr_m,Functor_t(f),Combine_t());
  }
private:
  Expr expr_m;
  Domain_t domain_m;
};
template<int Dim, class T, class Expr, class Domain>
struct NewEngine<Engine<Dim, T, ExpressionTag<Expr> >, Domain>
{
  typedef ViewFunctorTag<Domain> FTag_t;
  typedef typename ForEach<Expr, FTag_t, TreeCombine>::Type_t ExprView_t;
  typedef Engine<Dim, T, ExpressionTag<ExprView_t> > Type_t;
};
template <int Dim, class T, class Expr, int SliceDim>
struct NewEngine<Engine<Dim, T, ExpressionTag<Expr> >,
  SliceInterval<Dim,SliceDim> >
{
  typedef ViewFunctorTag<SliceInterval<Dim,SliceDim> > FTag_t;
  typedef typename ForEach<Expr, FTag_t, TreeCombine>::Type_t ExprView_t;
  typedef Engine<SliceDim, T, ExpressionTag<ExprView_t> > Type_t;
};
template <int Dim, class T, class Expr, int SliceDim>
struct NewEngine<Engine<Dim,T,ExpressionTag<Expr> >,
  SliceRange<Dim,SliceDim> >
{
  typedef ViewFunctorTag<SliceRange<Dim,SliceDim> > FTag_t;
  typedef typename ForEach<Expr, FTag_t, TreeCombine>::Type_t ExprView_t;
  typedef Engine<SliceDim, T, ExpressionTag<ExprView_t> > Type_t;
};
template<class Node, class Tag>
struct LeafFunctor<Node, EngineFunctorTag<Tag> >
{
};
template<class T, class Tag>
struct LeafFunctor<Scalar<T>, EngineFunctorTag<Tag> >
{
  typedef typename EngineFunctorScalar<T,Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Scalar<T> &scalar, const EngineFunctorTag<Tag> &tag)
  {
    return EngineFunctorScalar<T,Tag>::apply(scalar.value(), tag.tag());
  }
};
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Engine<Dim, T, E>, EngineFunctorTag<Tag> >
{
  typedef Engine<Dim, T, E> Engine_t;
  typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Engine_t &engine,
        const EngineFunctorTag<Tag> &tag)
  {
    return EngineFunctor<Engine_t, Tag>::apply(engine, tag.tag());
  }
};
template<int Dim, class T, class Expr, class Tag>
struct EngineFunctor<Engine<Dim,T,ExpressionTag<Expr> >,Tag>
{
  typedef EngineFunctorTag<Tag> Functor_t;
  typedef typename Tag::Combine_t Combine_t;
  typedef typename ForEach<Expr,Functor_t,Combine_t>::Type_t Type_t;
  inline static
  Type_t apply(const Engine<Dim, T, ExpressionTag<Expr> > &engine,
        const Tag &tag)
  {
    return forEach(engine.expression(), Functor_t(tag), Combine_t());
  }
};
template<int Dim, class T, class Expr>
struct EngineFunctor<Engine<Dim, T, ExpressionTag<Expr> >, EnginePatch>
{
  typedef typename EnginePatch::Combine_t Combine_t;
  typedef typename ForEach<Expr, EnginePatch, Combine_t>::Type_t NewExpr_t;
  typedef Engine<Dim, T, ExpressionTag<NewExpr_t> > Type_t;
  inline static
  Type_t apply(const Engine<Dim, T, ExpressionTag<Expr> > &engine,
        const EnginePatch &tag)
  {
    return Type_t(forEach(engine.expression(), tag, Combine_t()));
  }
};
template<int Dim, class T, class Expr, class Tag>
struct LeafFunctor<Engine<Dim, T, ExpressionTag<Expr> >, EngineView<Tag> >
{
  typedef EngineView<Tag> Functor_t;
  typedef typename Functor_t::Combine_t Combine_t;
  typedef typename ForEach<Expr, Functor_t, Combine_t>::Type_t NewExpr_t;
  typedef Engine<Dim, T, ExpressionTag<NewExpr_t> > Type_t;
  inline static
  Type_t apply(const Engine<Dim, T, ExpressionTag<Expr> > &engine,
        const EngineView<Tag> &tag)
  {
    return Type_t(forEach(engine.expression(), tag, Combine_t()));
  }
};
template<int Dim, class T, class Expr, class Tag>
struct LeafFunctor<Engine<Dim, T, ExpressionTag<Expr> >, ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const Engine<Dim, T, ExpressionTag<Expr> > &engine,
        const ExpressionApply<Tag> &tag)
  {
    return forEach(engine.expression(), tag, NullCombine());
  }
};
template<class Components>
class ComponentWrapper
{
public:
  explicit ComponentWrapper(const Components &c) : c_m(c) { }
  const Components &components() const { return c_m; }
private:
  const Components &c_m;
};
template<class T, class Components>
struct ComponentAccess
{
  typedef T Element_t;
  typedef T &ElementRef_t;
  static inline ElementRef_t indexRef(T &v, const Components &)
  {
    return v;
  }
  static inline Element_t index(const T &v, const Components &)
  {
    return v;
  }
};
template<class Engine>
struct NotifyEngineWrite
{
  NotifyEngineWrite(){}
 ~NotifyEngineWrite(){}
 inline static void
  notify(const Engine &)
  {
    PoomaCTAssert<(!(Engine::multiPatch))>::test();
  }
};
template<class Engine>
inline
void notifyEngineWrite(const Engine &e)
{
  NotifyEngineWrite<Engine>::notify(e);
}
template<class Engine>
inline
void notifyEngineWrite(const Engine &, const WrappedInt<false> &)
{
}
template<class Engine>
inline
void notifyEngineWrite(const Engine &e, const WrappedInt<true> &)
{
  NotifyEngineWrite<Engine>::notify(e);
}
template <int Dim> class DomainLayout;
template<class Eng, class Components>
struct CompFwd { };
template<int Dim, class T, class Eng, class Components>
class Engine<Dim, T, CompFwd<Eng, Components> >
{
public:
  typedef Engine<Dim, T, Eng> This_t;
  typedef This_t Engine_t;
  typedef Eng ElemEngine_t;
  typedef typename Eng::Element_t FwdElement_t;
  typedef ComponentAccess<FwdElement_t, Components> CompAccess_t;
  typedef typename CompAccess_t::Element_t Element_t;
  typedef typename CompAccess_t::ElementRef_t ElementRef_t;
  typedef typename Eng::Domain_t Domain_t;
  typedef CompFwd<Eng, Components> Tag_t;
  typedef typename Eng::Layout_t Layout_t;
  enum { dimensions = Eng::dimensions };
  enum { hasDataObject = Eng::hasDataObject };
  enum { dynamic = false };
  enum { zeroBased = Eng::zeroBased };
  enum { multiPatch = Eng::multiPatch };
  Engine()
    : engine_m(), components_m()
  { }
  Engine(const Eng &e, const Components &l)
    : engine_m(e), components_m(l)
  { }
  Engine(const This_t &e)
    : engine_m(e.elemEngine()), components_m(e.components()) { }
  template<class OtherEng, class Domain>
  Engine(const Engine< Dim, T, CompFwd<OtherEng, Components> > &e,
  const Domain &domain)
    : engine_m(NewEngineEngine<OtherEng,Domain>::apply(e.elemEngine(),domain),
        NewEngineDomain<OtherEng,Domain>::apply(e.elemEngine(),domain)),
      components_m(e.components()) { }
  ~Engine() { }
  inline ElementRef_t operator()(const Loc<dimensions> &eloc) const
  {
    return CompAccess_t::indexRef(elemEngine()(eloc), components());
  }
  inline ElementRef_t operator()(int i1) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1), components());
  }
  inline ElementRef_t operator()(int i1, int i2) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2), components());
  }
  inline ElementRef_t operator()(int i1, int i2, int i3) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2, i3),
      components());
  }
  inline ElementRef_t operator()(int i1, int i2, int i3, int i4) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2, i3, i4),
      components());
  }
  inline ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2, i3, i4, i5),
      components());
  }
  inline ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5,
     int i6) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2, i3, i4, i5, i6),
      components());
  }
  inline ElementRef_t operator()(int i1, int i2, int i3, int i4, int i5,
     int i6, int i7) const
  {
    return CompAccess_t::indexRef(elemEngine()(i1, i2, i3, i4, i5, i6, i7),
      components());
  }
  inline Element_t read(const Loc<dimensions> &eloc) const
  {
    return CompAccess_t::index(elemEngine().read(eloc), components());
  }
  inline Element_t read(int i1) const
  {
    return CompAccess_t::index(elemEngine().read(i1), components());
  }
  inline Element_t read(int i1, int i2) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2), components());
  }
  inline Element_t read(int i1, int i2, int i3) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2, i3),
          components());
  }
  inline Element_t read(int i1, int i2, int i3, int i4) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2, i3, i4),
          components());
  }
  inline Element_t read(int i1, int i2, int i3, int i4, int i5) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2, i3, i4, i5),
          components());
  }
  inline Element_t read(int i1, int i2, int i3, int i4, int i5,
   int i6) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2, i3, i4, i5, i6),
          components());
  }
  inline Element_t read(int i1, int i2, int i3, int i4, int i5,
   int i6, int i7) const
  {
    return CompAccess_t::index(elemEngine().read(i1, i2, i3, i4, i5, i6, i7),
          components());
  }
  inline const Layout_t& layout() const
  {
    return elemEngine().layout();
  }
  inline Layout_t& layout()
  {
    return elemEngine().layout();
  }
  inline const Domain_t& domain() const { return elemEngine().domain(); }
  inline int first(int i) const
  {
    return elemEngine().first(i);
  }
  This_t &makeOwnCopy()
  {
    elemEngine().makeOwnCopy();
    return *this;
  }
  Eng &elemEngine() { return engine_m; }
  const Eng &elemEngine() const { return engine_m; }
  const Components &components() const { return components_m; }
private:
  Eng engine_m;
  Components components_m;
};
template <int Dim, class T, class Eng, class Components, class Domain>
struct NewEngine<Engine<Dim, T, CompFwd<Eng, Components> >, Domain>
{
  typedef typename NewEngine<Eng, Domain>::Type_t NewEngine_t;
  typedef Engine<NewEngine_t::dimensions, T, CompFwd<NewEngine_t, Components> > Type_t;
};
template<int Dim, class T, class Eng, class Components, class EFTag>
struct EngineFunctor<Engine<Dim, T, CompFwd<Eng, Components> >, EFTag>
{
  typedef typename EngineFunctor<Eng, EFTag>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, CompFwd<Eng, Components> > &engine,
 const EFTag &tag)
  {
    return engineFunctor(engine.elemEngine(), tag);
  }
};
template <int D, class T, class E, class Comp, class Tag>
struct LeafFunctor<Engine<D, T, CompFwd<E, Comp> >, EngineView<Tag> >
{
  typedef LeafFunctor<E, EngineView<Tag> > LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t NewViewed_t;
  typedef Engine<D, T, CompFwd<NewViewed_t, Comp> > Type_t;
  static
  Type_t apply(const Engine<D, T, CompFwd<E, Comp> > &engine,
        const EngineView<Tag> &tag)
  {
    return Type_t(LeafFunctor_t::apply(engine.elemEngine(), tag),
    engine.components());
  }
};
template <int D, class T, class E, class Comp, class Tag>
struct LeafFunctor<Engine<D, T, CompFwd<E, Comp> >, ExpressionApply<Tag> >
{
  typedef LeafFunctor<E, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  static
  Type_t apply(const Engine<D, T, CompFwd<E, Comp> > &engine,
        const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(engine.elemEngine(), tag);
  }
};
template<int Dim, class T, class Eng, class Components>
struct NotifyEngineWrite<Engine<Dim,T,CompFwd<Eng,Components> > >
{
  inline static void
  notify(const Engine<Dim,T,CompFwd<Eng,Components> > &engine)
  {
    typedef typename Engine<Dim, T,
      CompFwd<Eng, Components> >::ElemEngine_t Engine_t;
    NotifyEngineWrite<Engine_t>::notify(engine.elemEngine());
  }
};
template <int D, class T, class E, class Comp>
struct EngineFunctor<Engine<D, T, CompFwd<E, Comp> >, EnginePatch>
{
  typedef typename EngineFunctor<E, EnginePatch>::Type_t NewViewed_t;
  typedef Engine<D, T, CompFwd<NewViewed_t, Comp> > Type_t;
  static
  Type_t apply(const Engine<D, T, CompFwd<E, Comp> > &engine,
        const EnginePatch &tag)
  {
    return Type_t(engineFunctor(engine.elemEngine(), tag),
    engine.components());
  }
};
struct WriteRequest {};
struct ReadRequest {};
struct WriteRelease {};
struct ReadRelease {};
struct CountBlocks {};
template<>
class DataObjectRequest<WriteRequest>
{
public:
  typedef int Type_t;
  typedef NullCombine Combine_t;
  DataObjectRequest(Pooma::Iterate_t& iterate)
    : iterate_m(iterate),
      lhs1_m(
# 18797 "tramp3d-v4.cpp" 3 4
            __null
# 18797 "tramp3d-v4.cpp"
                ), lhs2_m(
# 18797 "tramp3d-v4.cpp" 3 4
                          __null
# 18797 "tramp3d-v4.cpp"
                              )
  { }
  inline Type_t operator()(Pooma::DataObject_t* obj) const
  {
    if ((obj != lhs1_m) && (obj != lhs2_m))
    {
      if (lhs1_m == 
# 18803 "tramp3d-v4.cpp" 3 4
                   __null
# 18803 "tramp3d-v4.cpp"
                       )
      {
 lhs1_m = obj;
      }
      else
      {
 if (lhs2_m == 
# 18809 "tramp3d-v4.cpp" 3 4
              __null
# 18809 "tramp3d-v4.cpp"
                  )
 {
   lhs2_m = obj;
 }
 else
 {
   ;
 }
      }
      obj->request(iterate_m,Pooma::SmartsTag_t::Write);
    }
    return 0;
  }
  inline Type_t defaultValue() const
  {
    return 0;
  }
  Pooma::DataObject_t* dataObject1() const { return lhs1_m; }
  Pooma::DataObject_t* dataObject2() const { return lhs2_m; }
  Pooma::Iterate_t& iterate() const { return iterate_m; }
private:

  Pooma::Iterate_t& iterate_m;
  mutable Pooma::DataObject_t* lhs1_m;
  mutable Pooma::DataObject_t* lhs2_m;
};
template<>
class DataObjectRequest<ReadRequest>
{
public:
  typedef int Type_t;
  typedef NullCombine Combine_t;
  DataObjectRequest(const DataObjectRequest<WriteRequest>& write)
    : iterate_m(write.iterate()),
      lhs1_m(write.dataObject1()),
      lhs2_m(write.dataObject2())
  { }
  DataObjectRequest(Pooma::Iterate_t& iterate)
    : iterate_m(iterate),
      lhs1_m(
# 18848 "tramp3d-v4.cpp" 3 4
            __null
# 18848 "tramp3d-v4.cpp"
                ), lhs2_m(
# 18848 "tramp3d-v4.cpp" 3 4
                          __null
# 18848 "tramp3d-v4.cpp"
                              )
  { }
  inline Type_t operator()(Pooma::DataObject_t* obj) const
  {
    if ((lhs1_m != obj) && (lhs2_m != obj))
    {
      obj->request(iterate_m, Pooma::SmartsTag_t::Read);
    }
    return 0;
  }
  inline Type_t defaultValue() const
  {
    return 0;
  }
private:
  Pooma::Iterate_t& iterate_m;
  Pooma::DataObject_t* lhs1_m;
  Pooma::DataObject_t* lhs2_m;
};
template<>
class DataObjectRequest<WriteRelease>
{
public:
  typedef int Type_t;
  typedef NullCombine Combine_t;
  DataObjectRequest()
    : lhs1_m(
# 18874 "tramp3d-v4.cpp" 3 4
            __null
# 18874 "tramp3d-v4.cpp"
                ), lhs2_m(
# 18874 "tramp3d-v4.cpp" 3 4
                          __null
# 18874 "tramp3d-v4.cpp"
                              )
  { }
  inline Type_t operator()(Pooma::DataObject_t* obj) const
  {
    if ((obj != lhs1_m) && (obj != lhs2_m))
    {
      if (lhs1_m == 
# 18880 "tramp3d-v4.cpp" 3 4
                   __null
# 18880 "tramp3d-v4.cpp"
                       )
      {
 lhs1_m = obj;
      }
      else
      {
 if (lhs2_m == 
# 18886 "tramp3d-v4.cpp" 3 4
              __null
# 18886 "tramp3d-v4.cpp"
                  )
 {
   lhs2_m = obj;
 }
 else
 {
   ;
 }
      }
      obj->release(Pooma::SmartsTag_t::Write);
    }
    return 0;
  }
  inline Type_t defaultValue() const
  {
    return 0;
  }
  Pooma::DataObject_t* dataObject1() const { return lhs1_m; }
  Pooma::DataObject_t* dataObject2() const { return lhs2_m; }
private:
  mutable Pooma::DataObject_t* lhs1_m;
  mutable Pooma::DataObject_t* lhs2_m;
};
template<>
class DataObjectRequest<ReadRelease>
{
public:
  typedef int Type_t;
  typedef NullCombine Combine_t;
  DataObjectRequest()
    : lhs1_m(
# 18916 "tramp3d-v4.cpp" 3 4
            __null
# 18916 "tramp3d-v4.cpp"
                ), lhs2_m(
# 18916 "tramp3d-v4.cpp" 3 4
                          __null
# 18916 "tramp3d-v4.cpp"
                              )
  { }
  DataObjectRequest(const DataObjectRequest<WriteRelease>& write)
    : lhs1_m(write.dataObject1()), lhs2_m(write.dataObject2())
  { }
  inline Type_t operator()(Pooma::DataObject_t* obj) const
  {
    if ((lhs1_m != obj) && (lhs2_m != obj))
    {
      obj->release(Pooma::SmartsTag_t::Read);
    }
    return 0;
  }
  inline Type_t defaultValue() const
  {
    return 0;
  }
private:
  Pooma::DataObject_t* lhs1_m;
  Pooma::DataObject_t* lhs2_m;
};
template<>
class DataObjectRequest<CountBlocks>
{
public:
  typedef int Type_t;
  typedef SumCombine Combine_t;
  DataObjectRequest() { }
  inline Type_t operator()(Pooma::DataObject_t*) const
  {
    return 1;
  }
  inline Type_t defaultValue() const
  {
    return 0;
  }
};
template<class Eng, class Tag>
struct DefaultExpressionApply<Eng, DataObjectRequest<Tag> >
{
  enum { hasDataObject = Eng::hasDataObject };
  inline static
  int apply(const Eng &e,
     const ExpressionApply<DataObjectRequest<Tag> > &request)
  {
    DataObjectApply<hasDataObject>::apply(e, request.tag());
    return 0;
  }
};
template<int Dim> class DomainLayout;
template<class A1,class A2>
struct IndirectionTag
{ };
template<int Dim,class T,class A1,class A2>
class Engine<Dim,T,IndirectionTag<A1,A2> >
{
public:
  typedef IndirectionTag<A1,A2> Tag_t;
  typedef Engine<Dim,T,Tag_t> Engine_t;
  typedef typename A1::Element_t Element_t;
  typedef typename A1::ElementRef_t ElementRef_t;
  typedef typename A2::Domain_t Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef typename A1::Engine_t Engine1_t;
  typedef typename A2::Engine_t Engine2_t;
  enum { dimensions = Dim };
  enum { hasDataObject = Engine1_t::hasDataObject ||
  Engine2_t::hasDataObject };
  enum { multiPatch = Engine1_t::multiPatch ||
  Engine2_t::multiPatch };
  enum { dynamic = false };
  enum { zeroBased = Engine2_t::zeroBased };
  inline
  Engine(const A1 &array1,const A2 &array2)
    : array1_m(array1),array2_m(array2)
  {
    PoomaCTAssert<(A2::dimensions == Dim)>::test();
  }
  inline
  Engine(const Engine_t &engine)
    : array1_m(engine.array1()),array2_m(engine.array2())
  { }
  template<int OtherDim,class OtherA2, class Domain>
  inline
  Engine(const Engine<OtherDim,T,IndirectionTag<A1,OtherA2> > &e,
  const Domain &d)
    : array1_m(e.array1()),array2_m(e.array2(),d)
  {
    PoomaCTAssert<(A2::dimensions == Dim)>::test();
  }
  inline const A1 &array1() const { return array1_m; }
  inline A1 &array1() { return array1_m; }
  inline const A2 &array2() const { return array2_m; }
  inline A2 &array2() { return array2_m; }
  inline Element_t read(int i0) const
  {
    return array1_m.read(array2_m.read(i0));
  }
  inline Element_t read(int i0, int i1) const
  {
    return array1_m.read(array2_m.read(i0,i1));
  }
  inline Element_t read(int i0, int i1,int i2) const
  {
    return array1_m.read(array2_m.read(i0,i1,i2));
  }
  inline Element_t read(int i0, int i1,int i2,int i3) const
  {
    return array1_m.read(array2_m.read(i0,i1,i2,i3));
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4) const
  {
    return array1_m.read(array2_m.read(i0,i1,i2,i3,i4));
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4, int i5) const
  {
    return array1_m.read(array2_m.read(i0,i1,i2,i3,i4,i5));
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4, int i5,
   int i6) const
  {
    return array1_m.read(array2_m.read(i0,i1,i2,i3,i4,i5,i6));
  }
  template<class Domain>
  inline Element_t read(const Domain &loc) const
  {
    return array1_m.read(array2_m.read(loc));
  }
  inline ElementRef_t operator()(int i0) const
  {
    return array1_m(array2_m.read(i0));
  }
  inline ElementRef_t operator()(int i0, int i1) const
  {
    return array1_m(array2_m.read(i0,i1));
  }
  inline ElementRef_t operator()(int i0, int i1,int i2) const
  {
    return array1_m(array2_m.read(i0,i1,i2));
  }
  inline ElementRef_t operator()(int i0, int i1,int i2,int i3) const
  {
    return array1_m(array2_m.read(i0,i1,i2,i3));
  }
  inline ElementRef_t operator()(int i0, int i1, int i2, int i3, int i4) const
  {
    return array1_m(array2_m.read(i0,i1,i2,i3,i4));
  }
  inline ElementRef_t operator()(int i0, int i1, int i2, int i3, int i4,
     int i5) const
  {
    return array1_m(array2_m.read(i0,i1,i2,i3,i4,i5));
  }
  inline ElementRef_t operator()(int i0, int i1, int i2, int i3, int i4,
     int i5, int i6) const
  {
    return array1_m(array2_m.read(i0,i1,i2,i3,i4,i5,i6));
  }
  template<class Domain>
  inline ElementRef_t operator()(const Domain &loc) const
  {
    return array1_m(array2_m.read(loc));
  }
  inline const Domain_t& domain() const
  {
    return array2_m.domain();
  }
  inline int first(int i) const
  {
    return array2_m.first(i);
  }
private:
  A1 array1_m;
  A2 array2_m;
};
template<int Dim,class T,class A1,class A2,class Domain>
struct NewEngine<Engine<Dim,T,IndirectionTag<A1,A2> >,Domain>
{
  typedef typename View1<A2,Domain>::Type_t NewA2_t;
  enum { newDim = NewA2_t::dimensions };
  typedef Engine<newDim,T,IndirectionTag<A1,NewA2_t> > Type_t;
};
template<int Dim, class T, class A1, class A2, class RequestType>
struct EngineFunctor<Engine<Dim, T, IndirectionTag<A1, A2> >,
  DataObjectRequest<RequestType> >
{
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  typedef typename DataObjectRequest<RequestType>::Combine_t Combine_t;
  static Type_t
  apply(const Engine<Dim, T, IndirectionTag<A1, A2> > &engine,
 const DataObjectRequest<RequestType> &tag)
  {
    return Combine2<Type_t,Type_t,OpAdd,
      Combine_t>::combine(
     engineFunctor(engine.array1().engine(), tag),
     engineFunctor(engine.array2().engine(), tag),
     Combine_t()
     );
  }
};
template<int Dim, class T, class A1, class A2>
struct EngineFunctor<Engine<Dim, T, IndirectionTag<A1, A2> >,
  DataObjectRequest<WriteRequest> >
{
  typedef typename DataObjectRequest<WriteRequest>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, IndirectionTag<A1, A2> > &engine,
 const DataObjectRequest<WriteRequest> &tag)
  {
    engineFunctor(engine.array1().engine(), tag);
    return engineFunctor(engine.array2().engine(),
    DataObjectRequest<ReadRequest>(tag));
  }
};
template<int Dim, class T, class A1, class A2>
struct EngineFunctor<Engine<Dim, T, IndirectionTag<A1, A2> >,
  DataObjectRequest<WriteRelease> >
{
  typedef typename DataObjectRequest<WriteRelease>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, IndirectionTag<A1, A2> > &engine,
 const DataObjectRequest<WriteRelease> &tag)
  {
    engineFunctor(engine.array1().engine(), tag);
    return engineFunctor(engine.array2().engine(),
    DataObjectRequest<ReadRelease>(tag));
  }
};
struct Brick;
struct BrickView;
struct CompressibleBrick;
struct CompressibleBrickView;
template<class Eng, class Components> struct CompFwd;
template<class A1,class A2> struct IndirectionTag;
struct ConstantFunction;
template<class Expr> struct ExpressionTag;
template<class Stencil, class Expression> struct StencilEngine;
struct Compressible
{
  typedef AndCombine Combine_t;
};
struct Compressed
{
  typedef AndCombine Combine_t;
};
struct CompressedRead
{
  typedef OpCombine Combine_t;
};
struct CompressedReadWrite
{
};
struct CompressedBrickIsWholeView
{
};
struct UnCompressedViewEngine
{
};
template<int A, int B, class Op>
struct Combine2<WrappedInt<A>, WrappedInt<B>, Op, AndCombine>
{
  enum { val = A && B };
  typedef WrappedInt<val> Type_t;
  inline static
  Type_t combine(WrappedInt<A> , WrappedInt<B>, AndCombine)
  {
    return Type_t();
  }
};
template<class T>
struct EngineFunctorScalar<T, Compressible >
{
  typedef WrappedInt<true> Type_t;
  static Type_t apply(const T &, const Compressible &)
  {
    return Type_t();
  }
};
template<class T>
struct EngineFunctorScalar<T, Compressed >
{
  typedef bool Type_t;
  static Type_t apply(const T &, const Compressed &)
  {
    return true;
  }
};
template<class T>
struct EngineFunctorScalar<T, CompressedRead >
{
  typedef T Type_t;
  static inline
  Type_t apply(const T& s, const CompressedRead &)
  {
    return s;
  }
};
template<class Engine>
struct EngineFunctorDefault<Engine,Compressible>
{
  typedef WrappedInt<false> Type_t;
};
template<class Engine>
struct EngineFunctorDefault<Engine,Compressed>
{
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine &, const Compressed &)
  {
    return false;
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,Compressible>
{
  typedef WrappedInt<true> Type_t;
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,Compressed>
{
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine_t &e, const Compressed &)
  {
    return e.compressed();
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,CompressedRead>
{
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef T Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedRead &)
  {
    return e.compressedRead();
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,CompressedReadWrite>
{
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef T &Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedReadWrite &)
  {
    return e.compressedReadWrite();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,
  CompressedBrickIsWholeView>
{
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef bool Type_t;
  static inline
  bool apply(const Engine_t &e, const CompressedBrickIsWholeView &)
  {
    return e.compressedBrickIsWholeView();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrick>,UnCompressedViewEngine>
{
  typedef Engine<Dim,T,CompressibleBrick> Engine_t;
  typedef Engine<Dim,T,BrickView> Type_t;
  static inline
  Type_t apply(const Engine_t &e, const UnCompressedViewEngine &)
  {
    return Type_t(e);
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView>,Compressible>
{
  typedef WrappedInt<true> Type_t;
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView >,Compressed>
{
  typedef Engine<Dim,T,CompressibleBrickView > Engine_t;
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine_t &e, const Compressed &)
  {
    return e.compressed();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView >,CompressedRead>
{
  typedef Engine<Dim,T,CompressibleBrickView > Engine_t;
  typedef T Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedRead &)
  {
    return e.compressedRead();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView >,
  CompressedReadWrite>
{
  typedef Engine<Dim,T,CompressibleBrickView > Engine_t;
  typedef T &Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedReadWrite &)
  {
    return e.compressedReadWrite();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView >,
  CompressedBrickIsWholeView>
{
  typedef Engine<Dim,T,CompressibleBrickView > Engine_t;
  typedef bool Type_t;
  static inline
  bool apply(const Engine_t &e, const CompressedBrickIsWholeView &)
  {
    return e.compressedBrickIsWholeView();
  }
};
template<int Dim, class T>
struct EngineFunctor<Engine<Dim,T,CompressibleBrickView >,
  UnCompressedViewEngine>
{
  typedef Engine<Dim,T,CompressibleBrickView > Engine_t;
  typedef Engine<Dim,T,BrickView> Type_t;
  static inline
  Type_t apply(const Engine_t &e, const UnCompressedViewEngine &)
  {
    return Type_t(e);
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,ConstantFunction>,Compressible>
{
  typedef WrappedInt<true> Type_t;
  static inline
  Type_t apply(const Engine<Dim,T,ConstantFunction> &, const Compressible &)
  {
    return WrappedInt<true>();
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,ConstantFunction>,Compressed>
{
  typedef bool Type_t;
  static inline
  Type_t apply(const Engine<Dim,T,ConstantFunction> &, const Compressed &)
  {
    return true;
  }
};
template<int Dim,class T>
struct EngineFunctor<Engine<Dim,T,ConstantFunction>,CompressedRead>
{
  typedef T Type_t;
  static inline
  Type_t apply(const Engine<Dim,T,ConstantFunction> &e,
        const CompressedRead &)
  {
    return e.constant();
  }
};
template<int Dim, class T, class Eng, class Components>
struct EngineFunctor<Engine<Dim,T,CompFwd<Eng, Components> >,Compressible>
{
  typedef typename EngineFunctor<Eng,Compressible>::Type_t Comp_t;
  enum { compressible = Comp_t::val };
  typedef WrappedInt<compressible> Type_t;
};
template<int Dim, class T, class Eng, class Components>
struct EngineFunctor<Engine<Dim,T,CompFwd<Eng, Components> >,CompressedRead>
{
  typedef Engine<Dim,T,CompFwd<Eng, Components> > Engine_t;
  typedef typename Engine_t::CompAccess_t CompAccess_t;
  typedef typename CompAccess_t::Element_t Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedRead &tag)
  {
    return CompAccess_t::index(engineFunctor(e.elemEngine(),tag),
          e.components());
  }
};
template<int Dim, class T, class Eng, class Components>
struct EngineFunctor<Engine<Dim,T,CompFwd<Eng, Components> >,CompressedReadWrite>
{
  typedef Engine<Dim,T,CompFwd<Eng, Components> > Engine_t;
  typedef typename Engine_t::CompAccess_t CompAccess_t;
  typedef typename CompAccess_t::ElementRef_t Type_t;
  static inline
  Type_t apply(const Engine_t &e, const CompressedReadWrite &tag)
  {
    return CompAccess_t::indexRef(engineFunctor(e.elemEngine(),tag),
      e.components());
  }
};
template<int Dim, class T, class Eng, class Components>
struct EngineFunctor<Engine<Dim,T,CompFwd<Eng, Components> >,
  UnCompressedViewEngine>
{
  typedef Engine<Dim,T,CompFwd<Eng, Components> > Engine_t;
  typedef typename EngineFunctor<Eng,
    UnCompressedViewEngine>::Type_t CompEngine_t;
  typedef Engine<Dim,T,CompFwd<CompEngine_t, Components> > Type_t;
  static inline
  Type_t apply(const Engine_t &e,const UnCompressedViewEngine &tag)
  {
    return Type_t(engineFunctor(e.elemEngine(), tag), e.components());
  }
};
template<class Expr> struct CreateLeaf;
struct ErrorKernelTag
{
  ErrorKernelTag(){}
  ~ErrorKernelTag(){}
};
struct InlineKernelTag
{
  InlineKernelTag(){}
  ~InlineKernelTag(){}
};
struct CompressibleKernelTag
{
  CompressibleKernelTag(){}
  ~CompressibleKernelTag(){}
};
struct CompressibleViewKernelTag
{
  CompressibleViewKernelTag(){}
  ~CompressibleViewKernelTag(){}
};
template<bool lhsComp,bool rhsComp>
struct CompressibleKernel
{
  CompressibleKernel(){}
  ~CompressibleKernel(){}
};
template<>
struct CompressibleKernel<false,false>
{
  CompressibleKernel(){}
  ~CompressibleKernel(){}
  typedef InlineKernelTag Kernel_t;
};
template<>
struct CompressibleKernel<false,true>
{
  CompressibleKernel(){}
  ~CompressibleKernel(){}
  typedef InlineKernelTag Kernel_t;
};
template<>
struct CompressibleKernel<true,false>
{
  CompressibleKernel(){}
  ~CompressibleKernel(){}
  typedef CompressibleViewKernelTag Kernel_t;
};
template<>
struct CompressibleKernel<true,true>
{
  CompressibleKernel(){}
  ~CompressibleKernel(){}
  typedef CompressibleKernelTag Kernel_t;
};
template<class Expr>
struct KernelTag1
{
  KernelTag1(){}
 ~KernelTag1(){}
  typedef typename Expr::Engine_t ExprEngine_t;
  typedef typename EngineFunctor<ExprEngine_t, Compressible>::Type_t Expr_t;
  enum { exprComp = Expr_t::val };
  typedef typename CompressibleKernel<exprComp,exprComp>::Kernel_t Kernel_t;
};
template<class LHS,class RHS>
struct KernelTag
{
  KernelTag(){}
 ~KernelTag(){}
  typedef typename LHS::Engine_t LHSEngine_t;
  typedef typename RHS::Engine_t RHSEngine_t;
  typedef typename EngineFunctor<LHSEngine_t,Compressible>::Type_t LHST_t;
  typedef typename EngineFunctor<RHSEngine_t,Compressible>::Type_t RHST_t;
  enum { lhsComp = LHST_t::val };
  enum { rhsComp = RHST_t::val };
  typedef typename CompressibleKernel<lhsComp,rhsComp>::Kernel_t Kernel_t;
};
template<class KernelTag>
struct KernelEvaluator;
template<>
struct KernelEvaluator<InlineKernelTag>
{
  template<class LHS,class Op,class RHS,class Domain>
  static
  void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain)
  {
    PoomaCTAssert<(Domain::unitStride)>::test();
    for (int i=0; i<Domain::dimensions; ++i)
      ;
    evaluate(lhs,op,rhs,domain,
      WrappedInt<Domain::dimensions>());
    ;
  }
  template<class LHS,class Op,class RHS>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs)
  {
    evaluate(lhs,op,rhs,lhs.domain());
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<1>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
;
#pragma omp parallel for if (e0 > 512)
    for (int i0=0; i0<e0; ++i0)
      op(localLHS(i0),localRHS.read(i0));
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<2>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
#pragma omp parallel for
    for (int i1=0; i1<e1; ++i1) {
;
      for (int i0=0; i0<e0; ++i0)
 op(localLHS(i0,i1),localRHS.read(i0,i1));
    }
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<3>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
#pragma omp parallel for
    for (int i2=0; i2<e2; ++i2)
      for (int i1=0; i1<e1; ++i1) {
;
 for (int i0=0; i0<e0; ++i0)
   op(localLHS(i0,i1,i2),localRHS.read(i0,i1,i2));
      }
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<4>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
#pragma omp parallel for
    for (int i3=0; i3<e3; ++i3)
      for (int i2=0; i2<e2; ++i2)
 for (int i1=0; i1<e1; ++i1) {
;
   for (int i0=0; i0<e0; ++i0)
     op(localLHS(i0,i1,i2,i3),localRHS.read(i0,i1,i2,i3));
 }
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<5>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
#pragma omp parallel for
    for (int i4=0; i4<e4; ++i4)
      for (int i3=0; i3<e3; ++i3)
 for (int i2=0; i2<e2; ++i2)
   for (int i1=0; i1<e1; ++i1) {
;
     for (int i0=0; i0<e0; ++i0)
       op(localLHS(i0,i1,i2,i3,i4),localRHS.read(i0,i1,i2,i3,i4));
   }
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<6>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
    int e5 = domain[5].length();
#pragma omp parallel for
    for (int i5=0; i5<e5; ++i5)
      for (int i4=0; i4<e4; ++i4)
 for (int i3=0; i3<e3; ++i3)
   for (int i2=0; i2<e2; ++i2)
     for (int i1=0; i1<e1; ++i1) {
;
       for (int i0=0; i0<e0; ++i0)
  op(localLHS(i0,i1,i2,i3,i4,i5),
     localRHS.read(i0,i1,i2,i3,i4,i5));
     }
  }
  template<class LHS,class Op,class RHS,class Domain>
  inline static void evaluate(const LHS& lhs,const Op& op,const RHS& rhs,
         const Domain& domain,WrappedInt<7>)
  {
    LHS localLHS(lhs);
    RHS localRHS(rhs);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
    int e5 = domain[5].length();
    int e6 = domain[6].length();
#pragma omp parallel for
    for (int i6=0; i6<e6; ++i6)
      for (int i5=0; i5<e5; ++i5)
 for (int i4=0; i4<e4; ++i4)
   for (int i3=0; i3<e3; ++i3)
     for (int i2=0; i2<e2; ++i2)
       for (int i1=0; i1<e1; ++i1) {
;
  for (int i0=0; i0<e0; ++i0)
    op(localLHS(i0,i1,i2,i3,i4,i5,i6),
       localRHS.read(i0,i1,i2,i3,i4,i5,i6));
       }
  }
private:
};
template<>
struct KernelEvaluator<CompressibleViewKernelTag>
{
  template<class LHS, class Op, class RHS>
  static void evaluate(const LHS &lhs, const Op &op, const RHS &rhs)
  {
    KernelEvaluator<InlineKernelTag>().
      evaluate(engineFunctor(lhs, UnCompressedViewEngine()),
        op, rhs);
    ;
  }
};
template<>
struct KernelEvaluator<CompressibleKernelTag>
{
  template<class LHS, class Op, class RHS>
  static void evaluate(const LHS &lhs, const Op &op, const RHS &rhs)
  {
    typedef typename LHS::Element_t LHST_t;
    typedef typename RHS::Element_t RHST_t;
    if (engineFunctor(lhs, Compressed()) &&
 engineFunctor(rhs, Compressed()))
      {
        LHST_t &l = engineFunctor(lhs, CompressedReadWrite());
        LHST_t test = l;
        RHST_t r = engineFunctor(rhs, CompressedRead());
        op(test, r);
        if (test != l)
          {
     if (engineFunctor(lhs, CompressedBrickIsWholeView()))
       {
         l = test;
         ;
       }
     else
       {
         KernelEvaluator<CompressibleViewKernelTag>::
                  evaluate(lhs, op, rhs);
       }
          }
        else
          {
            ;
          }
      }
    else
      {
        KernelEvaluator<CompressibleViewKernelTag>::evaluate(lhs, op, rhs);
      }
  }
};
struct Brick;
struct BrickView;
struct BrickViewU;
struct CompressibleBrick;
struct CompressibleBrickView;
struct Dynamic;
struct DynamicView;
template<class LayoutTag, class PatchTag>
struct MultiPatch;
template<class LayoutTag, class PatchTag, int Dim2>
struct MultiPatchView;
template<class Functor>
struct IndexFunction;
template<int Dim2, class Functor>
struct IndexFunctionView;
template<class Eng, class Components>
struct CompFwd;
template<class A1,class A2>
struct IndirectionTag;
struct ConstantFunction;
template<class Expr>
struct ExpressionTag;
template<class Tag>
struct Remote;
struct DistributedTag;
struct ReplicatedTag;
struct ScalarEngineTag
{
  ScalarEngineTag() {}
  ~ScalarEngineTag() {}
};
struct MainEvaluatorTag
{
  MainEvaluatorTag() {}
  ~MainEvaluatorTag() {}
};
struct SinglePatchEvaluatorTag
{
  SinglePatchEvaluatorTag() {}
  ~SinglePatchEvaluatorTag() {}
};
struct MultiPatchEvaluatorTag
{
  MultiPatchEvaluatorTag() {}
  ~MultiPatchEvaluatorTag() {}
};
struct RemoteSinglePatchEvaluatorTag
{
  RemoteSinglePatchEvaluatorTag() {}
  ~RemoteSinglePatchEvaluatorTag() {}
};
struct RemoteMultiPatchEvaluatorTag
{
  RemoteMultiPatchEvaluatorTag() {}
  ~RemoteMultiPatchEvaluatorTag() {}
};
struct EvaluatorTypeTag
{
  EvaluatorTypeTag() {}
  ~EvaluatorTypeTag() {}
};
struct EvaluatorCombineTag
{
  EvaluatorCombineTag() {}
  ~EvaluatorCombineTag() {}
};
template<class EngineTag>
struct EvaluatorEngineTraits
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
};
template<>
struct EvaluatorEngineTraits<ScalarEngineTag>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<ConstantFunction>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<class Functor>
struct EvaluatorEngineTraits<IndexFunction<Functor> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<int Dim2, class Functor>
struct EvaluatorEngineTraits<IndexFunctionView<Dim2, Functor> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<Brick>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<BrickView>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<BrickViewU>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<CompressibleBrick>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<CompressibleBrickView>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<Dynamic>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorEngineTraits<DynamicView>
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<class A1,class A2>
struct EvaluatorEngineTraits<IndirectionTag<A1,A2> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<class Tag>
struct EvaluatorEngineTraits<Remote<Tag> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef RemoteSinglePatchEvaluatorTag Evaluator_t;
};
template<class LayoutTag, class PatchTag>
struct EvaluatorEngineTraits<MultiPatch<LayoutTag, PatchTag> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef MultiPatchEvaluatorTag Evaluator_t;
};
template<class LayoutTag, class PatchTag, int Dim2>
struct EvaluatorEngineTraits<MultiPatchView<LayoutTag, PatchTag, Dim2> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef MultiPatchEvaluatorTag Evaluator_t;
};
template<class LayoutTag, class Tag>
struct EvaluatorEngineTraits<MultiPatch<LayoutTag, Remote<Tag> > >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef RemoteMultiPatchEvaluatorTag Evaluator_t;
};
template<class LayoutTag, class Tag, int Dim2>
struct EvaluatorEngineTraits<MultiPatchView<LayoutTag, Remote<Tag>, Dim2> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef RemoteMultiPatchEvaluatorTag Evaluator_t;
};
template<class Eng, class Components>
struct EvaluatorEngineTraits<CompFwd<Eng, Components> >
{
  EvaluatorEngineTraits() {}
  ~EvaluatorEngineTraits() {}
  typedef EvaluatorEngineTraits<typename Eng::Tag_t> ET;
  typedef typename ET::Evaluator_t Evaluator_t;
};
template<class Expr>
struct EvaluatorEngineTraits<ExpressionTag<Expr> >
{
 EvaluatorEngineTraits() {}
 ~EvaluatorEngineTraits() {}
 typedef typename ForEach<Expr, EvaluatorTypeTag,
   EvaluatorCombineTag>::Type_t Evaluator_t;
};
template<class ETag>
struct DistributionTraits
{
  enum { remote = false };
  typedef ReplicatedTag LayoutTag_t;
};
template<class ETag>
struct DistributionTraits<Remote<ETag> >
{
  enum { remote = true };
  typedef DistributedTag LayoutTag_t;
};
template<class Eval1, class Eval2>
struct EvaluatorCombine
{
 EvaluatorCombine() {}
 ~EvaluatorCombine() {}
 typedef RemoteMultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<SinglePatchEvaluatorTag,
                        MultiPatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef MultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<MultiPatchEvaluatorTag,
                        SinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef MultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<RemoteSinglePatchEvaluatorTag,
                        MultiPatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef RemoteMultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<MultiPatchEvaluatorTag,
                        RemoteSinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef RemoteMultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<RemoteSinglePatchEvaluatorTag,
                        SinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef RemoteSinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<SinglePatchEvaluatorTag,
                        RemoteSinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef RemoteSinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<MultiPatchEvaluatorTag,
                        MultiPatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef MultiPatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<RemoteSinglePatchEvaluatorTag,
                        RemoteSinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef RemoteSinglePatchEvaluatorTag Evaluator_t;
};
template<>
struct EvaluatorCombine<SinglePatchEvaluatorTag,
                        SinglePatchEvaluatorTag>
{
  EvaluatorCombine() {}
  ~EvaluatorCombine() {}
  typedef SinglePatchEvaluatorTag Evaluator_t;
};
template<class T>
struct LeafFunctor<Scalar<T>, EvaluatorTypeTag>
{
 LeafFunctor() {}
 ~LeafFunctor() {}
 typedef typename EvaluatorEngineTraits<ScalarEngineTag>::Evaluator_t Type_t;
};
template<class A>
struct LeafFunctor<A, EvaluatorTypeTag>
{
  LeafFunctor() {}
  ~LeafFunctor() {}
  typedef typename
    EvaluatorEngineTraits<typename A::Engine_t::Tag_t>::Evaluator_t Type_t;
};
template<class Eval1,class Eval2,class Op>
struct Combine2<Eval1, Eval2, Op, EvaluatorCombineTag>
{
  Combine2() {}
  ~Combine2() {}
  typedef typename EvaluatorCombine<Eval1, Eval2>::Evaluator_t Type_t;
};
template<class Expr>
struct EvaluatorTag1
{
  EvaluatorTag1() {}
  ~EvaluatorTag1() {}
  typedef typename LeafFunctor<Expr, EvaluatorTypeTag>::Type_t Evaluator_t;
};
template<class LHS, class RHS>
struct EvaluatorTag
{
  EvaluatorTag() {}
  ~EvaluatorTag() {}
  typedef typename LeafFunctor<LHS, EvaluatorTypeTag>::Type_t LHSEval_t;
  typedef typename LeafFunctor<RHS, EvaluatorTypeTag>::Type_t RHSEval_t;
  typedef typename EvaluatorCombine<LHSEval_t, RHSEval_t>::Evaluator_t
    Evaluator_t;
};
template<class LHS,class Op,class RHS,class EvalTag>
class ExpressionKernel : public Pooma::Iterate_t
{
public:
  typedef ExpressionKernel<LHS,Op,RHS,EvalTag> This_t;
  ExpressionKernel(const LHS&,const Op&,const RHS&);
  virtual ~ExpressionKernel();
  virtual void run();
private:
  LHS lhs_m;
  Op op_m;
  RHS rhs_m;
};
template<class LHS,class Op,class RHS,class EvalTag>
ExpressionKernel<LHS,Op,RHS,EvalTag>::
ExpressionKernel(const LHS& lhs,const Op& op,const RHS& rhs)
  : Pooma::Iterate_t(Pooma::scheduler()),
    lhs_m(lhs), op_m(op), rhs_m(rhs)
{
  hintAffinity(engineFunctor(lhs, DataObjectRequest<BlockAffinity>()));
  DataObjectRequest<WriteRequest> writeReq(*this);
  engineFunctor(lhs_m, writeReq);
  DataObjectRequest<ReadRequest> readReq(writeReq);
  engineFunctor(rhs_m, readReq);
}
template<class LHS,class Op,class RHS,class EvalTag>
ExpressionKernel<LHS,Op,RHS,EvalTag>::~ExpressionKernel()
{
  DataObjectRequest<WriteRelease> writeReq;
  engineFunctor(lhs_m, writeReq);
  DataObjectRequest<ReadRelease> readReq(writeReq);
  engineFunctor(rhs_m, readReq);
}
template<class LHS,class Op,class RHS,class EvalTag>
void
ExpressionKernel<LHS,Op,RHS,EvalTag>::run()
{
  KernelEvaluator<EvalTag>::evaluate(lhs_m,op_m,rhs_m);
}
template<class LHS,class Op,class RHS,class EvalTag>
inline static
ExpressionKernel<LHS,Op,RHS,EvalTag>*
generateKernel(const LHS& lhs, const Op& op, const RHS& rhs, const EvalTag&)
{
  return new ExpressionKernel<LHS,Op,RHS,EvalTag>(lhs, op, rhs);
}
template<int Dim>
class IntersectorData
  : public RefCounted
{
public:
  typedef IntersectorData<Dim> This_t;
  typedef std::vector<int> IDContainer_t;
  typedef Range<7> BaseDomain_t;
  typedef std::vector<BaseDomain_t> BaseDomainContainer_t;
  typedef INode<Dim> INode_t;
  typedef std::vector<INode_t> INodeContainer_t;
  typedef typename INodeContainer_t::const_iterator const_iterator;
  typedef Unique::Value_t LayoutID_t;
  enum { dimensions = Dim };
  inline IntersectorData() { }
  inline ~IntersectorData() { }
  template<class Engine>
  void intersect(const Engine &engine)
  {
    typedef typename Engine::Layout_t Layout_t;
    const Layout_t &layout(engine.layout());
    int n = ids_m.size();
    for (int i = 0; i < n; ++i)
    {
      if (ids_m[i] == layout.ID())
 return;
      if (baseIDs_m[i] == layout.baseID()
   && sameBaseDomain(i, layout.baseDomain()))
      {
 shared(layout.ID(),ids_m[i]);
 return;
      }
    }
    touches(layout);
  }
  template<class Engine, int Dim2>
  bool intersect(const Engine &engine, const GuardLayers<Dim2> &guard,
   GuardLayers<Dim2> &usedGuards)
  {
    PoomaCTAssert<(Engine::dimensions == Dim)>::test();
    typedef typename Engine::Layout_t Layout_t;
    const Layout_t &layout(engine.layout());
    int n = ids_m.size();
    for (int i = 0; i < n; ++i)
    {
      if (ids_m[i] == layout.ID())
 return false;
      if (baseIDs_m[i] == layout.baseID()
   && sameBaseDomain(i, layout.baseDomain(), guard))
      {
 shared(layout.ID(),ids_m[i]);
 if (baseDims_m[i] < Dim2)
   return true;
 bool used = false;
 for (int j = 0; j < Dim2; j++)
 {
   usedGuards.lower(j) = std::max(0, baseDomains_m[i][j].first() - layout.baseDomain()[j].first());
   if (usedGuards.lower(j) != 0)
     used = true;
   usedGuards.upper(j) = std::max(0, layout.baseDomain()[j].last() - baseDomains_m[i][j].last());
   if (usedGuards.upper(j) != 0)
     used = true;
 }
 return used;
      }
    }
    touches(layout);
    return false;
  }
  template<int Dim2>
  bool sameBaseDomain(int i, const Range<Dim2> &domain,
        const GuardLayers<Dim2> &guard)
  {
    if (baseDims_m[i] != Dim2)
      return false;
    for (int j = 0; j < Dim2; j++)
    {
      if (baseDomains_m[i][j].stride() != domain[j].stride()) return false;
      if (baseDomains_m[i][j].first() > domain[j].first() + guard.lower(j))
 return false;
      if (baseDomains_m[i][j].last() < domain[j].last() - guard.upper(j))
 return false;
    }
    return true;
  }
  template<int Dim2>
  bool sameBaseDomain(int i, const Range<Dim2> &domain)
  {
    if (baseDims_m[i] != Dim2)
      return false;
    for (int j = 0; j < Dim2; j++)
      if (baseDomains_m[i][j] != domain[j]) return false;
    return true;
  }
  template<int Dim2>
  bool sameBaseDomain(int i, const Interval<Dim2> &domain,
        const GuardLayers<Dim2> & guard)
  {
    if (baseDims_m[i] != Dim2)
      return false;
    for (int j = 0; j < Dim2; j++)
    {
      if (baseDomains_m[i][j].stride() != 1) return false;
      if (baseDomains_m[i][j].first() > domain[j].first() + guard.lower(j))
 return false;
      if (baseDomains_m[i][j].last() < domain[j].last() - guard.upper(j))
 return false;
    }
    return true;
  }
  template<int Dim2>
  void pushBaseDomain(const Range<Dim2> &domain)
  {
    int i = baseDomains_m.size();
    baseDims_m.push_back(Dim2);
    baseDomains_m.push_back(BaseDomain_t());
    for (int j = 0; j < Dim2; j++)
      baseDomains_m[i][j] =
        Range<1>(domain[j].first(), domain[j].last(), domain[j].stride());
  }
  template<int Dim2>
  bool sameBaseDomain(int i, const Interval<Dim2> &domain)
  {
    if (baseDims_m[i] != Dim2)
      return false;
    for (int j = 0; j < Dim2; j++)
      if (baseDomains_m[i][j] != domain[j]) return false;
    return true;
  }
  template<int Dim2>
  void pushBaseDomain(const Interval<Dim2> &domain)
  {
    int i = baseDomains_m.size();
    baseDims_m.push_back(Dim2);
    baseDomains_m.push_back(BaseDomain_t());
    for (int j = 0; j < Dim2; j++)
      baseDomains_m[i][j] =
        Range<1>(domain[j].first(), domain[j].last(), domain[j].stride());
  }
  template<class Layout>
  void touches(const Layout &l)
  {
    int n = ids_m.size();
    ids_m.push_back(l.ID());
    baseIDs_m.push_back(l.baseID());
    pushBaseDomain(l.baseDomain());
    if (n == 0)
    {
      typename Layout::const_iterator p = l.beginGlobal();
      while (p != l.endGlobal())
      {
 if (! (*p).domain().empty())
   inodes_m.push_back(INode_t(*p,l.ID(),
         &(gidStore_m)));
 ++p;
      }
    }
    else
    {
      int ni = inodes_m.size();
      for (int i = 0; i < ni; i++)
 l.touches(inodes_m[i].domain(),
    std::back_inserter(inodes_m),
    inodes_m[i].touchesConstructINode(l.ID())
    );
      inodes_m.erase(inodes_m.begin(),
        inodes_m.begin() + ni);
    }
  }
  inline
  void shared(LayoutID_t id1, LayoutID_t id2)
  {
    gidStore_m.shared(id1,id2);
  }
  IntersectorData(const This_t &);
  This_t &operator=(const This_t &);
  IDContainer_t ids_m, baseIDs_m, baseDims_m;
  BaseDomainContainer_t baseDomains_m;
  INodeContainer_t inodes_m;
  GlobalIDDataBase gidStore_m;
};
template<int Dim>
class Intersector
{
public:
  typedef IntersectorData<Dim> IntersectorData_t;
  typedef Intersector<Dim> This_t;
  typedef typename IntersectorData_t::IDContainer_t IDContainer_t;
  typedef typename IntersectorData_t::BaseDomain_t BaseDomain_t;
  typedef typename IntersectorData_t::BaseDomainContainer_t
                                                        BaseDomainContainer_t;
  typedef typename IntersectorData_t::INode_t INode_t;
  typedef typename IntersectorData_t::INodeContainer_t INodeContainer_t;
  typedef typename IntersectorData_t::const_iterator const_iterator;
  typedef RefCountedPtr<IntersectorData_t> DataPtr_t;
  enum { dimensions = Dim };
  Intersector()
    : pdata_m(new IntersectorData_t())
  { }
  Intersector(const This_t &model)
    : pdata_m(model.pdata_m)
  { }
  This_t &operator=(const This_t &model)
  {
    if (this != &model)
      pdata_m = model.pdata_m;
    return *this;
  }
  ~Intersector() { }
  inline DataPtr_t &data() { return pdata_m; }
  inline const DataPtr_t &data() const { return pdata_m; }
  inline const_iterator begin() const { return data()->inodes_m.begin(); }
  inline const_iterator end() const { return data()->inodes_m.end(); }
  inline int size() const { return data()->inodes_m.size(); }
  template<class Engine>
  inline
  void intersect(const Engine &l)
  {
    data()->intersect(l);
  }
  template<class Engine, int Dim2>
  inline
  bool intersect(const Engine &l, const GuardLayers<Dim2> &guard, GuardLayers<Dim2> &usedGuards)
  {
    return (data()->intersect(l,guard,usedGuards));
  }
private:
  DataPtr_t pdata_m;
};
template <class EvalTag>
struct Evaluator
{
};
template <>
struct Evaluator<MainEvaluatorTag>
{
  Evaluator() { }
  ~Evaluator() { }
  template <class LHS, class RHS, class Op>
  void evaluate(const LHS& lhs, const Op& op, const RHS& rhs) const
  {
    typedef typename EvaluatorTag<LHS, RHS>::Evaluator_t Eval_t;
    Evaluator<Eval_t> evaluator;
    Pooma::beginExpression();
    evaluator.evaluate(lhs(), op, rhs());
    notifyEngineWrite(lhs.engine());
    Pooma::endExpression();
    ;
  }
  template <class LHS, class RHS, class Op>
  void evaluateZeroBased(const LHS& lhs, const Op& op, const RHS& rhs) const
  {
    typedef typename EvaluatorTag<LHS, RHS>::Evaluator_t Eval_t;
    Evaluator<Eval_t> evaluator;
    Pooma::beginExpression();
    evaluator.evaluate(lhs, op, rhs);
    notifyEngineWrite(lhs.engine());
    Pooma::endExpression();
    ;
  }
};
template <>
struct Evaluator<SinglePatchEvaluatorTag>
{
  Evaluator() { }
  ~Evaluator() { }
  template <class LHS, class RHS, class Op>
  void evaluate(const LHS& lhs, const Op& op, const RHS& rhs) const
  {
    typedef typename KernelTag<LHS,RHS>::Kernel_t Kernel_t;
    Pooma::Iterate_t *iterate = ::generateKernel(lhs, op, rhs, Kernel_t());
    Pooma::scheduler().handOff(iterate);
  }
};
template <>
struct Evaluator<MultiPatchEvaluatorTag>
{
  Evaluator() { }
  ~Evaluator() { }
  template <class LHS, class RHS, class Op>
  void evaluate(const LHS& lhs, const Op& op, const RHS& rhs) const
  {
    typedef Intersector<LHS::dimensions> Inter_t;
    Inter_t inter;
    expressionApply(lhs, IntersectorTag<Inter_t>(inter));
    expressionApply(rhs, IntersectorTag<Inter_t>(inter));
    typename Inter_t::const_iterator i = inter.begin();
    while (i != inter.end())
    {
      Evaluator<SinglePatchEvaluatorTag>().evaluate(lhs(*i), op, rhs(*i));
      ++i;
    }
    ;
    ;
  }
};
template<class T>
struct MaskAssign
{
  MaskAssign() { }
  MaskAssign(bool q) : cond_m(q) { }
  MaskAssign(bool q, const T& v) : cond_m(q), value_m(v) { }
  ~MaskAssign() { }
  inline bool defined() const { return cond_m; }
  inline const T &value() const { return value_m; }
  inline bool operator!=(const MaskAssign<T> &other) const
  {
    if (defined())
    {
      return ((other.defined() != defined()) || (other.value() != value()));
    }
    else
    {
      return other.defined();
    }
  }
  MaskAssign(const MaskAssign<T> &) { }
  MaskAssign<T> &operator=(const MaskAssign<T> &) { return *this; }
  bool cond_m;
  T value_m;
};
template<class Op>
struct OpMask
{
  OpMask() { }
  OpMask(const Op &op) : op_m(op) { }
  ~OpMask() { }
  template<class T1, class T2>
  inline void
  operator()(T1 &a, const MaskAssign<T2> &b) const
  {
    if (b.defined())
    {
      op_m(a, b.value());
    }
  }
  template<class T1, class T2>
  inline void
  operator()(T1 &a, const T2 &b) const
  {
    op_m(a, b);
  }
  Op op_m;
};
template<class T1, class T2, class Op>
struct BinaryReturn<T1, T2, OpMask<Op> >
{
  typedef T1 &Type_t;
};



template <class Op, class T>
struct ReductionTraits;
template <class Op, class T>
struct ReductionTraits<OpMask<Op>, T>
{
  static T identity() { return ReductionTraits<Op, T>::identity(); }
};
struct WhereMask
{
  WhereMask() { }
  WhereMask(const WhereMask &) { }
  WhereMask &operator=(const WhereMask &) { return *this; }
  ~WhereMask() { }
};
template<class T1, class T2>
struct BinaryReturn<T1, T2, WhereMask>
{
  typedef MaskAssign<T2> Type_t;
};
template<class A, class B, class FTag>
struct ForEach< BinaryNode<WhereMask, A, B>, FTag, OpCombine >
{
  typedef typename ForEach<A,FTag,OpCombine>::Type_t TypeA_t;
  typedef typename ForEach<B,FTag,OpCombine>::Type_t TypeB_t;
  typedef MaskAssign<TypeB_t> Type_t;
  inline
  static Type_t
  apply(const BinaryNode<WhereMask,A,B>& expr,
 const FTag &f, const OpCombine &c)
  {
    bool mask = forEach(expr.left(), f, c);
    if ( mask )
    {
      return Type_t(mask, forEach(expr.right(), f, c));
    }
    else
    {
      return Type_t(mask);
    }
  }
};
struct FarLeftTag;
template<class A, class B>
struct ForEach< BinaryNode<WhereMask, A, B>, FarLeftTag, FarLeftTag >
{
  typedef typename ForEach<B,FarLeftTag,FarLeftTag>::Type_t Type_t;
  inline
  static Type_t
  apply(const BinaryNode<WhereMask,A,B>& expr,
 const FarLeftTag &f, const FarLeftTag &c)
  {
    return forEach(expr.right(), f, c);
  }
};
template<class A, class T>
struct ForEach< BinaryNode<WhereMask, A, Scalar<T> >, FarLeftTag, FarLeftTag >
{
  typedef typename ForEach<A,FarLeftTag,FarLeftTag>::Type_t Type_t;
  inline
  static Type_t
  apply(const BinaryNode<WhereMask,A,Scalar<T> >& expr,
 const FarLeftTag &f, const FarLeftTag &c)
  {
    return forEach(expr.left(), f, c);
  }
};
template<class A, class B>
struct ForEachRef< BinaryNode<WhereMask, A, B>, FarLeftTag, FarLeftTag >
{
  typedef typename ForEach<B,FarLeftTag,FarLeftTag>::Type_t Type_t;
  inline
  static const Type_t&
  apply(const BinaryNode<WhereMask,A,B>& expr,
 const FarLeftTag &f, const FarLeftTag &c)
  {
    return forEachRef(expr.right(), f, c);
  }
};
template<class A, class T>
struct ForEachRef< BinaryNode<WhereMask, A, Scalar<T> >, FarLeftTag, FarLeftTag >
{
  typedef typename ForEach<A,FarLeftTag,FarLeftTag>::Type_t Type_t;
  inline
  static const Type_t&
  apply(const BinaryNode<WhereMask,A,Scalar<T> >& expr,
 const FarLeftTag &f, const FarLeftTag &c)
  {
    return forEachRef(expr.left(), f, c);
  }
};
template<class T>
struct ExpressionTraits
{
  typedef void Type_t;
};
struct ExpressionIsScalar { };
template<class T>
struct ExpressionTraits<Scalar<T> >
{
  typedef ExpressionIsScalar Type_t;
};
template<class A, class B>
struct CombineExpressionTraits
{ };
template<class T>
struct ExpressionTraits<Reference<T> >
{
  typedef typename ExpressionTraits<T>::Type_t Type_t;
};
template<class Op, class Child>
struct ExpressionTraits<UnaryNode<Op, Child> >
{
  typedef typename ExpressionTraits<Child>::Type_t Type_t;
};
template<class Op, class Left, class Right>
struct ExpressionTraits<BinaryNode<Op, Left, Right> >
{
  typedef typename ExpressionTraits<Left>::Type_t Left_t;
  typedef typename ExpressionTraits<Right>::Type_t Right_t;
  typedef typename CombineExpressionTraits<Left_t, Right_t>::Type_t Type_t;
};
template<class Op, class Left, class Middle, class Right>
struct ExpressionTraits<TrinaryNode<Op, Left, Middle, Right> >
{
  typedef typename ExpressionTraits<Left>::Type_t Left_t;
  typedef typename ExpressionTraits<Middle>::Type_t Middle_t;
  typedef typename ExpressionTraits<Right>::Type_t Right_t;
  typedef typename CombineExpressionTraits<Left_t, Right_t>::Type_t Temp_t;
  typedef typename CombineExpressionTraits<Temp_t, Middle_t>::Type_t Type_t;
};
template<class ETrait, class Tree>
struct ConvertWhereProxy
{ };
template<class F, class B>
struct WhereProxy
{
  template <class Cond, class Val, class F1, class B1>
  struct WhereProxyTraits {
    enum { dimensions = F1::dimensions };
    typedef typename ForEach<Val, EvalLeaf<dimensions>, OpCombine>::Type_t Element_t;
  };
  template <class Cond, class T, class F1, class B1>
  struct WhereProxyTraits<Cond, Scalar<T>, F1, B1> {
    enum { dimensions = F1::dimensions };
    typedef T Element_t;
  };
  template <class Val, class T, class F1, class B1>
  struct WhereProxyTraits<Scalar<T>, Val, F1, B1> {
    enum { dimensions = B1::dimensions };
    typedef typename ForEach<Val, EvalLeaf<dimensions>, OpCombine>::Type_t Element_t;
  };
  template <class T1, class T2, class F1, class B1>
  struct WhereProxyTraits<Scalar<T1>, Scalar<T2>, F1, B1> {
  };
  WhereProxy(const F& f, const B& b) : f_m(f), b_m(b) { }
  typedef BinaryNode<WhereMask,
    typename CreateLeaf<F>::Leaf_t,
    typename CreateLeaf<B>::Leaf_t> Tree_t;
  typedef typename ExpressionTraits<Tree_t>::Type_t ETrait_t;
  typedef typename ConvertWhereProxy<ETrait_t,Tree_t>::Make_t MakeFromTree_t;
  typedef typename MakeFromTree_t::Expression_t WhereMask_t;
  typedef typename WhereProxyTraits<typename CreateLeaf<F>::Leaf_t,
 typename CreateLeaf<B>::Leaf_t, F, B>::Element_t Element_t;
  inline WhereMask_t
  whereMask() const
  {
    return MakeFromTree_t::make(Tree_t(CreateLeaf<F>::make(f_m),
           CreateLeaf<B>::make(b_m)));
  }
  template<class Op>
  inline OpMask<Op>
  opMask(const Op &op) const
  {
    return OpMask<Op>(op);
  }
  inline const F &flag() { return f_m; }
  inline const B &value() { return b_m; }
  const F &f_m;
  const B &b_m;
};
template<class F, class B>
inline WhereProxy<F,B>
where(const F &f, const B &b)
{
  return WhereProxy<F,B>(f,b);
}
template<int D,class T,class E> class Vector;
template<int DR, int DC, class T, class E> class TinyMatrix;
template<int D, class T, class E> class Tensor;
template<int D, class T, class EngineTag> class Tensor;
template<class OutputEngineTag, int D, class T, class EngineTag>
Tensor<D, T, OutputEngineTag>
symmetrize(const Tensor<D, T, EngineTag> &x);
struct FnReal
{

  template<class T>
  inline typename UnaryReturn<T, FnReal >::Type_t
  operator()(const T &a) const
  {
    return (real(a));
  }
};
struct FnImag
{

  template<class T>
  inline typename UnaryReturn<T, FnImag >::Type_t
  operator()(const T &a) const
  {
    return (imag(a));
  }
};
struct FnAbs
{

  template<class T>
  inline typename UnaryReturn<T, FnAbs >::Type_t
  operator()(const T &a) const
  {
    return (std::abs(a));
  }
};
struct FnArg
{

  template<class T>
  inline typename UnaryReturn<T, FnArg >::Type_t
  operator()(const T &a) const
  {
    return (arg(a));
  }
};
struct FnNorm
{

  template<class T>
  inline typename UnaryReturn<T, FnNorm >::Type_t
  operator()(const T &a) const
  {
    return (norm(a));
  }
};
struct FnConj
{

  template<class T>
  inline typename UnaryReturn<T, FnConj >::Type_t
  operator()(const T &a) const
  {
    return (conj(a));
  }
};
struct FnPow2
{

  template<class T>
  inline typename UnaryReturn<T, FnPow2 >::Type_t
  operator()(const T &a) const
  {
    return (a*a);
  }
};
struct FnPow3
{

  template<class T>
  inline typename UnaryReturn<T, FnPow3 >::Type_t
  operator()(const T &a) const
  {
    return (a*a*a);
  }
};
struct FnPow4
{

  template<class T>
  inline typename UnaryReturn<T, FnPow4 >::Type_t
  operator()(const T &a) const
  {
    return (a*a*a*a);
  }
};
struct FnMagnitude
{

  template<class T>
  inline typename UnaryReturn<T, FnMagnitude >::Type_t
  operator()(const T &a) const
  {
    return (magnitude(a));
  }
};
struct FnTrace
{

  template<class T>
  inline typename UnaryReturn<T, FnTrace >::Type_t
  operator()(const T &a) const
  {
    return (trace(a));
  }
};
struct FnDet
{

  template<class T>
  inline typename UnaryReturn<T, FnDet >::Type_t
  operator()(const T &a) const
  {
    return (det(a));
  }
};
struct FnTranspose
{

  template<class T>
  inline typename UnaryReturn<T, FnTranspose >::Type_t
  operator()(const T &a) const
  {
    return (transpose(a));
  }
};
template<class OutputSymmetry>
struct FnSymmetrize
{

  template<class T>
  inline typename UnaryReturn<T, FnSymmetrize<OutputSymmetry> >::Type_t
  operator()(const T &a) const
  {
    return (symmetrize<OutputSymmetry>(a));
  }
};
struct FnDot
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnDot >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return dot(a,b);
  }
};
struct FnPolar
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnPolar >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (polar(a,b));
  }
};
struct FnOuterProduct
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnOuterProduct >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (outerProduct(a,b));
  }
};
struct FnOuterProductAsTinyMatrix
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnOuterProductAsTinyMatrix >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (outerProductAsTinyMatrix(a,b));
  }
};
struct FnDotDot
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnDotDot >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (dotdot(a,b));
  }
};
struct FnMin
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnMin >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return
        std::min(a, b)
;
  }
};
struct FnMax
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnMax >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return
        std::max(a, b)
;
  }
};
struct OpLT2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLT2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a < b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLT2 > {
  typedef bool Type_t;
};
struct OpLE2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpLE2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a <= b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpLE2 > {
  typedef bool Type_t;
};
struct OpGT2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpGT2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a > b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpGT2 > {
  typedef bool Type_t;
};
struct OpGE2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpGE2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a >= b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpGE2 > {
  typedef bool Type_t;
};
struct OpEQ2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpEQ2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a == b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpEQ2 > {
  typedef bool Type_t;
};
struct OpNE2
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, OpNE2 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (a != b);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, OpNE2 > {
  typedef bool Type_t;
};
struct FnMinAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnMinAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
        const_cast<T1 &>(a) = std::min(a, b)
;
    return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, FnMinAssign > {
  typedef T1 &Type_t;
};
struct FnMaxAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnMaxAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
        const_cast<T1 &>(a) = std::max(a, b)
;
    return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, FnMaxAssign > {
  typedef T1 &Type_t;
};
struct FnAndAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnAndAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    const_cast<T1 &>(a) = (a && b);
    return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, FnAndAssign > {
  typedef bool Type_t;
};
struct FnOrAssign
{

  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnOrAssign >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    const_cast<T1 &>(a) = (a || b);
    return const_cast<T1 &>(a);
  }
};
template<class T1, class T2 >
struct BinaryReturn<T1, T2, FnOrAssign > {
  typedef bool Type_t;
};
using std::complex;
template<class T>
struct UnaryReturn< complex<T>, FnConj >
{
  typedef complex<T> Type_t;
};
template<class T>
struct UnaryReturn<complex<T>, FnReal>
{
  typedef T Type_t;
};
template<class T>
struct UnaryReturn<complex<T>, FnImag>
{
  typedef T Type_t;
};
template<class T>
struct UnaryReturn<complex<T>, FnArg>
{
  typedef T Type_t;
};
template<class T>
struct UnaryReturn<complex<T>, FnNorm>
{
  typedef T Type_t;
};
template<class T>
struct UnaryReturn<T, FnAbs>
{
  typedef T Type_t;
};
template<class T>
struct UnaryReturn<complex<T>, FnAbs>
{
  typedef T Type_t;
};
template<class T>
struct Promote<complex<T>, complex<T> >
{
  typedef complex<T> Type_t;
};
template<class T>
struct Promote<complex<T>, T>
{
  typedef complex<T> Type_t;
};
template<class T>
struct Promote<T, complex<T> >
{
  typedef complex<T> Type_t;
};
template<class T>
struct BinaryReturn<complex<T>, int, FnPow>
{
  typedef complex<T> Type_t;
};
template<class T>
struct UnaryReturn<T, FnPow2>
{
  typedef typename BinaryReturn<T, T, OpMultiply>::Type_t Type_t;
};
template<class T>
struct UnaryReturn<T, FnPow3>
{
  typedef typename BinaryReturn<T, T, OpMultiply>::Type_t Type_t;
};
template<class T>
struct UnaryReturn<T, FnPow4>
{
  typedef typename BinaryReturn<T, T, OpMultiply>::Type_t Type_t;
};
template<class T, class A> struct LeafFunctor;
template<class T> class Scalar;
template<int D>
class ConformTag
{
public:
  template<class Domain>
  ConformTag(const Domain& domain)
  {
    for (int i=0; i<D; ++i)
      lengths_m[i] = domain[i].length();
  }
  int length(int i) const { return lengths_m[i]; }
private:
  int lengths_m[D];
};
template<class Domain>
bool conforms(const Domain &d, const ConformTag<1> &ct)
{
  return d.length() == ct.length(0);
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<2> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1));
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<3> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1))
      && (d[2].length() == ct.length(2));
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<4> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1))
      && (d[2].length() == ct.length(2))
      && (d[3].length() == ct.length(3));
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<5> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1))
      && (d[2].length() == ct.length(2))
      && (d[3].length() == ct.length(3))
      && (d[4].length() == ct.length(4));
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<6> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1))
      && (d[2].length() == ct.length(2))
      && (d[3].length() == ct.length(3))
      && (d[3].length() == ct.length(4))
      && (d[5].length() == ct.length(5));
}
template<class Domain>
bool conforms(const Domain &d, const ConformTag<7> &ct)
{
  return (d[0].length() == ct.length(0))
      && (d[1].length() == ct.length(1))
      && (d[2].length() == ct.length(2))
      && (d[3].length() == ct.length(3))
      && (d[3].length() == ct.length(4))
      && (d[5].length() == ct.length(5))
      && (d[6].length() == ct.length(6));
}
template<int D, class T>
struct LeafFunctor<Scalar<T>, ConformTag<D> >
{
  typedef bool Type_t;
  static Type_t apply(const Scalar<T> &, const ConformTag<D> &)
  {
    return true;
  }
};
template<class T, class A> struct LeafFunctor;
struct PerformUpdateTag {};
template<class Node>
struct LeafFunctor<Node, PerformUpdateTag>
{
  typedef int Type_t;
  inline static
  Type_t apply(const Node &, const PerformUpdateTag &)
    {
      return 0;
    }
};
template<class T>
class ModelElement
{
public:
  explicit ModelElement(const T &e) : e_m(e) { }
  ModelElement(const ModelElement<T> &m) : e_m(m.e_m) { }
  const T &element() const { return e_m; }
private:
  const T &e_m;
};
template<class T>
inline ModelElement<T> modelElement(const T &elem)
  {
    return ModelElement<T>(elem);
  }
template<class T, class A> struct LeafFunctor;
template<class T> class Scalar;
struct NotifyPreReadTag { };
template<class T>
struct LeafFunctor<Scalar<T>, NotifyPreReadTag>
{
  typedef bool Type_t;
  static Type_t apply(const Scalar<T> &, const NotifyPreReadTag &)
  {
    return true;
  }
};
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnArcCos,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
acos(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnArcCos,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnArcSin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
asin(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnArcSin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnArcTan,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
atan(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnArcTan,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnCeil,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
ceil(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnCeil,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnCos,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
cos(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnCos,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnHypCos,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
cosh(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnHypCos,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnExp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
exp(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnExp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnFabs,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
fabs(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnFabs,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnFloor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
floor(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnFloor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnLog,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
log(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnLog,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnLog10,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
log10(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnLog10,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
sin(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnSin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnHypSin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
sinh(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnHypSin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSqrt,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
sqrt(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnSqrt,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnTan,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
tan(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnTan,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnHypTan,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
tanh(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnHypTan,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
operator~(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<OpIdentity,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
PETE_identity(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<OpIdentity,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<OpNot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
operator!(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<OpNot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<UnaryNode<OpCast<T1>,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
peteCast(const T1&, const Array<D2,T2,E2> & l)
{
  typedef UnaryNode<OpCast<T1>,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D2,T2,E2> >::make(l)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<<(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>>(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<=(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>=(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator&&(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator||(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<<(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>>(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class T2,class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t,
  typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
where(const Array<D1,T1,E1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t,
    typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(c),
    CreateLeaf<T2 >::make(t),
    CreateLeaf<T3 >::make(f)));
}
template<int D, class T, class EngineTag> class Tensor;
template<class OutputEngineTag, int D, class T, class EngineTag>
Tensor<D, T, OutputEngineTag>
symmetrize(const Tensor<D, T, EngineTag> &x);
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnReal,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
real(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnReal,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnImag,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
imag(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnImag,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnAbs,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
abs(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnAbs,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnArg,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
arg(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnArg,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnNorm,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
norm(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnNorm,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnConj,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
conj(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnConj,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow2(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow3,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow3(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow3,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow4,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow4(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow4,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnMagnitude,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
magnitude(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnMagnitude,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnTrace,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
trace(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnTrace,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnDet,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
det(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnDet,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnTranspose,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
transpose(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnTranspose,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<class OutputSymmetry,int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSymmetrize<OutputSymmetry>,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
symmetrize(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnSymmetrize<OutputSymmetry>,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
polar(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LT(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GT(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
NE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
polar(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProduct(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dotdot(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LT(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GT(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
EQ(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
NE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
polar(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
min(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
max(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LT(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GT(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
NE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const Array<D1,T1,E1> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D1,T1,E1> >::make(r)));
}
template<int D1,class T1,class E1>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const Array<D1,T1,E1> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D1,T1,E1> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Vector<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Tensor<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const TinyMatrix<DR1,DC1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<int Dim, class T, class EngineTag>
struct CreateLeaf<Array<Dim, T, EngineTag> >
{
  typedef Array<Dim, T, EngineTag> Input_t;
  typedef Reference<Input_t> Leaf_t;
  typedef Leaf_t Return_t;
  inline static
  Return_t make(const Input_t &a)
    {
      return Leaf_t(a);
    }
};
template<int Dim, class T, class Expr>
struct CreateLeaf<Array<Dim, T, ExpressionTag<Expr> > >
{
  typedef Array<Dim, T, ExpressionTag<Expr> > Input_t;
  typedef Expr Leaf_t;
  typedef const Leaf_t &Return_t;
  inline static
  Return_t make(const Input_t &a)
    {
      return a.engine().expression();
    }
};
template<int Dim, class T, class EngineTag>
struct CreateLeaf<Scalar<Array<Dim, T, EngineTag> > >
{
  typedef Scalar<Array<Dim, T, EngineTag> > Input_t;
  typedef Scalar<ErrorType> Leaf_t;
  typedef Leaf_t Return_t;
  inline static
  Return_t make(const Input_t &)
    {
      return ErrorType();
    }
};
template<class Op,class Leaf>
struct MakeReturn<UnaryNode<Op,Leaf> >
{
  typedef UnaryNode<Op,Leaf> Tree_t;
  typedef typename ForEach<Tree_t,
    DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename UnaryReturn<typename ForEach<Leaf,
    EvalLeaf<dim>,OpCombine>::Type_t,
    Op>::Type_t T_t;
  typedef Engine<dim,T_t,ExpressionTag<Tree_t> > Engine_t;
  typedef Array<dim,T_t,ExpressionTag<Tree_t > > Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class Op,class Left,class Right>
struct MakeReturn<BinaryNode<Op,Left,Right> >
{
  typedef BinaryNode<Op,Left,Right> Tree_t;
  typedef typename ForEach<Tree_t,
    DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename BinaryReturn<typename ForEach<Left,
    EvalLeaf<dim>,OpCombine>::Type_t,
    typename ForEach<Right,EvalLeaf<dim>,OpCombine>::Type_t,
    Op>::Type_t T_t;
  typedef Engine<dim,T_t,ExpressionTag<Tree_t> > Engine_t;
  typedef Array<dim,T_t,ExpressionTag<Tree_t > > Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class Op,class Cl,class Tr,class Fl>
struct MakeReturn<TrinaryNode<Op,Cl,Tr,Fl> >
{
  typedef TrinaryNode<Op,Cl,Tr,Fl> Tree_t;
  typedef typename ForEach<Tree_t,
    DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename TrinaryReturn<typename ForEach<Cl,
    EvalLeaf<dim>,OpCombine>::Type_t,
    typename ForEach<Tr,EvalLeaf<dim>,OpCombine>::Type_t,
    typename ForEach<Fl,EvalLeaf<dim>,OpCombine>::Type_t,
    Op>::Type_t T_t;
  typedef Engine<dim,T_t,ExpressionTag<Tree_t> > Engine_t;
  typedef Array<dim,T_t,ExpressionTag<Tree_t > > Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class Op, class T>
struct ReductionTraits {
};
template<class T>
struct ReductionTraits<OpAddAssign, T> {
  static inline T identity() { return T(0); }
};
template<class T>
struct ReductionTraits<OpMultiplyAssign, T> {
  static inline T identity() { return T(1); }
};
template<class T>
struct ReductionTraits<FnMinAssign, T> {
  static inline T identity() { return std::numeric_limits<T>::max(); }
};
template<class T>
struct ReductionTraits<FnMaxAssign, T> {
  static inline T identity() { return std::numeric_limits<T>::min(); }
};
template<class T>
struct ReductionTraits<FnOrAssign, T> {
  static inline T identity() { return T(false); }
};
template<class T>
struct ReductionTraits<FnAndAssign, T> {
  static inline T identity() { return T(true); }
};
template<class T>
struct ReductionTraits<OpBitwiseOrAssign, T> {
  static inline T identity() { return T(); }
};
template<class T>
struct ReductionTraits<OpBitwiseAndAssign, T> {
  static inline T identity() { return ~T(); }
};

template<class T>
struct PartialReduction {
 static inline void init() {}
 inline void storePartialResult(const T& result)
 {
   answer = result;
 }
 template <class Op>
 inline void reduce(T& ret, const Op&)
 {
   ret = answer;
 }
 T answer;
};
# 24284 "tramp3d-v4.cpp"
template<class KernelTag>
struct ReductionEvaluator;
template<>
struct ReductionEvaluator<InlineKernelTag>
{
  template<class T, class Op, class Expr>
  static
  void evaluate(T &ret, const Op &op, const Expr &e)
  {
    typedef typename Expr::Domain_t Domain_t;
    PoomaCTAssert<(Domain_t::unitStride)>::test();
    for (int i=0; i<Domain_t::dimensions; ++i)
      ;
    PartialReduction<T>::init();
    evaluate(ret, op, e, e.domain(),
      WrappedInt<Domain_t::dimensions>());
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<1>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    PartialReduction<T> reduction;
#pragma omp parallel if (e0 > 512)
    {
      T answer = ReductionTraits<Op, T>::identity();
;
#pragma omp for nowait
      for (int i0 = 0; i0 < e0; ++i0)
        op(answer, localExpr.read(i0));
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<2>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i1 = 0; i1 < e1; ++i1) {
;
 for (int i0 = 0; i0 < e0; ++i0)
   op(answer, localExpr.read(i0, i1));
      }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<3>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i2 = 0; i2 < e2; ++i2)
 for (int i1 = 0; i1 < e1; ++i1) {
;
   for (int i0 = 0; i0 < e0; ++i0)
     op(answer, localExpr.read(i0, i1, i2));
 }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<4>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i3 = 0; i3 < e3; ++i3)
 for (int i2 = 0; i2 < e2; ++i2)
   for (int i1 = 0; i1 < e1; ++i1) {
;
     for (int i0 = 0; i0 < e0; ++i0)
       op(answer, localExpr.read(i0, i1, i2, i3));
   }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<5>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i4 = 0; i4 < e4; ++i4)
 for (int i3 = 0; i3 < e3; ++i3)
   for (int i2 = 0; i2 < e2; ++i2)
     for (int i1 = 0; i1 < e1; ++i1) {
;
       for (int i0 = 0; i0 < e0; ++i0)
  op(answer, localExpr.read(i0, i1, i2, i3, i4));
     }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<6>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
    int e5 = domain[5].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i5 = 0; i5 < e5; ++i5)
 for (int i4 = 0; i4 < e4; ++i4)
   for (int i3 = 0; i3 < e3; ++i3)
     for (int i2 = 0; i2 < e2; ++i2)
       for (int i1 = 0; i1 < e1; ++i1) {
;
  for (int i0 = 0; i0 < e0; ++i0)
    op(answer, localExpr.read(i0, i1, i2, i3, i4, i5));
       }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
  template<class T, class Op, class Expr, class Domain>
  inline static void evaluate(T &ret, const Op &op, const Expr &e,
    const Domain &domain, WrappedInt<7>)
  {
    Expr localExpr(e);
    int e0 = domain[0].length();
    int e1 = domain[1].length();
    int e2 = domain[2].length();
    int e3 = domain[3].length();
    int e4 = domain[4].length();
    int e5 = domain[5].length();
    int e6 = domain[6].length();
    PartialReduction<T> reduction;
#pragma omp parallel
    {
      T answer = ReductionTraits<Op, T>::identity();
#pragma omp for nowait
      for (int i6 = 0; i6 < e6; ++i6)
 for (int i5 = 0; i5 < e5; ++i5)
   for (int i4 = 0; i4 < e4; ++i4)
     for (int i3 = 0; i3 < e3; ++i3)
       for (int i2 = 0; i2 < e2; ++i2)
  for (int i1 = 0; i1 < e1; ++i1) {
;
    for (int i0 = 0; i0 < e0; ++i0)
      op(answer, localExpr.read(i0, i1, i2, i3, i4, i5, i6));
  }
      reduction.storePartialResult(answer);
    }
    reduction.reduce(ret, op);
  }
};
template<class T, class Op>
struct CompressibleReduce
{
  template<class T1>
  inline static void evaluate(T &ret, const Op &, const T1 &val, int)
  {
    ret = static_cast<T>(val);
  }
};
template<class T>
struct CompressibleReduce<T, OpAddAssign>
{
  template<class T1>
  inline static void evaluate(T &ret, const OpAddAssign &, const T1 &val,
    int n)
  {
    ret = static_cast<T>(n * val);
  }
};
template<class T>
struct CompressibleReduce<T, OpMultiplyAssign>
{
  template<class T1>
  inline static void evaluate(T &ret, const OpMultiplyAssign &, const T1 &val,
    int n)
  {
    ret = static_cast<T>(val);
    while (--n > 0)
      ret *= static_cast<T>(val);
  }
};
template<>
struct ReductionEvaluator<CompressibleKernelTag>
{
  template<class T, class Op, class Expr>
  inline static void evaluate(T &ret, const Op &op, const Expr &e)
  {
    if (engineFunctor(e, Compressed()))
      {
        CompressibleReduce<T, Op>::
          evaluate(ret, op, engineFunctor(e, CompressedRead()),
            e.domain().size());
      }
    else
      {
        ReductionEvaluator<InlineKernelTag>::evaluate(ret, op, e);
      }
  }
};
namespace Pooma {
class CountingSemaphore
{
public:
  CountingSemaphore() { }
  CountingSemaphore(const CountingSemaphore &) { }
  CountingSemaphore &operator=(const CountingSemaphore &) { return *this; }
  void wait() const { }
  int count() const { return 0; }
  int height() const { return 0; }
  void height(int) { }
  void raise_height(int) { }
  void incr() { }
  CountingSemaphore &operator++() { incr(); return *this; }
  int operator+=(int) { return 0; }
};
}
template<class T, class Op, class Expr, class KernelTag>
class ReductionKernel : public Pooma::Iterate_t
{
public:
  typedef ReductionKernel<T, Op, Expr, KernelTag> This_t;
  ReductionKernel(T &ret, const Op &op, const Expr &e,
    Pooma::CountingSemaphore &csem);
  virtual ~ReductionKernel();
  virtual void run();
private:
  T &ret_m;
  Op op_m;
  Expr expr_m;
  Pooma::CountingSemaphore &csem_m;
};
template<class T, class Op, class Expr, class KernelTag>
ReductionKernel<T, Op, Expr, KernelTag>::
ReductionKernel(T &ret, const Op &op, const Expr &e,
  Pooma::CountingSemaphore &csem)
  : Pooma::Iterate_t(Pooma::scheduler()),
    ret_m(ret), op_m(op), expr_m(e), csem_m(csem)
{
  DataObjectRequest<ReadRequest> readReq(*this);
  engineFunctor(expr_m, readReq);
}
template<class T, class Op, class Expr, class KernelTag>
ReductionKernel<T, Op, Expr, KernelTag>::~ReductionKernel()
{
  DataObjectRequest<ReadRelease> readRelease;
  engineFunctor(expr_m, readRelease);
  csem_m.incr();
}
template<class T, class Op, class Expr, class KernelTag>
void ReductionKernel<T, Op, Expr, KernelTag>::run()
{
  ReductionEvaluator<KernelTag>::evaluate(ret_m, op_m, expr_m);
}
template <class EvalTag>
struct Reduction
{ };
template <>
struct Reduction<MainEvaluatorTag>
{
  Reduction() { }
  ~Reduction() { }
  template <class Expr>
  static inline bool checkValidity(const Expr &e, WrappedInt<false>)
  {
    return true;
  }
  template <class Expr>
  static inline bool checkValidity(const Expr &e, WrappedInt<true>)
  {
    return e.centeringSize() == 1 && e.numMaterials() == 1;
  }
  template<class T, class Op, class Cond, class Expr>
  void evaluate(T &ret, const Op &op, const WhereProxy<Cond, Expr> &w) const
  {
    evaluate(ret, w.opMask(op), w.whereMask());
  }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e) const
  {
    typedef typename EvaluatorTag1<Expr>::Evaluator_t Evaluator_t;
    Pooma::scheduler().beginGeneration();
    ;
    forEach(e, PerformUpdateTag(), NullCombine());
    Reduction<Evaluator_t>().evaluate(ret, op, e());
    Pooma::scheduler().endGeneration();
    ;
  }
};
template <>
struct Reduction<SinglePatchEvaluatorTag>
{
  Reduction() { }
  ~Reduction() { }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e,
  Pooma::CountingSemaphore &csem) const
  {
    typedef typename KernelTag1<Expr>::Kernel_t Kernel_t;
    Pooma::Iterate_t *iterate =
      new ReductionKernel<T, Op, Expr, Kernel_t>(ret, op, e, csem);
    Pooma::scheduler().handOff(iterate);
  }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e) const
  {
    Pooma::CountingSemaphore csem;
    csem.height(1);
    evaluate(ret, op, e, csem);
    csem.wait();
  }
};
template <>
struct Reduction<MultiPatchEvaluatorTag>
{
  Reduction() { }
  ~Reduction() { }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e) const
  {
    typedef Intersector<Expr::dimensions> Inter_t;
    Inter_t inter;
    expressionApply(e, IntersectorTag<Inter_t>(inter));
    const int n = inter.size();
    Pooma::CountingSemaphore csem;
    csem.height(n);
    T *vals = new T[n];
    typename Inter_t::const_iterator i = inter.begin();
    int j = 0;
    while (j < n)
      {
        Reduction<SinglePatchEvaluatorTag>().
          evaluate(vals[j], op, e(*i), csem);
        ++i; ++j;
      }
    csem.wait();
    ret = vals[0];
    for (j = 1; j < n; j++)
      op(ret, vals[j]);
    delete [] vals;
  }
};
template<class Subject>
typename Subject::Element_t sum(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, OpAddAssign(), s);
  return ret;
}
template<class Subject>
typename Subject::Element_t prod(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, OpMultiplyAssign(), s);
  return ret;
}
template<class Subject>
typename Subject::Element_t min(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, FnMinAssign(), s);
  return ret;
}
template<class Subject>
typename Subject::Element_t max(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, FnMaxAssign(), s);
  return ret;
}
template<class Subject>
bool all(const Subject &s)
{
  bool ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, FnAndAssign(), s);
  return ret;
}
template<class Subject>
bool any(const Subject &s)
{
  bool ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, FnOrAssign(), s);
  return ret;
}
template<class Subject>
typename Subject::Element_t bitOr(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, OpBitwiseOrAssign(), s);
  return ret;
}
template<class Subject>
typename Subject::Element_t bitAnd(const Subject &s)
{
  typename Subject::Element_t ret;
  Reduction<MainEvaluatorTag>().evaluate(ret, OpBitwiseAndAssign(), s);
  return ret;
}
template<int Dim, class T, class EngineTag,
  int OtherDim, class OtherT, class OtherEngineTag, class Op>
inline const Array<Dim, T, EngineTag> &
assign(const Array<Dim, T, EngineTag> &lhs,
       const Array<OtherDim, OtherT, OtherEngineTag> &rhs,
       const Op &op);
template<int Dim, class T, class EngineTag, class T1, class Op>
inline const Array<Dim, T, EngineTag> &
assign(const Array<Dim, T, EngineTag> &lhs, const T1 &rhs, const Op &op);
template<class Subject, class Sub1, bool SV>
struct View1Implementation;
template<int Dim, class T, class EngineTag, class Domain>
struct View1Implementation<Array<Dim, T, EngineTag>, Domain, true>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  template<class S1, class Combine>
  inline static
  Type_t make(const Subject_t &a, const S1 &s1,
       const Combine &)
    {
      Domain s(Combine::make(a, s1));
      return a.engine()(s);
    }
  template<class S1, class S2, class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2));
      return a.engine()(s);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3));
      return a.engine()(s);
    }
  template<class S1, class S2, class S3, class S4,
    class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const S4 &s4,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4));
      return a.engine()(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const S4 &s4, const S5 &s5,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5));
      return a.engine()(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const S4 &s4, const S5 &s5, const S6 &s6,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
      return a.engine()(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class S7, class Combine>
  inline static
  Type_t make(const Subject_t &a,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const S4 &s4, const S5 &s5, const S6 &s6,
       const S7 &s7,
       const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
      return a.engine()(s);
    }
  template<class S1, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a, const S1 &s1,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1));
      return a.engine().read(s);
    }
  template<class S1, class S2, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2));
      return a.engine().read(s);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2, const S3 &s3,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3));
      return a.engine().read(s);
    }
  template<class S1, class S2, class S3, class S4,
    class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2, const S3 &s3,
                   const S4 &s4,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4));
      return a.engine().read(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2, const S3 &s3,
                   const S4 &s4, const S5 &s5,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5));
      return a.engine().read(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2, const S3 &s3,
                   const S4 &s4, const S5 &s5, const S6 &s6,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
      return a.engine().read(s);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class S7, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &a,
                   const S1 &s1, const S2 &s2, const S3 &s3,
                   const S4 &s4, const S5 &s5, const S6 &s6,
                   const S7 &s7,
                   const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
      return a.engine().read(s);
    }
};
template<int Dim, class T, class EngineTag, class Domain>
struct View1Implementation<Array<Dim, T, EngineTag>, Domain, false>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef typename NewEngine<Engine_t, Domain>::Type_t NewEngine_t;
  enum { newDim = NewEngine_t::dimensions };
  typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  typedef Array<newDim, T, NewEngineTag_t> Type_t;
  typedef Type_t ReadType_t;
  typedef NewEngineEngine<Engine_t, Domain> NewEE_t;
  typedef NewEngineDomain<Engine_t, Domain> NewED_t;
  template<class S1, class Combine>
  static
  Type_t make(const Subject_t &a, const S1 &s1,
           const Combine &)
    {
      Domain s(Combine::make(a, s1));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class Combine>
  static
  Type_t make(const Subject_t &a, const S1 &s1,
           const S2 &s2, const Combine &)
    {
      Domain s(Combine::make(a, s1, s2));
      return Type_t(
     NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class S3,
    class Combine>
  static
  Type_t make(const Subject_t &a,
           const S1 &s1, const S2 &s2, const S3 &s3,
           const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class S3, class S4,
    class Combine>
  static
  Type_t make(const Subject_t &a,
           const S1 &s1, const S2 &s2, const S3 &s3,
           const S4 &s4,
           const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class Combine>
  static
  Type_t make(const Subject_t &a,
           const S1 &s1, const S2 &s2, const S3 &s3,
           const S4 &s4, const S5 &s5,
           const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class Combine>
  static
  Type_t make(const Subject_t &a,
           const S1 &s1, const S2 &s2, const S3 &s3,
           const S4 &s4, const S5 &s5, const S6 &s6,
           const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class S7, class Combine>
  static
  Type_t make(const Subject_t &a,
           const S1 &s1, const S2 &s2, const S3 &s3,
           const S4 &s4, const S5 &s5, const S6 &s6,
           const S7 &s7,
           const Combine &)
    {
      Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
      return Type_t(
  NewEE_t::apply(a.engine(), s),
  NewED_t::apply(a.engine(), s));
    }
  template<class S1, class Combine>
  inline static
  Type_t makeRead(const Subject_t &a, const S1 &s1,
               const Combine &c)
    {
      return make(a, s1, c);
    }
  template<class S1, class S2, class Combine>
  inline static
  Type_t makeRead(const Subject_t &a, const S1 &s1,
               const S2 &s2, const Combine &c)
    {
      return make(a, s1, s2, c);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &a,
               const S1 &s1, const S2 &s2, const S3 &s3,
               const Combine &c)
    {
      return make(a, s1, s2, s3, c);
    }
  template<class S1, class S2, class S3, class S4,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &a,
               const S1 &s1, const S2 &s2, const S3 &s3,
               const S4 &s4, const Combine &c)
    {
      return make(a, s1, s2, s3, s4, c);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &a,
               const S1 &s1, const S2 &s2, const S3 &s3,
               const S4 &s4, const S5 &s5, const Combine &c)
    {
      return make(a, s1, s2, s3, s4, s5, c);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &a,
               const S1 &s1, const S2 &s2, const S3 &s3,
               const S4 &s4, const S5 &s5, const S6 &s6,
               const Combine &c)
    {
      return make(a, s1, s2, s3, s4, s5, s6, c);
    }
  template<class S1, class S2, class S3, class S4, class S5,
    class S6, class S7,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &a,
               const S1 &s1, const S2 &s2, const S3 &s3,
               const S4 &s4, const S5 &s5, const S6 &s6,
               const S7 &s7, const Combine &c)
    {
      return make(a, s1, s2, s3, s4, s5, s6, s7, c);
    }
};
template<int Dim, class T, class EngineTag, class Domain>
struct View1<Array<Dim, T, EngineTag>, Domain>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef TemporaryNewDomain1<Domain_t, Domain> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Domain &s1)
    {
      return Dispatch_t::make(a, s1, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Domain &s1)
    {
      return Dispatch_t::makeRead(a, s1, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View0<Array<Dim, T, EngineTag> >
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef typename NewEngine<Engine_t, Domain_t>::Type_t NewEngine_t;
  enum { newDim = NewEngine_t::dimensions };
  typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  typedef Array<newDim, T, NewEngineTag_t> Type_t;
  typedef Type_t ReadType_t;
  static Type_t make(const Subject_t &a)
    {
      typedef NewEngineEngine<Engine_t, Domain_t> NewEE_t;
      typedef NewEngineDomain<Engine_t, Domain_t> NewED_t;
      return Type_t(
  NewEE_t::apply(a.engine(), a.engine().domain()),
  NewED_t::apply(a.engine(), a.engine().domain()));
    }
  inline static ReadType_t makeRead(const Subject_t &a)
    {
      return make(a);
    }
};
template<int Dim, class T, class EngineTag>
struct View1<Array<Dim, T, EngineTag>, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1)
    {
      return a.engine()(s1);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1)
    {
      return a.engine().read(s1);
    }
};
template<int Dim, class T, class EngineTag>
struct View1<Array<Dim, T, EngineTag>, Loc<Dim> >
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, const Loc<Dim>& s1)
    {
      ;
      return a.engine()(s1);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Loc<Dim>& s1)
    {
      ;
      return a.engine().read(s1);
    }
};
template<int D1, class T1, class E1, int D2, class T2, class E2>
struct View1<Array<D1, T1, E1>, Array<D2, T2, E2> >
{
  typedef Array<D1, T1, E1> Array1_t;
  typedef Array<D2, T2, E2> Array2_t;
  typedef IndirectionTag<Array1_t, Array2_t> Tag_t;
  typedef Array<D2, T1, Tag_t> Type_t;
  typedef Type_t ReadType_t;
  static
  Type_t make(const Array1_t &a, const Array2_t &s)
    {
      return Type_t(a, s);
    }
  inline static
  Type_t makeRead(const Array1_t &a, const Array2_t &s)
    {
      return make(a, s);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2>
struct View2<Array<Dim, T, EngineTag>, Sub1, Sub2>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain2<Sub1, Sub2> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2)
    {
      return Dispatch_t::make(a, s1, s2, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2)
    {
      return Dispatch_t::makeRead(a, s1, s2, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View2<Array<Dim, T, EngineTag>, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1, int s2)
    {
      return a.engine()(s1, s2);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2)
    {
      return a.engine().read(s1, s2);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3>
struct View3<Array<Dim, T, EngineTag>, Sub1, Sub2, Sub3>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain3<Sub1, Sub2, Sub3> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3)
    {
      return Dispatch_t::make(a, s1, s2, s3, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3)
    {
      return Dispatch_t::makeRead(a, s1, s2, s3, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View3<Array<Dim, T, EngineTag>, int, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1, int s2, int s3)
    {
      return a.engine()(s1, s2, s3);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2, int s3)
    {
      return a.engine().read(s1, s2, s3);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3, class Sub4>
struct View4<Array<Dim, T, EngineTag>,
  Sub1, Sub2, Sub3, Sub4>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain4<Sub1, Sub2, Sub3, Sub4> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4)
    {
      return Dispatch_t::make(a, s1, s2, s3, s4, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4)
    {
      return Dispatch_t::makeRead(a, s1, s2, s3, s4, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View4<Array<Dim, T, EngineTag>, int, int, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1, int s2, int s3, int s4)
    {
      return a.engine()(s1, s2, s3, s4);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2, int s3, int s4)
    {
      return a.engine().read(s1, s2, s3, s4);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
struct View5<Array<Dim, T, EngineTag>,
  Sub1, Sub2, Sub3, Sub4, Sub5>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain5<Sub1, Sub2, Sub3, Sub4, Sub5> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5)
    {
      return Dispatch_t::make(a, s1, s2, s3, s4, s5, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5)
    {
      return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View5<Array<Dim, T, EngineTag>, int, int, int, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2, int s3,
    int s4, int s5)
    {
      return a.engine().read(s1, s2, s3, s4, s5);
    }
  inline static
  Type_t make(const Subject_t &a, int s1, int s2, int s3, int s4, int s5)
    {
      return a.engine()(s1, s2, s3, s4, s5);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
  class Sub6>
struct View6<Array<Dim, T, EngineTag>,
  Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain6<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5, const Sub6 &s6)
    {
      return Dispatch_t::make(a, s1, s2, s3, s4, s5, s6, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5, const Sub6 &s6)
    {
      return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View6<Array<Dim, T, EngineTag>, int, int, int, int, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1, int s2, int s3, int s4, int s5,
       int s6)
    {
      return a.engine()(s1, s2, s3, s4, s5, s6);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2, int s3,
    int s4, int s5, int s6)
    {
      return a.engine().read(s1, s2, s3, s4, s5, s6);
    }
};
template<int Dim, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
  class Sub6, class Sub7>
struct View7<Array<Dim, T, EngineTag>,
  Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain7<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>
    NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::Type_t Type_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  inline static
  Type_t make(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5, const Sub6 &s6,
    const Sub7 &s7)
    {
      return Dispatch_t::make(a, s1, s2, s3, s4, s5, s6, s7, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3, const Sub4 &s4, const Sub5 &s5, const Sub6 &s6,
    const Sub7 &s7)
    {
      return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, s7,
        Combine_t());
    }
};
template<int Dim, class T, class EngineTag>
struct View7<Array<Dim, T, EngineTag>, int, int, int, int, int, int, int>
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &a, int s1, int s2, int s3, int s4, int s5,
       int s6, int s7)
    {
      return a.engine()(s1, s2, s3, s4, s5, s6, s7);
    }
  inline static
  ReadType_t makeRead(const Subject_t &a, int s1, int s2, int s3,
    int s4, int s5, int s6, int s7)
    {
      return a.engine().read(s1, s2, s3, s4, s5, s6, s7);
    }
};
template <class Subject, class Domain>
struct ReverseSliceView;
template <int SliceDim, class T, class EngineTag, int Dim>
struct ReverseSliceView<Array<SliceDim, T, EngineTag>, SliceInterval<Dim, SliceDim> >
{
  typedef Array<SliceDim, T, EngineTag> Subject_t;
  typedef SliceInterval<Dim, SliceDim> Domain_t;
  typedef typename NewEngine<typename Subject_t::Engine_t, Domain_t>::Type_t NewEngine_t;
  typedef Array<Dim, T, typename NewEngine_t::Tag_t> Type_t;
  inline static
  Type_t make(const Subject_t &a, const SliceInterval<Dim, SliceDim>& dom,
       const Interval<Dim>& totalDom)
  {
    return Type_t(NewEngine_t(a.engine(), dom, totalDom));
  }
};
template<int Dim, class T, class EngineTag>
struct Patch<Array<Dim, T, EngineTag> >
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t OldEngine_t;
  typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  typedef Array<Dim, T, typename Engine_t::Tag_t> Type_t;
  inline static
  Type_t make(const Subject_t &subject, int i)
    {
      return Type_t(engineFunctor(subject.engine(), EnginePatch(i)));
    }
};
template<class Components, int Dim, class T, class EngineTag>
struct ComponentView<Components, Array<Dim, T, EngineTag> >
{
  typedef Array<Dim, T, EngineTag> Subject_t;
  typedef Engine<Dim, T, EngineTag> Engine_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename ComponentAccess<Element_t, Components>::Element_t NewT_t;
  typedef CompFwd<Engine_t, Components> NewEngineTag_t;
  typedef Array<Dim, NewT_t, NewEngineTag_t> Type_t;
  inline static
  Type_t make(const Subject_t &a, const Components &c)
    {
      return Type_t(a, ComponentWrapper<Components>(c));
    }
};
template<int Dim, class T = double,
  class EngineTag = Brick>
class Array
{
public:
  typedef Array<Dim, T, EngineTag> This_t;
  typedef Engine<Dim, T, EngineTag> Engine_t;
  typedef EngineTag EngineTag_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef typename Engine_t::Domain_t Domain_t;
  typedef typename Engine_t::Layout_t Layout_t;
  enum { dimensions = Engine_t::dimensions };
  enum { rank = Engine_t::dimensions };
  enum { hasRelations = false };
  Array() { }
  inline explicit Array(const Engine_t &modelEngine)
  : engine_m(modelEngine)
    { }
  template<int Dim2, class T2, class EngineTag2, class Initializer>
  inline Array(const Engine<Dim2, T2, EngineTag2> &engine,
    const Initializer &init)
  : engine_m(engine, init)
    { }
  template<int D1, class T1, class E1, int D2, class T2, class E2>
  inline Array(const Array<D1, T1, E1> &a1, const Array<D2, T2, E2> &a2)
  : engine_m(a1, a2)
    { }
  inline Array(const This_t &model)
  : engine_m(model.engine())
    { }
  template<int OtherDim, class OtherT, class OtherEngineTag>
  inline explicit Array(const Array<OtherDim, OtherT, OtherEngineTag> &model)
  : engine_m(model.engine())
    { }
  template<int OtherDim, class OtherT, class OtherEngineTag, class OtherDomain>
  inline Array(const Array<OtherDim, OtherT, OtherEngineTag> &model,
        const OtherDomain &domain)
  : engine_m(NewEngineEngine<Engine<OtherDim,OtherT,OtherEngineTag>,
             OtherDomain>::apply(model.engine(),domain),
             NewEngineDomain<Engine<OtherDim,OtherT,OtherEngineTag>,
             OtherDomain>::apply(model.engine(),domain))
    { }
  template <class OtherT, class OtherEngineTag, class Components>
  Array(const Array<Dim, OtherT, OtherEngineTag> &a,
 const ComponentWrapper<Components>& c)
  : engine_m(a.engine(), c.components())
    { }
  template<class Sub1>
  explicit Array(const Sub1 &s1)
  : engine_m(NewDomain1<Sub1>::combine(s1))
    { }
  template<class Sub1, class Sub2>
  Array(const Sub1 &s1, const Sub2 &s2)
  : engine_m(NewDomain2<Sub1, Sub2>::combine(s1, s2))
    { }
  template<class Sub1, class Sub2, class Sub3>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3)
  : engine_m(NewDomain3<Sub1, Sub2, Sub3>::combine(s1, s2, s3))
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4)
  : engine_m(NewDomain4<Sub1, Sub2, Sub3, Sub4>::
      combine(s1, s2, s3, s4))
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5)
  : engine_m(NewDomain5<Sub1, Sub2, Sub3, Sub4, Sub5>::
      combine(s1, s2, s3, s4, s5))
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5, const Sub6 &s6)
  : engine_m(NewDomain6<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::
      combine(s1, s2, s3, s4, s5, s6))
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5, const Sub6 &s6, const Sub7 &s7)
  : engine_m(NewDomain7<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::
      combine(s1, s2, s3, s4, s5, s6, s7))
    { }
  template<class Sub1>
  Array(const Sub1 &s1, const ModelElement<Element_t> &model)
  : engine_m(NewDomain1<Sub1>::combine(s1), model.element())
    { }
  template<class Sub1, class Sub2>
  Array(const Sub1 &s1, const Sub2 &s2,
        const ModelElement<Element_t> &model)
  : engine_m(NewDomain2<Sub1, Sub2>::combine(s1, s2), model.element())
    { }
  template<class Sub1, class Sub2, class Sub3>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
        const ModelElement<Element_t> &model)
  : engine_m(NewDomain3<Sub1, Sub2, Sub3>::combine(s1, s2, s3),
      model.element())
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const ModelElement<Element_t> &model)
  : engine_m(NewDomain4<Sub1, Sub2, Sub3, Sub4>::
      combine(s1, s2, s3, s4), model.element())
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5, const ModelElement<Element_t> &model)
  : engine_m(NewDomain5<Sub1, Sub2, Sub3, Sub4, Sub5>::
      combine(s1, s2, s3, s4, s5), model.element())
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5, const Sub6 &s6, const ModelElement<Element_t> &model)
  : engine_m(NewDomain6<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::
      combine(s1, s2, s3, s4, s5, s6), model.element())
    { }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  Array(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
        const Sub5 &s5, const Sub6 &s6, const Sub7 &s7,
        const ModelElement<Element_t> &model)
  : engine_m(NewDomain7<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::
      combine(s1, s2, s3, s4, s5, s6, s7), model.element())
    { }
  void initialize(const Engine_t &modelEngine)
    {
      engine_m = modelEngine;
    }
  template<int Dim2, class T2, class EngineTag2, class Initializer>
  void initialize(const Engine<Dim2, T2, EngineTag2> &engine,
    const Initializer &init)
    {
      engine_m = Engine_t(engine, init);
    }
  void initialize(const This_t &model)
    {
      engine_m = model.engine();
    }
  template<int OtherDim, class OtherT, class OtherEngineTag>
  void initialize(const Array<OtherDim, OtherT, OtherEngineTag> &model)
    {
      engine_m = Engine_t(model.engine());
    }
  template<int OtherDim, class OtherT, class OtherEngineTag, class OtherDomain>
  void initialize(const Array<OtherDim, OtherT, OtherEngineTag> &model,
    const OtherDomain &domain)
    {
      engine_m = Engine_t(
        NewEngineEngine<Engine<OtherDim,OtherT,OtherEngineTag>, OtherDomain>::
        apply(model.engine(),domain),
        NewEngineDomain<Engine<OtherDim,OtherT,OtherEngineTag>, OtherDomain>::
        apply(model.engine(),domain));
    }
  template<class Sub1>
  void initialize(const Sub1 &s1)
    {
      engine_m = Engine_t(NewDomain1<Sub1>::combine(s1));
    }
  template<class Sub1, class Sub2>
  void initialize(const Sub1 &s1, const Sub2 &s2)
    {
      engine_m = Engine_t(NewDomain2<Sub1, Sub2>::combine(s1, s2));
    }
  template<class Sub1, class Sub2, class Sub3>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3)
    {
      engine_m = Engine_t(NewDomain3<Sub1, Sub2, Sub3>::combine(s1, s2, s3));
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4)
    {
      engine_m = Engine_t(NewDomain4<Sub1, Sub2, Sub3, Sub4>::
                          combine(s1, s2, s3, s4));
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
                  const Sub5 &s5)
    {
      engine_m = Engine_t(NewDomain5<Sub1, Sub2, Sub3, Sub4, Sub5>::
                          combine(s1, s2, s3, s4, s5));
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
                  const Sub5 &s5, const Sub6 &s6)
    {
      engine_m = Engine_t(NewDomain6<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::
                          combine(s1, s2, s3, s4, s5, s6));
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6, const Sub7 &s7)
    {
      engine_m =
        Engine_t(NewDomain7<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::
        combine(s1, s2, s3, s4, s5, s6, s7));
    }
  template<class Sub1>
  void initialize(const Sub1 &s1, const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain1<Sub1>::combine(s1), model.element());
    }
  template<class Sub1, class Sub2>
  void initialize(const Sub1 &s1, const Sub2 &s2,
    const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain2<Sub1, Sub2>::combine(s1, s2),
        model.element());
    }
  template<class Sub1, class Sub2, class Sub3>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain3<Sub1, Sub2, Sub3>::combine(s1, s2, s3),
        model.element());
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
    const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain4<Sub1, Sub2, Sub3, Sub4>::
        combine(s1, s2, s3, s4), model.element());
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
    const Sub5 &s5, const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain5<Sub1, Sub2, Sub3, Sub4, Sub5>::
        combine(s1, s2, s3, s4, s5), model.element());
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3, const Sub4 &s4,
    const Sub5 &s5, const Sub6 &s6, const ModelElement<Element_t> &model)
    {
      engine_m = Engine_t(NewDomain6<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::
        combine(s1, s2, s3, s4, s5, s6), model.element());
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  void initialize(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6, const Sub7 &s7,
    const ModelElement<Element_t> &model)
    {
      engine_m =
        Engine_t(NewDomain7<Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::
        combine(s1, s2, s3, s4, s5, s6, s7), model.element());
    }
  ~Array()
    { }
  inline typename Patch<This_t>::Type_t
  patchLocal(int i) const
    {
      return Patch<This_t>::make(*this, i);
    }
  inline int
  numPatchesLocal() const
    {
      return engineFunctor(engine_m, EngineNumPatches());
    }
  inline const Domain_t& domain() const
    {
      return engine_m.domain();
    }
  inline Domain_t physicalDomain() const
    {
      return engine_m.layout().innerDomain();
    }
  inline const Domain_t& totalDomain() const
    {
      return engine_m.domain();
    }
  inline typename Engine_t::Layout_t layout() const
    {
      return engine_m.layout();
    }
  typename View0<This_t>::ReadType_t
  read() const
    {
      typedef View0<This_t> Ret_t;
      return Ret_t::makeRead(*this);
    }
  template<class Sub1>
  inline typename View1<This_t, Sub1>::ReadType_t
  read(const Sub1 &s1) const
    {
      typedef View1<This_t, Sub1> Ret_t;
      return Ret_t::makeRead(*this, s1);
    }
  template<class Sub1, class Sub2>
  inline typename View2<This_t, Sub1, Sub2>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2) const
    {
      typedef View2<This_t, Sub1, Sub2> Ret_t;
      return Ret_t::makeRead(*this, s1, s2);
    }
  template<class Sub1, class Sub2, class Sub3>
  inline typename View3<This_t, Sub1, Sub2, Sub3>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3) const
    {
      typedef View3<This_t, Sub1, Sub2, Sub3> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  inline typename View4<This_t, Sub1, Sub2, Sub3, Sub4>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4) const
    {
      typedef View4<This_t, Sub1, Sub2, Sub3, Sub4> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3, s4);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  inline typename View5<This_t, Sub1, Sub2, Sub3, Sub4, Sub5>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5) const
    {
      typedef View5<This_t, Sub1, Sub2, Sub3, Sub4, Sub5> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3, s4, s5);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  inline typename View6<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6) const
    {
      typedef View6<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3, s4, s5, s6);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  inline typename
    View7<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6, const Sub7 &s7) const
    {
      typedef View7<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3, s4, s5, s6, s7);
    }
  typename View0<This_t>::Type_t
  operator()() const
    {
      typedef View0<This_t> Ret_t;
      return Ret_t::make(*this);
    }
  template<class Sub1>
  inline typename View1<This_t,Sub1>::Type_t
  operator()(const Sub1 &s1) const
    {
      typedef View1<This_t, Sub1> Ret_t;
      return Ret_t::make(*this, s1);
    }
  template<class Sub1, class Sub2>
  inline typename View2<This_t, Sub1, Sub2>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2) const
    {
      typedef View2<This_t, Sub1, Sub2> Ret_t;
      return Ret_t::make(*this, s1, s2);
    }
  template<class Sub1, class Sub2, class Sub3>
  inline typename View3<This_t, Sub1, Sub2, Sub3>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3) const
    {
      typedef View3<This_t, Sub1, Sub2, Sub3> Ret_t;
      return Ret_t::make(*this, s1, s2, s3);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4>
  inline typename View4<This_t, Sub1, Sub2, Sub3, Sub4>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4) const
    {
      typedef View4<This_t, Sub1, Sub2, Sub3, Sub4> Ret_t;
      return Ret_t::make(*this, s1, s2, s3, s4);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5>
  inline typename View5<This_t, Sub1, Sub2, Sub3, Sub4, Sub5>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5) const
    {
      typedef View5<This_t, Sub1, Sub2, Sub3, Sub4, Sub5> Ret_t;
      return Ret_t::make(*this, s1, s2, s3, s4, s5);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6>
  inline typename
    View6<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6) const
    {
      typedef View6<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6> Ret_t;
      return Ret_t::make(*this, s1, s2, s3, s4, s5, s6);
    }
  template<class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
    class Sub6, class Sub7>
  inline typename
    View7<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3,
    const Sub4 &s4, const Sub5 &s5, const Sub6 &s6, const Sub7 &s7) const
    {
      typedef View7<This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7> Ret_t;
      return Ret_t::make(*this, s1, s2, s3, s4, s5, s6, s7);
    }
  inline typename ComponentView<Loc<1>, This_t>::Type_t
  comp(int i1) const
    {
      return ComponentView<Loc<1>, This_t>::make(*this, Loc<1>(i1));
    }
  inline typename ComponentView<Loc<2>, This_t>::Type_t
  comp(int i1, int i2) const
    {
      return ComponentView<Loc<2>, This_t>::make(*this, Loc<2>(i1, i2));
    }
  inline typename ComponentView<Loc<3>, This_t>::Type_t
  comp(int i1, int i2, int i3) const
    {
      return ComponentView<Loc<3>, This_t>::make(*this, Loc<3>(i1, i2, i3));
    }
  inline typename ComponentView<Loc<4>, This_t>::Type_t
  comp(int i1, int i2, int i3, int i4) const
    {
      return ComponentView<Loc<4>, This_t>::make(*this,
        Loc<4>(i1, i2, i3, i4));
    }
  inline typename ComponentView<Loc<5>, This_t>::Type_t
  comp(int i1, int i2, int i3, int i4, int i5) const
    {
      return ComponentView<Loc<5>, This_t>::make(*this,
        Loc<5>(i1, i2, i3, i4, i5));
    }
  inline typename ComponentView<Loc<6>, This_t>::Type_t
  comp(int i1, int i2, int i3, int i4, int i5, int i6) const
    {
      return ComponentView<Loc<6>, This_t>::make(*this,
        Loc<6>(i1, i2, i3, i4, i5, i6));
    }
  inline typename ComponentView<Loc<7>, This_t>::Type_t
  comp(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
    {
      return ComponentView<Loc<7>, This_t>::make(*this,
        Loc<7>(i1, i2, i3, i4, i5, i6, i7));
    }
  template<class Components>
  inline typename ComponentView<Components, This_t>::Type_t
  comp(const Components &components) const
    {
      return ComponentView<Components, This_t>::make(*this, components);
    }
  inline void makeOwnCopy()
    { engine_m.makeOwnCopy(); }
  inline int first(int d) const
  {
      return engine_m.first(d);
    }
  inline int last(int d) const
    {
      return engine_m.domain()[d].last();
    }
  inline int length(int d) const
    {
      return engine_m.domain()[d].length();
    }
  inline Loc<Dim> firsts() const
    {
      return engine_m.domain().firsts();
    }
  inline Loc<Dim> lasts() const
    {
      return engine_m.domain().lasts();
    }
  inline Loc<Dim> lengths() const
    {
      return engine_m.domain().lengths();
    }
  inline long size() const
    {
      return engine_m.domain().size();
    }
  This_t &operator=(const Array<Dim, T, EngineTag> &rhs)
    {
      assign(*this, rhs, OpAssign());
      return *this;
    }
  const This_t &operator=(const Array<Dim, T, EngineTag> &rhs) const
    {
      return assign(*this, rhs, OpAssign());
    }
  template<class T1>
  const This_t &operator=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpAssign());
    }
  template<class T1>
  const This_t &operator+=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpAddAssign());
    }
  template<class T1>
  const This_t &operator-=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpSubtractAssign());
    }
  template<class T1>
  const This_t &operator*=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpMultiplyAssign());
    }
  template<class T1>
  const This_t &operator/=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpDivideAssign());
    }
  template<class T1>
  const This_t &operator%=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpModAssign());
    }
  template<class T1>
  const This_t &operator|=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseOrAssign());
    }
  template<class T1>
  const This_t &operator&=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseAndAssign());
    }
  template<class T1>
  const This_t &operator^=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseXorAssign());
    }
  template<class T1>
  const This_t &operator<<=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpLeftShiftAssign());
    }
  template<class T1>
  const This_t &operator>>=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpRightShiftAssign());
    }
  inline Engine_t &engine()
    { return engine_m; }
  inline const Engine_t &engine() const
    { return engine_m; }
private:
  Engine_t engine_m;
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, DomainFunctorTag>
{
  typedef typename Engine<Dim, T, EngineTag>::Domain_t Type_t;
  static Type_t apply(const Array<Dim, T, EngineTag> &a,
        const DomainFunctorTag &)
  {
    return a.domain();
  }
};
template<int Dim, class T, class EngineTag, class Domain>
struct LeafFunctor<Array<Dim, T, EngineTag>, ViewFunctorTag<Domain> >
{
  typedef typename View1<Array<Dim, T, EngineTag>, Domain>::Type_t Type_t;
  inline static Type_t apply(const Array<Dim, T, EngineTag> &a,
    const ViewFunctorTag<Domain> &t)
    {
      typedef View1<Array<Dim, T, EngineTag>, Domain> Ret_t;
      return Ret_t::make(a, t.domain_m + a.firsts());
    }
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, EvalLeaf<Dim> >
{
  typedef typename Array<Dim, T, EngineTag>::Element_t Type_t;
  inline static
  Type_t apply(const Array<Dim, T, EngineTag> &a, const EvalLeaf<Dim> &t)
    {
      return t.eval(a.engine());
    }
};
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Array<Dim, T, E>, EngineView<Tag> >
{
  typedef LeafFunctor<Engine<Dim, T, E>, EngineView<Tag> > LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t NewEngine_t;
  typedef typename NewEngine_t::Tag_t NewTag_t;
  typedef Array<Dim, T, NewTag_t> Type_t;
  inline static
  Type_t apply(const Array<Dim, T, E> &array,
        const EngineView<Tag> &tag)
  {
    return Type_t(LeafFunctor_t::apply(array.engine(), tag));
  }
};
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Array<Dim, T, E>, ExpressionApply<Tag> >
{
  typedef LeafFunctor<Engine<Dim, T, E>, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Array<Dim, T, E> &array,
        const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(array.engine(), tag);
  }
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, ConformTag<Dim> >
{
  typedef bool Type_t;
  static Type_t apply(const Array<Dim, T, EngineTag> &array,
    const ConformTag<Dim> &ct)
    {
      return conforms(array.domain(), ct);
    }
};
template<int Dim1, int Dim2, class T, class EngineTag>
struct LeafFunctor<Array<Dim1, T, EngineTag>, ConformTag<Dim2> >
{
  typedef bool Type_t;
  static Type_t apply(const Array<Dim1, T, EngineTag> &,
    const ConformTag<Dim2> &)
    {
      return false;
    }
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, NotifyPreReadTag>
{
  typedef bool Type_t;
  static Type_t apply(const Array<Dim, T, EngineTag> &a,
    const NotifyPreReadTag &)
    {
      return true;
    }
};
template<int Dim, class T, class E, class Tag>
struct LeafFunctor<Array<Dim, T, E>, EngineFunctorTag<Tag> >
{
  typedef typename Array<Dim,T,E>::Engine_t Engine_t;
  typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Array<Dim, T, E> &array, const EngineFunctorTag<Tag> &tag)
  {
    return EngineFunctor<Engine_t,Tag>::apply(array.engine(), tag.tag());
  }
};
template<int Dim, class T, class E, class Tag>
struct EngineFunctor<Array<Dim, T, E>, Tag>
{
  typedef typename EngineFunctor<Engine<Dim, T, E>, Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Array<Dim, T, E> &array,
        const Tag &tag)
  {
    return engineFunctor(array.engine(), tag);
  }
};
template <int Dim, class T, class EngineTag>
std::ostream &operator<<(std::ostream &o,
                         const Array<Dim, T, EngineTag> &ca)
{
  Pooma::blockAndEvaluate();
  PrintArray().print(o, ca);
  return o;
}
template <int Dim, class T, class EngineTag>
std::fstream &operator<<(std::fstream &f,
                         const Array<Dim, T, EngineTag> &ca)
{
  Pooma::blockAndEvaluate();
  PrintArray().print(f, ca);
  return f;
}
struct ExpressionIsArray { };
template<int Dim, class T, class EngineTag>
struct ExpressionTraits<Array<Dim, T, EngineTag> >
{
  typedef ExpressionIsArray Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsArray, ExpressionIsArray>
{
  typedef ExpressionIsArray Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsArray, ExpressionIsScalar>
{
  typedef ExpressionIsArray Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsScalar, ExpressionIsArray>
{
  typedef ExpressionIsArray Type_t;
};
template<int Dim, class T, class EngineTag,
  int OtherDim, class OtherT, class OtherEngineTag, class Op>
inline const Array<Dim, T, EngineTag> &
assign(const Array<Dim, T, EngineTag> &lhs,
       const Array<OtherDim, OtherT, OtherEngineTag> &rhs,
       const Op &op)
{
  ;
  Evaluator<MainEvaluatorTag>().evaluate(lhs, op, rhs);
  return lhs;
}
template<int Dim, class T, class EngineTag, class T1, class Op>
inline const Array<Dim, T, EngineTag> &
assign(const Array<Dim, T, EngineTag> &lhs, const T1 &rhs, const Op &op)
{
  Array<Dim, T1, ConstantFunction> rhsExpr(lhs.domain());
  rhsExpr.engine().setConstant(rhs);
  Evaluator<MainEvaluatorTag>().evaluate(lhs, op, rhsExpr);
  return lhs;
}
template<class Tree>
struct ConvertWhereProxy<ExpressionIsArray, Tree>
{
  typedef MakeReturn<Tree> Make_t;
};
template<int Dim, class T, class EngineTag, class F, class B, class Op>
inline const Array<Dim, T, EngineTag> &
assign(const Array<Dim, T, EngineTag> &lhs,
       const WhereProxy<F,B> &rhs,
       const Op &op)
{
  assign(lhs, rhs.whereMask(), rhs.opMask(op));
  return lhs;
}
template<int Dim, class T, class EngineTag>
inline long
elementsCompressed(const Array<Dim, T, EngineTag> &a)
{
  return elementsCompressed(a.engine());
}
template<int Dim, class T, class EngineTag>
inline bool
compressed(const Array<Dim, T, EngineTag> &a)
{
  return compressed(a.engine());
}
template<int Dim, class T, class EngineTag>
inline void
compress(Array<Dim, T, EngineTag> &a)
{
  compress(a.engine());
}
template<int Dim, class T, class EngineTag>
inline void
uncompress(Array<Dim, T, EngineTag> &a)
{
  uncompress(a.engine());
}
template <int Dim, class T, class EngineTag>
struct ElementProperties< Array<Dim, T, EngineTag> >
  : public MakeOwnCopyProperties< Array<Dim, T, EngineTag> >
{ };
template <int Dim> class UniformGridLayout;
template <int Dim, int Dim2> class UniformGridLayoutView;
struct UniformTag { };
template <int Dim>
struct MultiPatchLayoutTraits<UniformTag,Dim>
{
  typedef UniformGridLayout<Dim> Layout_t;
  template <int ViewDim>
  struct View
  {
    typedef UniformGridLayoutView<ViewDim,Dim> Layout_t;
  };
};
template <int Dim>
class UniformGridLayoutData
 : public LayoutBaseData<Dim>,
   public RefCounted,
   public Observable<UniformGridLayoutData<Dim> >
{
public:
  typedef Interval<Dim> Domain_t;
  typedef Interval<Dim> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef typename LayoutBaseData<Dim>::GCFillInfo GCFillInfo_t;
  typedef typename std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  enum { dimensions = Dim };
  enum { repartitionEvent = 1 };
  enum { dynamic = false };
  UniformGridLayoutData();
  template <class Partitioner>
  UniformGridLayoutData(const Domain_t &gdom,
   const Partitioner &gpar,
   const ContextMapper<Dim> & cmap );
  void initialize(const Domain_t& idom,
    const List_t& nodes,
    const Loc<Dim>& blocks,
    bool hasIG, bool hasEG,
    const GuardLayers_t& ig,
    const GuardLayers_t& eg);
  ~UniformGridLayoutData()
  {
    typename List_t::iterator a;
    for (a = this->all_m.begin(); a != this->all_m.end(); ++a)
      delete (*a);
  }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &d, OutIter o, const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesLocal(const OtherDomain &d,
     OutIter o,
     const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesRemote(const OtherDomain &d,
      OutIter o,
      const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAlloc(const OtherDomain &d, OutIter o,
                   const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAllocLocal(const OtherDomain &d, OutIter o,
   const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAllocRemote(const OtherDomain &d, OutIter o,
    const ConstructTag &ctag) const;
  friend class UniformGridLayout<Dim>;
  int globalID(const Loc<Dim> &loc) const;
  int globalID(int) const;
  int globalID(int,int) const;
  int globalID(int,int,int) const;
  int globalID(int,int,int,int) const;
  int globalID(int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int,int) const;
  template <class Partitioner>
  void partition(const Partitioner &, const ContextMapper<Dim>& cmap);
  template <class Partitioner>
  bool repartition(const Partitioner &,const ContextMapper<Dim>&);
  void calcGCFillList();
  int blockstride_m[Dim];
  int blocksizes_m[Dim];
  Interval<Dim> allDomain_m;
};
template <int Dim>
class UniformGridLayout : public LayoutBase<Dim,UniformGridLayoutData<Dim> >,
                          public Observable<UniformGridLayout<Dim> >,
                          public Observer<UniformGridLayoutData<Dim> >
{
public:
  typedef UniformGridLayoutData<Dim> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef UniformGridLayout<Dim> This_t;
  typedef Observable<This_t> Observable_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef typename LayoutData_t::GCFillInfo_t GCFillInfo_t;
  typedef typename
    std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  enum { dimensions = Dim };
  enum { repartitionEvent = LayoutData_t::repartitionEvent };
  enum { dynamic = false };
  UniformGridLayout();
  UniformGridLayout(const Domain_t &,
      const DistributedTag &);
  UniformGridLayout(const Domain_t &,
                    const GuardLayers_t &,
      const DistributedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
      const DistributedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
                    const GuardLayers_t &,
      const DistributedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
                    const GuardLayers_t &,
                    const GuardLayers_t &,
      const DistributedTag &);
  UniformGridLayout(const Domain_t &,
      const ReplicatedTag &);
  UniformGridLayout(const Domain_t &,
                    const GuardLayers_t &,
      const ReplicatedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
      const ReplicatedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
                    const GuardLayers_t &,
      const ReplicatedTag &);
  UniformGridLayout(const Domain_t &,
                    const Loc<Dim> &,
                    const GuardLayers_t &,
                    const GuardLayers_t &,
      const ReplicatedTag &);
  template <class Partitioner>
  UniformGridLayout(const Domain_t &,
      const Partitioner &,
      const ContextMapper<Dim> & );
  template <class Partitioner>
  UniformGridLayout(const Domain_t &,
                    const Partitioner &,
      const DistributedTag &);
  template <class Partitioner>
  UniformGridLayout(const Domain_t &,
                    const Partitioner &,
      const ReplicatedTag &);
  UniformGridLayout(const This_t &);
  This_t &operator=(const This_t &);
  inline ~UniformGridLayout()
  {
    this->pdata_m->detach(*this);
  }
  void initialize(const Domain_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const DistributedTag & );
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const ReplicatedTag & );
  void initialize(const Domain_t &,
                  const Loc<Dim> &,
                  const GuardLayers_t &,
                  const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
                  const Loc<Dim> &,
                  const GuardLayers_t &,
                  const GuardLayers_t &,
    const ReplicatedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const DistributedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const ReplicatedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const ContextMapper<Dim> &);
  void initialize(const Domain_t& idom,
    const List_t& nodes,
    const Loc<Dim>& blocks,
    bool hasIG, bool hasEG,
    const GuardLayers_t& ig,
    const GuardLayers_t& eg);
  virtual void notify(LayoutData_t &d, const ObserverEvent &event)
  {
    ;
    Observable_t::notify(event);
  }
  template <class Ostream>
  void print(Ostream &ostr) const;
  template <int Dim1, int Dim2>
  friend class UniformGridLayoutView;
  friend class UniformGridLayoutData<Dim>;
};
template <int Dim, int Dim2>
class UniformGridLayoutViewData
  : public LayoutBaseViewData<Dim, Dim2, UniformGridLayout<Dim2> >,
    public RefCounted
{
public:
  typedef UniformGridLayout<Dim2> Layout_t;
  typedef UniformGridLayoutView<Dim, Dim2> ViewLayout_t;
  typedef LayoutBaseViewData<Dim,Dim2,Layout_t> Base_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim2> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef typename Layout_t::Domain_t AllocatedDomain_t;
  typedef ViewIndexer<Dim,Dim2> Indexer_t;
  typedef Node<Domain_t,AllocatedDomain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  enum { dim = Dim };
  enum { dim2 = Dim2};
  UniformGridLayoutViewData() { };
  template <class DT>
  inline
  UniformGridLayoutViewData(const Layout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,UniformGridLayout<Dim2> >(layout,dom)
  {
  }
  template <class DT>
  inline
  UniformGridLayoutViewData(const Layout_t &layout, const SliceDomain<DT> &dom)
  :LayoutBaseViewData<Dim,Dim2,UniformGridLayout<Dim2> >(layout,dom)
  {
  }
  template <class DT>
  UniformGridLayoutViewData(const ViewLayout_t &layout,
                            const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,UniformGridLayout<Dim2> >(
           layout.pdata_m->layout_m,
           layout,
           layout.pdata_m->indexer_m,
           dom,
           layout.internalGuards(),
           layout.externalGuards())
  {
  }
  template <int OrigDim, class DT>
  UniformGridLayoutViewData(const UniformGridLayoutView<OrigDim,Dim2> &layout,
                            const SliceDomain<DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,UniformGridLayout<Dim2> >(
        layout.pdata_m->layout_m,
        layout,
        Indexer_t(layout.pdata_m->indexer_m,dom),
        dom)
  {
  }
  ~UniformGridLayoutViewData()
  {
    typename List_t::iterator a;
    for (a = this->all_m.begin(); a != this->all_m.end(); ++a)
      delete (*a);
  }
};
template <int Dim, int Dim2>
class UniformGridLayoutView
  : public LayoutBaseView<Dim, Dim2, UniformGridLayoutViewData<Dim,Dim2> >
{
public:
  enum { dimensions = Dim };
  enum { dim = Dim };
  enum { dim2 = Dim2};
  typedef UniformGridLayoutViewData<Dim, Dim2> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Layout_t Layout_t;
  typedef typename LayoutData_t::AllocatedDomain_t AllocatedDomain_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef typename LayoutData_t::Indexer_t Indexer_t;
  typedef typename LayoutData_t::GuardLayers_t GuardLayers_t;
  typedef UniformGridLayoutView<Dim, Dim2> This_t;
  typedef UniformGridLayoutView<Dim, Dim2> ViewLayout_t;
  typedef LayoutBaseView<Dim,Dim2,LayoutData_t> Base_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  UniformGridLayoutView()
  : Base_t(new LayoutData_t())
  { }
  template <class DT>
  UniformGridLayoutView(const Layout_t &layout, const Domain<Dim2, DT> &dom)
  : LayoutBaseView<Dim,Dim2,UniformGridLayoutViewData<Dim,Dim2> >
    (new UniformGridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  UniformGridLayoutView(const Layout_t &layout, const SliceDomain<DT> &dom)
  : LayoutBaseView<Dim,Dim2,UniformGridLayoutViewData<Dim,Dim2> >
    (new UniformGridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  UniformGridLayoutView(const ViewLayout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseView<Dim,Dim2,UniformGridLayoutViewData<Dim,Dim2> >
    (new UniformGridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <int OldViewDim, class DT>
  UniformGridLayoutView(const UniformGridLayoutView<OldViewDim, Dim2> &layout,
                        const SliceDomain<DT> &dom)
  : LayoutBaseView<Dim,Dim2,UniformGridLayoutViewData<Dim,Dim2> >
    (new UniformGridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  inline UniformGridLayoutView(const This_t &model)
    : LayoutBaseView<Dim,
                     Dim2,
                     UniformGridLayoutViewData<Dim,Dim2> >(model.pdata_m)
  { }
  inline This_t &operator=(const This_t &model)
  {
    if (this != &model)
      {
        this->pdata_m = model.pdata_m;
      }
    return *this;
  }
  inline ~UniformGridLayoutView()
  { }
  template <class Ostream>
  void print(Ostream &ostr) const;
  template <int OtherDim, int OtherDim2>
  friend class UniformGridLayoutView;
  template <int OtherDim, int OtherDim2>
  friend class UniformGridLayoutViewData;
};
template <int Dim>
struct NewDomain1<UniformGridLayout<Dim> >
{
  typedef UniformGridLayout<Dim> &Type_t;
  inline static Type_t combine(const UniformGridLayout<Dim> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim, int Dim2>
struct NewDomain1<UniformGridLayoutView<Dim, Dim2> >
{
  typedef UniformGridLayoutView<Dim, Dim2> &Type_t;
  inline static Type_t combine(const UniformGridLayoutView<Dim, Dim2> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim>
std::ostream &operator<<(std::ostream &ostr,
                         const UniformGridLayout<Dim> &layout)
{
  layout.print(ostr);
  return ostr;
}
template <int Dim, int Dim2>
std::ostream &operator<<(std::ostream &ostr,
                         const UniformGridLayoutView<Dim, Dim2> &layout)
{
  layout.print(ostr);
  return ostr;
}
template <int Dim>
inline UniformGridLayoutData<Dim>::
UniformGridLayoutData()
  : Observable<UniformGridLayoutData>(*this)
{
  for (int i = 0; i < Dim; ++i)
    blockstride_m[i] = blocksizes_m[i] = 0;
}
template <int Dim>
template <class Partitioner>
UniformGridLayoutData<Dim>::
UniformGridLayoutData(const Domain_t &gdom,
        const Partitioner &gpar,
        const ContextMapper<Dim> & cmap )
  : LayoutBaseData<Dim>(false,
   false,
   GuardLayers_t(0),
   GuardLayers_t(0),
   gdom,
   gdom),
    Observable<UniformGridLayoutData>(*this)
{
  if (gpar.hasInternalGuards() && gpar.maxSize() > 1)
    {
      this->hasInternalGuards_m = true;
      this->internalGuards_m = gpar.internalGuards();
    }
  if (gpar.hasExternalGuards())
    {
      this->hasExternalGuards_m = true;
      this->externalGuards_m = gpar.externalGuards();
      GuardLayers<Dim>::addGuardLayers(this->domain_m,this->externalGuards_m);
    }
  partition(gpar,cmap);
}
template <int Dim>
template <class Partitioner>
void UniformGridLayoutData<Dim>::partition(const Partitioner &gpar,
        const ContextMapper<Dim> &cmap)
{
  int i;
  PoomaCTAssert<(Partitioner::uniform)>::test();
  ;
  ;
  ;
  ;
  ;
  this->blocks_m = gpar.blocks();
  blockstride_m[0] = 1;
  int blocks[Dim];
  for (i = 0; i < Dim; ++i)
  {
    this->firsti_m[i] = this->innerdomain_m[i].first();
    this->firste_m[i] = this->domain_m[i].first();
    blocks[i] = gpar.blocks()[i].first();
    allDomain_m[i] = Interval<1>(blocks[i]);
    blocksizes_m[i] = this->innerdomain_m[i].length() / blocks[i];
    if (i > 0)
      blockstride_m[i] = blockstride_m[i-1] * blocks[i-1];
  }
  gpar.partition(this->innerdomain_m, this->all_m, cmap);
  typename List_t::const_iterator start = this->all_m.begin();
  typename List_t::const_iterator end = this->all_m.end();
  for ( ; start!=end ; ++start)
    {
      if ( (*start)->context() == Pooma::context()
    || (*start)->context() == -1 )
 {
   (*start)->localID() = this->local_m.size();
   this->local_m.push_back(*start);
 }
      else
 this->remote_m.push_back(*start);
    }
  if (this->hasInternalGuards_m)
    {
      this->gcFillList_m.clear();
      calcGCFillList();
    }
}
template<int Dim>
void UniformGridLayoutData<Dim>::initialize(const Domain_t& idom,
     const List_t& nodes,
     const Loc<Dim>& ublocks,
     bool hasIG, bool hasEG,
     const GuardLayers_t& ig,
     const GuardLayers_t& eg)
{
  int i;
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  this->domain_m = idom;
  this->innerdomain_m = idom;
  this->hasInternalGuards_m = hasIG;
  if (this->hasInternalGuards_m)
    {
      this->internalGuards_m = ig;
    }
  this->hasExternalGuards_m = (hasEG && ! this->domain_m.empty());
  if (this->hasExternalGuards_m)
    {
      this->externalGuards_m = eg;
      GuardLayers<Dim>::addGuardLayers(this->domain_m, this->externalGuards_m);
    }
  this->blocks_m = ublocks;
  blockstride_m[0] = 1;
  int blocks[Dim];
  for (i = 0; i < Dim; ++i)
  {
    this->firsti_m[i] = this->innerdomain_m[i].first();
    this->firste_m[i] = this->domain_m[i].first();
    blocks[i] = ublocks[i].first();
    allDomain_m[i] = Interval<1>(blocks[i]);
    blocksizes_m[i] = this->innerdomain_m[i].length() / blocks[i];
    if (i > 0)
      blockstride_m[i] = blockstride_m[i-1] * blocks[i-1];
  }
  this->all_m= nodes;
  typename List_t::iterator start = this->all_m.begin();
  typename List_t::iterator end = this->all_m.end();
  for ( ; start!=end ;++start )
    {
      if( (*start)->context() == Pooma::context() ||
   (*start)->context() == -1 )
 this->local_m.push_back(*start);
      else
 this->remote_m.push_back(*start);
    }
  if (this->hasInternalGuards_m)
    {
      this->gcFillList_m.clear();
      calcGCFillList();
    }
}
template <int Dim>
void UniformGridLayoutData<Dim>::calcGCFillList()
  {
    int d, p;
    int numPatches = this->all_m.size();
    this->gcFillList_m.reserve(2*Dim*this->local_m.size());
    for (d = 0; d < Dim; ++d)
      {
        if (this->internalGuards_m.lower(d) > 0)
          {
            typename Interval<Dim>::iterator pos = allDomain_m.begin();
            for (p = 0; p < numPatches; ++p, ++pos)
              {
                if ( (*pos)[d].first() == allDomain_m[d].last() ) continue;
                int sourceID = p;
                int destID = p + blockstride_m[d];
                ;
                ;
                Domain_t gcdom(this->all_m[p]->allocated());
                int max = this->all_m[p]->domain()[d].last();
                int min = max - this->internalGuards_m.lower(d) + 1;
                gcdom[d] = Interval<1>(min,max);
   if (
      this->all_m[sourceID]->context() == -1 ||
      this->all_m[sourceID]->context() == Pooma::context() ||
       this->all_m[destID]->context() == Pooma::context()
      )
                this->gcFillList_m.push_back(GCFillInfo_t(gcdom,sourceID,destID,d*2));
              }
          }
        if (this->internalGuards_m.upper(d) > 0)
          {
            typename Interval<Dim>::iterator pos = allDomain_m.begin();
            for (p = 0; p < numPatches; ++p, ++pos)
              {
                if ( (*pos)[d].first() == allDomain_m[d].first() ) continue;
                int sourceID = p;
                int destID = p - blockstride_m[d];
                ;
                Domain_t gcdom(this->all_m[p]->allocated());
                int min = this->all_m[p]->domain()[d].first();
                int max = min + this->internalGuards_m.upper(d) - 1;
                gcdom[d] = Interval<1>(min,max);
   if (
      this->all_m[sourceID]->context() == -1 ||
      this->all_m[sourceID]->context() == Pooma::context() ||
       this->all_m[destID]->context() == Pooma::context()
      )
    this->gcFillList_m.push_back(GCFillInfo_t(gcdom,sourceID,destID,d*2+1));
              }
          }
      }
  }
template <int Dim>
template <class Partitioner>
bool UniformGridLayoutData<Dim>::
repartition(const Partitioner &p,
     const ContextMapper<Dim>& cmap)
{
  ;
  for (int i = 0; i < this->all_m.size(); ++i)
    delete this->all_m[i];
  this->all_m.clear();
  this->local_m.clear();
  this->remote_m.clear();
  partition(p,cmap);
  if (this->hasInternalGuards_m)
    {
      this->gcFillList_m.clear();
      calcGCFillList();
    }
  this->notify(repartitionEvent);
  return true;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touches(const OtherDomain &d, OutIter o,
     const ConstructTag &ctag) const
{
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->all_m[indx]->domain());
      ;
      *o = touchesConstruct(outDomain,
       this->all_m[indx]->allocated(),
       this->all_m[indx]->affinity(),
       this->all_m[indx]->context(),
       this->all_m[indx]->globalID(),
       this->all_m[indx]->localID(),
       ctag);
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touchesLocal(const OtherDomain &d,
          OutIter o,
          const ConstructTag &ctag) const
{
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->local_m[indx]->domain());
      ;
      *o = touchesConstruct(outDomain,
       this->local_m[indx]->allocated(),
       this->local_m[indx]->affinity(),
       this->local_m[indx]->context(),
       this->local_m[indx]->globalID(),
       this->local_m[indx]->localID(),
       ctag);
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touchesRemote(const OtherDomain &d,
           OutIter o,
           const ConstructTag &ctag) const
{
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->remote_m[indx]->domain());
      ;
      *o = touchesConstruct(outDomain,
       this->remote_m[indx]->allocated(),
       this->remote_m[indx]->affinity(),
       this->remote_m[indx]->context(),
       this->remote_m[indx]->globalID(),
       this->remote_m[indx]->localID(),
       ctag);
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touchesAlloc(const OtherDomain &d, OutIter o,
          const ConstructTag &ctag) const
{
  if (!this->hasInternalGuards_m) return touches(d,o,ctag);
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      if (a > 0) --a;
      if (b < allDomain_m[i].last()) ++b;
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->all_m[indx]->allocated());
      if (!outDomain.empty())
 {
   *o = touchesConstruct(outDomain,
    this->all_m[indx]->allocated(),
    this->all_m[indx]->affinity(),
    this->all_m[indx]->context(),
    this->all_m[indx]->globalID(),
    this->all_m[indx]->localID(),
    ctag);
 }
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touchesAllocLocal(const OtherDomain &d, OutIter o,
               const ConstructTag &ctag) const
{
  if (!this->hasInternalGuards_m) return touches(d,o,ctag);
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      if (a > 0) --a;
      if (b < allDomain_m[i].last()) ++b;
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->local_m[indx]->allocated());
      if (!outDomain.empty())
 {
   *o = touchesConstruct(outDomain,
    this->local_m[indx]->allocated(),
    this->local_m[indx]->affinity(),
    this->local_m[indx]->context(),
    this->local_m[indx]->globalID(),
    this->local_m[indx]->localID(),
    ctag);
 }
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int UniformGridLayoutData<Dim>::touchesAllocRemote(const OtherDomain &d, OutIter o,
                const ConstructTag &ctag) const
{
  if (!this->hasInternalGuards_m) return touches(d,o,ctag);
  int i, count = 0;
  ;
  ;
  Interval<Dim> box = Pooma::NoInit();
  for (i = 0; i < Dim; ++i)
    {
      int a, b;
      if (!this->hasExternalGuards_m)
 {
   a = (d[i].min() - this->firsti_m[i]) / blocksizes_m[i];
   b = (d[i].max() - this->firsti_m[i]) / blocksizes_m[i];
 }
      else
 {
   a = b = 0;
   int pos = d[i].min();
   int last = this->innerdomain_m[i].last();
   int del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       a = del / blocksizes_m[i];
     else
       a = allDomain_m[i].last();
   pos = d[i].max();
   del = pos - this->firsti_m[i];
   if (del >= 0)
     if (pos <= last)
       b = del / blocksizes_m[i];
     else
       b = allDomain_m[i].last();
 }
      if (a > 0) --a;
      if (b < allDomain_m[i].last()) ++b;
      box[i] = Interval<1>(a, b);
    }
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  typename Interval<Dim>::const_iterator boxiter = box.begin();
  while (boxiter != box.end())
    {
      int indx = (*boxiter)[0].first();
      for (i = 1; i < Dim; ++i)
 indx += blockstride_m[i] * (*boxiter)[i].first();
      ;
      outDomain = intersect(d, this->remote_m[indx]->allocated());
      if (!outDomain.empty())
 {
   *o = touchesConstruct(outDomain,
    this->remote_m[indx]->allocated(),
    this->remote_m[indx]->affinity(),
    this->remote_m[indx]->context(),
    this->remote_m[indx]->globalID(),
    this->remote_m[indx]->localID(),
    ctag);
 }
      ++o;
      ++count;
      ++boxiter;
    }
  return count;
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout()
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t()),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const DistributedTag& t)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(),
        DistributedMapper<Dim>(UniformGridPartition<Dim>()))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const ReplicatedTag & t)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(),
        LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const GuardLayers_t &gcs,
    const DistributedTag &)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(gcs),
        DistributedMapper<Dim>(UniformGridPartition<Dim>(gcs)))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const GuardLayers_t &gcs,
    const ReplicatedTag & )
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(gcs),
        LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const Loc<Dim> &blocks,
    const DistributedTag & )
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(blocks),
        DistributedMapper<Dim>(
          UniformGridPartition<Dim>(blocks)))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const Loc<Dim> &blocks,
    const ReplicatedTag & t)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(blocks),
        LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
                  const Loc<Dim> &blocks,
                  const GuardLayers_t &igcs,
    const DistributedTag &)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
   (new LayoutData_t(gdom,
       UniformGridPartition<Dim>(blocks,igcs),
       DistributedMapper<Dim>(
        UniformGridPartition<Dim>(blocks,igcs)))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
                  const Loc<Dim> &blocks,
                  const GuardLayers_t &igcs,
    const ReplicatedTag &)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
     (new LayoutData_t(gdom,
         UniformGridPartition<Dim>(blocks,igcs),
         LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
                  const Loc<Dim> &blocks,
                  const GuardLayers_t &igcs,
                  const GuardLayers_t &egcs,
    const DistributedTag &)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(blocks,igcs,egcs),
        DistributedMapper<Dim>(
                       UniformGridPartition<Dim>(blocks,igcs,egcs)))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
                  const Loc<Dim> &blocks,
                  const GuardLayers_t &igcs,
                  const GuardLayers_t &egcs,
    const ReplicatedTag &t)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,
        UniformGridPartition<Dim>(blocks,igcs,egcs),
        LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const Partitioner &gpar,
    const DistributedTag & )
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
   (new LayoutData_t(gdom,gpar,DistributedMapper<Dim>(gpar))),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const Partitioner &gpar,
    const ReplicatedTag &)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
   (new LayoutData_t(gdom,gpar,LocalMapper<Dim>())),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
inline UniformGridLayout<Dim>::
UniformGridLayout(const Domain_t &gdom,
    const Partitioner &gpar,
    const ContextMapper<Dim> & cmap)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >
    (new LayoutData_t(gdom,gpar,cmap)),
  Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim>::
UniformGridLayout(const This_t &model)
: LayoutBase<Dim,UniformGridLayoutData<Dim> >(model.pdata_m),
  Observable<This_t>(*this)
{
   this->pdata_m->attach(*this);
}
template <int Dim>
inline UniformGridLayout<Dim> & UniformGridLayout<Dim>::
operator=(const This_t &model)
{
  if (this != &model)
    {
      this->pdata_m->detach(*this);
      this->pdata_m = model.pdata_m;
      this->pdata_m->attach(*this);
    }
  return *this;
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const DistributedTag &)
{
  ;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(),
       DistributedMapper<Dim>(UniformGridPartition<Dim>()));
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(),
       LocalMapper<Dim>());
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const GuardLayers_t &gcs,
    const DistributedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(gcs),
       DistributedMapper<Dim>(UniformGridPartition<Dim>(gcs) ));
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const GuardLayers_t &gcs,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(gcs),
       LocalMapper<Dim>());
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const Loc<Dim> &blocks,
    const DistributedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks),
      DistributedMapper<Dim>(UniformGridPartition<Dim>(blocks)));
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
    const Loc<Dim> &blocks,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks),
       LocalMapper<Dim>());
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Loc<Dim> &blocks,
           const GuardLayers_t &gcs,
    const DistributedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks, gcs),
       DistributedMapper<Dim>(
         UniformGridPartition<Dim>(blocks, gcs)));
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Loc<Dim> &blocks,
           const GuardLayers_t &gcs,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks, gcs),
       LocalMapper<Dim>());
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Loc<Dim> &blocks,
           const GuardLayers_t &igcs,
           const GuardLayers_t &egcs,
    const DistributedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks, igcs, egcs),
       DistributedMapper<Dim>(
         UniformGridPartition<Dim>(blocks, igcs, egcs)));
}
template <int Dim>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Loc<Dim> &blocks,
           const GuardLayers_t &igcs,
           const GuardLayers_t &egcs,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->blocks_m = blocks;
  this->pdata_m->partition(UniformGridPartition<Dim>(blocks, igcs, egcs),
       LocalMapper<Dim>());
}
template <int Dim>
template <class Partitioner>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Partitioner &p,
    const DistributedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->blocks_m = p.blocks();
  this->pdata_m->partition(p,DistributedMapper<Dim>(p));
}
template <int Dim>
template <class Partitioner>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Partitioner &p,
    const ReplicatedTag &)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->blocks_m = p.blocks();
  this->pdata_m->partition(p,LocalMapper<Dim>());
}
template <int Dim>
template <class Partitioner>
inline void
UniformGridLayout<Dim>::
initialize(const Domain_t &gdom,
           const Partitioner &p,
    const ContextMapper<Dim> &cmap)
{
  ;
  this->pdata_m->innerdomain_m = gdom;
  this->pdata_m->domain_m = gdom;
  this->pdata_m->blocks_m = p.blocks();
  this->pdata_m->partition(p,cmap);
}
template <int Dim>
void UniformGridLayout<Dim>::initialize(const Domain_t& idom,
     const List_t& nodes,
     const Loc<Dim>& blocks,
     bool hasIG, bool hasEG,
     const GuardLayers_t& ig,
     const GuardLayers_t& eg)
{
  this->pdata_m->initialize(idom,nodes,blocks,hasIG,hasEG,ig,eg);
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(const Loc<Dim> &loc) const
{
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (loc[0].first() - this->firsti_m[0]) / blocksizes_m[0];
      for (int d = 1; d < Dim; ++d)
        currloc += blockstride_m[d] *
          ((loc[d].first() - this->firsti_m[d]) / blocksizes_m[d]);
    }
  else
    {
      currloc = 0;
      for (int d = 0; d < Dim; ++d)
        {
          int l = loc[d].first();
          if (l >= this->firsti_m[d])
            {
              if (l <= this->innerdomain_m[d].last())
                {
                  currloc += blockstride_m[d] *
                    ((l - this->firsti_m[d]) / blocksizes_m[d]);
                }
              else
                {
                  currloc += blockstride_m[d] * allDomain_m[d].last();
                }
            }
        }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0) const
{
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
          currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
          currloc = allDomain_m[0].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1) const
{
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
          currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
          currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1, int i2) const
{
  ;
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1])
              + blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
          currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
          currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
      if (i2 >= this->firsti_m[2]) {
        if (i2 <= this->innerdomain_m[2].last())
          currloc += blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
        else
          currloc += blockstride_m[2] * allDomain_m[2].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3) const
{
  ;
  ;
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1])
              + blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2])
              + blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
           currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
           currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
      if (i2 >= this->firsti_m[2]) {
        if (i2 <= this->innerdomain_m[2].last())
          currloc += blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
        else
          currloc += blockstride_m[2] * allDomain_m[2].last();
      }
      if (i3 >= this->firsti_m[3]) {
        if (i3 <= this->innerdomain_m[3].last())
          currloc += blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3]);
        else
          currloc += blockstride_m[3] * allDomain_m[3].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
                                     int i4) const
{
  ;
  ;
  ;
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1])
              + blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2])
              + blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3])
              + blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
           currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
           currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
      if (i2 >= this->firsti_m[2]) {
        if (i2 <= this->innerdomain_m[2].last())
          currloc += blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
        else
          currloc += blockstride_m[2] * allDomain_m[2].last();
      }
      if (i3 >= this->firsti_m[3]) {
        if (i3 <= this->innerdomain_m[3].last())
          currloc += blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3]);
        else
          currloc += blockstride_m[3] * allDomain_m[3].last();
      }
      if (i4 >= this->firsti_m[4]) {
        if (i4 <= this->innerdomain_m[4].last())
          currloc += blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4]);
        else
          currloc += blockstride_m[4] * allDomain_m[4].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
                                     int i4, int i5) const
{
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1])
              + blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2])
              + blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3])
              + blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4])
              + blockstride_m[5] * ((i5 - this->firsti_m[5]) / blocksizes_m[5]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
           currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
           currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
      if (i2 >= this->firsti_m[2]) {
        if (i2 <= this->innerdomain_m[2].last())
          currloc += blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
        else
          currloc += blockstride_m[2] * allDomain_m[2].last();
      }
      if (i3 >= this->firsti_m[3]) {
        if (i3 <= this->innerdomain_m[3].last())
          currloc += blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3]);
        else
          currloc += blockstride_m[3] * allDomain_m[3].last();
      }
      if (i4 >= this->firsti_m[4]) {
        if (i4 <= this->innerdomain_m[4].last())
          currloc += blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4]);
        else
          currloc += blockstride_m[4] * allDomain_m[4].last();
      }
      if (i5 >= this->firsti_m[5]) {
        if (i5 <= this->innerdomain_m[5].last())
          currloc += blockstride_m[5] * ((i5 - this->firsti_m[5]) / blocksizes_m[5]);
        else
          currloc += blockstride_m[5] * allDomain_m[5].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
inline int
UniformGridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
                                     int i4, int i5, int i6) const
{
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  int currloc;
  if (!this->hasExternalGuards_m)
    {
      currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0]
              + blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1])
              + blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2])
              + blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3])
              + blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4])
              + blockstride_m[5] * ((i5 - this->firsti_m[5]) / blocksizes_m[5])
              + blockstride_m[6] * ((i6 - this->firsti_m[6]) / blocksizes_m[6]);
    }
  else
    {
      currloc = 0;
      if (i0 >= this->firsti_m[0]) {
        if (i0 <= this->innerdomain_m[0].last())
           currloc = (i0 - this->firsti_m[0]) / blocksizes_m[0];
        else
           currloc = allDomain_m[0].last();
      }
      if (i1 >= this->firsti_m[1]) {
        if (i1 <= this->innerdomain_m[1].last())
          currloc += blockstride_m[1] * ((i1 - this->firsti_m[1]) / blocksizes_m[1]);
        else
          currloc += blockstride_m[1] * allDomain_m[1].last();
      }
      if (i2 >= this->firsti_m[2]) {
        if (i2 <= this->innerdomain_m[2].last())
          currloc += blockstride_m[2] * ((i2 - this->firsti_m[2]) / blocksizes_m[2]);
        else
          currloc += blockstride_m[2] * allDomain_m[2].last();
      }
      if (i3 >= this->firsti_m[3]) {
        if (i3 <= this->innerdomain_m[3].last())
          currloc += blockstride_m[3] * ((i3 - this->firsti_m[3]) / blocksizes_m[3]);
        else
          currloc += blockstride_m[3] * allDomain_m[3].last();
      }
      if (i4 >= this->firsti_m[4]) {
        if (i4 <= this->innerdomain_m[4].last())
          currloc += blockstride_m[4] * ((i4 - this->firsti_m[4]) / blocksizes_m[4]);
        else
          currloc += blockstride_m[4] * allDomain_m[4].last();
      }
      if (i5 >= this->firsti_m[5]) {
        if (i5 <= this->innerdomain_m[5].last())
          currloc += blockstride_m[5] * ((i5 - this->firsti_m[5]) / blocksizes_m[5]);
        else
          currloc += blockstride_m[5] * allDomain_m[5].last();
      }
      if (i6 >= this->firsti_m[6]) {
        if (i6 <= this->innerdomain_m[6].last())
          currloc += blockstride_m[6] * ((i6 - this->firsti_m[6]) / blocksizes_m[6]);
        else
          currloc += blockstride_m[6] * allDomain_m[6].last();
      }
    }
  ;
  return currloc;
}
template <int Dim>
template <class Ostream>
void UniformGridLayout<Dim>::print(Ostream &ostr) const
{
  ostr << "UniformGridLayout " << this->ID() << " on global domain "
       << this->domain() << ":" << '\n';
  ostr << "   Total subdomains: " << this->sizeGlobal() << '\n';
  ostr << "   Local subdomains: " << this->sizeLocal() << '\n';
  ostr << "  Remote subdomains: " << this->sizeRemote() << '\n';
  ostr << "        Grid blocks: " << this->blocks() << '\n';
  typename UniformGridLayout<Dim>::const_iterator a;
  for (a = this->beginGlobal(); a != this->endGlobal(); ++a)
    ostr << "  Global subdomain = " << *a << '\n';
  for (a = this->beginLocal(); a != this->endLocal(); ++a)
    ostr << "   Local subdomain = " << *a << '\n';
  for (a = this->beginRemote(); a != this->endRemote(); ++a)
    ostr << "  Remote subdomain = " << *a << '\n';
}
template <int Dim, int Dim2>
template <class Ostream>
void UniformGridLayoutView<Dim, Dim2>::print(Ostream &ostr) const
{
  ostr << "UniformGridLayoutView " << this->ID() << " on global domain "
       << this->domain() << ":" << '\n';
  ostr << "   Base ID:          " << this->baseID() << '\n';
  ostr << "   Base domain:      " << this->baseDomain() << '\n';
  ostr << "   Total subdomains: " << this->sizeGlobal() << '\n';
  ostr << "   Local subdomains: " << this->sizeLocal() << '\n';
  ostr << "  Remote subdomains: " << this->sizeRemote() << '\n';
  const_iterator a;
  for (a = this->beginGlobal(); a != this->endGlobal(); ++a)
    ostr << "  Global subdomain = " << *a << '\n';
  for (a = this->beginLocal(); a != this->endLocal(); ++a)
    ostr << "   Local subdomain = " << *a << '\n';
  for (a = this->beginRemote(); a != this->endRemote(); ++a)
    ostr << "  Remote subdomain = " << *a << '\n';
}
template <class DT> class SliceDomain;
template<class Tag> struct Remote;
template <class LayoutTag, class PatchTag>
struct MultiPatch
{
  MultiPatch(){}
  ~MultiPatch(){}
};
template <class LayoutTag, class PatchTag, int Dim2>
struct MultiPatchView
{
  MultiPatchView(){}
  ~MultiPatchView(){}
};
template <int Dim, class T, class LayoutTag, class PatchTag>
class Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >;
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
class Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag,Dim2> >;
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  Interval<Dim> >
{
  typedef Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  Range<Dim> >
{
  typedef Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, class Domain>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  Node<Domain> >
{
  typedef typename
    NewEngine<Engine<Dim, T, PatchTag>, Node<Domain> >::Type_t Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, class Domain>
struct NewEngineEngine<
  Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> >,
  Node<Domain> >
{
  typedef Engine<Dim,T,PatchTag> &Type_t;
  static inline Engine<Dim,T,PatchTag> &
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &e,
 const Node<Domain> &i)
  {
    return e.globalPatch(i);
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag, class Domain>
struct NewEngineDomain<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  Node<Domain> >
{
  typedef const Domain &Type_t;
  static inline const Domain &
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &,
 const Node<Domain> &i)
  {
    return i.domain();
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  INode<Dim> >
{
  typedef typename
    NewEngine<Engine<Dim, T, PatchTag>, Interval<Dim> >::Type_t Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngineEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  INode<Dim> >
{
  typedef Engine<Dim,T,PatchTag> &Type_t;
  static inline Engine<Dim,T,PatchTag> &
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &e,
 const INode<Dim> &i)
  {
    return e.globalPatch(i);
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngineDomain<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  INode<Dim> >
{
  typedef const Interval<Dim> &Type_t;
  static inline const Interval<Dim> &
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &,
 const INode<Dim> &i)
  {
    return i.domain();
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag, int SliceDim>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  SliceInterval<Dim,SliceDim> >
{
  typedef
    Engine<SliceDim, T, MultiPatchView<LayoutTag, PatchTag, Dim> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, int SliceDim>
struct NewEngine<
  Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  SliceRange<Dim,SliceDim> >
{
  typedef
    Engine<SliceDim, T, MultiPatchView<LayoutTag, PatchTag, Dim> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  Interval<Dim> >
{
  typedef
    Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  Range<Dim> >
{
  typedef
    Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> > Type_t;
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, int Dim2, class Domain>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  Node<Domain> >
{
  typedef typename
    NewEngine<Engine<Dim2, T, PatchTag>, SliceRange<Dim2, Dim> >::Type_t
      Type_t;
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, class Domain>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim> >,
  Node<Domain> >
{
  typedef typename
    NewEngine<Engine<Dim, T, PatchTag>, Range<Dim> >::Type_t
      Type_t;
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, int Dim2, class Domain>
struct NewEngineEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
  Node<Domain> >
{
  typedef typename NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
    Node<Domain> >::Type_t Type_t;
  static inline Type_t
  apply(const Engine<Dim,T,MultiPatchView<LayoutTag,PatchTag,Dim2> > &e,
 const Node<Domain> &i)
  {
    return e.globalPatch(i);
  }
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, int Dim2, class Domain>
struct NewEngineDomain<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
  Node<Domain> >
{
  typedef EngineConstructTag Type_t;
  static inline EngineConstructTag
  apply(const Engine<Dim,T,MultiPatchView<LayoutTag,PatchTag,Dim2> > &,
 const Node<Domain> &)
  {
    return EngineConstructTag();
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  INode<Dim> >
{
  typedef typename
    NewEngine<Engine<Dim2, T, PatchTag>, SliceRange<Dim2, Dim> >::Type_t
      Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim> >,
  INode<Dim> >
{
  typedef typename
    NewEngine<Engine<Dim, T, PatchTag>, Range<Dim> >::Type_t
      Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
struct NewEngineEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
  INode<Dim> >
{
  typedef typename NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
    INode<Dim> >::Type_t Type_t;
  static inline Type_t
  apply(const Engine<Dim,T,MultiPatchView<LayoutTag,PatchTag,Dim2> > &e,
 const INode<Dim> &i)
  {
    return e.globalPatch(i);
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
struct NewEngineDomain<
  Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag, Dim2> >,
  INode<Dim> >
{
  typedef EngineConstructTag Type_t;
  static inline EngineConstructTag
  apply(const Engine<Dim,T,MultiPatchView<LayoutTag,PatchTag,Dim2> > &,
 const INode<Dim> &)
  {
    return EngineConstructTag();
  }
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, int Dim2, int SliceDim>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  SliceInterval<Dim, SliceDim> >
{
  typedef
    Engine<SliceDim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> > Type_t;
};
template <int Dim, class T,
          class LayoutTag, class PatchTag, int Dim2, int SliceDim>
struct NewEngine<
  Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >,
  SliceRange<Dim, SliceDim> >
{
  typedef
    Engine<SliceDim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> > Type_t;
};
template <int Dim, class T, class LayoutTag, class PatchTag>
class Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> > :
  public Observer<typename MultiPatchLayoutTraits<LayoutTag,Dim>::Layout_t>
{
public:
  typedef MultiPatch<LayoutTag,PatchTag> Tag_t;
  typedef Engine<Dim,T,Tag_t> This_t;
  typedef Engine<Dim,T,Tag_t> Engine_t;
  typedef Interval<Dim> Domain_t;
  typedef T Element_t;
  typedef PatchTag PatchTag_t;
  typedef Engine<Dim, T, PatchTag> PatchEngine_t;
  typedef typename PatchEngine_t::ElementRef_t ElementRef_t;
  typedef RefCountedBlockPtr<PatchEngine_t> PatchContainer_t;
  typedef MultiPatchLayoutTraits<LayoutTag,Dim> LayoutTraits_t;
  typedef typename LayoutTraits_t::Layout_t Layout_t;
  typedef Layout_t Observable_t;
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef ObserverEvent::ID_t DynamicID_t;
  typedef typename NewEngine<PatchEngine_t, Domain_t>::Type_t PatchView_t;
  enum { brick = false };
  enum { dimensions = Dim };
  enum { hasDataObject = false };
  enum { dynamic = PatchEngine_t::dynamic };
  enum { zeroBased = false };
  enum { multiPatch = true };
  Engine();
  explicit Engine(const Layout_t &layout);
  Engine(const Engine_t &model);
  ~Engine();
  Engine_t &operator=(const Engine_t &model);
  Element_t read(const Loc<Dim> &) const;
  ElementRef_t operator()(const Loc<Dim> &) const;
  Element_t read(int) const;
  Element_t read(int, int) const;
  Element_t read(int, int, int) const;
  Element_t read(int, int, int, int) const;
  Element_t read(int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int, int) const;
  ElementRef_t operator()(int) const;
  ElementRef_t operator()(int, int) const;
  ElementRef_t operator()(int, int, int) const;
  ElementRef_t operator()(int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int, int) const;
  inline PatchEngine_t &globalPatch(const INode<Dim> &inode) const
  {
    int gid = inode.globalID(layout_m.ID());
    PatchEngine_t &pengine = data()[gid];
    ;
    return pengine;
  }
  template<class Domain>
  inline PatchEngine_t &globalPatch(const Node<Domain> &node) const
  {
    int gid = node.globalID();
    PatchEngine_t &pengine = data()[gid];
    ;
    return pengine;
  }
  inline PatchEngine_t &globalPatch(PatchID_t gpatchID) const
  {
    return data()[gpatchID];
  }
  inline PatchEngine_t &localPatch(PatchID_t lpatchID) const
  {
    int gID = (layout_m.nodeListLocal()[lpatchID])->globalID();
    return data()[gID];
  }
  inline bool patchEmpty(PatchID_t patch) const
  {
    return data()[patch].domain().empty();
  }
  inline const Layout_t &layout() const
  {
    return layout_m;
  }
  inline Layout_t &layout()
  {
    return layout_m;
  }
  inline const Domain_t &domain() const
  {
    return layout().domain();
  }
  inline const Domain_t &innerDomain() const
  {
    return layout().innerDomain();
  }
  inline int first(int d) const
  {
    return layout().first(d);
  }
  inline bool initialized() const
  {
    return layout().initialized();
  }
  inline const PatchContainer_t &data() const
  {
    return data_m;
  }
  Engine_t &makeOwnCopy();
  inline void fillGuards(const GuardLayers<Dim>& g) const
  {
    fillGuardsHandler(g, WrappedInt<Layout_t::supportsGuards>());
  }
  inline void fillGuards() const
  {
    fillGuards(layout().internalGuards());
  }
  inline void fillGuardsHandler(const GuardLayers<Dim>&, const WrappedInt<false>&) const { };
  void fillGuardsHandler(const GuardLayers<Dim>&, const WrappedInt<true>&) const ;
  void setGuards(const T &val) const;
  void accumulateFromGuards() const;
  inline int dirty() const { return *pDirty_m; }
  inline void setDirty() const
  {
    *pDirty_m = (1<<(Dim*2))-1;
  }
  inline void clearDirty(int face = -1) const
  {
    if (face == -1)
      *pDirty_m = 0;
    else {
      ;
      *pDirty_m &= ~(1<<face);
    }
  }
  inline bool isDirty(int face = -1) const
  {
    if (face == -1)
      return *pDirty_m != 0;
    else {
      ;
      return *pDirty_m & (1<<face);
    }
  }
  virtual void notify(Observable_t &observed, const ObserverEvent &event);
  void dynamicHandler(Observable_t &, const ObserverEvent &,
                      const WrappedInt<false> &);
  void dynamicHandler(Observable_t &, const ObserverEvent &,
                      const WrappedInt<true> &);
  inline void create(CreateSize_t num, PatchID_t localPatchID = (-1))
    {
      layout().create(num, localPatchID);
    }
  template<class Dom, class DeleteMethod>
  inline void destroy(const Dom &killlist, const DeleteMethod &method)
  {
    layout().destroy(killlist, method);
  }
  template<class Dom>
  inline void destroy(const Dom &killlist)
  {
    layout().destroy(killlist, BackFill());
  }
  template<class Dom, class DeleteMethod>
  inline void destroy(const Dom &killlist, PatchID_t frompatch,
        const DeleteMethod &method)
    {
      layout().destroy(killlist, frompatch, method);
    }
  template<class Dom>
  inline void copy(const Dom &domain, PatchID_t topatch = (-1))
    {
      layout().copy(domain, topatch);
    }
  template<class Dom>
  inline void copy(const Dom &killlist,
                   PatchID_t frompatch, PatchID_t topatch)
    {
      layout().copy(killlist, frompatch, topatch);
    }
  inline void copy(const IndirectionList< IndirectionList<int> > &domlists,
     const IndirectionList< int > &fromlist,
     PatchID_t topatch,
     bool docreate)
    {
      layout().copy(domlists, fromlist, topatch, docreate);
    }
  void sync()
    {
      layout().sync();
    }
private:
  void performCreate(CreateSize_t num, PatchID_t patch,
       DynamicID_t did);
  template<class Dom, class DeleteMethod>
  void performDestroy(const Dom &killlist, PatchID_t patch,
        const DeleteMethod &method,
        DynamicID_t did);
  template<class Dom>
  void performCopy(const Dom &domain, PatchID_t frompatch, PatchID_t topatch,
     DynamicID_t did);
  void performPatchCopy(const IndirectionList< IndirectionList<int> > &dlists,
   const IndirectionList< int > &fromlist,
   PatchID_t topatch,
   bool docreate,
   DynamicID_t did);
  template <class Node, class Counter>
  class PatchAllocator : public Pooma::Runnable_t
  {
  public:
    PatchAllocator(PatchEngine_t &dest, const Node &node, Counter &c)
      : Pooma::Runnable_t(node.affinity()), dest_m(dest),
 node_m(node), counter_m(c)
    {
    }
    ~PatchAllocator() { }
    void run()
    {
      dest_m = PatchEngine_t(node_m);
      ++counter_m;
    }
  private:
    PatchEngine_t &dest_m;
    const Node &node_m;
    Counter &counter_m;
  };
  Layout_t layout_m;
  PatchContainer_t data_m;
  int *pDirty_m;
};
template <int D1, int D2>
struct SubDomainTraits
{
  typedef SliceRange<D1,D2> LocalToBase_t;
  typedef Range<D1> TotalDomain_t;
  inline static
  TotalDomain_t totalDomain(const LocalToBase_t &d)
  {
    return d.totalDomain();
  }
};
template <int D1>
struct SubDomainTraits<D1, D1>
{
  typedef Range<D1> LocalToBase_t;
  typedef Range<D1> TotalDomain_t;
  inline static
  TotalDomain_t totalDomain(const LocalToBase_t &dom)
  {
    return dom;
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
class Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag,Dim2> >
{
public:
  typedef MultiPatchView<LayoutTag, PatchTag, Dim2> Tag_t;
  typedef Engine<Dim,T,Tag_t> This_t;
  typedef Engine<Dim,T,Tag_t> Engine_t;
  typedef Engine<Dim2,T,MultiPatch<LayoutTag,PatchTag> > ViewedEngine_t;
  typedef Interval<Dim> Domain_t;
  typedef T Element_t;
  typedef PatchTag PatchTag_t;
  typedef Engine<Dim2, T, PatchTag_t> PatchEngine_t;
  typedef typename PatchEngine_t::ElementRef_t ElementRef_t;
  typedef RefCountedBlockPtr<PatchEngine_t> PatchContainer_t;
  typedef MultiPatchLayoutTraits<LayoutTag,Dim2> ViewedLayoutTraits_t;
  typedef typename ViewedLayoutTraits_t::Layout_t ViewedLayout_t;
  typedef typename ViewedLayoutTraits_t::template View<Dim>
                                                    NestedViewTraits_t;
  typedef typename NestedViewTraits_t::Layout_t Layout_t;
  enum { dimensions = Dim };
  enum { hasDataObject = false };
  enum { dynamic = PatchEngine_t::dynamic };
  enum { zeroBased = true };
  enum { multiPatch = true };
  Engine() { }
  template<class DT>
  Engine(const ViewedEngine_t &engine, const Domain<Dim2, DT> &domain)
  : layout_m(engine.layout(), domain),
    baseEngine_m(engine)
  { }
  template<class DT>
  Engine(const ViewedEngine_t &engine, const SliceDomain<DT> &domain)
  : layout_m(engine.layout(), domain),
    baseEngine_m(engine)
  { }
  template<class DT>
  Engine(const This_t &engine, const Domain<Dim, DT> &domain)
  : layout_m(engine.layout(), domain),
    baseEngine_m(engine.baseEngine_m)
  { }
  template<int OrigDim, class DT>
  Engine(const Engine<OrigDim, T, Tag_t> &engine,
    const SliceDomain<DT> &domain)
  : layout_m(engine.layout(), domain),
    baseEngine_m(engine.baseEngine())
  { }
  Engine(const Engine_t &model);
  ~Engine();
  Engine_t &operator=(const Engine_t &model);
  Element_t read(const Loc<Dim> &) const;
  ElementRef_t operator()(const Loc<Dim> &) const;
  Element_t read(int) const;
  Element_t read(int, int) const;
  Element_t read(int, int, int) const;
  Element_t read(int, int, int, int) const;
  Element_t read(int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int, int) const;
  ElementRef_t operator()(int) const;
  ElementRef_t operator()(int, int) const;
  ElementRef_t operator()(int, int, int) const;
  ElementRef_t operator()(int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int, int) const;
  typename NewEngine<This_t, INode<Dim> >::Type_t
  globalPatch(const INode<Dim> &inode) const
  {
    typedef SubDomainTraits<Dim2, Dim> SubDomainTraits_t;
    typedef typename SubDomainTraits_t::LocalToBase_t LocalToBase_t;
    int gid = inode.globalID(layout_m.ID());
    PatchEngine_t &pengine = data()[gid];
    LocalToBase_t bdom = Pooma::NoInit();
    layout_m.localToBase(inode.domain(), bdom);
    ;
    typedef typename NewEngine<This_t,INode<Dim> >::Type_t Ret_t;
    return Ret_t(pengine, bdom);
  }
  template<class Domain>
  typename NewEngine<This_t, Node<Domain> >::Type_t
  globalPatch(const Node<Domain> &node) const
  {
    typedef SubDomainTraits<Dim2, Dim> SubDomainTraits_t;
    typedef typename SubDomainTraits_t::LocalToBase_t LocalToBase_t;
    LocalToBase_t bdom = Pooma::NoInit();
    layout_m.localToBase(node.domain(), bdom);
    int gid = node.globalID();
    PatchEngine_t &pengine = data()[gid];
    ;
    typedef typename NewEngine<This_t,Node<Domain> >::Type_t Ret_t;
    return Ret_t(pengine, bdom);
  }
  inline Layout_t &layout()
  {
    return layout_m;
  }
  inline const Layout_t &layout() const
  {
    return layout_m;
  }
  inline const Domain_t &domain() const
  {
    return layout().domain();
  }
  inline const Domain_t &innerDomain() const
  {
    return layout().innerDomain();
  }
  inline int first(int) const
  {
    return 0;
  }
  inline bool initialized() const
  {
    return layout().initialized();
  }
  inline void fillGuards() const
  {
    baseEngine_m.fillGuards();
  }
  inline void fillGuards(const GuardLayers<Dim2>& g) const
  {
    baseEngine_m.fillGuards(g);
  }
  inline void setGuards(const T &val) const
  {
    baseEngine_m.setGuards(val);
  }
  inline void accumulateFromGuards() const
  {
    baseEngine_m.accumulateFromGuards();
  }
  inline void setDirty() const
  {
    baseEngine_m.setDirty();
  }
  inline void clearDirty(int face=-1) const
  {
    baseEngine_m.clearDirty(face);
  }
  inline bool isDirty(int face=-1) const
  {
    return baseEngine_m.isDirty(face);
  }
  inline const PatchContainer_t &data() const
  {
    return baseEngine_m.data();
  }
  template<int D1, class T1>
  inline bool sameController(const Engine<D1, T1, Tag_t> &e) const
  {
    return block() == e.block();
  }
  PatchContainer_t block() const
  {
    return baseEngine_m.data();
  }
  inline const ViewedEngine_t &baseEngine() const
  {
    return baseEngine_m;
  }
private:
  Layout_t layout_m;
  ViewedEngine_t baseEngine_m;
};
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(const Loc<Dim> &loc) const
{
  return data()[layout_m.globalID(loc)].read(loc);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0) const
{
  return data()[layout_m.globalID(i0)].read(i0);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1) const
{
  return data()[layout_m.globalID(i0, i1)].read(i0, i1);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1, int i2)
const
{
  return data()[layout_m.globalID(i0, i1, i2)].read(i0, i1, i2);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1, int i2,
  int i3) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3)].read(i0, i1, i2, i3);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1, int i2,
  int i3, int i4) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4)].read
    (i0, i1, i2, i3, i4);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1, int i2,
  int i3, int i4, int i5) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5)].read
    (i0, i1, i2, i3, i4, i5);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::Element_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::read(int i0, int i1, int i2,
  int i3, int i4, int i5, int i6) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5, i6)].read
    (i0, i1, i2, i3, i4, i5, i6);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(const Loc<Dim> &loc)
  const
{
  return data()[layout_m.globalID(loc)](loc);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0) const
{
  return data()[layout_m.globalID(i0)](i0);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0,
  int i1) const
{
  return data()[layout_m.globalID(i0, i1)](i0, i1);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0, int i1,
  int i2) const
{
  return data()[layout_m.globalID(i0, i1, i2)](i0, i1, i2);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0, int i1,
  int i2, int i3) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3)](i0, i1, i2, i3);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0, int i1,
  int i2, int i3, int i4) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4)]
    (i0, i1, i2, i3, i4);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0, int i1,
  int i2, int i3, int i4, int i5) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5)]
    (i0, i1, i2, i3, i4, i5);
}
template<int Dim, class T, class LayoutTag, class PatchTag>
inline typename Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::ElementRef_t
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::operator()(int i0, int i1,
  int i2, int i3, int i4, int i5, int i6) const
{
  return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5, i6)]
    (i0, i1, i2, i3, i4, i5, i6);
}
template <int Dim, class T, class LayoutTag, class PatchTag>
inline void Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
dynamicHandler(Observable_t &, const ObserverEvent &,
               const WrappedInt<false> &)
{
  if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("This patch engine does not support dynamic events!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.h", 1460);
}
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
Engine(const Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >
  &modelEngine)
: layout_m(modelEngine.layout_m),
  baseEngine_m(modelEngine.baseEngine_m)
{ }
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> > &
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator=(const Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >
  &rhs)
{
  if (&rhs == this) return *this;
  layout_m = rhs.layout_m;
  baseEngine_m = rhs.baseEngine_m;
  return *this;
}
template <int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
Engine<Dim, T, MultiPatchView<LayoutTag,PatchTag,Dim2> >::
~Engine()
{ }
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(const Loc<Dim> &loc) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(loc, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::read(int i0) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1, int i2) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1, int i2, int i3) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1, int i2, int i3, int i4) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1, int i2, int i3, int i4, int i5) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline
typename Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::Element_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
read(int i0, int i1, int i2, int i3, int i4, int i5, int i6) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, i6, gloc);
  return data()[o].read(gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(const Loc<Dim> &loc) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(loc, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1, int i2) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1, int i2, int i3) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1, int i2, int i3, int i4) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1, int i2, int i3, int i4, int i5) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, gloc);
  return data()[o](gloc);
}
template<int Dim, class T, class LayoutTag, class PatchTag, int Dim2>
inline typename
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::ElementRef_t
Engine<Dim, T, MultiPatchView<LayoutTag, PatchTag, Dim2> >::
operator()(int i0, int i1, int i2, int i3, int i4, int i5, int i6) const
{
  Loc<Dim2> gloc = Pooma::NoInit();
  int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, i6, gloc);
  return data()[o](gloc);
}
template <int Dim, class T, class LayoutTag, class PatchTag, class Intersect>
struct LeafFunctor<Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  ExpressionApply<IntersectorTag<Intersect> > >
{
  typedef int Type_t;
  static Type_t
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &engine,
 const ExpressionApply<IntersectorTag<Intersect> > &tag)
  {
    GuardLayers<Dim> usedGuards;
    bool useGuards =
      tag.tag().intersector_m.intersect(engine,
      engine.layout().internalGuards(), usedGuards);
    if (useGuards)
      engine.fillGuards(usedGuards);
    return 0;
  }
};
template <int Dim, class T, class LT, class PatchTag, int BD,
  class Intersect>
struct LeafFunctor<Engine<Dim, T, MultiPatchView<LT,PatchTag,BD> >,
  ExpressionApply<IntersectorTag<Intersect> > >
{
  typedef int Type_t;
  static Type_t
  apply(const Engine<Dim,T,MultiPatchView<LT,PatchTag,BD> > &engine,
 const ExpressionApply<IntersectorTag<Intersect> > &tag)
  {
    typedef typename MultiPatchLayoutTraits<LT,Dim>::Layout_t Layout_t;
    return applyHandler(engine, tag, WrappedInt<Layout_t::supportsGuards>());
  }
  inline static Type_t
  applyHandler(const Engine<Dim,T,MultiPatchView<LT,PatchTag,BD> > &engine,
        const ExpressionApply<IntersectorTag<Intersect> > &tag,
        const WrappedInt<true> &)
  {
    GuardLayers<BD> usedGuards;
    bool useGuards =
      tag.tag().intersector_m.
      intersect(engine,
  engine.layout().baseLayout().internalGuards(), usedGuards);
    if (useGuards)
      engine.fillGuards(usedGuards);
    return 0;
  }
  inline static Type_t
  applyHandler(const Engine<Dim,T,MultiPatchView<LT,PatchTag,BD> > &engine,
        const ExpressionApply<IntersectorTag<Intersect> > &tag,
        const WrappedInt<false> &)
  {
    tag.tag().intersector_m.intersect(engine);
    return 0;
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct EngineFunctor<Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  EnginePatch >
{
  typedef Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> > Subject_t;
  typedef Engine<Dim,T,PatchTag> Type_t;
  static inline
  Type_t apply(const Subject_t &engine, const EnginePatch &tag)
  {
    return engine.localPatch(tag.patch_m);
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct EngineFunctor<Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  EngineNumPatches >
{
  typedef int Type_t;
  static inline
  Type_t apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &engine,
        const EngineNumPatches &)
  {
    return engine.layout().sizeLocal();
  }
};
template <int Dim, class T, class LayoutTag, class PatchTag>
struct NotifyEngineWrite<Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> > >
{
  inline static void
  notify(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &engine)
  {
    engine.setDirty();
  }
};
template <int Dim, class T, class LT, class PatchTag, int BD>
struct NotifyEngineWrite<Engine<Dim, T, MultiPatchView<LT,PatchTag,BD> > >
{
  inline static void
  notify(const Engine<Dim,T,MultiPatchView<LT,PatchTag,BD> > &engine)
  {
    engine.setDirty();
  }
};
template<class PatchEngine>
inline
PatchEngine &localPatchEngine(PatchEngine &e)
{
  return e;
}
class TagGenerator
{
public:
  TagGenerator()
    : send_m(1), receive_m(1)
  {
    send_m[0] = 0;
    receive_m[0] = 0;
  }
  TagGenerator(int n)
    : send_m(n), receive_m(n)
  {
    int i;
    for (i = 0; i < n; ++i)
      {
        send_m[i] = 0;
        receive_m[i] = 0;
      }
  }
  int send(int otherContext)
  {
    ;
    int tag = send_m[otherContext];
    send_m[otherContext]++;
    return tag;
  }
  int receive(int otherContext)
  {
    ;
    int tag = receive_m[otherContext];
    receive_m[otherContext]++;
    return tag;
  }
private:
  std::vector<int> send_m;
  std::vector<int> receive_m;
};
namespace Pooma {
extern int expectedMessages_g;
void initializeCheetahHelpers(int contexts);
void finalizeCheetahHelpers();
int sendTag(int context);
int receiveTag(int context);
inline void addIncomingMessage()
{
  expectedMessages_g++;
}
inline void gotIncomingMessage()
{
  expectedMessages_g--;
}
inline bool incomingMessages()
{
  return (expectedMessages_g > 0);
}
}
class Full;
template<int D, class T, class E> class Vector;
template<int D, class T, class E> class VectorEngine;
template<class V, int I>
struct VectorElem
{
  typedef V Element_t;
  typedef const V& ConstElementRef_t;
  typedef V& ElementRef_t;
  static const V& get(const V& x) { return x; }
  static V& get( V& x) { return x; }
};
template<int D, class T, class E, int I>
struct VectorEngineElem
{
  typedef VectorEngine<D,T,E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::ConstElementRef_t ConstElementRef_t;
  typedef typename V::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x(I); }
  static ElementRef_t get( V& x) { return x(I); }
};
template<int D, class T, class E, int I>
struct VectorElem< Vector<D,T,E> , I >
{
  typedef Vector<D,T,E> V;
  typedef VectorEngineElem<D,T,E,I> VE;
  typedef typename VE::Element_t Element_t;
  typedef typename VE::ConstElementRef_t ConstElementRef_t;
  typedef typename VE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return VE::get(x.engine()); }
  static ElementRef_t get(V& x) { return VE::get(x.engine()); }
};
template<class V1, class V2, class Op, int B, int L>
struct VectorAssign
{
  static void apply(V1& v1, const V2& v2, Op op)
    {
      PoomaCTAssert<(L>1)>::test();
      VectorAssign<V1,V2,Op,B,L/2>::apply(v1,v2,op);
      VectorAssign<V1,V2,Op,B+L/2,L-L/2>::apply(v1,v2,op);
    }
};
template<class V1, class V2, class Op, int B>
struct VectorAssign<V1,V2,Op,B,0>
{
  static void apply(V1&, const V2&, Op) {}
};
template<class V1, class V2, class Op, int B>
struct VectorAssign<V1,V2,Op,B,1>
{
  static void apply(V1& v1, const V2& v2, Op op)
    {
      op(VectorElem<V1,B>::get(v1),VectorElem<V2,B>::get(v2));
    }
};
template<class V1, class V2, class Op, int B>
struct VectorAssign<V1,V2,Op,B,2>
{
  static void apply(V1& v1, const V2& v2, Op op)
    {
      op(VectorElem<V1,B >::get(v1), VectorElem<V2,B >::get(v2));
      op(VectorElem<V1,B+1>::get(v1), VectorElem<V2,B+1>::get(v2));
    }
};
template<class V1, class V2, class Op, int B>
struct VectorAssign<V1,V2,Op,B,3>
{
  static void apply(V1& v1, const V2& v2, Op op)
    {
      op(VectorElem<V1,B >::get(v1), VectorElem<V2,B >::get(v2));
      op(VectorElem<V1,B+1>::get(v1), VectorElem<V2,B+1>::get(v2));
      op(VectorElem<V1,B+2>::get(v1), VectorElem<V2,B+2>::get(v2));
    }
};
template<class V1, class V2, class Op>
class BinaryVectorOp;
template<int D, class T, class V1, class V2, class Op>
class VectorEngine<D,T, BinaryVectorOp<V1,V2,Op> >
{
public:
  enum { dimensions=1 };
  enum { d1=D };
  typedef T Element_t;
  typedef BinaryVectorOp<V1,V2,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef VectorEngine<D,T, BinaryVectorOp<V1,V2,Op> > This_t;
  VectorEngine(const V1& v1, const V2& v2)
    : v1_m(v1), v2_m(v2) {}
  Element_t operator()(int i) const
  {
    return Op()(v1_m(i), v2_m(i));
  }
  template<int DD,class TT, class EE, int I>
    friend struct VectorEngineElem;
private:
  const V1& v1_m;
  const V2& v2_m;
};
template<int D, class T, class V1, class V2, class Op, int I>
struct VectorEngineElem<D,T,BinaryVectorOp<V1,V2,Op>, I >
{
  typedef VectorEngine<D,T,BinaryVectorOp<V1,V2,Op> > V;
  typedef typename VectorElem<V1,I>::Element_t T1;
  typedef typename VectorElem<V2,I>::Element_t T2;
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(
        VectorElem<V1,I>::get(x.v1_m),
        VectorElem<V2,I>::get(x.v2_m));
    }
};
template<class V1, class Op>
class UnaryVectorOp;
template<int D, class T, class V1, class Op>
class VectorEngine<D,T,UnaryVectorOp<V1,Op> >
{
public:
  enum { dimensions=1 };
  enum { d1 = D };
  typedef T Element_t;
  typedef UnaryVectorOp<V1,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef VectorEngine<D,T, UnaryVectorOp<V1,Op> > This_t;
  explicit VectorEngine(const V1& v1)
    : v1_m(v1) {}
  Element_t operator()(int i) const
  {
    return Op()(v1_m(i));
  }
  template<int DD,class TT, class EE, int I>
    friend struct VectorEngineElem;
private:
  const V1& v1_m;
};
template<int D, class T, class V1, class Op, int I>
struct VectorEngineElem<D,T,UnaryVectorOp<V1,Op>, I>
{
  typedef VectorEngine<D,T,UnaryVectorOp<V1,Op> > V;
  typedef typename VectorElem<V1,I>::Element_t T1;
  typedef typename UnaryReturn<T1,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(VectorElem<V1,I>::get(x.v1_m));
    }
};
template<int D, class T, class E> class Vector;
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnArcCos > { typedef Vector< D, typename UnaryReturn<T,FnArcCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnArcCos >::Type_t acos( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnArcCos>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnArcCos> > Expr_t; typedef typename UnaryReturn<V1,FnArcCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnArcSin > { typedef Vector< D, typename UnaryReturn<T,FnArcSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnArcSin >::Type_t asin( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnArcSin>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnArcSin> > Expr_t; typedef typename UnaryReturn<V1,FnArcSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnArcTan > { typedef Vector< D, typename UnaryReturn<T,FnArcTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnArcTan >::Type_t atan( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnArcTan>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnArcTan> > Expr_t; typedef typename UnaryReturn<V1,FnArcTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnCeil > { typedef Vector< D, typename UnaryReturn<T,FnCeil>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnCeil >::Type_t ceil( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnCeil>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnCeil> > Expr_t; typedef typename UnaryReturn<V1,FnCeil>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnCos > { typedef Vector< D, typename UnaryReturn<T,FnCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnCos >::Type_t cos( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnCos>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnCos> > Expr_t; typedef typename UnaryReturn<V1,FnCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnHypCos > { typedef Vector< D, typename UnaryReturn<T,FnHypCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnHypCos >::Type_t cosh( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnHypCos>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnHypCos> > Expr_t; typedef typename UnaryReturn<V1,FnHypCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnExp > { typedef Vector< D, typename UnaryReturn<T,FnExp>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnExp >::Type_t exp( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnExp>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnExp> > Expr_t; typedef typename UnaryReturn<V1,FnExp>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnFabs > { typedef Vector< D, typename UnaryReturn<T,FnFabs>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnFabs >::Type_t fabs( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnFabs>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnFabs> > Expr_t; typedef typename UnaryReturn<V1,FnFabs>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnFloor > { typedef Vector< D, typename UnaryReturn<T,FnFloor>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnFloor >::Type_t floor( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnFloor>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnFloor> > Expr_t; typedef typename UnaryReturn<V1,FnFloor>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnLog > { typedef Vector< D, typename UnaryReturn<T,FnLog>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnLog >::Type_t log( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnLog>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnLog> > Expr_t; typedef typename UnaryReturn<V1,FnLog>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnLog10 > { typedef Vector< D, typename UnaryReturn<T,FnLog10>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnLog10 >::Type_t log10( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnLog10>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnLog10> > Expr_t; typedef typename UnaryReturn<V1,FnLog10>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnSin > { typedef Vector< D, typename UnaryReturn<T,FnSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnSin >::Type_t sin( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnSin>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnSin> > Expr_t; typedef typename UnaryReturn<V1,FnSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnHypSin > { typedef Vector< D, typename UnaryReturn<T,FnHypSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnHypSin >::Type_t sinh( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnHypSin>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnHypSin> > Expr_t; typedef typename UnaryReturn<V1,FnHypSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnSqrt > { typedef Vector< D, typename UnaryReturn<T,FnSqrt>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnSqrt >::Type_t sqrt( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnSqrt>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnSqrt> > Expr_t; typedef typename UnaryReturn<V1,FnSqrt>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnTan > { typedef Vector< D, typename UnaryReturn<T,FnTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnTan >::Type_t tan( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnTan>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnTan> > Expr_t; typedef typename UnaryReturn<V1,FnTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, FnHypTan > { typedef Vector< D, typename UnaryReturn<T,FnHypTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, FnHypTan >::Type_t tanh( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,FnHypTan>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,FnHypTan> > Expr_t; typedef typename UnaryReturn<V1,FnHypTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, OpUnaryMinus > { typedef Vector< D, typename UnaryReturn<T,OpUnaryMinus>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, OpUnaryMinus >::Type_t operator-( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,OpUnaryMinus>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,OpUnaryMinus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryMinus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, OpUnaryPlus > { typedef Vector< D, typename UnaryReturn<T,OpUnaryPlus>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, OpUnaryPlus >::Type_t operator+( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,OpUnaryPlus>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,OpUnaryPlus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryPlus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Vector<D,T,E>, OpBitwiseNot > { typedef Vector< D, typename UnaryReturn<T,OpBitwiseNot>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Vector<D,T,E>, OpBitwiseNot >::Type_t operator~( const Vector<D,T,E>& v1 ) { typedef Vector<D,T,E> V1; typedef typename UnaryReturn<T,OpBitwiseNot>::Type_t T3; typedef Vector< D, T3, UnaryVectorOp<V1,OpBitwiseNot> > Expr_t; typedef typename UnaryReturn<V1,OpBitwiseNot>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpAdd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpAdd >::Type_t operator+( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpAdd> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpAdd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpAdd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpAdd >::Type_t operator+( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpAdd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpAdd >::Type_t operator+( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpAdd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpSubtract > { typedef Vector< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpSubtract >::Type_t operator-( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpSubtract> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpSubtract > { typedef Vector< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpSubtract > { typedef Vector< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpSubtract >::Type_t operator-( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpSubtract> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpSubtract >::Type_t operator-( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpSubtract> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpMultiply > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpMultiply >::Type_t operator*( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpMultiply> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpMultiply > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpMultiply > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpMultiply >::Type_t operator*( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpMultiply> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpMultiply >::Type_t operator*( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpMultiply> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpDivide > { typedef Vector< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpDivide >::Type_t operator/( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpDivide> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpDivide > { typedef Vector< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpDivide > { typedef Vector< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpDivide >::Type_t operator/( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpDivide> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpDivide >::Type_t operator/( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpDivide> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpMod > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpMod >::Type_t operator%( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpMod> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpMod > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpMod > { typedef Vector< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpMod >::Type_t operator%( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpMod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpMod >::Type_t operator%( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpMod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpBitwiseAnd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpBitwiseAnd >::Type_t operator&( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseAnd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseAnd > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseAnd >::Type_t operator&( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseAnd >::Type_t operator&( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpBitwiseOr > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpBitwiseOr >::Type_t operator|( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseOr > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseOr > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseOr >::Type_t operator|( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseOr >::Type_t operator|( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, OpBitwiseXor > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, OpBitwiseXor >::Type_t operator^( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseXor > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseXor > { typedef Vector< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, OpBitwiseXor >::Type_t operator^( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, OpBitwiseXor >::Type_t operator^( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, FnLdexp > { typedef Vector< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, FnLdexp >::Type_t ldexp( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,FnLdexp> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, FnLdexp > { typedef Vector< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, FnLdexp > { typedef Vector< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, FnLdexp >::Type_t ldexp( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,FnLdexp> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, FnLdexp >::Type_t ldexp( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,FnLdexp> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, FnPow > { typedef Vector< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, FnPow >::Type_t pow( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,FnPow> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, FnPow > { typedef Vector< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, FnPow > { typedef Vector< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, FnPow >::Type_t pow( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,FnPow> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, FnPow >::Type_t pow( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,FnPow> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, FnFmod > { typedef Vector< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, FnFmod >::Type_t fmod( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,FnFmod> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, FnFmod > { typedef Vector< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, FnFmod > { typedef Vector< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, FnFmod >::Type_t fmod( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,FnFmod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, FnFmod >::Type_t fmod( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,FnFmod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, Vector<D,T2,E>, FnArcTan2 > { typedef Vector< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Vector<D,T1,E1>, Vector<D,T2,E2>, FnArcTan2 >::Type_t atan2( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { typedef Vector<D,T1,E1> V1; typedef Vector<D,T2,E2> V2; typedef typename BinaryReturn<V1,V2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,V2,FnArcTan2> > Expr_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Vector<D,T1,E>, T2, FnArcTan2 > { typedef Vector< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Vector<D,T2,E>, FnArcTan2 > { typedef Vector< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Vector<D,T1,E>, T2, FnArcTan2 >::Type_t atan2( const Vector<D,T1,E>& v1, const T2& x ) { typedef Vector<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<V1,T2,FnArcTan2> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Vector<D,T2,E>, FnArcTan2 >::Type_t atan2( const T1& x, const Vector<D,T2,E>& v2 ) { typedef Vector<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Vector< D, T3, BinaryVectorOp<T1,V2,FnArcTan2> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template<class V1, class V2, int B, int L>
struct VectorDotVector
{
  typedef typename VectorDotVector<V1,V2,B,L/2>::Type_t Left_t;
  typedef typename VectorDotVector<V1,V2,B+L/2,L-L/2>::Type_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpAdd>::Type_t Type_t;
  static Type_t get(const V1& x, const V2& y)
    {
      return
        VectorDotVector<V1,V2,B,L/2>::get(x,y) +
        VectorDotVector<V1,V2,B+L/2,L-L/2>::get(x,y);
    }
};
template<class V1, class V2, int B>
struct VectorDotVector<V1,V2,B,1>
{
  typedef typename VectorElem<V1,B>::Element_t Left_t;
  typedef typename VectorElem<V2,B>::Element_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpMultiply>::Type_t Type_t;
  static Type_t get(const V1& x, const V2& y)
    {
      return VectorElem<V1,B>::get(x) * VectorElem<V2,B>::get(y);
    }
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Vector<D,T2,E2> , FnDot >
{
  typedef Vector<D,T1,E1> V1;
  typedef Vector<D,T2,E2> V2;
  typedef typename VectorDotVector<V1,V2,0,D>::Type_t T0;
  typedef T0 Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< Vector<D,T1,E1>,Vector<D,T2,E2> , FnDot >::Type_t
dot( const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 )
{
  return VectorDotVector<Vector<D,T1,E1>,Vector<D,T2,E2>,0,D>::get(v1,v2);
}
template<int D, class T, class E>
struct UnaryReturn< Vector<D,T,E> , FnNorm >
{
  typedef T Type_t;
};
template<int D, class T, class E>
inline T
norm(const Vector<D,T,E>& x)
{
  return sqrt(dot(x,x));
}
template<int D, class T, class E>
inline T
norm2(const Vector<D,T,E>& x)
{
  return dot(x,x);
}
template<class V1, class V2, int B, int L>
struct VectorEqualsVector
{
  typedef typename VectorEqualsVector<V1,V2,B,L/2>::Type_t Left_t;
  typedef typename VectorEqualsVector<V1,V2,B+L/2,L-L/2>::Type_t Right_t;
  typedef bool Type_t;
  static Type_t get(const V1& x, const V2& y)
    {
      return
        VectorEqualsVector<V1,V2,B,L/2>::get(x,y) &&
        VectorEqualsVector<V1,V2,B+L/2,L-L/2>::get(x,y);
    }
};
template<class V1, class V2, int B>
struct VectorEqualsVector<V1,V2,B,1>
{
  typedef typename VectorElem<V1,B>::Element_t Left_t;
  typedef typename VectorElem<V2,B>::Element_t Right_t;
  typedef bool Type_t;
  static Type_t get(const V1& x, const V2& y)
    {
      return VectorElem<V1,B>::get(x) == VectorElem<V2,B>::get(y);
    }
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Vector<D,T2,E2> , OpEQ >
{
  typedef bool Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Vector<D,T2,E2> , OpNE >
{
  typedef bool Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< Vector<D,T1,E1>,Vector<D,T2,E2> , OpEQ >::Type_t
operator==(const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2)
{
  return VectorEqualsVector<Vector<D,T1,E1>,Vector<D,T2,E2>,0,D>::get(v1,v2);
}
template<int D, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< Vector<D,T1,E1>,Vector<D,T2,E2> , OpNE >::Type_t
operator!=(const Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2)
{
  return !(v1 == v2);
}
template<int D, class T, class E>
inline typename
BinaryReturn<Vector<D, T, E>, Vector<D, T, E> , OpNE>::Type_t
operator!=(const Vector<D, T, E>& v1, const Vector<D, T, E>& v2)
{
  return !(v1 == v2);
}
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator+=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpAddAssign,0,D>::apply(v1,v2,OpAddAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator+=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpAddAssign,0,D>::apply(v1,v2,OpAddAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator-=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpSubtractAssign,0,D>::apply(v1,v2,OpSubtractAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator-=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpSubtractAssign,0,D>::apply(v1,v2,OpSubtractAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator*=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpMultiplyAssign,0,D>::apply(v1,v2,OpMultiplyAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator*=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpMultiplyAssign,0,D>::apply(v1,v2,OpMultiplyAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator/=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpDivideAssign,0,D>::apply(v1,v2,OpDivideAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator/=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpDivideAssign,0,D>::apply(v1,v2,OpDivideAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator%=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpModAssign,0,D>::apply(v1,v2,OpModAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator%=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpModAssign,0,D>::apply(v1,v2,OpModAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator|=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpBitwiseOrAssign,0,D>::apply(v1,v2,OpBitwiseOrAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator|=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpBitwiseOrAssign,0,D>::apply(v1,v2,OpBitwiseOrAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator&=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpBitwiseAndAssign,0,D>::apply(v1,v2,OpBitwiseAndAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator&=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpBitwiseAndAssign,0,D>::apply(v1,v2,OpBitwiseAndAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator^=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpBitwiseXorAssign,0,D>::apply(v1,v2,OpBitwiseXorAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator^=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpBitwiseXorAssign,0,D>::apply(v1,v2,OpBitwiseXorAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator<<=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpLeftShiftAssign,0,D>::apply(v1,v2,OpLeftShiftAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator<<=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpLeftShiftAssign,0,D>::apply(v1,v2,OpLeftShiftAssign()); return v1; }
template <int D, class T1, class T2, class E1, class E2> inline Vector<D,T1,E1>& operator>>=( Vector<D,T1,E1>& v1, const Vector<D,T2,E2>& v2 ) { VectorAssign<Vector<D,T1,E1>,Vector<D,T2,E2>,OpRightShiftAssign,0,D>::apply(v1,v2,OpRightShiftAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Vector<D,T1,E1>& operator>>=( Vector<D,T1,E1>& v1, const T2& v2 ) { VectorAssign<Vector<D,T1,E1>,T2,OpRightShiftAssign,0,D>::apply(v1,v2,OpRightShiftAssign()); return v1; }
template<int D, class T, class E> class Vector;
template<int D, class T, class E> class VectorEngine;
template <class T>
void reverseBytes(T&);
template<int Dim, class T=double, class EngineTag=Full>
class Vector
{
public:
  enum { dimensions=1 };
  enum { d1 = Dim };
  typedef T Element_t;
  typedef EngineTag EngineTag_t;
  typedef VectorEngine<Dim,T,EngineTag> Engine_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef typename Engine_t::ConstElementRef_t ConstElementRef_t;
  typedef Vector<Dim,T,EngineTag> This_t;
  Vector() {}
  Vector(const This_t& x) : engine_m(x.engine_m) {}
  template<int D2, class T2, class EngineTag2>
  Vector(const Vector<D2, T2, EngineTag2>& x) : engine_m(x) {}
  template<class X>
  explicit Vector(const X& x) : engine_m(x) {}
  template<class X1, class X2>
  Vector(const X1& x, const X2& y)
    : engine_m(x,y) {}
  template<class X1, class X2, class X3>
  Vector(const X1& x, const X2& y, const X3& z)
    : engine_m(x,y,z) {}
  template<class X1, class X2, class X3, class X4>
  Vector(const X1& x, const X2& y, const X3& z, const X4& a)
    : engine_m(x,y,z,a) {}
  template<class X1, class X2, class X3, class X4, class X5>
  Vector(const X1& x, const X2& y, const X3& z, const X4& a,
  const X5& b)
    : engine_m(x,y,z,a,b) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  Vector(const X1& x, const X2& y, const X3& z, const X4& a,
  const X5& b, const X6& c)
    : engine_m(x,y,z,a,b,c) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6, class X7>
  Vector(const X1& x, const X2& y, const X3& z, const X4& a,
  const X5& b, const X6& c, const X7& d)
    : engine_m(x,y,z,a,b,c,d) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
      class X7, class X8, class X9, class X10>
  Vector(const X1& x, const X2& y, const X3& z, const X4& a,
  const X5& b, const X6& c, const X7& d, const X8& e,
  const X9& f, const X10& g)
    : engine_m(x,y,z,a,b,c,d,e,f,g) {}
  ~Vector() {}
  This_t& operator=(const This_t& x)
    {
      if ( this != &const_cast<This_t &>(x) )
        engine() = x.engine();
      return *this;
    }
  template<class V>
    This_t&
      operator=(const V& x)
        {
          engine() = x;
          return *this;
        }
  ConstElementRef_t operator()(int i) const
    {
      return engine()(i);
    }
  ElementRef_t operator()(int i)
    {
      return engine()(i);
    }
  const Engine_t& engine() const { return engine_m; }
  Engine_t& engine() { return engine_m; }
  template<class Out>
  void print(Out &out) const;
  inline void reverseBytes() { engine_m.reverseBytes(); }
private:
  Engine_t engine_m;
};
template<int Dim, class T, class EngineTag>
template<class Out>
void Vector<Dim, T, EngineTag>::print(Out &out) const
{
  std::ios::fmtflags incomingFormatFlags = out.flags();
  long width = out.width();
  long precision = out.precision();
  out.width(0);
  out << "(";
  out.flags(incomingFormatFlags);
  out.width(width);
  out.precision(precision);
  out << (*this)(0) ;
  for (int i = 1; i < Dim; i++) {
    out << ",";
    out.flags(incomingFormatFlags);
    out.width(width);
    out.precision(precision);
    out << (*this)(i);
  }
  out << ")";
}
template<int D, class T, class E>
std::ostream &operator<<(std::ostream &out, const Vector<D,T,E> &v)
{
  v.print(out);
  return out;
}
template <int D, class T, class E>
struct ElementProperties< Vector<D,T,E> >
  : public TrivialElementProperties< Vector<D,T,E> >
{ };
template<int D, class T>
class VectorEngine<D,T,Full>
{
public:
  enum { dimensions=1 };
  enum { d1 = D };
  typedef T Element_t;
  typedef Full EngineTag_t;
  typedef T& ElementRef_t;
  typedef const T& ConstElementRef_t;
  typedef VectorEngine<D,T,Full> This_t;
  VectorEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
    for (int i = 0; i < D; ++i)
      {
 ElementProperties<T>::construct(&x_m[i]);
      }
  }
  inline VectorEngine(const VectorEngine<D,T,Full>&);
  template<class X>
    inline explicit VectorEngine(const X& x)
      {
        VectorAssign< VectorEngine<D,T,Full> , X , OpAssign, 0, D >
          ::apply(*this,x,OpAssign());
      }
  template<class X1, class X2>
  inline VectorEngine(const X1& x, const X2& y)
  {
    PoomaCTAssert<(D == 2)>::test();
    x_m[0] = x;
    x_m[1] = y;
  }
  template<class X1, class X2, class X3>
  inline VectorEngine(const X1& x, const X2& y, const X3& z)
  {
    PoomaCTAssert<(D == 3)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
  }
  template<class X1, class X2, class X3, class X4>
  inline VectorEngine(const X1& x, const X2& y, const X3& z,
        const X4& a)
  {
    PoomaCTAssert<(D == 4)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
    x_m[3] = a;
  }
  template<class X1, class X2, class X3, class X4, class X5>
  inline VectorEngine(const X1& x, const X2& y, const X3& z,
        const X4& a, const X5& b)
  {
    PoomaCTAssert<(D == 5)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
    x_m[3] = a;
    x_m[4] = b;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  inline VectorEngine(const X1& x, const X2& y, const X3& z,
        const X4& a, const X5& b, const X6& c)
  {
    PoomaCTAssert<(D == 6)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
    x_m[3] = a;
    x_m[4] = b;
    x_m[5] = c;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6, class X7>
  inline VectorEngine(const X1& x, const X2& y, const X3& z,
        const X4& a, const X5& b, const X6& c, const X7& d)
  {
    PoomaCTAssert<(D == 7)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
    x_m[3] = a;
    x_m[4] = b;
    x_m[5] = c;
    x_m[6] = d;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
     class X7, class X8, class X9, class X10>
  inline VectorEngine(const X1& x, const X2& y, const X3& z,
        const X4& a, const X5& b, const X6& c,
        const X7& d, const X8& e, const X9& f,
        const X10& g)
  {
    PoomaCTAssert<(D == 10)>::test();
    x_m[0] = x;
    x_m[1] = y;
    x_m[2] = z;
    x_m[3] = a;
    x_m[4] = b;
    x_m[5] = c;
    x_m[6] = d;
    x_m[7] = e;
    x_m[8] = f;
    x_m[9] = g;
  }
  ~VectorEngine() {}
  This_t&
    operator=(const This_t& x)
      {
        if ( this != &x )
          VectorAssign<This_t,This_t,OpAssign,0,D>::apply(*this,x,OpAssign());
        return *this;
      }
  template<class V>
    This_t&
      operator=(const V& x)
        {
          VectorAssign<This_t,V,OpAssign,0,D>::apply(*this,x,OpAssign());
          return *this;
        }
  ConstElementRef_t operator()(int i) const
    {
      ;
      return x_m[i];
    }
  ElementRef_t operator()(int i)
    {
      ;
      return x_m[i];
    }
  inline void reverseBytes()
  {
    for (int d = 0; d < D; ++d) ::reverseBytes(x_m[d]);
  }
private:
  T x_m[D];
};
template<int D, class T, int I>
struct VectorElem< VectorEngine<D,T,Full> , I >
{
  typedef VectorEngine<D,T,Full> V;
  typedef VectorEngineElem<D,T,Full,I> VE;
  typedef typename VE::Element_t Element_t;
  typedef typename VE::ConstElementRef_t ConstElementRef_t;
  typedef typename VE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return VE::get(x); }
  static ElementRef_t get(V& x) { return VE::get(x); }
};
template<class T, class Components> struct ComponentAccess;
template<int D, class T, class E, int N>
struct ComponentAccess< Vector<D, T, E>, Loc<N> >
{
  typedef Vector<D, T, E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::ElementRef_t ElementRef_t;
  static inline ElementRef_t indexRef(V &v, const Loc<N> &l)
    {
      PoomaCTAssert<(N==1)>::test();
      return v(l[0].first());
    }
  static inline Element_t index(const V &v, const Loc<N> &l)
    {
      PoomaCTAssert<(N==1)>::test();
      return v(l[0].first());
    }
};
template<int D, class T>
inline
VectorEngine<D,T,Full>::VectorEngine(const VectorEngine<D,T,Full>& x)
{
  VectorAssign<This_t,This_t,OpAssign,0,D>::apply(*this,x,OpAssign());
}
template<class T>
class RemoteProxy
{
public:
  typedef RemoteProxy<T> This_t;
  RemoteProxy(T &val, int owningContext = 0)
  {
    if (Pooma::context() == owningContext)
    {
      value_m = &val;
    }
  }
  RemoteProxy(const RemoteProxy<T> &s)
  {
    if (s.value_m != &s.storedValue_m)
    {
      value_m = s.value_m;
    }
    else
    {
      storedValue_m = s.value();
      value_m = &storedValue_m;
    }
  }
  inline
  operator T() const { return *value_m; }
  inline
  T &value() { return *value_m; }
  inline
  const T &value() const { return *value_m; }
  template<class S>
  inline
  RemoteProxy<T> &operator=(const S &s)
  {
    *value_m = s;
    return *this;
  }
  template<class S>
  inline
  RemoteProxy<T> &operator=(const RemoteProxy<S> &s)
  {
    *value_m = s.value();
    return *this;
  }
  inline
  RemoteProxy<T> &operator=(const RemoteProxy<T> &s)
  {
    *value_m = s.value();
    return *this;
  }
  inline
  typename ComponentAccess<T, Loc<1> >::Element_t
  operator()(int i) const
  {
    return ComponentAccess<T, Loc<1> >::index(value(), Loc<1>(i));
  }
  inline
  typename ComponentAccess<T, Loc<1> >::ElementRef_t
  operator()(int i)
  {
    return ComponentAccess<T, Loc<1> >::indexRef(value(), Loc<1>(i));
  }
private:
  T *value_m;
  T storedValue_m;
};
template<class T, class S>
inline T
operator*(const RemoteProxy<T> &t, const S &s)
{
  return t.value() * s;
}
template<class T>
class ReductionValue
{
public:
  ReductionValue(bool valid, const T &val)
    : valid_m(valid)
    {
      if (valid_m)
 val_m = val;
    }
  ReductionValue(const ReductionValue<T> &model)
    {
      valid_m = model.valid();
      if (valid_m)
 val_m = model.value();
    }
  ReductionValue<T> &operator=(const ReductionValue<T> &rhs)
    {
      if (&rhs != this)
 {
   valid_m = rhs.valid();
   if (valid_m)
     val_m = rhs.value();
 }
      return *this;
    }
  bool valid() const { return valid_m; }
  const T &value() const { ; return val_m; }
  T &value() { ; return val_m; }
private:
  bool valid_m;
  T val_m;
};
template<class T, class ReductionOp>
class ReduceOverContexts
{
  typedef ReduceOverContexts<T, ReductionOp> This_t;
public:
  ReduceOverContexts(const T &val, int = 0, bool valid = true)
    {
      ;
      value_m = val;
    }
  void broadcast(T &val)
    {
      val = value_m;
    }
  inline operator T() const { return value_m; }
private:
  static void receive(This_t *me, ReductionValue<T> &v)
  {
    if (v.valid())
      {
 if (!me->valid_m)
   {
     me->value_m = v.value();
     me->valid_m = true;
   }
 else
   {
     ReductionOp()(me->value_m, v.value());
   }
      }
    me->toReceive_m--;
  }
  T value_m;
  bool valid_m;
  int toReceive_m;
  int toContext_m;
};
struct SendReceive
{
  template<class View>
  static
  void send(const View &view, int toContext)
  {
    ;
  }
};
template<class IncomingView>
struct Receive
{
  template<class View>
  static
  void receive(const View &view, int fromContext)
  {
    ;
  }
};
template<int Dim>
Interval<Dim> &
shrinkRightInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() - s[d].first();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
shrinkRightInPlace(Interval<Dim> &dom, int s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() - s;
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
growRightInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() + s[d].first();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
growRightInPlace(Interval<Dim> &dom, int s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() + s;
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
shrinkLeftInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s[d].first();
      int b = dom[d].last();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
shrinkLeftInPlace(Interval<Dim> &dom, int s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s;
      int b = dom[d].last();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
growLeftInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s[d].first();
      int b = dom[d].last();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
Interval<Dim> &
growLeftInPlace(Interval<Dim> &dom, int s)
{
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s;
      int b = dom[d].last();
      dom[d] = Interval<1>(a, b);
    }
  return dom;
}
template<int Dim>
inline Interval<Dim>
shrinkRight(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() - s[d].first();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrinkRight(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() - s;
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
growRight(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() + s[d].first();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
growRight(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first();
      int b = dom[d].last() + s;
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrinkLeft(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s[d].first();
      int b = dom[d].last();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrinkLeft(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s;
      int b = dom[d].last();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
growLeft(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s[d].first();
      int b = dom[d].last();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
growLeft(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s;
      int b = dom[d].last();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
grow(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s;
      int b = dom[d].last() + s;
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
grow(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() - s[d].first();
      int b = dom[d].last() + s[d].first();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrink(const Interval<Dim> &dom, int s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s;
      int b = dom[d].last() - s;
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template<int Dim>
inline Interval<Dim>
shrink(const Interval<Dim> &dom, const Loc<Dim> &s)
{
  Interval<Dim> ret = Pooma::NoInit();
  for (int d = 0; d < Dim; ++d)
    {
      int a = dom[d].first() + s[d].first();
      int b = dom[d].last() - s[d].first();
      ret[d] = Interval<1>(a, b);
    }
  return ret;
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
Engine()
  : pDirty_m(0)
{
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
Engine(const Layout_t &layout)
  : layout_m(layout),
    data_m(layout.sizeGlobal()),
    pDirty_m(new int)
{
  typedef typename Layout_t::Value_t Node_t;
  setDirty();
  int sz = data().size();
  typedef Pooma::CountingSemaphore CountingSemaphore_t;
  typedef typename Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
    template PatchAllocator<Node_t,CountingSemaphore_t> PatchAllocator_t;
  CountingSemaphore_t csem;
  csem.height(sz);
  typename Layout_t::const_iterator p = layout_m.beginGlobal();
  for (int i = 0; i < sz; ++i, ++p)
    {
      PatchAllocator_t *spot = new PatchAllocator_t(data()[i], *p, csem);
      Pooma::addRunnable(spot);
    }
  csem.wait();
  layout_m.attach(*this);
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
Engine(const Engine_t &modelEngine)
  : layout_m(modelEngine.layout_m),
    data_m(modelEngine.data_m),
    pDirty_m(modelEngine.pDirty_m)
{
  layout_m.attach(*this);
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
~Engine()
{
  if (initialized())
    {
      layout_m.detach(*this);
      if (!data().isShared())
 delete pDirty_m;
    }
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> > &
Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
operator=(const Engine_t &model)
{
  if (&model == this)
    return *this;
  if (!model.initialized())
    return *this;
  if (initialized())
    {
      if (!data().isShared())
 delete pDirty_m;
      layout_m.detach(*this);
    }
  data_m = model.data();
  pDirty_m = model.pDirty_m;
  layout_m = model.layout_m;
  layout_m.attach(*this);
  return *this;
}
template <int Dim, class T, class LayoutTag, class PatchTag>
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> > &
Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
makeOwnCopy()
{
  if (data_m.isValid() && data_m.isShared()) {
    data_m.makeOwnCopy();
    pDirty_m = new int(*pDirty_m);
  }
  return *this;
}
template <int Dim, class T, class Tag>
static inline
void simpleAssign(const Array<Dim, T, Tag>& lhs,
    const Array<Dim, T, Tag>& rhs,
    const Interval<Dim>& domain)
{
  lhs(domain) = rhs(domain);
}
template <int Dim, class T, class Tag>
static inline
void simpleAssign(const Array<Dim, T, Remote<Tag> >& lhs,
    const Array<Dim, T, Remote<Tag> >& rhs,
    const Interval<Dim>& domain)
{
  if (lhs.engine().owningContext() == rhs.engine().owningContext())
    lhs(domain) = rhs(domain);
  else {
    typedef typename NewEngine<Engine<Dim, T, Tag>, Interval<Dim> >::Type_t ViewEngine_t;
    if (lhs.engine().engineIsLocal())
      Receive<ViewEngine_t>::receive(ViewEngine_t(lhs.engine().localEngine(), domain),
         rhs.engine().owningContext());
    else if (rhs.engine().engineIsLocal())
      SendReceive::send(ViewEngine_t(rhs.engine().localEngine(), domain),
   lhs.engine().owningContext());
  }
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
fillGuardsHandler(const GuardLayers<Dim>& g, const WrappedInt<true> &) const
{
  if (!isDirty()) return;
  int updated = 0;
  typename Layout_t::FillIterator_t p = layout_m.beginFillList();
  while (p != layout_m.endFillList())
    {
      int src = p->ownedID_m;
      int dest = p->guardID_m;
      if (isDirty(p->face_m)) {
 int d = p->face_m/2;
 int guardSizeNeeded = p->face_m & 1 ? g.upper(d) : g.lower(d);
        if (!(p->face_m != -1
       && guardSizeNeeded == 0)) {
          Array<Dim, T, PatchTag> lhs(data()[dest]), rhs(data()[src]);
          lhs(p->domain_m) = rhs(p->domain_m);
   updated |= 1<<p->face_m;
 }
      }
      ++p;
    }
  *pDirty_m &= ~updated;
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
setGuards(const T &val) const
{
  typename Layout_t::FillIterator_t p = layout_m.beginFillList();
  while (p != layout_m.endFillList())
    {
      int dest = p->guardID_m;
      Array<Dim, T, PatchTag> lhs(data()[dest]);
      lhs(p->domain_m) = val;
      ++p;
    }
  setDirty();
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
accumulateFromGuards() const
{
  typename Layout_t::FillIterator_t p = layout_m.beginFillList();
  while (p != layout_m.endFillList())
    {
      int dest = p->ownedID_m;
      int src = p->guardID_m;
      Array<Dim, T, PatchTag> lhs(data()[dest]), rhs(data()[src]);
      lhs(p->domain_m) += rhs(p->domain_m);
      ++p;
    }
  setDirty();
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >::
dynamicHandler(Observable_t &,
               const ObserverEvent &event,
               const WrappedInt<true> &)
{
  switch (event.event())
  {
    case DynamicEvents::create:
      {
        typedef const CreateEvent &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        performCreate(e.amount(), e.patch(), e.ID());
      }
      break;
    case DynamicEvents::destroyInterval:
      {
        typedef const DestroyEvent< Interval<1> > &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        switch (e.method())
        {
          case DynamicEvents::backfill:
            performDestroy(e.domain(), e.patch(), BackFill(), e.ID());
     break;
   case DynamicEvents::shiftup:
     performDestroy(e.domain(), e.patch(), ShiftUp(), e.ID());
     break;
   default:
     if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("Unsupported delete method MultiPatchEngine::destroy", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.cpp", 455);
        }
      }
      break;
    case DynamicEvents::destroyRange:
      {
        typedef const DestroyEvent< Range<1> > &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        switch (e.method())
        {
          case DynamicEvents::backfill:
            performDestroy(e.domain(), e.patch(), BackFill(), e.ID());
     break;
   case DynamicEvents::shiftup:
     performDestroy(e.domain(), e.patch(), ShiftUp(), e.ID());
     break;
   default:
     if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("Unsupported delete method MultiPatchEngine::destroy", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.cpp", 476);
        }
      }
      break;
    case DynamicEvents::destroyList:
      {
        typedef const DestroyEvent< IndirectionList<int> > &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        switch (e.method())
        {
          case DynamicEvents::backfill:
            performDestroy(e.domain(), e.patch(), BackFill(), e.ID());
     break;
   case DynamicEvents::shiftup:
     performDestroy(e.domain(), e.patch(), ShiftUp(), e.ID());
     break;
   default:
     if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("Unsupported delete method MultiPatchEngine::destroy", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.cpp", 497);
        }
      }
      break;
    case DynamicEvents::destroyIterList:
      {
        using Pooma::IteratorPairDomain;
        typedef
          const DestroyEvent< IteratorPairDomain<const int*> > &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        switch (e.method())
        {
          case DynamicEvents::backfill:
            performDestroy(e.domain(), e.patch(), BackFill(), e.ID());
     break;
   case DynamicEvents::shiftup:
     performDestroy(e.domain(), e.patch(), ShiftUp(), e.ID());
     break;
   default:
     if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("Unsupported delete method MultiPatchEngine::destroy", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.cpp", 520);
        }
      }
      break;
    case DynamicEvents::copyInterval:
      {
        typedef const CopyEvent< Interval<1> > &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        performCopy(e.domain(), e.fromPatch(), e.toPatch(), e.ID());
      }
      break;
    case DynamicEvents::copyRange:
      {
        typedef const CopyEvent< Range<1> > &EventRef_t;
 EventRef_t e = dynamic_cast<EventRef_t>(event);
 performCopy(e.domain(), e.fromPatch(), e.toPatch(), e.ID());
      }
      break;
    case DynamicEvents::copyList:
      {
        typedef const CopyEvent< IndirectionList<int> > &EventRef_t;
 EventRef_t e = dynamic_cast<EventRef_t>(event);
 performCopy(e.domain(), e.fromPatch(), e.toPatch(), e.ID());
      }
      break;
    case DynamicEvents::copyPatchList:
      {
        typedef const CopyPatchEvent &EventRef_t;
        EventRef_t e = dynamic_cast<EventRef_t>(event);
        performPatchCopy(e.domainLists(), e.fromPatch(), e.toPatch(),
                         e.create(), e.ID());
      }
      break;
    case DynamicEvents::sync:
      {
        for (int i=0; i < layout().sizeGlobal(); ++i)
   data()[i].sync(layout().nodeListGlobal()[i]->domain());
      }
      break;
    default:
      if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Invalid dynamic op???", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Engine/MultiPatchEngine.cpp", 567);
  }
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
notify(Observable_t &observed, const ObserverEvent &event)
{
  ;
  if(event.event() == Layout_t::repartitionEvent)
    {
      typedef typename Layout_t::Value_t Node_t;
      int sz = layout().sizeGlobal();
      PatchContainer_t newData(sz);
      typedef Pooma::CountingSemaphore CountingSemaphore_t;
      typedef typename Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
        template PatchAllocator<Node_t,CountingSemaphore_t> PatchAllocator_t;
      CountingSemaphore_t csem;
      csem.height(sz);
      typename Layout_t::const_iterator p = layout().beginGlobal();
      for (int i = 0; i < sz; ++i, ++p)
 {
          PatchAllocator_t *spot = new PatchAllocator_t(newData[i], *p, csem);
          Pooma::addRunnable(spot);
        }
      csem.wait();
      data_m = newData;
    }
  else
    {
      if (DynamicEvents::isDynamic(event.event()))
        {
          dynamicHandler(observed, event,
            WrappedInt<PatchEngine_t::dynamic>());
 }
      else
 {
 }
    }
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
performCreate(CreateSize_t num, PatchID_t localPatchID, DynamicID_t did)
{
  ;
  ;
  int globalID = layout().nodeListLocal()[localPatchID]->globalID();
  if (! checkDynamicID(data()[globalID], did))
    return;
  data()[globalID].create(num);
}
template <int Dim, class T, class LayoutTag, class PatchTag>
template <class Dom, class DeleteMethod>
void Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
performDestroy(const Dom &killlist, PatchID_t localPatchID,
        const DeleteMethod &method, DynamicID_t did)
{
  ;
  int globalID = layout().nodeListLocal()[localPatchID]->globalID();
  if (! checkDynamicID(data()[globalID], did))
    return;
  data()[globalID].destroy(killlist, method, true);
}
template <int Dim, class T, class LayoutTag, class PatchTag>
template <class Dom>
void Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
performCopy(const Dom &copylist, PatchID_t frompatch, PatchID_t topatch,
     DynamicID_t did)
{
  ;
  ;
  ;
  int from_gID = layout().nodeListLocal()[frompatch]->globalID();
  int to_gID = layout().nodeListLocal()[topatch]->globalID();
  bool chk1 = checkDynamicID(data()[from_gID], did);
  bool chk2 = chk1;
  if (frompatch != topatch)
    chk2 = checkDynamicID(data()[to_gID], did);
  ;
  if (!chk1 || !chk2)
    return;
  ;
  int offs = data()[from_gID].domain()[0].first();
  int i = data()[to_gID].domain()[0].last() + 1;
  int num = copylist.size();
  data()[to_gID].create(num);
  for (int n = 0; n < num; ++n, ++i)
  {
    localPatchEngine(data()[to_gID])(i) =
      localPatchEngine(data()[from_gID])(copylist[0](n) + offs);
  }
}
template <int Dim, class T, class LayoutTag, class PatchTag>
void Engine<Dim, T, MultiPatch<LayoutTag, PatchTag> >::
performPatchCopy(const IndirectionList< IndirectionList<int> > &domlists,
   const IndirectionList< int > &fromlist,
   PatchID_t topatch,
   bool docreate,
   DynamicID_t did)
{
  ;
  ;
  int to_gID = layout().nodeListLocal()[topatch]->globalID();
  if (! checkDynamicID(data()[to_gID], did))
    return;
  int i, p, fill, created = 0;
  int np = domlists.size();
  ;
  for (p = 0; p < np; ++p)
    {
      int frompatch = fromlist(p);
      int from_gID = layout().nodeListLocal()[frompatch]->globalID();
      ;
      ;
      ;
      created += domlists(p).size();
    }
  if (docreate)
    {
      fill = data()[to_gID].domain()[0].last() + 1;
      data()[to_gID].create(created);
    }
  else
    {
      ;
      fill = data()[to_gID].domain()[0].last() + 1 - created;
    }
  for (p = 0; p < np; ++p)
    {
      int sz = domlists(p).size();
      int frompatch = fromlist(p);
      int from_gID = layout().nodeListLocal()[frompatch]->globalID();
      int offs = data()[from_gID].domain()[0].first();
      for (i = 0; i < sz; ++i, ++fill)
      {
 localPatchEngine(data()[to_gID])(fill) =
   localPatchEngine(data()[from_gID])(domlists(p)(i) + offs);
      }
    }
}
template<int Dim, class T, class LTag, class PatchTag>
long elementsCompressed(const Engine<Dim, T, MultiPatch<LTag, PatchTag> >
  &engine)
{
  int size = engine.layout().sizeLocal();
  bool distributed = true;
  if (size > 0 && engine.layout().beginLocal()->context() == -1)
    distributed = false;
  long num = 0L;
  for (int i = 0 ; i < size ; ++i )
    num += elementsCompressed(engine.localPatch(i));
  if (distributed)
    {
      ReduceOverContexts<long, OpAddAssign> total(num);
      total.broadcast(num);
    }
  return num;
}
template<int Dim, class T, class LTag, class PatchTag>
bool compressed(const Engine<Dim, T, MultiPatch<LTag, PatchTag> > &engine)
{
  int size = engine.layout().sizeLocal();
  bool distributed = true;
  if (size > 0 && engine.layout().beginLocal()->context() == -1)
    distributed = false;
  int com = 1;
  for (int i = 0 ; i < size ; ++i )
    com &= (compressed(engine.localPatch(i)) ? 1 : 0);
  if (distributed)
    {
      ReduceOverContexts<int, OpBitwiseAndAssign> total(com);
      total.broadcast(com);
    }
  return com ? true : false;
}
template<int Dim, class T, class LTag, class PatchTag, int Dim2>
long elementsCompressed(const
  Engine<Dim, T, MultiPatchView<LTag, PatchTag, Dim2> > &engine)
{
  typedef Engine<Dim, T, MultiPatchView<LTag, PatchTag, Dim2> > Engine_t;
  typedef typename Engine_t::Layout_t Layout_t;
  int size = engine.layout().sizeLocal();
  bool distributed = true;
  if (size > 0 && engine.layout().beginLocal()->context() == -1)
    distributed = false;
  typename Layout_t::const_iterator i = engine.layout().beginLocal();
  long num = 0L;
  while (i != engine.layout().endLocal())
    {
      num += elementsCompressed(engine.globalPatch(*i));
      ++i;
    }
  if (distributed)
    {
      ReduceOverContexts<long, OpAddAssign> total(num);
      total.broadcast(num);
    }
  return num;
}
template<int Dim, class T, class LTag, class PatchTag>
void compress(Engine<Dim, T, MultiPatch<LTag, PatchTag> > &engine)
{
  for (int i = 0; i < engine.layout().sizeLocal(); ++i)
    compress(engine.localPatch(i));
}
template<int Dim, class T, class LTag, class PatchTag>
void uncompress(Engine<Dim, T, MultiPatch<LTag, PatchTag> > &engine)
{
  for (int i = 0; i < engine.layout().sizeLocal(); ++i)
    uncompress(engine.localPatch(i));
}
template <int Dim> class GridLayoutData;
template <int Dim> class GridLayout;
template <int Dim, int Dim2> class GridLayoutViewData;
template <int Dim, int Dim2> class GridLayoutView;
struct GridTag { };
template <int Dim>
struct MultiPatchLayoutTraits<GridTag,Dim>
{
  typedef GridLayout<Dim> Layout_t;
  template <int ViewDim>
  struct View
  {
    typedef GridLayoutView<ViewDim,Dim> Layout_t;
  };
};
template<int Dim>
class GridLayoutData
  : public LayoutBaseData<Dim>,
    public RefCounted,
    public Observable< GridLayoutData<Dim> >
{
public:
  typedef GridLayoutData<Dim> This_t;
  typedef Observable<This_t> Observable_t;
  typedef Interval<Dim> Domain_t;
  typedef Interval<Dim> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef Node<Domain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef int AxisIndex_t;
  typedef typename DynamicEvents::PatchID_t PatchID_t;
  typedef typename DynamicEvents::CreateSize_t CreateSize_t;
  typedef typename LayoutBaseData<Dim>::GCFillInfo_t GCFillInfo_t;
  typedef typename std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  enum { dimensions = Dim };
  enum { repartitionEvent = 1 };
  enum { dynamic = false };
  GridLayoutData();
  template <class Partitioner>
  GridLayoutData(const Domain_t &gdom,
   const Partitioner &gpar,
   const ContextMapper<Dim> & cmap);
  template <class Partitioner>
  GridLayoutData(const Grid<Dim> &gdom,
   const Partitioner &gpar,
                 const ContextMapper<Dim> &cmap);
  ~GridLayoutData();
  template <class Partitioner>
  void initialize(const Domain_t &gdom,
    const Partitioner &gpar,
    const ContextMapper<Dim> &cmap);
  template <class Partitioner>
  inline void initialize(const Grid<Dim> &gdom,
    const Partitioner &gpar,
                         const ContextMapper<Dim> &cmap);
  void initialize(const Domain_t& idom,
    const List_t& nodes,
    const Loc<Dim>& blocks,
    bool hasIG, bool hasEG,
    const GuardLayers_t& ig,
    const GuardLayers_t& eg);
  inline const Loc<Dim> &blocks() const
    {
      return this->blocks_m;
    }
  inline bool dirty() const
    {
      return dirtyLayout_m;
    }
  int globalID(const Loc<Dim> &loc) const;
  int globalID(int) const;
  int globalID(int,int) const;
  int globalID(int,int,int) const;
  int globalID(int,int,int,int) const;
  int globalID(int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int) const;
  int globalID(int,int,int,int,int,int,int) const;
  FillIterator_t beginFillList() const
    {
      return this->gcFillList_m.begin();
    }
  FillIterator_t endFillList() const
    {
      return this->gcFillList_m.end();
    }
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touches(const OtherDomain &fulld, OutIter o,
       const ConstructTag &ctag) const;
  template <class OtherDomain, class OutIter, class ConstructTag>
  int touchesAlloc(const OtherDomain &fulld, OutIter o,
     const ConstructTag &ctag) const;
  void sync();
  template<class Out>
  void print(Out & ostr);
private:
  void calcGCFillList();
  void calcDomains();
  void calcMaps() const;
  void calcAllocMaps() const;
  inline int blockIndex(const Loc<Dim> &loc) const
    {
      int pos = loc[0].first();
      for (int i=1; i < Dim; ++i)
 pos += loc[i].first() * blockStrides_m[i];
      return pos;
    }
  bool dirtyLayout_m;
  int blockStrides_m[Dim];
  mutable DomainMap<Interval<1>,AxisIndex_t> map_m[Dim];
  mutable DomainMap<Interval<1>,AxisIndex_t> mapAloc_m[Dim];
};
template <int Dim>
class GridLayout : public LayoutBase<Dim,GridLayoutData<Dim> >,
                   public Observable<GridLayout<Dim> >,
                   public Observer<GridLayoutData<Dim> >
{
public:
  typedef GridLayout<Dim> This_t;
  typedef Observable<This_t> Observable_t;
  typedef GridLayoutData<Dim> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef DynamicEvents::PatchID_t PatchID_t;
  typedef DynamicEvents::CreateSize_t CreateSize_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  typedef typename LayoutData_t::GCFillInfo_t GCFillInfo_t;
  typedef typename
    std::vector<GCFillInfo_t>::const_iterator FillIterator_t;
  enum { dimensions = Dim };
  enum { repartitionEvent = 1 };
  enum { dynamic = true };
  GridLayout();
  GridLayout(const Domain_t &,const DistributedTag &);
  GridLayout(const Domain_t &,const ReplicatedTag &);
  GridLayout(const Domain_t &,
             const GuardLayers_t &,const DistributedTag &);
  GridLayout(const Domain_t &,
             const GuardLayers_t &,const ReplicatedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,const DistributedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,
      const GuardLayers_t &,const DistributedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,
      const GuardLayers_t &,
      const GuardLayers_t &,const DistributedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,const ReplicatedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,
      const GuardLayers_t &,const ReplicatedTag &);
  GridLayout(const Domain_t &,
      const Loc<Dim> &,
      const GuardLayers_t &,
      const GuardLayers_t &,const ReplicatedTag &);
  GridLayout(const Grid<Dim> &,
      const DistributedTag &);
  GridLayout(const Grid<Dim> &,
      const GuardLayers_t &,
      const DistributedTag &);
  GridLayout(const Grid<Dim> &,
      const GuardLayers_t &,
      const GuardLayers_t &,
      const DistributedTag &);
  GridLayout(const Grid<Dim> &,
      const ReplicatedTag &);
  GridLayout(const Grid<Dim> &,
      const GuardLayers_t &,
      const ReplicatedTag &);
  GridLayout(const Grid<Dim> &,
      const GuardLayers_t &,
      const GuardLayers_t &,
      const ReplicatedTag &);
  template <class Partitioner>
  GridLayout(const Domain_t &,
      const Partitioner &,
      const DistributedTag &);
  template <class Partitioner>
  GridLayout(const Domain_t &,
      const Partitioner &,
      const ReplicatedTag &);
  template <class Partitioner>
  GridLayout(const Domain_t &,
      const Partitioner &,
      const ContextMapper<Dim> &);
  GridLayout(const This_t &);
  This_t &operator=(const This_t &);
  inline ~GridLayout()
    {
      this->pdata_m->detach(*this);
    }
  void initialize(const Domain_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Grid<Dim> &,
    const DistributedTag &);
  void initialize(const Grid<Dim> &,
    const GuardLayers_t &,
    const DistributedTag &);
  void initialize(const Grid<Dim> &,
    const GuardLayers_t &,
    const GuardLayers_t &,
    const DistributedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const DistributedTag &);
  void initialize(const Domain_t &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  void initialize(const Domain_t &,
    const Loc<Dim> &,
    const GuardLayers_t &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  void initialize(const Grid<Dim> &,
    const ReplicatedTag &);
  void initialize(const Grid<Dim> &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  void initialize(const Grid<Dim> &,
    const GuardLayers_t &,
    const GuardLayers_t &,
    const ReplicatedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const ReplicatedTag &);
  template <class Partitioner>
  void initialize(const Domain_t &,
    const Partitioner &,
    const ContextMapper<Dim> &);
  void initialize(const Domain_t& idom,
    const List_t& nodes,
    const Loc<Dim>& blocks,
    bool hasIG, bool hasEG,
    const GuardLayers_t& ig,
    const GuardLayers_t& eg);
  inline const Loc<Dim> &blocks() const
    {
      return this->pdata_m->blocks();
    }
  template <class Partitioner>
  inline bool repartition(const Partitioner &gp,const ContextMapper<Dim> &cm)
    {
      this->pdata_m->initialize(this->domain(),gp,cm);
      this->pdata_m->notify(repartitionEvent);
      return true;
    }
  inline void sync()
    {
      this->pdata_m->sync();
    }
  virtual void notify(LayoutData_t &d, const ObserverEvent &event)
    {
      ;
      Observable_t::notify(event);
    }
  template <class Ostream>
  void print(Ostream &ostr) const;
  template <int Dim1, int Dim2>
  friend class GridLayoutView;
  friend class GridLayoutData<Dim>;
};
template <int Dim, int Dim2>
class GridLayoutViewData :
                public LayoutBaseViewData<Dim, Dim2, GridLayout<Dim2> >,
                public RefCounted
{
public:
  typedef GridLayout<Dim2> Layout_t;
  typedef GridLayoutView<Dim, Dim2> ViewLayout_t;
  typedef Interval<Dim> Domain_t;
  typedef Range<Dim2> BaseDomain_t;
  typedef int Context_t;
  typedef Unique::Value_t ID_t;
  typedef typename Layout_t::Domain_t AllocatedDomain_t;
  typedef ViewIndexer<Dim,Dim2> Indexer_t;
  typedef Node<Domain_t,AllocatedDomain_t> Value_t;
  typedef std::vector<Value_t *> List_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef GridLayoutViewData<Dim,Dim2> LayoutData_t;
  enum { dim = Dim };
  enum { dim2 = Dim2 };
  GridLayoutViewData() { }
  template <class DT>
  inline GridLayoutViewData(const Layout_t &layout, const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,GridLayout<Dim2> >(layout,dom)
  {
  }
  template <class DT>
  inline GridLayoutViewData(const Layout_t &layout,
                            const SliceDomain<DT> &dom)
  :LayoutBaseViewData<Dim,Dim2,GridLayout<Dim2> >(layout,dom)
  {
  }
  template <class DT>
  GridLayoutViewData(const ViewLayout_t &layout,
                     const Domain<Dim, DT> &dom)
  : LayoutBaseViewData<Dim,Dim2,GridLayout<Dim2> >(
           layout.pdata_m->layout_m,
           layout,
           layout.pdata_m->indexer_m,
           dom,
           layout.internalGuards(),
           layout.externalGuards())
  {
  }
  template <int OrigDim, class DT>
  GridLayoutViewData(const GridLayoutView<OrigDim, Dim2> &layout,
                     const SliceDomain<DT> &dom)
    : LayoutBaseViewData<Dim,Dim2,GridLayout<Dim2> >(
        layout.pdata_m->layout_m,
        layout,
        Indexer_t(layout.pdata_m->indexer_m,dom),
        dom)
  {
  }
  ~GridLayoutViewData()
  {
    typename List_t::iterator a;
    for (a = this->all_m.begin(); a != this->all_m.end(); ++a)
      delete (*a);
  }
};
template <int Dim, int Dim2>
class GridLayoutView
: public LayoutBaseView<Dim, Dim2, GridLayoutViewData<Dim,Dim2> >
{
public:
  enum { dimensions = Dim };
  enum { dim = Dim };
  enum { dim2 = Dim2 };
  typedef GridLayoutViewData<Dim, Dim2> LayoutData_t;
  typedef typename LayoutData_t::Domain_t Domain_t;
  typedef typename LayoutData_t::BaseDomain_t BaseDomain_t;
  typedef typename LayoutData_t::Context_t Context_t;
  typedef typename LayoutData_t::ID_t ID_t;
  typedef typename LayoutData_t::Layout_t Layout_t;
  typedef typename LayoutData_t::AllocatedDomain_t AllocatedDomain_t;
  typedef typename LayoutData_t::Value_t Value_t;
  typedef typename LayoutData_t::List_t List_t;
  typedef typename LayoutData_t::Indexer_t Indexer_t;
  typedef typename LayoutData_t::GuardLayers_t GuardLayers_t;
  typedef GridLayoutView<Dim, Dim2> This_t;
  typedef GridLayoutView<Dim, Dim2> ViewLayout_t;
  typedef LayoutBaseView<Dim, Dim2, LayoutData_t> Base_t;
  typedef DerefIterator<Value_t> iterator;
  typedef ConstDerefIterator<Value_t> const_iterator;
  GridLayoutView()
    : Base_t(new LayoutData_t())
  { }
  template <class DT>
  GridLayoutView(const Layout_t &layout, const Domain<Dim2, DT> &dom)
    : LayoutBaseView<Dim,Dim2,GridLayoutViewData<Dim,Dim2> >
  (new GridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  GridLayoutView(const Layout_t &layout, const SliceDomain<DT> &dom)
    : LayoutBaseView<Dim,Dim2,GridLayoutViewData<Dim,Dim2> >
  (new GridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <class DT>
  GridLayoutView(const ViewLayout_t &layout, const Domain<Dim, DT> &dom)
 : LayoutBaseView<Dim,Dim2,GridLayoutViewData<Dim,Dim2> >
  (new GridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  template <int OldViewDim, class DT>
  GridLayoutView(const GridLayoutView<OldViewDim, Dim2> &layout,
                        const SliceDomain<DT> &dom)
  : LayoutBaseView<Dim,Dim2,GridLayoutViewData<Dim,Dim2> >
  (new GridLayoutViewData<Dim,Dim2>(layout,dom))
  { }
  inline GridLayoutView(const This_t &model)
    : LayoutBaseView<Dim,Dim2,GridLayoutViewData<Dim,Dim2> >(model.pdata_m)
  { }
  inline This_t &operator=(const This_t &model)
  {
    if (this != &model)
      {
        this->pdata_m = model.pdata_m;
      }
    return *this;
  }
  inline ~GridLayoutView()
  { }
  template <class Ostream>
  void print(Ostream &ostr) const;
  template <int OtherDim, int OtherDim2>
  friend class GridLayoutView;
  template <int OtherDim, int OtherDim2>
  friend class GridLayoutViewData;
  void computeSubdomains() const { this->pdata_m->computeSubdomains(); }
};
template <int Dim>
struct NewDomain1<GridLayout<Dim> >
{
  typedef GridLayout<Dim> &Type_t;
  inline static Type_t combine(const GridLayout<Dim> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim, int Dim2>
struct NewDomain1<GridLayoutView<Dim, Dim2> >
{
  typedef GridLayoutView<Dim, Dim2> &Type_t;
  inline static Type_t combine(const GridLayoutView<Dim, Dim2> &a)
    {
      return const_cast<Type_t>(a);
    }
};
template <int Dim>
std::ostream &operator<<(std::ostream &ostr,
    const GridLayout<Dim> &layout)
{
  layout.print(ostr);
  return ostr;
}
template <int Dim, int Dim2>
std::ostream &operator<<(std::ostream &ostr,
    const GridLayoutView<Dim, Dim2> &layout)
{
  layout.print(ostr);
  return ostr;
}
template<int Dim>
GridLayoutData<Dim>::GridLayoutData()
 : LayoutBaseData<Dim>(false,false,
     GuardLayers_t(0),GuardLayers_t(0),
     Interval<Dim>(),Interval<Dim>()),
    Observable<GridLayoutData>(*this)
{
  for (int d=0; d < Dim; ++d)
    this->firsti_m[d] = this->firste_m[d] = blockStrides_m[d] = 0;
}
template<int Dim>
template<class Partitioner>
GridLayoutData<Dim>::GridLayoutData(const Grid<Dim> &gdom,
        const Partitioner &gpar,
        const ContextMapper<Dim> &cmap)
  : LayoutBaseData<Dim>(false,false,
   GuardLayers_t(0),GuardLayers_t(0),
   Interval<Dim>(), Interval<Dim>()),
    Observable<GridLayoutData>(*this)
{
  initialize(gdom, gpar, cmap);
}
template<int Dim>
template<class Partitioner>
GridLayoutData<Dim>::GridLayoutData(const Domain_t &gdom,
        const Partitioner &gpar,
        const ContextMapper<Dim> &cmap)
  : LayoutBaseData<Dim>(false,false,
   GuardLayers_t(0),GuardLayers_t(0),
   gdom,gdom),
    Observable<GridLayoutData>(*this)
{
  for (int d=0; d < Dim; ++d)
    this->firsti_m[d] = this->firste_m[d] = blockStrides_m[d] = 0;
  initialize(gdom, gpar, cmap);
}
template<int Dim>
GridLayoutData<Dim>::~GridLayoutData()
{
  for (typename List_t::iterator a = this->all_m.begin(); a != this->all_m.end(); ++a)
    delete (*a);
}
template<int Dim>
template <class Partitioner>
inline void GridLayoutData<Dim>::initialize(const Grid<Dim> &gdom,
         const Partitioner &gpar,
         const ContextMapper<Dim> &cmap)
{
  Domain_t idom = Pooma::NoInit();
  for (int d=0; d < Dim; ++d)
    idom[d] = Interval<1>(gdom[d].first(), gdom[d].last() - 1);
  initialize(idom, gpar, cmap);
}
template<int Dim>
template<class Partitioner>
inline void GridLayoutData<Dim>::initialize(const Domain_t &gdom,
         const Partitioner &gpar,
         const ContextMapper<Dim> &cmap)
{
  int i;
  PoomaCTAssert<(Partitioner::gridded)>::test();
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  dirtyLayout_m = true;
  this->domain_m = gdom;
  this->innerdomain_m = gdom;
  this->hasInternalGuards_m = (gpar.hasInternalGuards() && gpar.maxSize() > 1);
  if (this->hasInternalGuards_m)
    {
      this->internalGuards_m = gpar.internalGuards();
    }
  this->hasExternalGuards_m = (gpar.hasExternalGuards() && ! this->domain_m.empty());
  if (this->hasExternalGuards_m)
    {
      this->externalGuards_m = gpar.externalGuards();
      GuardLayers<Dim>::addGuardLayers(this->domain_m, this->externalGuards_m);
    }
  this->blocks_m = gpar.blocks();
  for (i=0; i < Dim; ++i)
    {
      if (!this->domain_m[i].empty())
 this->firsti_m[i] = this->domain_m[i].first();
      blockStrides_m[i] = (i == 0 ? 1 :
      blockStrides_m[i-1] * this->blocks_m[i-1].first());
    }
  gpar.partition(this->innerdomain_m, this->all_m, cmap);
  typename List_t::iterator start = this->all_m.begin();
  typename List_t::iterator end = this->all_m.end();
  for ( ; start!=end ;++start )
    {
      if( (*start)->context() == Pooma::context()
   ||(*start)->context() == -1 )
 this->local_m.push_back(*start);
      else
 this->remote_m.push_back(*start);
    }
  calcMaps();
  calcAllocMaps();
  calcGCFillList();
}
template<int Dim>
void GridLayoutData<Dim>::initialize(const Domain_t& idom,
     const List_t& nodes,
     const Loc<Dim>& blocks,
     bool hasIG, bool hasEG,
     const GuardLayers_t& ig,
     const GuardLayers_t& eg)
{
  int i;
  if (this->all_m.size() > 0)
    {
      for (i=0; i < this->all_m.size(); ++i)
 delete this->all_m[i];
      this->all_m.clear();
      this->local_m.clear();
      this->remote_m.clear();
    }
  dirtyLayout_m = true;
  this->domain_m = idom;
  this->innerdomain_m = idom;
  this->hasInternalGuards_m = hasIG;
  if (this->hasInternalGuards_m)
    {
      this->internalGuards_m = ig;
    }
  this->hasExternalGuards_m = (hasEG && ! this->domain_m.empty());
  if (this->hasExternalGuards_m)
    {
      this->externalGuards_m = eg;
      GuardLayers<Dim>::addGuardLayers(this->domain_m, this->externalGuards_m);
    }
  this->blocks_m = blocks;
  for (i=0; i < Dim; ++i)
    {
      if (!this->domain_m[i].empty())
 this->firsti_m[i] = this->domain_m[i].first();
      blockStrides_m[i] = (i == 0 ? 1 :
      blockStrides_m[i-1] * this->blocks_m[i-1].first());
    }
  this->all_m= nodes;
  typename List_t::iterator start = this->all_m.begin();
  typename List_t::iterator end = this->all_m.end();
  for ( ; start!=end ;++start )
    {
      if( (*start)->context() == Pooma::context() ||
   (*start)->context() == -1 )
 this->local_m.push_back(*start);
      else
 this->remote_m.push_back(*start);
    }
  calcMaps();
  calcAllocMaps();
  calcGCFillList();
}
template<int Dim>
void GridLayoutData<Dim>::sync()
{
  ;
  if (!this->initialized() || !dirty())
    return;
  calcDomains();
  calcMaps();
  this->notify(SyncEvent());
}
template<int Dim>
void GridLayoutData<Dim>::calcGCFillList()
{
  int d;
  if (!this->initialized() || !this->hasInternalGuards_m)
    return;
  this->gcFillList_m.clear();
  int numPatches = this->all_m.size();
  this->gcFillList_m.reserve(2*Dim*this->local_m.size());
  ;
  Interval<Dim> grid;
  for (d=0; d < Dim; ++d)
    grid[d] = Interval<1>(this->blocks_m[d].first() + 1);
  for (d=0; d < Dim; ++d)
    {
      if (this->internalGuards_m.lower(d) > 0)
 {
   typename Interval<Dim>::blockIterator start = grid.beginBlock();
   typename Interval<Dim>::blockIterator end = grid.endBlock();
   for (; start != end; ++start)
     {
       int sourceID = start.index();
       Loc<Dim> tmp = start.point();
       tmp[d] += 1;
       if (!(tmp[d] >= this->blocks_m[d] || tmp[d].first() < 0))
  {
    int destID = blockIndex(tmp);
    if (!(this->all_m[sourceID]->domain().empty() ||
   this->all_m[destID]->domain().empty()))
      {
        ;
        Domain_t gcdom(this->all_m[sourceID]->allocated());
        int max = this->all_m[sourceID]->domain()[d].last();
        int min = max - this->internalGuards_m.lower(d) + 1;
        gcdom[d] = Interval<1>(min, max);
        this->gcFillList_m.push_back(GCFillInfo_t(gcdom, sourceID, destID, d*2));
      }
  }
     }
 }
      if (this->internalGuards_m.upper(d) > 0)
 {
   typename Interval<Dim>::blockIterator start = grid.beginBlock();
   typename Interval<Dim>::blockIterator end = grid.endBlock();
   for (; start != end; ++start)
     {
       int sourceID = start.index();
       Loc<Dim> tmp = start.point();
       tmp[d] -= 1;
       if (!(tmp[d] >= this->blocks_m[d] || tmp[d].first() < 0))
  {
    int destID = blockIndex(tmp);
    if (!(this->all_m[sourceID]->domain().empty() ||
   this->all_m[destID]->domain().empty()))
      {
        ;
        Domain_t gcdom(this->all_m[sourceID]->allocated());
        int min = this->all_m[sourceID]->domain()[d].first();
        int max = min + this->internalGuards_m.upper(d) - 1;
        gcdom[d] = Interval<1>(min, max);
        this->gcFillList_m.push_back(GCFillInfo_t(gcdom, sourceID, destID, d*2+1));
      }
  }
     }
 }
    }
}
template<int Dim>
void GridLayoutData<Dim>::calcDomains()
{
  if (!this->initialized() || !dirty())
    return;
  ;
  ;
  CreateSize_t sizes = this->firsti_m[0];
  bool allempty = true;
  for (int i=0; i < this->all_m.size(); ++i)
    {
      Domain_t dom = this->all_m[i]->domain();
      if (!dom[0].empty())
 {
   dom[0] = Interval<1>(sizes, sizes + dom[0].length() - 1);
   sizes += dom[0].length();
   allempty = false;
 }
      this->all_m[i]->setDomain(dom);
      this->all_m[i]->setAllocated(dom);
    }
  if (allempty)
    this->domain_m = Domain_t();
  else
    this->domain_m = Interval<1>(this->firsti_m[0], sizes - 1);
  this->innerdomain_m = this->domain_m;
  dirtyLayout_m = false;
}
template<int Dim>
void GridLayoutData<Dim>::calcMaps() const
{
  int i, j;
  if (!this->initialized() || !dirty())
    return;
  for (i=0; i < Dim; ++i)
    {
      map_m[i].zap();
      if (this->domain_m[i].empty())
 continue;
      Loc<Dim> blockLoc(0);
      map_m[i].initialize(Interval<1>(this->domain_m[i].first() -
          this->externalGuards_m.lower(i),
          this->domain_m[i].last() +
          this->externalGuards_m.upper(i)));
      int b = this->blocks_m[i].first();
      for (j=0; j < b; ++j)
 {
   blockLoc[i] = Loc<1>(j);
   int k = blockIndex(blockLoc);
   Interval<1> blockDom = this->all_m[k]->domain()[i];
   if (!blockDom.empty())
     {
       int lo = (j == 0 ? this->externalGuards_m.lower(i) : 0);
       int hi = (j == (b - 1) ? this->externalGuards_m.upper(i) : 0);
       Interval<1> mval(blockDom.first() - lo, blockDom.last() + hi);
       typename DomainMap<Interval<1>,int>::Value_t val(mval, j);
       map_m[i].insert(val);
     }
 }
      map_m[i].update();
    }
}
template<int Dim>
void GridLayoutData<Dim>::calcAllocMaps() const
{
  int i, j;
  if (!this->initialized() || !dirty())
    return;
  for (i=0; i < Dim; ++i)
    {
      mapAloc_m[i].zap();
      if (this->domain_m[i].empty())
 continue;
      Loc<Dim> blockLoc(0);
      mapAloc_m[i].initialize(Interval<1>(this->domain_m[i].first() -
       this->externalGuards_m.lower(i),
       this->domain_m[i].last() +
       this->externalGuards_m.upper(i)));
      int b = this->blocks_m[i].first();
      for (j=0; j < b; ++j)
 {
   blockLoc[i] = Loc<1>(j);
   int k = blockIndex(blockLoc);
   Interval<1> blockDom = this->all_m[k]->domain()[i];
   if (!blockDom.empty())
     {
       int lo = (j==0 ?
   this->externalGuards_m.lower(i) :
   this->internalGuards_m.lower(i));
       int hi = (j == (b - 1) ?
   this->externalGuards_m.upper(i) :
   this->internalGuards_m.upper(i));
       Interval<1> ival(blockDom.first() - lo, blockDom.last() + hi);
       typename DomainMap<Interval<1>,int>::Value_t valAl(ival, j);
       mapAloc_m[i].insert(valAl);
     }
 }
      mapAloc_m[i].update();
    }
}
template<int Dim>
int GridLayoutData<Dim>::globalID(const Loc<Dim> &loc) const
{
  ;
  Loc<Dim> point;
  for (int i=0; i < Dim; ++i)
    {
      DomainMapTouchIterator<Interval<1>,int> dmti =
 (map_m[i].touch(Interval<1>(loc[i]))).first;
      DomainMapTouchIterator<Interval<1>,int> baditerator;
      ;
     point[i] = *dmti;
    }
  return blockIndex(point);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1, int i2) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4, int i5) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  loc[5] = i5;
  return globalID(loc);
}
template <int Dim>
int GridLayoutData<Dim>::globalID(int i0, int i1, int i2, int i3,
      int i4, int i5, int i6) const
{
  ;
  Loc<Dim> loc;
  loc[0] = i0;
  loc[1] = i1;
  loc[2] = i2;
  loc[3] = i3;
  loc[4] = i4;
  loc[5] = i5;
  loc[6] = i6;
  return globalID(loc);
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int GridLayoutData<Dim>::touches(const OtherDomain &fulld, OutIter o,
     const ConstructTag &ctag) const
{
  int i;
  ;
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t d = intersect(this->domain_m, fulld);
  if (d.empty())
    return 0;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  int hiAxisIndex[Dim];
  int loAxisIndex[Dim];
  Loc<Dim> curnode;
  for (i=0;i < Dim; ++i)
    {
      loAxisIndex[i] =
 *((map_m[i].touch(Interval<1>(d[i].first(),d[i].first()))).first);
      ;
      hiAxisIndex[i] =
 *((map_m[i].touch(Interval<1>(d[i].last(),d[i].last() ))).first);
      ;
      if(loAxisIndex[i]>hiAxisIndex[i])
 {
   int tmp = hiAxisIndex[i];
   hiAxisIndex[i] = loAxisIndex[i];
   loAxisIndex[i] = tmp;
 }
      curnode[i] = loAxisIndex[i];
    }
  int count=0;
  while(1)
    {
      int nodeListIndex = blockIndex(curnode);
      if (!this->all_m[nodeListIndex]->domain().empty())
 {
   outDomain = intersect(fulld,this->all_m[nodeListIndex]->domain());
   ;
   *o = touchesConstruct(outDomain,
    this->all_m[nodeListIndex]->allocated(),
    this->all_m[nodeListIndex]->affinity(),
    this->all_m[nodeListIndex]->context(),
    this->all_m[nodeListIndex]->globalID(),
    this->all_m[nodeListIndex]->localID(),
    ctag);
   ++count;
 }
      curnode[0] += 1;
      for (i=0; i < Dim; ++i)
 {
   if (curnode[i] == (hiAxisIndex[i]+1))
     {
       if (i==(Dim-1))
  break;
       curnode[i] = loAxisIndex[i];
       curnode[i+1] += 1;
     }
 }
      if (curnode[Dim-1] == (hiAxisIndex[Dim-1]+1))
 break;
    }
  return count;
}
template <int Dim>
template <class OtherDomain, class OutIter, class ConstructTag>
int GridLayoutData<Dim>::touchesAlloc(const OtherDomain &fulld, OutIter o,
          const ConstructTag &ctag) const
{
  int i;
  ;
  typedef typename
    IntersectReturnType<Domain_t,OtherDomain>::Type_t OutDomain_t;
  OutDomain_t d = intersect(this->domain_m, fulld);
  if (d.empty())
    return 0;
  OutDomain_t outDomain = Pooma::NoInit();
  typedef Node<OutDomain_t,Domain_t> OutNode_t;
  int hiAxisIndex[Dim];
  int loAxisIndex[Dim];
  Loc<Dim> curnode;
  for (i=0; i < Dim; ++i)
    {
      loAxisIndex[i] =
 *((mapAloc_m[i].touch(Interval<1>(d[i].first(),d[i].first()))).first);
      ;
      hiAxisIndex[i] =
 *((mapAloc_m[i].touch(Interval<1>(d[i].last(),d[i].last()))).first);
      ;
      if(loAxisIndex[i]>hiAxisIndex[i])
 {
   int tmp = hiAxisIndex[i];
   hiAxisIndex[i] = loAxisIndex[i];
   loAxisIndex[i] = tmp;
 }
      curnode[i] = loAxisIndex[i];
    }
  int count=0;
  while(1)
    {
      int nodeListIndex = blockIndex(curnode);
      if (!this->all_m[nodeListIndex]->domain().empty())
 {
   outDomain = intersect(fulld,this->all_m[nodeListIndex]->allocated());
   ;
   *o = touchesConstruct(outDomain,
    this->all_m[nodeListIndex]->allocated(),
    this->all_m[nodeListIndex]->affinity(),
    this->all_m[nodeListIndex]->context(),
    this->all_m[nodeListIndex]->globalID(),
    this->all_m[nodeListIndex]->localID(),
    ctag);
   ++count;
 }
      curnode[0] += 1;
      for (i=0; i < Dim; ++i)
 {
   if (curnode[i] == (hiAxisIndex[i]+1))
     {
       if (i == (Dim-1))
  break;
       curnode[i] = loAxisIndex[i];
       curnode[i+1] += 1;
     }
 }
      if (curnode[Dim-1] == (hiAxisIndex[Dim-1]+1))
 break;
    }
  return count;
}
template<int Dim>
template<class Out>
void GridLayoutData<Dim>::print(Out & ostr)
{
  int i;
  ostr << " hasInternalGuards_m, hasExternalGuards_m "
       << this->hasInternalGuards_m << ' ' << this->hasExternalGuards_m
       << "\n internalGuards_m ";
  for (i=0; i<Dim; ++i)
    ostr << this->internalGuards_m.upper(i) << '-'
  << this->internalGuards_m.lower(i) << ' ';
  ostr << "\n externalGuards_m ";
  for (i=0; i<Dim; ++i)
    ostr << this->externalGuards_m.upper(i) << '-'
  << this->externalGuards_m.lower(i) << ' ';
  ostr << '\n';
  FillIterator_t gstart = this->gcFillList_m.begin();
  FillIterator_t gend = this->gcFillList_m.end();
  ostr << " this->gcFillList_m\n";
  for(; gstart!=gend; ++gstart)
    ostr << "       "
  << gstart->domain_m << ' '
  << gstart->ownedID_m << ' '
  << gstart->guardID_m << '\n';
  ostr << std::flush;
}
template <int Dim>
GridLayout<Dim>::GridLayout()
  : LayoutBase<Dim,GridLayoutData<Dim> >(new LayoutData_t()),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,const DistributedTag & )
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(gdom,
    GridPartition<Dim>(Loc<Dim>(1)),
    DistributedMapper<Dim>(GridPartition<Dim>(Loc<Dim>(1))))),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(gdom,
    GridPartition<Dim>(Loc<Dim>(1)),
    LocalMapper<Dim>())),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const GuardLayers_t &gcs,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(gdom,
    GridPartition<Dim>(Loc<Dim>(1),gcs),
    DistributedMapper<Dim>(
    GridPartition<Dim>(Loc<Dim>(1),gcs)))),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const GuardLayers_t &gcs,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(gdom,
    GridPartition<Dim>(Loc<Dim>(1),gcs),
    LocalMapper<Dim>())),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m =
      new LayoutData_t( gdom,
   GridPartition<Dim>(makeRGrid(gdom,blocks)),
        DistributedMapper<Dim>(GridPartition<Dim>(makeRGrid(gdom,blocks)))
   );
  else
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(blocks),
 DistributedMapper<Dim>(GridPartition<Dim>(blocks))
    );
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(makeRGrid(gdom,blocks)),
    LocalMapper<Dim>());
  else
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(blocks),
    LocalMapper<Dim>());
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const GuardLayers_t &gcs,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(makeRGrid(gdom,blocks),gcs),
       DistributedMapper<Dim>(GridPartition<Dim>(makeRGrid(gdom,blocks),gcs)));
  else
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(blocks,gcs),
       DistributedMapper<Dim>(GridPartition<Dim>(blocks,gcs)));
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const GuardLayers_t &gcs,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m = new LayoutData_t(gdom,
          GridPartition<Dim>(makeRGrid(gdom,blocks),gcs),
          LocalMapper<Dim>());
  else
    this->pdata_m = new LayoutData_t(gdom,
          GridPartition<Dim>(blocks,gcs),
          LocalMapper<Dim>());
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const GuardLayers_t &igcs,
       const GuardLayers_t &egcs,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m = new LayoutData_t( gdom,
      GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs),
      DistributedMapper<Dim>(
       GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs)));
  else
    this->pdata_m = new LayoutData_t( gdom,
      GridPartition<Dim>(blocks,igcs,egcs),
      DistributedMapper<Dim>(GridPartition<Dim>(blocks,igcs,egcs)));
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Loc<Dim> &blocks,
       const GuardLayers_t &igcs,
       const GuardLayers_t &egcs,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >((LayoutData_t*) 0),
    Observable<This_t>(*this)
{
  if (!gdom.empty())
    this->pdata_m = new LayoutData_t(
     gdom,
     GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs),
     LocalMapper<Dim>() );
  else
    this->pdata_m = new LayoutData_t( gdom,
    GridPartition<Dim>(blocks,igcs,egcs),
    LocalMapper<Dim>() );
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >(
      new LayoutData_t( grid,
   GridPartition<Dim>(grid),
   DistributedMapper<Dim>(GridPartition<Dim>(grid)))),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >(
      new LayoutData_t( grid,
   GridPartition<Dim>(grid),
   LocalMapper<Dim>())),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const GuardLayers_t &gcs,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
( new LayoutData_t( grid,
      GridPartition<Dim>(grid,gcs),
      DistributedMapper<Dim>(GridPartition<Dim>(grid,gcs) )) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const GuardLayers_t &gcs,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
( new LayoutData_t( grid,
      GridPartition<Dim>(grid,gcs),
      LocalMapper<Dim>()) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const GuardLayers_t &igcs,
       const GuardLayers_t &egcs,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(grid,
    GridPartition<Dim>(grid,igcs,egcs),
    DistributedMapper<Dim>(GridPartition<Dim>(grid,igcs,egcs)))),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const Grid<Dim> &grid,
       const GuardLayers_t &igcs,
       const GuardLayers_t &egcs,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t( grid,
     GridPartition<Dim>(grid,igcs,egcs),
     LocalMapper<Dim>() ) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Partitioner &gpar,
       const DistributedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
(new LayoutData_t(gdom,
    gpar,
    DistributedMapper<Dim>(gpar)) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Partitioner &gpar,
       const ReplicatedTag &)
  : LayoutBase<Dim,GridLayoutData<Dim> >
      (new LayoutData_t(gdom,
            gpar,
   LocalMapper<Dim>()) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
template <class Partitioner>
GridLayout<Dim>::GridLayout(const Domain_t &gdom,
       const Partitioner &gpar,
       const ContextMapper<Dim> &cmap)
  : LayoutBase<Dim,GridLayoutData<Dim> >(new LayoutData_t(gdom, gpar, cmap) ),
    Observable<This_t>(*this)
{
  this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim>::GridLayout(const This_t &model)
  : LayoutBase<Dim,GridLayoutData<Dim> >(model.pdata_m),
    Observable<This_t>(*this)
{
   this->pdata_m->attach(*this);
}
template <int Dim>
GridLayout<Dim> &GridLayout<Dim>::operator=(const This_t &model)
{
  if (this != &model)
    {
      this->pdata_m->detach(*this);
      this->pdata_m = model.pdata_m;
      this->pdata_m->attach(*this);
    }
  return *this;
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const DistributedTag &)
{
  this->pdata_m->initialize( gdom,
         GridPartition<Dim>(),
         DistributedMapper<Dim>(GridPartition<Dim>()) );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const GuardLayers_t &gcs,
     const DistributedTag &)
{
  this->pdata_m->initialize( gdom,
         GridPartition<Dim>(gcs),
         DistributedMapper<Dim>(GridPartition<Dim>(gcs)) );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const DistributedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize(
    gdom,
    GridPartition<Dim>(makeRGrid(gdom,blocks)),
    DistributedMapper<Dim>(GridPartition<Dim>(makeRGrid(gdom,blocks))));
  else
    this->pdata_m->initialize( gdom,
    GridPartition<Dim>(blocks),
    DistributedMapper<Dim>(GridPartition<Dim>(blocks)) );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const GuardLayers_t &gcs,
     const DistributedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize(
       gdom,
       GridPartition<Dim>(makeRGrid(gdom,blocks),gcs),
       DistributedMapper<Dim>(
                GridPartition<Dim>(makeRGrid(gdom,blocks),gcs)));
  else
    this->pdata_m->initialize(
   gdom,
   GridPartition<Dim>(blocks,gcs),
   DistributedMapper<Dim>(
     GridPartition<Dim>(blocks,gcs)) );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const GuardLayers_t &igcs,
     const GuardLayers_t &egcs,
     const DistributedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize(
      gdom,
      GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs),
      DistributedMapper<Dim>(
 GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs)));
  else
    this->pdata_m->initialize(
   gdom,
   GridPartition<Dim>(blocks,igcs,egcs),
   DistributedMapper<Dim>(
     GridPartition<Dim>(blocks,igcs,egcs)));
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const DistributedTag &)
{
  this->pdata_m->initialize( grid,
         GridPartition<Dim>(grid),
         DistributedMapper<Dim>(GridPartition<Dim>(grid)));
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const GuardLayers_t &gcs,
     const DistributedTag &)
{
  this->pdata_m->initialize( grid,
         GridPartition<Dim>(grid,gcs),
         DistributedMapper<Dim>(GridPartition<Dim>(grid,gcs)) );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const GuardLayers_t &igcs,
     const GuardLayers_t &egcs,
     const DistributedTag &)
{
  this->pdata_m->initialize(
        grid,
        GridPartition<Dim>(grid,igcs,egcs),
        DistributedMapper<Dim>(
   GridPartition<Dim>(grid,igcs,egcs)) );
}
template <int Dim>
template <class Partitioner>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Partitioner &gpar,
     const DistributedTag &)
{
  this->pdata_m->initialize(gdom,
        gpar,
        DistributedMapper<Dim>(gpar));
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const ReplicatedTag &)
{
  this->pdata_m->initialize( gdom, GridPartition<Dim>(),LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const GuardLayers_t &gcs,
     const ReplicatedTag &)
{
  this->pdata_m->initialize( gdom, GridPartition<Dim>(gcs),LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const ReplicatedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize(
   gdom,
   GridPartition<Dim>(makeRGrid(gdom,blocks)),
   LocalMapper<Dim>() );
  else
    this->pdata_m->initialize(
   gdom,
   GridPartition<Dim>(blocks),
   LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const GuardLayers_t &gcs,
     const ReplicatedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize( gdom,
    GridPartition<Dim>(makeRGrid(gdom,blocks),gcs),
    LocalMapper<Dim>() );
  else
    this->pdata_m->initialize( gdom,
    GridPartition<Dim>(blocks,gcs),
    LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Loc<Dim> &blocks,
     const GuardLayers_t &igcs,
     const GuardLayers_t &egcs,
     const ReplicatedTag &)
{
  if (!gdom.empty())
    this->pdata_m->initialize(
       gdom,
       GridPartition<Dim>(makeRGrid(gdom,blocks),igcs,egcs),
       LocalMapper<Dim>() );
  else
    this->pdata_m->initialize(
   gdom,
   GridPartition<Dim>(blocks,igcs,egcs),
   LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const ReplicatedTag &)
{
  this->pdata_m->initialize( grid,
         GridPartition<Dim>(grid),
         LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const GuardLayers_t &gcs,
     const ReplicatedTag &)
{
  this->pdata_m->initialize(
        grid,
        GridPartition<Dim>(grid,gcs),
        LocalMapper<Dim>() );
}
template <int Dim>
void GridLayout<Dim>::initialize(const Grid<Dim> &grid,
     const GuardLayers_t &igcs,
     const GuardLayers_t &egcs,
     const ReplicatedTag &)
{
  this->pdata_m->initialize(
        grid,
        GridPartition<Dim>(grid,igcs,egcs),
        LocalMapper<Dim>() );
}
template <int Dim>
template <class Partitioner>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Partitioner &gpar,
     const ReplicatedTag &)
{
  this->pdata_m->initialize(gdom,
        gpar,
        LocalMapper<Dim>());
}
template <int Dim>
void GridLayout<Dim>::initialize(const Domain_t& idom,
     const List_t& nodes,
     const Loc<Dim>& blocks,
     bool hasIG, bool hasEG,
     const GuardLayers_t& ig,
     const GuardLayers_t& eg)
{
  this->pdata_m->initialize(idom,nodes,blocks,hasIG,hasEG,ig,eg);
}
template <int Dim>
template <class Partitioner>
void GridLayout<Dim>::initialize(const Domain_t &gdom,
     const Partitioner &gpar,
     const ContextMapper<Dim> &cmap)
{
  this->pdata_m->initialize(gdom, gpar, cmap);
}
template <int Dim>
template <class Ostream>
void GridLayout<Dim>::print(Ostream &ostr) const
{
  ostr << "GridLayout " << this->ID() << " on global domain "
       << this->domain() << ":" << '\n';
  ostr << "   Total subdomains: " << this->sizeGlobal() << '\n';
  ostr << "   Local subdomains: " << this->sizeLocal() << '\n';
  ostr << "  Remote subdomains: " << this->sizeRemote() << '\n';
  ostr << "        Grid blocks: " << this->blocks() << '\n';
  typename GridLayout<Dim>::const_iterator a;
  for (a = this->beginGlobal(); a != this->endGlobal(); ++a)
    ostr << "  Global subdomain = " << *a << '\n';
  for (a = this->beginLocal(); a != this->endLocal(); ++a)
    ostr << "   Local subdomain = " << *a << '\n';
  for (a = this->beginRemote(); a != this->endRemote(); ++a)
    ostr << "  Remote subdomain = " << *a << '\n';
  this->pdata_m->print(ostr);
}
template<int Dim, int Dim2>
template <class Ostream>
void GridLayoutView<Dim, Dim2>::print(Ostream &ostr) const
{
  ostr << "GridLayoutView " << this->ID() << " on global domain "
       << this->domain() << ':' << '\n';
  ostr << "   Base ID:          " << this->baseID() << '\n';
  ostr << "   Base domain:      " << this->baseDomain() << '\n';
  ostr << "   Total subdomains: " << this->sizeGlobal() << '\n';
  ostr << "   Local subdomains: " << this->sizeLocal() << '\n';
  ostr << "  Remote subdomains: " << this->sizeRemote() << '\n';
  const_iterator a;
  for (a = this->beginGlobal(); a != this->endGlobal(); ++a)
    ostr << "  Global subdomain = " << *a << '\n';
  for (a = this->beginLocal(); a != this->endLocal(); ++a)
    ostr << "   Local subdomain = " << *a << '\n';
  for (a = this->beginRemote(); a != this->endRemote(); ++a)
    ostr << "  Remote subdomain = " << *a << '\n';
}
template<int OriginalDim, class ViewedEngineTag>
struct ViewEngine
{
  ViewEngine() {};
  ~ViewEngine() {};
 };
template<int Dim, class T, int OriginalDim, class ViewedEngineTag>
class Engine<Dim, T, ViewEngine<OriginalDim, ViewedEngineTag> >
{
public:
  typedef ViewEngine<OriginalDim, ViewedEngineTag> Tag_t;
  typedef Engine<Dim, T, Tag_t> This_t;
  typedef This_t Engine_t;
  typedef Engine<OriginalDim, T, ViewedEngineTag> ViewedEngine_t;
  typedef ViewIndexer<Dim, OriginalDim> Indexer_t;
  typedef Interval<Dim> Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  enum { dimensions = Dim };
  enum { hasDataObject = ViewedEngine_t::hasDataObject };
  enum { dynamic = false };
  enum { zeroBased = true };
  enum { multiPatch = ViewedEngine_t::multiPatch };
  Engine()
    : eng_m()
  {
  }
  template<class DT>
  Engine(const Engine<Dim, T, ViewedEngineTag> &e, const Domain<Dim, DT> &dom)
    : eng_m(e), indexer_m(dom)
  {
    PoomaCTAssert<(OriginalDim == Dim)>::test();
  }
  template<class DT>
  Engine(const Engine<OriginalDim, T, ViewedEngineTag> &e,
  const SliceDomain<DT> &dom)
    : eng_m(e), indexer_m(dom)
  {
    PoomaCTAssert<(DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<(DT::dimensions == OriginalDim)>::test();
  }
  template<class Domain>
  Engine(const Engine<Dim, T, ViewedEngineTag> &e, const Node<Domain> &node)
    : eng_m(e), indexer_m(node.domain())
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
  }
  Engine(const Engine<Dim, T, ViewedEngineTag> &e, const INode<Dim> &inode)
    : eng_m(e), indexer_m(inode.domain())
  { }
  template<class DT>
  Engine(const Engine<Dim, T, ViewEngine<OriginalDim, ViewedEngineTag> > &e,
  const Domain<Dim, DT> &dom)
    : eng_m(e.viewedEngine()), indexer_m(e.indexer(), dom)
  {
  }
  template<int OrigDim, class DT>
  Engine(const Engine<OrigDim, T, ViewEngine<OriginalDim, ViewedEngineTag> > &e,
  const SliceDomain<DT> &dom)
    : eng_m(e.viewedEngine()), indexer_m(e.indexer(), dom)
  {
    PoomaCTAssert<(DT::sliceDimensions == Dim)>::test();
    PoomaCTAssert<(DT::dimensions == OrigDim)>::test();
  }
  template<class Domain>
  Engine(const Engine<Dim, T, ViewEngine<OriginalDim, ViewedEngineTag> > &e,
  const Node<Domain> &node)
    : eng_m(e.viewedEngine()), indexer_m(e.indexer(), node.domain())
  {
    PoomaCTAssert<(Domain::dimensions == Dim)>::test();
  }
  Engine(const Engine<Dim, T, ViewEngine<OriginalDim, ViewedEngineTag> > &e,
  const INode<Dim> &inode)
    : eng_m(e.viewedEngine()), indexer_m(e.indexer(), inode.domain())
  { }
  Engine(const Engine<Dim, T, ViewEngine<OriginalDim, ViewedEngineTag> >
  &model)
    : eng_m(model.viewedEngine()), indexer_m(model.indexer())
  { }
  This_t &operator=(const This_t &rhs)
  {
    eng_m = rhs.viewedEngine();
    indexer_m = rhs.indexer();
    return *this;
  }
  inline Element_t read(int i0) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1, int i2) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, i2, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1, int i2, int i3) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, i2, i3, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, i2, i3, i4, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4, int i5) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, i2, i3, i4, i5, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4,
   int i5, int i6) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(i0, i1, i2, i3, i4, i5, i6, oloc);
    return eng_m.read(oloc);
  }
  inline Element_t read(const Loc<Dim> &loc) const
  {
    Loc<OriginalDim> oloc;
    indexer_m.translate(loc, oloc);
    return eng_m.read(oloc);
  }
  inline const Domain_t &domain() const { return indexer_m.domain(); }
  inline Layout_t layout() const { return Layout_t(domain()); }
  inline int first(int i) const
  {
    ;
    return 0;
  }
  inline const ViewedEngine_t &viewedEngine() const { return eng_m; }
  inline const Indexer_t &indexer() const { return indexer_m; }
  template<class RequestType>
  inline
  typename DataObjectRequest<RequestType>::Type_t
  dataObjectRequest(const DataObjectRequest<RequestType>& f) const
  {
    return eng_m.dataObjectRequest(f);
  }
private:
  ViewedEngine_t eng_m;
  Indexer_t indexer_m;
};
template <int Dim, class T, int D2, class ViewedTag>
struct NewEngine< Engine<Dim,T,ViewEngine<D2,ViewedTag> >, Interval<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Type_t;
};
template <int Dim, class T, int D2, class ViewedTag>
struct NewEngine< Engine<Dim,T,ViewEngine<D2,ViewedTag> >, Range<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Type_t;
};
template <int Dim, class T, int D2, class ViewedTag, int SliceDim>
struct NewEngine< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  SliceInterval<Dim, SliceDim> >
{
  typedef Engine<SliceDim, T, ViewEngine<D2, ViewedTag> > Type_t;
};
template <int Dim, class T, int D2, class ViewedTag, int SliceDim>
struct NewEngine< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  SliceRange<Dim, SliceDim> >
{
  typedef Engine<SliceDim, T, ViewEngine<D2, ViewedTag> > Type_t;
};
template <int Dim, class T, int D2, class ViewedTag>
struct NewEngine< Engine<Dim, T, ViewEngine<D2, ViewedTag> >, INode<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Engine_t;
  typedef typename Engine_t::ViewedEngine_t ViewedEngine_t;
  typedef typename NewEngine<ViewedEngine_t,
    INode<D2> >::Type_t NewViewedEngine_t;
  typedef typename NewEngine<NewViewedEngine_t,
    SliceRange<D2, Dim> >::Type_t Type_t;
};
template <int Dim, class T, int D2, class ViewedTag>
struct NewEngineEngine< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  INode<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Engine_t;
  typedef typename NewEngine< Engine_t, INode<Dim> >::NewViewedEngine_t Type_t;
  static inline Type_t
  apply(const Engine_t &e, const INode<Dim> &inode)
  {
    Range<D2> base;
    e.indexer().localToBase(inode.domain(), base);
    Interval<D2> baseInt;
    int i;
    for (i = 0; i < D2; ++i)
    {
      baseInt[i] = Interval<1>(base[i].first(), base[i].last());
    }
    INode<D2> viewNode(inode, baseInt);
    return Type_t(e.viewedEngine(), viewNode);
  }
};
template <int Dim, class T, int D2, class ViewedTag>
struct NewEngineDomain< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  INode<Dim> >
{
  typedef SliceRange<D2, Dim> Type_t;
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Engine_t;
  static inline Type_t
  apply(const Engine_t &e, const INode<Dim> &inode)
  {
    SliceRange<D2, Dim> base;
    e.indexer().localToBase(inode.domain(), base);
    base.totalDomain() -= base.totalDomain().firsts();
    base.setSliceFromTotal();
    return base;
  }
};
template <int Dim, class T, class ViewedTag>
struct NewEngine<Engine<Dim, T, ViewEngine<Dim, ViewedTag> >, INode<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, ViewedTag> > Engine_t;
  typedef typename Engine_t::ViewedEngine_t ViewedEngine_t;
  typedef typename NewEngine<ViewedEngine_t,
    INode<Dim> >::Type_t NewViewedEngine_t;
  typedef typename NewEngine<NewViewedEngine_t,
    Range<Dim> >::Type_t Type_t;
};
template <int Dim, class T, class ViewedTag>
struct NewEngineEngine<Engine<Dim, T, ViewEngine<Dim, ViewedTag> >,
  INode<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, ViewedTag> > Engine_t;
  typedef typename NewEngine<Engine_t, INode<Dim> >::NewViewedEngine_t Type_t;
  static inline Type_t
  apply(const Engine_t &e, const INode<Dim> &inode)
  {
    Range<Dim> base;
    e.indexer().localToBase(inode.domain(), base);
    Interval<Dim> baseInt;
    int i;
    for (i = 0; i < Dim; ++i)
    {
      baseInt[i] = Interval<1>(base[i].first(), base[i].last());
    }
    INode<Dim> viewNode(inode, baseInt);
    return Type_t(e.viewedEngine(), viewNode);
  }
};
template <int Dim, class T, class ViewedTag>
struct NewEngineDomain< Engine<Dim, T, ViewEngine<Dim, ViewedTag> >,
  INode<Dim> >
{
  typedef Range<Dim> Type_t;
  typedef Engine<Dim, T, ViewEngine<Dim, ViewedTag> > Engine_t;
  static inline Type_t
  apply(const Engine_t &e, const INode<Dim> &inode)
  {
    Range<Dim> base;
    e.indexer().localToBase(inode.domain(), base);
    base -= base.firsts();
    return base;
  }
};
template<int OriginalDim, class ViewedEngineTag>
struct EvaluatorEngineTraits<ViewEngine<OriginalDim, ViewedEngineTag> >
{
  typedef typename EvaluatorEngineTraits<ViewedEngineTag>::Evaluator_t
  Evaluator_t;
};
template<int Dim, int ViewD1, int ViewD2>
class ViewIntersector
{
public:
  typedef IntersectorData<Dim> IntersectorData_t;
  typedef ViewIntersector<Dim, ViewD1, ViewD2> This_t;
  typedef typename IntersectorData_t::IDContainer_t IDContainer_t;
  typedef typename IntersectorData_t::BaseDomain_t BaseDomain_t;
  typedef typename IntersectorData_t::BaseDomainContainer_t
                                                        BaseDomainContainer_t;
  typedef typename IntersectorData_t::INode_t INode_t;
  typedef typename IntersectorData_t::INodeContainer_t INodeContainer_t;
  typedef typename IntersectorData_t::const_iterator const_iterator;
  typedef RefCountedPtr<IntersectorData_t> DataPtr_t;
  typedef ViewIndexer<ViewD1, ViewD2> Indexer_t;
  enum { dimensions = Dim };
  ViewIntersector(const ViewIndexer<ViewD1, ViewD2> &indexer,
    const Intersector<Dim> &model)
    : pdata_m(model.data()), indexer_m(indexer)
  {
    PoomaCTAssert<(Dim == ViewD1)>::test();
  }
  This_t &operator=(const This_t &model)
  {
    if (this != &model)
    {
      indexer_m = model.indexer_m;
      pdata_m = model.pdata_m;
    }
    return *this;
  }
  ~ViewIntersector() { }
  inline DataPtr_t &data() { return pdata_m; }
  inline const DataPtr_t &data() const { return pdata_m; }
  inline const_iterator begin() const { return data()->inodes_m.begin(); }
  inline const_iterator end() const { return data()->inodes_m.end(); }
  template<class Engine>
  inline
  void intersect(const Engine &e)
  {
    int n = data()->ids_m.size();
    typedef INode<ViewD2> INode2_t;
    typedef std::vector<INode2_t> INode2Container_t;
    INode2Container_t inodes2;
    int id = e.layout().ID();
    if (n == 0)
    {
      Range<ViewD2> base = indexer_m.baseDomain();
      e.layout().touches(base,
    std::back_inserter(inodes2),
    TouchesConstructINode<ViewD2>(id, GlobalIDDataBase::
             nullNodeKey(),
             &(data()->gidStore_m))
    );
      int i;
      int ni = inodes2.size();
      for (i = 0; i < ni; i++)
      {
 Interval<Dim> ival1;
 indexer_m.baseToLocalInterval(inodes2[i].domain(), ival1);
 INode<Dim> inode(inodes2[i], ival1);
 data()->inodes_m.push_back(inode);
      }
    }
    else
    {
      int ni = data()->inodes_m.size();
      int i;
      for (i = 0; i < ni; i++)
      {
 Range<ViewD2> range;
 indexer_m.localToBase(data()->inodes_m[i].domain(), range);
 e.layout().touches(range,
      std::back_inserter(inodes2),
      INode<ViewD2>::touchesConstructINode(id,
         data()->inodes_m[i])
      );
      }
      data()->inodes_m.erase(data()->inodes_m.begin(),
        data()->inodes_m.begin() + ni);
      ni = inodes2.size();
      for (i = 0; i < ni; i++)
      {
 Interval<Dim> ival1;
 indexer_m.baseToLocalInterval(inodes2[i].domain(), ival1);
 INode<Dim> inode(inodes2[i], ival1);
 data()->inodes_m.push_back(inode);
      }
    }
  }
  template<class Engine, int Dim2>
  inline
  bool intersect(const Engine &l, const GuardLayers<Dim2> &guard)
  {
    return (data()->intersect(l,guard));
  }
private:
  DataPtr_t pdata_m;
  Indexer_t indexer_m;
};
template <int Dim, class T, int D2, class ViewedTag, class Intersect>
struct LeafFunctor< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  ExpressionApply<IntersectorTag<Intersect> > >
{
  typedef int Type_t;
  typedef Engine<Dim, T, ViewEngine<D2, ViewedTag> > Engine_t;
  static Type_t
  apply(const Engine_t &,
 const ExpressionApply<IntersectorTag<Intersect> > &,
 const WrappedInt<false> &)
  {
    return 0;
  }
  static Type_t
  apply(const Engine_t &engine,
 const ExpressionApply<IntersectorTag<Intersect> > &tag,
 const WrappedInt<true> &)
  {
    enum { d1 = Intersect::dimensions };
    ViewIntersector<d1, Dim, D2> newIntersector(engine.indexer(),
      tag.tag().intersector_m);
    ExpressionApply<IntersectorTag<ViewIntersector<d1, Dim, D2> > >
      newTag(newIntersector);
    forEach(engine.viewedEngine(), newTag, NullCombine());
    return 0;
  }
  static Type_t
  apply(const Engine_t &engine,
 const ExpressionApply<IntersectorTag<Intersect> > &tag)
  {
    enum { multiPatch =
    Engine<Dim, T, ViewEngine<D2, ViewedTag> >::multiPatch };
    return apply(engine, tag, WrappedInt<multiPatch>());
  }
};
template<class RequestType> class DataObjectRequest;
template <int Dim, class T, int D2, class ViewedTag, class RequestType>
struct EngineFunctor< Engine<Dim, T, ViewEngine<D2, ViewedTag> >,
  DataObjectRequest<RequestType> >
{
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, ViewEngine<D2, ViewedTag> > &engine,
 const DataObjectRequest<RequestType> &tag)
  {
    return engineFunctor(engine.viewedEngine(), tag);
  }
};
template <int D, class T, int D2, class E, class Tag>
struct LeafFunctor<Engine<D, T, ViewEngine<D2, E> >, ExpressionApply<Tag> >
{
  typedef Engine<D, T, ViewEngine<D2, E> > Subject_t;
  typedef typename Subject_t::ViewedEngine_t Engine_t;
  typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  static
  Type_t apply(const Subject_t &engine, const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(engine.viewedEngine(), tag);
  }
};
template<class Functor>
struct IndexFunction
{
  typedef Functor Functor_t;
};
template<int Dim, class Functor>
struct IndexFunctionView
{ };
template<int Dim, class T, class Functor>
class Engine<Dim, T, IndexFunction<Functor> >
{
public:
  typedef IndexFunction<Functor> Tag_t;
  typedef Engine<Dim, T, Tag_t> This_t;
  typedef This_t Engine_t;
  typedef Interval<Dim> Domain_t;
  typedef DomainLayout<Dim> Layout_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  enum { dimensions = Dim };
  enum { hasDataObject = false };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = false };
  Engine() { }
  explicit Engine(const Domain_t &domain, const Functor &f = Functor())
  : funct_m(f), domain_m(domain)
  {
  }
  template<class Layout>
  explicit Engine(const Layout &layout, const Functor &f = Functor())
  : funct_m(f), domain_m(layout.domain())
  {
  }
  Engine(const This_t &model)
  : funct_m(model.functor()), domain_m(model.domain())
  {
  }
  This_t &operator=(const This_t &rhs)
  {
    domain_m = rhs.domain();
    funct_m = rhs.functor();
    return *this;
  }
  inline Element_t read(int i0) const
    {
      return funct_m(i0);
    }
  inline Element_t read(int i0, int i1) const
    {
      return funct_m(i0, i1);
    }
  inline Element_t read(int i0, int i1, int i2) const
    {
      return funct_m(i0, i1, i2);
    }
  inline Element_t read(int i0, int i1, int i2, int i3) const
    {
      return funct_m(i0, i1, i2, i3);
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4) const
    {
      return funct_m(i0, i1, i2, i3, i4);
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4,
    int i5) const
    {
      return funct_m(i0, i1, i2, i3, i4, i5);
    }
  inline Element_t read(int i0, int i1, int i2, int i3, int i4,
    int i5, int i6) const
    {
      return funct_m(i0, i1, i2, i3, i4, i5, i6);
    }
  inline Element_t read(const Loc<1> &loc) const
    {
      return funct_m(loc[0].first());
    }
  inline Element_t read(const Loc<2> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first());
    }
  inline Element_t read(const Loc<3> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first(), loc[2].first());
    }
  inline Element_t read(const Loc<4> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first(), loc[2].first(),
        loc[3].first());
    }
  inline Element_t read(const Loc<5> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first(), loc[2].first(),
        loc[3].first(), loc[4].first());
    }
  inline Element_t read(const Loc<6> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first(), loc[2].first(),
        loc[3].first(), loc[4].first(), loc[5].first());
    }
  inline Element_t read(const Loc<7> &loc) const
    {
      return funct_m(loc[0].first(), loc[1].first(), loc[2].first(),
        loc[3].first(), loc[4].first(), loc[5].first(), loc[6].first());
    }
  inline const Domain_t &domain() const { return domain_m; }
  void setDomain(const Domain_t &dom) { domain_m = dom; }
  inline int first(int i) const
  {
    ;
    return domain_m[i].first();
  }
  Layout_t layout() const
  {
    return Layout_t(domain_m);
  }
  const Functor &functor() const { return funct_m; }
  void setFunctor(const Functor &f) { funct_m = f; }
private:
  Functor funct_m;
  Domain_t domain_m;
};
template <int Dim, class T, class Functor>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >, Interval<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
template <int Dim, class T, class Functor>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >, Range<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
template <int Dim, class T, class Functor, int SliceDim>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >,
  SliceInterval<Dim, SliceDim> >
{
  typedef Engine<SliceDim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
template <int Dim, class T, class Functor, int SliceDim>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >,
  SliceRange<Dim, SliceDim> >
{
  typedef Engine<SliceDim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
template <int Dim, class T, class Functor, class Domain>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >, Node<Domain> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
template <int Dim, class T, class Functor>
struct NewEngine<Engine<Dim, T, IndexFunction<Functor> >, INode<Dim> >
{
  typedef Engine<Dim, T, ViewEngine<Dim, IndexFunction<Functor> > > Type_t;
};
class IotaFunctor
{
public:
  inline IotaFunctor() { }
  inline IotaFunctor(const IotaFunctor &) { }
  inline IotaFunctor &operator=(const IotaFunctor &) { return *this; }
  inline
  Vector<1, int> operator()(int i1) const
  {
    return Vector<1, int>(i1);
  }
  inline
  Vector<2, int> operator()(int i1, int i2) const
  {
    return Vector<2, int>(i1, i2);
  }
  inline
  Vector<3, int> operator()(int i1, int i2, int i3) const
  {
    return Vector<3, int>(i1, i2, i3);
  }
};
template<int Dim>
struct Iota
{
  typedef Array<Dim, Vector<Dim, int>, IndexFunction<IotaFunctor> >
    Iota_t;
  typedef typename ComponentView<Loc<1>, Iota_t>::Type_t Index_t;
};
template<int Dim>
inline
typename Iota<Dim>::Iota_t
iota(const Interval<Dim> &domain)
{
  typedef typename Iota<Dim>::Iota_t Iota_t;
  return Iota_t(domain);
}
template<int Dim>
inline
typename Iota<Dim>::Index_t
iotaIndex(const Interval<Dim> &domain, int i)
{
  typedef typename Iota<Dim>::Iota_t Iota_t;
  return Iota_t(domain).comp(i);
}
inline
Array<1, Vector<1, int>, IndexFunction<IotaFunctor> >
iota(int i1);
inline
Array<1, Vector<1, int>, IndexFunction<IotaFunctor> >
iota(int i1)
{
  return Array<1, Vector<1, int>,
    IndexFunction<IotaFunctor> >(Interval<1>(i1));
}
inline
Array<2, Vector<2, int>, IndexFunction<IotaFunctor> >
iota(int i1, int i2);
inline
Array<2, Vector<2, int>, IndexFunction<IotaFunctor> >
iota(int i1, int i2)
{
  return Array<2, Vector<2, int>,
    IndexFunction<IotaFunctor> >(Interval<2>(i1, i2));
}
inline
Array<3, Vector<3, int>, IndexFunction<IotaFunctor> >
iota(int i1, int i2, int i3);
inline
Array<3, Vector<3, int>, IndexFunction<IotaFunctor> >
iota(int i1, int i2, int i3)
{
  return Array<3, Vector<3, int>,
    IndexFunction<IotaFunctor> >(Interval<3>(i1, i2, i3));
}
template<class Functor, class ArgumentType>
struct FunctorResult
{
  typedef ArgumentType Type_t;
};
template<int D, class T, class E> class Array;
template<class UserFunction, class Expression>
struct UserFunctionEngine
{ };
template<int D, class T, class UserFunction, class Expression>
class Engine< D, T, UserFunctionEngine<UserFunction,Expression> >
{
public:
  typedef UserFunctionEngine<UserFunction,Expression> Tag_t;
  typedef Engine<D,T,Tag_t> This_t;
  typedef This_t Engine_t;
  typedef typename Expression::Domain_t Domain_t;
  typedef typename Expression::Layout_t Layout_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  typedef typename Expression::Engine_t ExprEngine_t;
  enum { dimensions = D };
  enum { hasDataObject = ExprEngine_t::hasDataObject };
  enum { dynamic = false };
  enum { zeroBased = ExprEngine_t::zeroBased };
  enum { multiPatch = ExprEngine_t::multiPatch };
  Engine(const UserFunction& s, const Expression& e)
    : userFunction_m(s), expression_m(e) {}
  template<class OtherE, class Domain>
  Engine(const Engine<D,T,UserFunctionEngine<UserFunction,OtherE> >& e,
  const Domain& d)
    : userFunction_m(e.userFunction()),
      expression_m( e.expression(), d ) {}
  inline Element_t read(const Loc<D> &loc) const
  {
    return userFunction_m(expression_m.read(loc));
  }
  inline Element_t read(int i) const
  {
    return userFunction_m(expression_m.read(i));
  }
  inline Element_t read(int i, int j) const
  {
    return userFunction_m(expression_m.read(i,j));
  }
  inline Element_t read(int i, int j, int k) const
  {
    return userFunction_m(expression_m.read(i,j,k));
  }
  inline Element_t read(int i, int j, int k, int l) const
  {
    return userFunction_m(expression_m.read(i,j,k,l));
  }
  inline Element_t read(int i, int j, int k, int l,int m) const
  {
    return userFunction_m(expression_m.read(i,j,k,l,m));
  }
  inline Element_t read(int i, int j, int k, int l,int m,int n) const
  {
    return userFunction_m(expression_m.read(i,j,k,l,m,n));
  }
  inline Element_t read(int i, int j, int k, int l,int m,int n,int o) const
  {
    return userFunction_m(expression_m.read(i,j,k,l,m,n,o));
  }
  inline Element_t operator()(const Loc<D> &loc) const
  {
    return userFunction_m(expression_m(loc));
  }
  inline Element_t operator()(int i) const
  {
    return userFunction_m(expression_m(i));
  }
  inline Element_t operator()(int i, int j) const
  {
    return userFunction_m(expression_m(i,j));
  }
  inline Element_t operator()(int i, int j, int k) const
  {
    return userFunction_m(expression_m(i,j,k));
  }
  inline Element_t operator()(int i, int j, int k, int l) const
  {
    return userFunction_m(expression_m(i,j,k,l));
  }
  inline Element_t operator()(int i, int j, int k, int l,int m) const
  {
    return userFunction_m(expression_m(i,j,k,l,m));
  }
  inline Element_t operator()(int i, int j, int k, int l,int m,int n) const
  {
    return userFunction_m(expression_m(i,j,k,l,m,n));
  }
  inline Element_t operator()(int i, int j, int k, int l,int m,int n,int o)
    const
  {
    return userFunction_m(expression_m(i,j,k,l,m,n,o));
  }
  inline const Domain_t& domain() const { return expression_m.domain(); }
  inline int first(int d) const
  {
    return expression_m.first(d);
  }
  const UserFunction& userFunction() const { return userFunction_m; }
  const Expression& expression() const { return expression_m; }
  template<class RequestType>
  inline
  typename DataObjectRequest<RequestType>::Type_t
  dataObjectRequest(const DataObjectRequest<RequestType>& f) const
  {
    return engineFunctor(expression_m.engine(),f);
  }
private:
  UserFunction userFunction_m;
  Expression expression_m;
};
template<class Func> class UserFunction;
template<class Func,int D,class T,class E>
struct View1<UserFunction<Func>,Array<D,T,E> >
{
  typedef Array<D,T,E> Expr_t;
  typedef UserFunctionEngine<Func,Expr_t> NewTag_t;
  typedef typename FunctorResult<Func,T>::Type_t NewT_t;
  typedef Engine<D,NewT_t,NewTag_t> NewEngine_t;
  typedef Array<D,NewT_t,NewTag_t> Type_t;
};
template<class Func>
class UserFunction
{
public:
  UserFunction()
  { }
  UserFunction(const Func &func)
    : function_m(func)
  { }
  template<class Init>
  UserFunction(const Init &init)
    : function_m(init)
  { }
  template<class I1, class I2>
  UserFunction(const I1 &i1, const I2 &i2)
    : function_m(i1,i2)
  { }
  template<class I1, class I2, class I3>
  UserFunction(const I1 &i1, const I2 &i2, const I3 &i3)
    : function_m(i1,i2,i3)
  { }
  template<class I1, class I2, class I3, class I4>
  UserFunction(const I1 &i1, const I2 &i2, const I3 &i3, const I4 &i4)
    : function_m(i1,i2,i3,i4)
  { }
  template<class I1, class I2, class I3, class I4, class I5>
  UserFunction(const I1 &i1, const I2 &i2, const I3 &i3, const I4 &i4,
        const I5 &i5)
    : function_m(i1,i2,i3,i4,i5)
  { }
  template<class I1, class I2, class I3, class I4, class I5, class I6>
  UserFunction(const I1 &i1, const I2 &i2, const I3 &i3, const I4 &i4,
        const I5 &i5, const I6 &i6)
    : function_m(i1,i2,i3,i4,i5,i6)
  { }
  template<class I1, class I2, class I3, class I4, class I5, class I6,
    class I7>
  UserFunction(const I1 &i1, const I2 &i2, const I3 &i3, const I4 &i4,
        const I5 &i5, const I6 &i6, const I7 &i7)
    : function_m(i1,i2,i3,i4,i5,i6,i7)
  { }
  template<int D, class T, class E>
  typename View1<UserFunction<Func>,Array<D,T,E> >::Type_t
  operator()(const Array<D,T,E>& expr) const
  {
    typedef typename View1<UserFunction<Func>,Array<D,T,E> >::NewEngine_t
      NewEngine_t;
    typedef typename View1<UserFunction<Func>,Array<D,T,E> >::Type_t
      Type_t;
    return Type_t(NewEngine_t(function(),expr));
  }
  inline Func &function() { return function_m; }
  inline const Func &function() const { return function_m; }
private:
  Func function_m;
};
template <int Dim, class T, class S, class E, class Domain>
struct NewEngine< Engine<Dim,T,UserFunctionEngine<S,E> >, Domain >
{
  typedef typename View1<E,Domain>::Type_t NewExpr_t;
  typedef UserFunctionEngine<S,NewExpr_t> NewTag_t;
  typedef typename NewExpr_t::Element_t OldElement_t;
  typedef typename FunctorResult<S,OldElement_t>::Type_t NewElement_t;
  typedef Engine<Dim,NewElement_t,NewTag_t> Type_t;
};
template<class UserFunction,class Expression>
struct EvaluatorEngineTraits<UserFunctionEngine<UserFunction,Expression> >
{
  typedef typename Expression::Engine_t Engine_t;
  typedef typename Engine_t::Tag_t Tag_t;
  typedef typename EvaluatorEngineTraits<Tag_t>::Evaluator_t Evaluator_t;
};
template <int Dim, class T, class S, class E, class EFTag>
struct EngineFunctor<Engine<Dim, T, UserFunctionEngine<S, E> >, EFTag>
{
  typedef typename EngineFunctor<E, EFTag>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, UserFunctionEngine<S, E> > &engine,
 const EFTag &tag)
  {
    return engineFunctor(engine.expression(), tag);
  }
};
template <int D, class T, class Func, class Expr, class Tag>
struct LeafFunctor<Engine<D, T, UserFunctionEngine<Func, Expr> >,
  EngineView<Tag> >
{
  typedef LeafFunctor<Expr, EngineView<Tag> > LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t NewViewed_t;
  typedef Engine<D, T, UserFunctionEngine<Func, NewViewed_t> > Type_t;
  static
  Type_t apply(const Engine<D, T, UserFunctionEngine<Func, Expr> > &engine,
        const EngineView<Tag> &tag)
  {
    return Type_t(engine.userFunction(),
    LeafFunctor_t::apply(engine.expression(), tag));
  }
};
template <int D, class T, class Func, class Expr, class Tag>
struct LeafFunctor<Engine<D, T, UserFunctionEngine<Func, Expr> >,
  ExpressionApply<Tag> >
{
  typedef LeafFunctor<Expr, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  static
  Type_t apply(const Engine<D, T, UserFunctionEngine<Func, Expr> > &engine,
        const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(engine.expression(), tag);
  }
};
template<int D, class T, class E> class Array;
template<class M, class T, class E> class Field;
template<class ST> class Stencil;
template<class Function, class Expression>
struct StencilEngine
{
  typedef typename Expression::Element_t ViewedElement_t;
  typedef typename FunctorResult<Function,ViewedElement_t>::Type_t Element_t;
};
template<class Function, int D>
inline
Interval<D> insetDomain(const Function &f, const Interval<D> &domain)
{
  Interval<D> ret;
  int d;
  for (d = 0; d < D; ++d)
  {
    ret[d] = Interval<1>(domain[d].first() + f.lowerExtent(d),
    domain[d].last() - f.upperExtent(d));
  }
  return ret;
}
template<int D, class T, class Function, class Expression>
class Engine<D, T, StencilEngine<Function, Expression> >
{
public:
  typedef StencilEngine<Function, Expression> Tag_t;
  typedef Engine<D, T, Tag_t> This_t;
  typedef This_t Engine_t;
  typedef Interval<D> Domain_t;
  typedef DomainLayout<D> Layout_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  typedef typename Expression::Engine_t ExprEngine_t;
  enum { dimensions = D };
  enum { hasDataObject = ExprEngine_t::hasDataObject };
  enum { dynamic = false };
  enum { multiPatch = ExprEngine_t::multiPatch };
  enum { zeroBased = true };
  Engine()
    : function_m(), expression_m(), domain_m(Pooma::NoInit())
  {
  }
  template <class Layout2>
  explicit Engine(const Layout2 &layout)
    : function_m(), expression_m(), domain_m(layout.domain())
  {
  }
  Engine(const Function &f, const Expression &e)
    : function_m(f), expression_m(e), domain_m(Pooma::NoInit())
  {
    Interval<D> inset = insetDomain(f, e.domain());
    int d;
    for (d = 0; d < D; ++d)
    {
      domain_m[d] = Interval<1>(inset[d].length());
      offset_m[d] = function().lowerExtent(d);
    }
  }
  Engine(const Function &f, const Expression &e, const Interval<D> &domain)
    : function_m(f), expression_m(e), domain_m(Pooma::NoInit())
  {
    int d;
    for (d = 0; d < D; ++d)
    {
      domain_m[d] = Interval<1>(domain[d].length());
      offset_m[d] = domain[d].first();
    }
  }
  template<class OtherE>
  Engine(const Engine<D, T, StencilEngine<Function, OtherE> > &e,
  const INode<D> &node)
    : function_m(e.function()),
      expression_m(e.expression()(e.viewDomain(node))),
      domain_m(Pooma::NoInit())
  {
    int d;
    for (d = 0; d < D; ++d)
    {
      domain_m[d] = Interval<1>(node.domain()[d].length());
      offset_m[d] = function().lowerExtent(d);
    }
  }
  Engine(const Engine_t &e,
  const Interval<D> &domain)
    : function_m(e.function()),
      expression_m(e.expression()),
      domain_m(Pooma::NoInit())
  {
    int d;
    for (d = 0; d < D; ++d)
    {
      domain_m[d] = Interval<1>(domain[d].length());
      offset_m[d] = e.offset_m[d] + domain[d].first();
    }
  }
  template <int Dim, class Tx, class EngineTag>
  void initExpressionFromModel(const Array<Dim, Tx, EngineTag>& model)
  {
    expression_m.engine() = model.engine();
  }
  template <class Mesh, class Tx, class EngineTag>
  void initExpressionFromModel(const Field<Mesh, Tx, EngineTag>& model)
  {
    expression_m.fieldEngine() = model.fieldEngine();
  }
  This_t &operator=(const This_t &model)
  {
    domain_m = model.domain();
    function_m = model.function();
    initExpressionFromModel(model.expression());
    for (int d = 0; d < D; ++d)
    {
      domain_m[d] = model.domain()[d];
      offset_m[d] = model.offset(d);
    }
    return *this;
  }
  inline Element_t read(int i) const
  {
    return function()(expression_m,
        i + offset_m[0]);
  }
  inline Element_t read(int i, int j) const
  {
    return function()(expression_m,
        i + offset_m[0],
        j + offset_m[1]);
  }
  inline Element_t read(int i, int j, int k) const
  {
    return function()(expression_m,
        i + offset_m[0],
        j + offset_m[1],
        k + offset_m[2]);
  }
  inline Element_t read(const Loc<1> &loc) const
  {
    return function()(expression_m,
        loc[0].first() + offset_m[0]);
  }
  inline Element_t read(const Loc<2> &loc) const
  {
    return function()(expression_m,
        loc[0].first() + offset_m[0],
        loc[1].first() + offset_m[1]);
  }
  inline Element_t read(const Loc<3> &loc) const
  {
    return function()(expression_m,
        loc[0].first() + offset_m[0],
        loc[1].first() + offset_m[1],
        loc[2].first() + offset_m[2]);
  }
  inline Element_t operator()(int i) const
  {
    return read(i);
  }
  inline Element_t operator()(int i, int j) const
  {
    return read(i, j);
  }
  inline Element_t operator()(int i, int j, int k) const
  {
    return read(i, j, k);
  }
  inline const Domain_t &domain() const { return domain_m; }
  inline Layout_t layout() const { return Layout_t(domain_m); }
  inline int first(int i) const
  {
    return 0;
  }
  inline
  Interval<D> viewDomain(const Interval<D> &domain) const
  {
    Interval<D> ret;
    int d;
    for (d = 0; d < D; ++d)
    {
      ret[d] =
 Interval<1>(
      domain[d].first() + offset_m[d]
      - function().lowerExtent(d),
      domain[d].last() + offset_m[d] + function().upperExtent(d)
      );
    }
    return ret;
  }
  inline
  INode<D> viewDomain(const INode<D> &inode) const
  {
    return INode<D>(inode, viewDomain(inode.domain()));
  }
  inline
  Interval<D> intersectDomain() const
  {
    Interval<D> ret;
    int d;
    for (d = 0; d < D; ++d)
    {
      ret[d] =
 Interval<1>(
      domain_m[d].first() + offset_m[d],
      domain_m[d].last() + offset_m[d]
      );
    }
    return ret;
  }
  inline const Function &function() const { return function_m; }
  inline const Expression &expression() const { return expression_m; }
  int offset(int d) const { return offset_m[d]; }
private:
  Function function_m;
  Expression expression_m;
  Interval<D> domain_m;
  int offset_m[D];
};
template<class Function, int D, class T, class E>
struct View1<Stencil<Function>, Array<D, T, E> >
{
  typedef Array<D,T,E> ArrayIn_t;
  typedef StencilEngine<Function, ArrayIn_t> NewTag_t;
  typedef typename NewTag_t::Element_t NewT_t;
  typedef Engine<D, NewT_t, NewTag_t> NewEngine_t;
  typedef Array<D, NewT_t, NewTag_t> Type_t;
  static inline
  Type_t make(const Stencil<Function> &s, const ArrayIn_t &a)
  {
    return Type_t(NewEngine_t(s.function(), a,
         insetDomain(s.function(), a.domain())
         ));
  }
};
template<class Function, class ArrayIn, int Dim>
struct View2<Stencil<Function>,ArrayIn,Interval<Dim> >
{
  enum { dim = ArrayIn::dimensions };
  typedef Interval<Dim> ViewDom_t;
  typedef typename View1<ArrayIn,ViewDom_t>::Type_t Expression_t;
  typedef StencilEngine<Function, Expression_t> NewTag_t;
  typedef typename NewTag_t::Element_t NewT_t;
  typedef Engine<dim,NewT_t,NewTag_t> NewEngine_t;
  typedef Array<dim,NewT_t,NewTag_t> Type_t;
  static inline
  Type_t make(const Stencil<Function> &s, const ArrayIn &a,
       const Interval<Dim> &d)
  {
    return Type_t(NewEngine_t(s.function(), a(s.inputDomain(d))));
  }
};
template<class Function, class ArrayIn, class Dom>
struct View2<Stencil<Function>, ArrayIn, Dom>
{
  enum { dim2 = ArrayIn::dimensions };
  enum { dim = Dom::dimensions };
  typedef Interval<dim2> ViewDom_t;
  typedef typename View1<ArrayIn, ViewDom_t>::Type_t Expression_t;
  typedef StencilEngine<Function, Expression_t> StencilTag_t;
  typedef typename StencilTag_t::Element_t NewT_t;
  typedef ViewEngine<dim2, StencilTag_t> NewTag_t;
  typedef Engine<dim,NewT_t,NewTag_t> NewEngine_t;
  typedef Array<dim,NewT_t,NewTag_t> Type_t;
  static inline
  Type_t make(const Stencil<Function> &s, const ArrayIn &a, const Dom &dom)
  {
    ViewDom_t viewDom = s.inputDomain(dom);
    ViewDom_t insetDom = insetDomain(s.function(), viewDom);
    ViewIndexer<dim,dim2> indexer(insetDom);
    Dom stView;
    indexer.baseToLocal(dom,stView);
    typedef typename NewEngine_t::ViewedEngine_t ViewedEngine_t;
    ViewedEngine_t viewed(s.function(),a(viewDom));
    return Type_t(NewEngine_t(viewed,stView));
  }
};
template<class Function>
class Stencil
{
public:
  Stencil()
  { }
  Stencil(const Stencil<Function> &model)
    : function_m(model.function_m)
  { }
  ~Stencil() {}
  template<class Init>
  Stencil(const Init &init)
    : function_m(init)
  { }
  template<int D, class T, class E>
  typename View1<Stencil<Function>,Array<D,T,E> >::Type_t
  operator()(const Array<D,T,E>& expr) const
  {
    typedef View1<Stencil<Function>,Array<D,T,E> > Ret_t;
    return Ret_t::make(*this,expr);
  }
  template<int D, class T, class E,class Dom>
  typename View2<Stencil<Function>,Array<D,T,E>,Dom>::Type_t
  operator()(const Array<D,T,E>& expr,const Dom &domain) const
  {
    PoomaCTAssert<(D==Dom::dimensions)>::test();
    typedef View2<Stencil<Function>,Array<D,T,E>,Dom> Ret_t;
    return Ret_t::make(*this,expr,domain);
  }
  template<int D>
  inline
  Interval<D> insetDomain(const Interval<D> &domain)
  {
    return ::insetDomain(function(), domain);
  }
  template<int D, class DT>
  inline
  Interval<D> inputDomain(const Domain<D,DT> &domain) const
  {
    Interval<D> ret;
    int d;
    for (d = 0; d < D; ++d)
    {
      ret[d] =
 Interval<1>(
      domain[d].first() - function().lowerExtent(d),
      domain[d].last() + function().upperExtent(d)
      );
    }
    return ret;
  }
  inline Function &function() { return function_m; }
  inline const Function &function() const { return function_m; }
private:
  Function function_m;
};
template <int Dim, class T, class S, class E>
struct NewEngine<Engine<Dim, T, StencilEngine<S, E> >, Interval<Dim> >
{
  typedef Engine<Dim, T, StencilEngine<S, E> > Type_t;
};
template <int Dim, class T, class S, class E>
struct NewEngine<Engine<Dim, T, StencilEngine<S, E> >, INode<Dim> >
{
  typedef typename View1<E, INode<Dim> >::Type_t NewExpr_t;
  typedef StencilEngine<S, NewExpr_t> NewTag_t;
  typedef Engine<Dim, T, NewTag_t> Type_t;
};
template <int Dim, class T, class S, class E>
struct NewEngine<Engine<Dim, T, StencilEngine<S, E> >, Range<Dim> >
{
  typedef StencilEngine<S,E> SETag_t;
  typedef ViewEngine<Dim,SETag_t> NewTag_t;
  typedef Engine<Dim,T,NewTag_t> Type_t;
};
template <int Dim, class T, class S, class E, int SliceDim>
struct NewEngine< Engine<Dim,T,StencilEngine<S,E> >,
  SliceInterval<Dim,SliceDim> >
{
  typedef StencilEngine<S,E> SETag_t;
  typedef ViewEngine<Dim,SETag_t> NewTag_t;
  typedef Engine<SliceDim,T,NewTag_t> Type_t;
};
template <int Dim, class T, class S, class E, int SliceDim>
struct NewEngine< Engine<Dim,T,StencilEngine<S,E> >,
  SliceRange<Dim,SliceDim> >
{
  typedef StencilEngine<S,E> SETag_t;
  typedef ViewEngine<Dim,SETag_t> NewTag_t;
  typedef Engine<SliceDim,T,NewTag_t> Type_t;
};
template<class UserFunction,class Expression>
struct EvaluatorEngineTraits<StencilEngine<UserFunction,Expression> >
{
  typedef typename Expression::Engine_t Engine_t;
  typedef typename Engine_t::Tag_t Tag_t;
  typedef typename EvaluatorEngineTraits<Tag_t>::Evaluator_t Evaluator_t;
};
template<int Dim, class Intersect>
class StencilIntersector
{
public:
  typedef typename Intersect::IntersectorData_t IntersectorData_t;
  typedef StencilIntersector<Dim, Intersect> This_t;
  typedef typename IntersectorData_t::const_iterator const_iterator;
  typedef RefCountedPtr<IntersectorData_t> DataPtr_t;
  enum { dimensions = Intersect::dimensions };
  StencilIntersector(const This_t &model)
    : domain_m(model.domain_m),
      stencilExtent_m(model.stencilExtent_m),
      intersector_m(model.intersector_m)
  { }
  StencilIntersector(const Interval<Dim> &domain, const Intersect &intersect,
    const GuardLayers<Dim> &stencilExtent)
    : domain_m(domain),
      stencilExtent_m(stencilExtent),
      intersector_m(intersect)
  { }
  This_t &operator=(const This_t &model)
  {
    if (this != &model)
    {
      intersector_m = model.intersector_m;
      domain_m = model.domain_m;
      stencilExtent_m = model.stencilExtent_m;
    }
    return *this;
  }
  ~StencilIntersector() { }
  inline DataPtr_t &data() { return intersector_m.data(); }
  inline const DataPtr_t &data() const { return intersector_m.data(); }
  inline const_iterator begin() const { return data()->inodes_m.begin(); }
  inline const_iterator end() const { return data()->inodes_m.end(); }
  template<class Engine>
  inline
  void intersect(const Engine &engine)
  {
    typedef typename NewEngine<Engine,Interval<Dim> >::Type_t NewEngine_t;
    NewEngine_t newEngine(engine, domain_m);
    intersector_m.intersect(newEngine);
    data()->shared(engine.layout().ID(),newEngine.layout().ID());
  }
  template<class Engine, int Dim2>
  inline
  bool intersect(const Engine &engine, const GuardLayers<Dim2> &g,
    GuardLayers<Dim> &usedGuards)
  {
    intersect(engine);
    usedGuards = stencilExtent_m;
    return true;
  }
private:
  Interval<Dim> domain_m;
  GuardLayers<Dim> stencilExtent_m;
  Intersect intersector_m;
};
template <int D, class T, class S, class E, class Intersect>
struct LeafFunctor<Engine<D,T,StencilEngine<S,E> >,
  ExpressionApply<IntersectorTag<Intersect> > >
{
  typedef int Type_t;
  static
  Type_t apply(const Engine<D,T,StencilEngine<S,E> > &engine,
        const ExpressionApply<IntersectorTag<Intersect> > &tag)
  {
    typedef StencilIntersector<D, Intersect> NewIntersector_t;
    GuardLayers<D> stencilExtent;
    for (int i=0; i<D; ++i) {
      stencilExtent.lower(i) = engine.function().lowerExtent(i);
      stencilExtent.upper(i) = engine.function().upperExtent(i);
    }
    NewIntersector_t newIntersector(engine.intersectDomain(),
        tag.tag().intersector_m,
        stencilExtent);
    expressionApply(engine.expression(),
      IntersectorTag<NewIntersector_t>(newIntersector));
    return 0;
  }
};
template<class RequestType> class DataObjectRequest;
template <int D, class T, class S, class E, class RequestType>
struct EngineFunctor<Engine<D, T, StencilEngine<S, E> >,
  DataObjectRequest<RequestType> >
{
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  static Type_t
  apply(const Engine<D, T, StencilEngine<S, E> > &engine,
 const DataObjectRequest<RequestType> &tag)
  {
    return engineFunctor(engine.expression(), tag);
  }
};
template <int D, class T, class S, class E, class Tag>
struct LeafFunctor<Engine<D, T, StencilEngine<S, E> >, EngineView<Tag> >
{
  typedef LeafFunctor<E, EngineView<Tag> > LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t NewViewed_t;
  typedef Engine<D, T, StencilEngine<S, NewViewed_t> > Type_t;
  static
  Type_t apply(const Engine<D, T, StencilEngine<S, E> > &engine,
        const EngineView<Tag> &tag)
  {
    return Type_t(engine.function(),
    LeafFunctor_t::apply(engine.expression(), tag));
  }
};
template <int D, class T, class S, class E, class Tag>
struct LeafFunctor<Engine<D, T, StencilEngine<S, E> >, ExpressionApply<Tag> >
{
  typedef LeafFunctor<E, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  static
  Type_t apply(const Engine<D, T, StencilEngine<S, E> > &engine,
        const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(engine.expression(), tag);
  }
};
namespace Pooma {
namespace Algorithms {
template <bool type>
struct IsConcrete
{
inline IsConcrete() { }; inline IsConcrete(const IsConcrete &) { }; inline IsConcrete &operator=(const IsConcrete &) { return *this; };
};
template <class It, class It2>
inline It2 copy(It begin, It end, It2 dest)
{
  ;
  ;
  typedef typename std::iterator_traits<It>::value_type Value_t;
  typedef ElementProperties<Value_t> EP_t;
  typedef IsConcrete<EP_t::concrete> ConcreteType_t;
  return copy_special(begin, end, dest, ConcreteType_t());
}
template <class It, class It2>
inline It2 copy_special(It begin, It end, It2 dest, IsConcrete<true>)
{
  typedef std::iterator_traits<It> DataTraits_t;
  typedef typename DataTraits_t::difference_type Diff_t;
  typedef typename DataTraits_t::value_type Value_t;
  return std::copy(begin, end, dest);
}
template <class It, class It2>
inline It2 copy_special(It begin, It end, It2 dest, IsConcrete<false>)
{
  typedef typename std::iterator_traits<It>::value_type Value_t;
  while (begin < end)
    {
      ElementProperties<Value_t>::construct(dest++, *begin++);
    }
  return dest;
}
template <class DataIterator, class KillIterator>
inline
typename std::iterator_traits<DataIterator>::difference_type
delete_backfill(DataIterator data_begin, DataIterator data_end,
  const KillIterator kill_begin, const KillIterator kill_end,
  typename std::iterator_traits<DataIterator>::difference_type offset = 0)
{
  ;
  ;
  std::reverse_iterator<KillIterator> rk_pos(kill_end);
  std::reverse_iterator<KillIterator> rk_end(kill_begin);
  typedef std::iterator_traits<DataIterator> DataTraits_t;
  typedef typename DataTraits_t::difference_type Diff_t;
  Diff_t last = data_end - data_begin - 1;
  while (!(rk_pos == rk_end))
    {
      if ((*rk_pos - offset) != last) break;
      --last;
      ++rk_pos;
    }
  DataIterator last_pos = data_begin + last;
  while (!(rk_pos == rk_end))
    {
      *(data_begin + (*rk_pos++ - offset)) = *last_pos--;
    }
  return kill_end - kill_begin;
}
template <class DataIterator, class KillIterator>
inline
typename std::iterator_traits<DataIterator>::difference_type
delete_shiftup(DataIterator data_begin, DataIterator data_end,
  KillIterator kill_begin, KillIterator kill_end,
  typename std::iterator_traits<DataIterator>::difference_type offset = 0)
{
  DataIterator insert_pos = data_begin + (*kill_begin - offset);
  KillIterator kill_pos = kill_begin;
  typedef std::iterator_traits<DataIterator> DataTraits_t;
  typedef typename DataTraits_t::value_type Value_t;
  typedef typename DataTraits_t::difference_type Diff_t;
  while (kill_pos < kill_end)
  {
    Diff_t copy_index = *kill_pos + 1;
    while ( (kill_pos + 1) < kill_end && copy_index == *(kill_pos + 1) )
    {
      ++copy_index;
      ++kill_pos;
    }
    DataIterator copy_begin = data_begin + (copy_index - offset);
    DataIterator copy_end;
    if (copy_begin < data_end)
    {
      if (kill_pos + 1 < kill_end)
        copy_end = data_begin + (*(kill_pos + 1) - offset);
      else
        copy_end = data_end;
      const Diff_t length = copy_end - copy_begin;
      Pooma::Algorithms::copy(copy_begin, copy_end, insert_pos);
      insert_pos += length;
    }
    ++kill_pos;
  }
  return kill_end - kill_begin;
}
template<class DataIterator>
inline DataIterator
find_most_common(DataIterator dataBegin, DataIterator dataEnd)
{
  DataIterator checkValue, mostCommonValue = dataEnd;
  int checkCount, count = 0;
  while (dataBegin != dataEnd)
    {
      checkValue = dataBegin++;
      checkCount = 1;
      while (dataBegin != dataEnd && *dataBegin == *checkValue)
 {
   ++checkCount;
   ++dataBegin;
 }
      if (checkCount > count)
        {
   mostCommonValue = checkValue;
   count = checkCount;
 }
    }
  return mostCommonValue;
}
}
}
template<class Tag>
struct Remote
{ };
template <int Dim, class T, class Tag>
class Engine<Dim, T, Remote<Tag> >
{
public:
  typedef Engine<Dim, T, Remote<Tag> > This_t;
  typedef Engine<Dim, T, Remote<Tag> > Engine_t;
  typedef Engine<Dim, T, Tag> LocalEngine_t;
  typedef Interval<Dim> Domain_t;
  typedef T Element_t;
  typedef RemoteProxy<T> ElementRef_t;
  typedef Remote<Tag> Tag_t;
  typedef DomainLayout<Dim> Layout_t;
  enum { dimensions = Dim };
  enum { hasDataObject = true };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = false };
  typedef Shared<LocalEngine_t> LocalShared_t;
  typedef RefCountedPtr<LocalShared_t> LocalPtr_t;
  Engine();
  explicit
  Engine(const Domain_t &domain);
  Engine(int owningContext, const Domain_t &domain);
  Engine(const Domain_t &domain, const T &elementModel);
  explicit
  Engine(const Node<Domain_t> &node);
  explicit
  Engine(const Layout_t &layout);
  Engine(const Engine_t &model);
  Engine(const Engine_t &, const EngineConstructTag &);
  template<class OtherEngine, class Domain>
  Engine(const OtherEngine &otherEngine, const Domain &domain);
  template<class OtherEngine, int D2>
  Engine(const OtherEngine &otherEngine,
  const SliceRange<D2, Dim> &domain);
  ~Engine();
  Engine_t &operator=(const Engine_t &model);
  Element_t read(const Loc<Dim> &) const;
  ElementRef_t operator()(const Loc<Dim> &) const;
  Element_t read(int) const;
  Element_t read(int, int) const;
  Element_t read(int, int, int) const;
  Element_t read(int, int, int, int) const;
  Element_t read(int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int) const;
  Element_t read(int, int, int, int, int, int, int) const;
  ElementRef_t operator()(int) const;
  ElementRef_t operator()(int, int) const;
  ElementRef_t operator()(int, int, int) const;
  ElementRef_t operator()(int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int) const;
  ElementRef_t operator()(int, int, int, int, int, int, int) const;
  inline const Domain_t &domain() const
  {
    return domain_m;
  }
  inline
  bool engineIsLocal() const
  {
    return (Pooma::context() == owningContext_m);
  }
  inline
  int owningContext() const
  {
    return owningContext_m;
  }
  inline
  const LocalEngine_t &localEngine() const
  {
    ;
    ;
    return (*localEnginePtr_m).data();
  }
  inline
  LocalEngine_t &localEngine()
  {
    ;
    ;
    return (*localEnginePtr_m).data();
  }
  inline int first(int i) const
  {
    return domain_m[i].first();
  }
  inline
  Engine_t &makeOwnCopy()
  {
    if (engineIsLocal() && localEnginePtr_m.isValid())
    {
      LocalEngine_t engine(localEngine());
      engine.makeOwnCopy();
      localEnginePtr_m = LocalPtr_t(new LocalShared_t(engine));
    }
    return *this;
  }
protected:
  Domain_t domain_m;
private:
  int owningContext_m;
  LocalPtr_t localEnginePtr_m;
};
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(const Loc<Dim> &loc) const
{
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(loc);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2, int i3) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2, i3);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2, int i3, int i4) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2, i3, i4);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2, i3, i4, i5);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2, i3, i4, i5, i6);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline T Engine<Dim, T, Remote<Tag> >::
read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  T value;
  if (engineIsLocal())
  {
    value = localEngine().read(i1, i2, i3, i4, i5, i6, i7);
  }
  return ElementRef_t(value, owningContext());
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(const Loc<Dim> &loc) const
{
  if (engineIsLocal())
  {
    T &value = localEngine()(loc);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2, int i3) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2, i3);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2, int i3, int i4) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2, i3, i4);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2, int i3, int i4, int i5) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2, i3, i4, i5);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2, int i3, int i4, int i5, int i6) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2, i3, i4, i5, i6);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
inline RemoteProxy<T> Engine<Dim, T, Remote<Tag> >::
operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
{
  ;
  if (engineIsLocal())
  {
    T &value = localEngine()(i1, i2, i3, i4, i5, i6, i7);
    return ElementRef_t(value, owningContext());
  }
  else
  {
    T val;
    return ElementRef_t(val, owningContext());
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine()
  : owningContext_m(0)
{
  ;
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine(const Node<Domain_t> &node)
  : domain_m(node.allocated()),
    owningContext_m(node.context())
{
  ;
  if (engineIsLocal())
  {
    localEnginePtr_m = LocalPtr_t(new LocalShared_t(LocalEngine_t(node)));
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine(const Layout_t &layout)
  : domain_m(layout.node().allocated()),
    owningContext_m(0)
{
  ;
  if (engineIsLocal())
  {
    localEnginePtr_m = LocalPtr_t(new LocalShared_t(LocalEngine_t(layout.
          node())));
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine(const Domain_t &dom)
  : domain_m(dom), owningContext_m(0)
{
  if (engineIsLocal())
  {
    localEnginePtr_m = LocalPtr_t(new LocalShared_t(LocalEngine_t(domain_m)));
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine(int owningContext, const Domain_t &dom)
  : domain_m(dom),
    owningContext_m(owningContext)
{
  if (engineIsLocal())
  {
    localEnginePtr_m = LocalPtr_t(new LocalShared_t(LocalEngine_t(domain_m)));
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::Engine(const Domain_t &dom, const T& model)
  : domain_m(dom), owningContext_m(0)
{
  if (engineIsLocal())
  {
    localEnginePtr_m =
      LocalPtr_t(new LocalShared_t(LocalEngine_t(domain_m, model)));
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::
Engine(const Engine<Dim, T, Remote<Tag> > &modelEngine)
  : domain_m(modelEngine.domain()),
    owningContext_m(modelEngine.owningContext()),
    localEnginePtr_m(modelEngine.localEnginePtr_m)
{
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::
Engine(const Engine<Dim, T, Remote<Tag> > &modelEngine,
       const EngineConstructTag &)
  : domain_m(modelEngine.domain()),
    owningContext_m(modelEngine.owningContext()),
    localEnginePtr_m(modelEngine.localEnginePtr_m)
{
}
template <int Dim, class T, class Tag>
template<class OtherEngine, class Domain>
Engine<Dim, T, Remote<Tag> >::
Engine(const OtherEngine &otherEngine, const Domain &domain)
  : owningContext_m(otherEngine.owningContext())
{
  if (engineIsLocal())
  {
    localEnginePtr_m =
      LocalPtr_t(new LocalShared_t(LocalEngine_t(otherEngine.localEngine(),
       domain)));
  }
  int i;
  for (i = 0; i < Dim; ++i)
  {
    domain_m[i] = Interval<1>(domain[i].length());
  }
}
template <int Dim, class T, class Tag>
template<class OtherEngine, int D2>
Engine<Dim, T, Remote<Tag> >::
Engine(const OtherEngine &otherEngine, const SliceRange<D2, Dim> &domain)
  : owningContext_m(otherEngine.owningContext())
{
  if (engineIsLocal())
  {
    localEnginePtr_m =
      LocalPtr_t(new LocalShared_t(LocalEngine_t(otherEngine.localEngine(),
       domain)));
  }
  int i;
  for (i = 0; i < Dim; ++i)
  {
    domain_m[i] = Interval<1>(domain.totalDomain()[i].length());
  }
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> > &
Engine<Dim, T, Remote<Tag> >::
operator=(const Engine<Dim, T, Remote<Tag> > &modelEngine)
{
  if (this == &modelEngine)
    return *this;
  owningContext_m = modelEngine.owningContext_m;
  domain_m = modelEngine.domain_m;
  localEnginePtr_m = modelEngine.localEnginePtr_m;
  return *this;
}
template <int Dim, class T, class Tag>
Engine<Dim, T, Remote<Tag> >::~Engine()
{
}
template<int Dim, class T, class Tag, class Domain>
struct NewEngine<Engine<Dim, T, Remote<Tag> >, Domain>
{
  typedef typename NewEngine<Engine<Dim, T, Tag>, Domain>::Type_t Local_t;
  typedef typename Local_t::Tag_t NewTag_t;
  enum { newDim = Local_t::dimensions };
  typedef Engine<newDim, T, Remote<NewTag_t> > Type_t;
};
template<int Dim, class T, class Tag>
struct NewEngineDomain<Engine<Dim, T, Remote<Tag> >, INode<Dim> >
{
  typedef const Interval<Dim> &Type_t;
  static inline const Interval<Dim> &
  apply(const Engine<Dim, T, Remote<Tag> > &,
 const INode<Dim> &i)
  {
    return i.domain();
  }
};
struct RemoteView { };
template<>
struct EngineView<RemoteView>
{
  typedef TreeCombine Combine_t;
};
struct RemoteSend
{
  RemoteSend(int n) : toContext_m(n) { }
  inline int toContext() const { return toContext_m; }
  int toContext_m;
};
template<class Engine>
struct DefaultExpressionApply<Engine, RemoteSend >
{
  typedef Engine Subject_t;
  typedef int Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const ExpressionApply<RemoteSend> &)
  {
    return 0;
  }
};
template<class Engine>
struct DefaultEngineView<Engine, RemoteView>
{
  typedef Engine Subject_t;
  typedef Engine Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const EngineView<RemoteView> &)
  {
    return engine;
  }
};
template<int Dim, class T, class Tag>
struct LeafFunctor<Engine<Dim, T, Remote<Tag> >, ExpressionApply<RemoteSend> >
{
  typedef Engine<Dim, T, Remote<Tag> > Subject_t;
  typedef int Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const ExpressionApply<RemoteSend> &sendTag)
  {
    if (engine.engineIsLocal())
    {
      if (sendTag.tag().toContext() == -1)
      {
 for (int i = 0; i < Pooma::contexts(); i++)
   if (i != Pooma::context())
     SendReceive::send(engine.localEngine(), i);
      }
      else
      {
 if (Pooma::context() != sendTag.tag().toContext())
   SendReceive::send(engine.localEngine(), sendTag.tag().toContext());
      }
    }
    return 0;
  }
};
template<int Dim, class T, class Tag>
struct LeafFunctor<Engine<Dim, T, Remote<Tag> >, EngineView<RemoteView> >
{
};
template<int Dim, class T>
struct LeafFunctor<Engine<Dim, T, Remote<Brick> >, EngineView<RemoteView> >
{
  typedef Engine<Dim, T, Remote<Brick> > Subject_t;
  typedef Engine<Dim, T, Brick> Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const EngineView<RemoteView> &)
  {
    if (engine.engineIsLocal())
    {
      return engine.localEngine();
    }
    else
    {
      Type_t local(engine.domain());
      Receive<Type_t>::receive(local, engine.owningContext());
      return local;
    }
  }
};
template<int Dim, class T>
struct LeafFunctor<Engine<Dim, T, Remote<BrickView> >,
  EngineView<RemoteView> >
{
  typedef Engine<Dim, T, Remote<BrickView> > Subject_t;
  typedef Engine<Dim, T, Brick> IncomingView_t;
  typedef Engine<Dim, T, Brick> Brick_t;
  typedef Engine<Dim, T, BrickView> Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const EngineView<RemoteView> &)
  {
    if (engine.engineIsLocal())
    {
      return engine.localEngine();
    }
    else
    {
      Interval<Dim> dom = engine.domain();
      Brick_t local(dom);
      Type_t view(local, dom);
      Receive<IncomingView_t>::receive(view, engine.owningContext());
      return view;
    }
  }
};
template<int Dim, class T>
struct LeafFunctor<Engine<Dim, T, Remote<BrickViewU> >,
  EngineView<RemoteView> >
{
  typedef Engine<Dim, T, Remote<BrickViewU> > Subject_t;
  typedef Engine<Dim, T, Brick> IncomingView_t;
  typedef Engine<Dim, T, Brick> Brick_t;
  typedef Engine<Dim, T, BrickViewU> Type_t;
  static inline
  Type_t apply(const Subject_t &engine,
        const EngineView<RemoteView> &)
  {
    if (engine.engineIsLocal())
    {
      return engine.localEngine();
    }
    else
    {
      Interval<Dim> dom = engine.domain();
      Brick_t local(dom);
      Type_t view(local, dom);
      Receive<IncomingView_t>::receive(view, engine.owningContext());
      return view;
    }
  }
};
template<int Dim, class T>
struct LeafFunctor<Engine<Dim, T, Remote<CompressibleBrick> >,
  EngineView<RemoteView> >
{
  typedef Engine<Dim, T, Remote<CompressibleBrick> > Subject_t;
  typedef Engine<Dim, T, CompressibleBrick> Type_t;
  static inline
  Type_t apply(const Subject_t &engine, const EngineView<RemoteView> &)
  {
    if (engine.engineIsLocal())
    {
      return engine.localEngine();
    }
    else
    {
      Type_t local(engine.domain());
      Receive<Type_t>::receive(local, engine.owningContext());
      return local;
    }
  }
};
template<int Dim, class T>
struct LeafFunctor<Engine<Dim, T, Remote<CompressibleBrickView> >,
  EngineView<RemoteView> >
{
  typedef Engine<Dim, T, Remote<CompressibleBrickView> > Subject_t;
  typedef Engine<Dim, T, CompressibleBrick> CompBrick_t;
  typedef Engine<Dim, T, CompressibleBrickView> Type_t;
  static inline
  Type_t apply(const Subject_t &engine, const EngineView<RemoteView> &)
  {
    if (engine.engineIsLocal())
    {
      return engine.localEngine();
    }
    else
    {
      Interval<Dim> dom = engine.domain();
      CompBrick_t local(dom);
      Type_t view(local, dom);
      Receive<Type_t>::receive(view, engine.owningContext());
      return view;
    }
  }
};
struct EngineBlockSerialize
{
  template<class Op, class Eng>
  inline static
  int apply(Op &op, const Eng &engine)
    {
      typedef typename Eng::Domain_t Domain_t;
      return apply(op, engine, engine.domain(),
     WrappedInt<Domain_t::dimensions>());
    }
  template<class Op, class Eng, class Dom>
  inline static
  int apply(Op &op, const Eng &engine, const Dom &domain)
    {
      return apply(op, engine, domain,
     WrappedInt<Dom::dimensions>());
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain, WrappedInt<1>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int e0 = domain[0].last();
      for (int i0 = f0; i0<=e0; ++i0)
 op(engine(i0));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<2>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int f1 = domain[1].first();
      int e0 = domain[0].last();
      int e1 = domain[1].last();
      for (int i1 = f1; i1<=e1; ++i1)
 for (int i0 = f0; i0<=e0; ++i0)
   op(engine(i0,i1));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<3>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int f1 = domain[1].first();
      int f2 = domain[2].first();
      int e0 = domain[0].last();
      int e1 = domain[1].last();
      int e2 = domain[2].last();
      for (int i2 = f2; i2<=e2; ++i2)
 for (int i1 = f1; i1<=e1; ++i1)
   for (int i0 = f0; i0<=e0; ++i0)
     op(engine(i0,i1,i2));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<4>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int f1 = domain[1].first();
      int f2 = domain[2].first();
      int f3 = domain[3].first();
      int e0 = domain[0].last();
      int e1 = domain[1].last();
      int e2 = domain[2].last();
      int e3 = domain[3].last();
      for (int i3 = f3; i3<=e3; ++i3)
 for (int i2 = f2; i2<=e2; ++i2)
   for (int i1 = f1; i1<=e1; ++i1)
     for (int i0 = f0; i0<=e0; ++i0)
       op(engine(i0,i1,i2,i3));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<5>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int f1 = domain[1].first();
      int f2 = domain[2].first();
      int f3 = domain[3].first();
      int f4 = domain[4].first();
      int e0 = domain[0].last();
      int e1 = domain[1].last();
      int e2 = domain[2].last();
      int e3 = domain[3].last();
      int e4 = domain[4].last();
      for (int i4 = f4; i4<=e4; ++i4)
 for (int i3 = f3; i3<=e3; ++i3)
   for (int i2 = f2; i2<=e2; ++i2)
     for (int i1 = f1; i1<=e1; ++i1)
       for (int i0 = f0; i0<=e0; ++i0)
  op(engine(i0,i1,i2,i3,i4));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<6>)
    {
      PoomaCTAssert<(Domain::unitStride == 1)>::test();
      int f0 = domain[0].first();
      int f1 = domain[1].first();
      int f2 = domain[2].first();
      int f3 = domain[3].first();
      int f4 = domain[4].first();
      int f5 = domain[5].first();
      int e0 = domain[0].last();
      int e1 = domain[1].last();
      int e2 = domain[2].last();
      int e3 = domain[3].last();
      int e4 = domain[4].last();
      int e5 = domain[5].last();
      for (int i5 = f5; i5<=e5; ++i5)
 for (int i4 = f4; i4<=e4; ++i4)
   for (int i3 = f3; i3<=e3; ++i3)
     for (int i2 = f2; i2<=e2; ++i2)
       for (int i1 = f1; i1<=e1; ++i1)
  for (int i0 = f0; i0<=e0; ++i0)
    op(engine(i0,i1,i2,i3,i4,i5));
      return op.total_m;
    }
  template<class Op,class Eng,class Domain>
  inline static int apply(Op &op,const Eng &engine,
     const Domain &domain,WrappedInt<7>)
{
  PoomaCTAssert<(Domain::unitStride == 1)>::test();
  int f0 = domain[0].first();
  int f1 = domain[1].first();
  int f2 = domain[2].first();
  int f3 = domain[3].first();
  int f4 = domain[4].first();
  int f5 = domain[5].first();
  int f6 = domain[6].first();
  int e0 = domain[0].last();
  int e1 = domain[1].last();
  int e2 = domain[2].last();
  int e3 = domain[3].last();
  int e4 = domain[4].last();
  int e5 = domain[5].last();
  int e6 = domain[6].last();
  for (int i6 = f6; i6<=e6; ++i6)
    for (int i5 = f5; i5<=e5; ++i5)
      for (int i4 = f4; i4<=e4; ++i4)
 for (int i3 = f3; i3<=e3; ++i3)
   for (int i2 = f2; i2<=e2; ++i2)
     for (int i1 = f1; i1<=e1; ++i1)
       for (int i0 = f0; i0<=e0; ++i0)
  op(engine(i0,i1,i2,i3,i4,i5,i6));
  return op.total_m;
}
private:
};
template <int Dim, class T, class Tag>
long elementsCompressed(const Engine<Dim, T, Remote<Tag> > &engine)
{
  return elementsCompressed(engine.localEngine());
}
template <int Dim, class T, class Tag>
void compress(Engine<Dim, T, Remote<Tag> > &engine)
{
  compress(engine.localEngine());
}
template <int Dim, class T, class Tag>
void uncompress(Engine<Dim, T, Remote<Tag> > &engine)
{
  uncompress(engine.localEngine());
}
template <int Dim, class T, class Tag>
bool compressed(const Engine<Dim, T, Remote<Tag> > &engine)
{
  return compressed(engine.localEngine());
}
class GatherContexts
{
private:
  class GatherContextsData : public RefCounted
  {
  public:
    inline GatherContextsData() {}
    inline GatherContextsData(const GatherContextsData &model)
    : contexts_m(model.contexts_m) {}
    inline ~GatherContextsData() {}
    void addContext(int c) const
      {
        if (c != -1)
          {
            if (contexts_m.empty())
              contexts_m.reserve(4);
     contexts_m.push_back(c);
   }
      }
    int mostCommonContext() const
      {
        if (contexts_m.size() != 0)
          {
            std::sort(contexts_m.begin(), contexts_m.end());
            return
       *Pooma::Algorithms::find_most_common(contexts_m.begin(),
                    contexts_m.end());
     }
        else
          {
            return -1;
          }
      }
  private:
    mutable std::vector<int> contexts_m;
  };
public:
  typedef NullCombine Combine_t;
  inline GatherContexts()
  : data_m(new GatherContextsData) {}
  inline GatherContexts(const GatherContexts &model)
  : data_m(model.data_m) { }
  GatherContexts &operator=(const GatherContexts &rhs)
    {
      data_m = rhs.data_m;
      return *this;
    }
  inline ~GatherContexts() {}
  inline void addContext(int c) const
    { data_m->addContext(c); }
  inline int mostCommonContext() const
    { return data_m->mostCommonContext(); }
private:
  RefCountedPtr<GatherContextsData> data_m;
};
template<class T>
struct EngineFunctorScalar<T, GatherContexts>
{
  typedef int Type_t;
  static inline
  Type_t apply(const T &, const GatherContexts &)
    {
      return 0;
    }
};
template<class Engine>
struct EngineFunctorDefault<Engine, GatherContexts>
{
  typedef Engine Subject_t;
  typedef int Type_t;
  static inline
  Type_t apply(const Subject_t &, const GatherContexts &)
    {
      return 0;
    }
};
template<int Dim, class T, class Tag>
struct EngineFunctor<Engine<Dim, T, Remote<Tag> >, GatherContexts>
{
  typedef Engine<Dim, T, Remote<Tag> > Subject_t;
  typedef int Type_t;
  static inline
  Type_t apply(const Subject_t &engine, const GatherContexts &tag)
    {
      tag.addContext(engine.owningContext());
      return 0;
    }
};
template <>
struct Evaluator<RemoteSinglePatchEvaluatorTag>
{
  Evaluator() { }
  ~Evaluator() { }
  template <class LHS, class RHS, class Op>
  void evaluate(const LHS &lhs, const Op &op, const RHS &rhs) const
  {
    GatherContexts gtag;
    engineFunctor(lhs.engine(), gtag);
    int lhsContext = gtag.mostCommonContext();
    expressionApply(rhs, RemoteSend(lhsContext));
    if (lhsContext == -1 || Pooma::context() == lhsContext)
      {
 EngineView<RemoteView> view;
        Evaluator<SinglePatchEvaluatorTag>().
   evaluate(forEach(lhs, view, TreeCombine()), op,
     forEach(rhs, view, TreeCombine()));
      }
    else
      {
      }
  }
};
template <>
struct Evaluator<RemoteMultiPatchEvaluatorTag>
{
  Evaluator() { }
  ~Evaluator() { }
  template <class LHS, class RHS, class Op>
  void evaluate(const LHS &lhs, const Op &op, const RHS &rhs) const
  {
    typedef Intersector<LHS::dimensions> Inter_t;
    Inter_t inter;
    expressionApply(lhs, IntersectorTag<Inter_t>(inter));
    expressionApply(rhs, IntersectorTag<Inter_t>(inter));
    typename Inter_t::const_iterator i = inter.begin();
    while (i != inter.end())
      {
        Evaluator<RemoteSinglePatchEvaluatorTag>().
          evaluate(lhs(*i), op, rhs(*i));
        ++i;
      }
  }
};
template <>
struct Reduction<RemoteSinglePatchEvaluatorTag>
{
  Reduction() { }
  ~Reduction() { }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e) const
  {
    GatherContexts gtag;
    engineFunctor(e.engine(), gtag);
    int computationContext = gtag.mostCommonContext();
    Pooma::CountingSemaphore csem;
    csem.height(1);
    if (Pooma::context() != computationContext)
    {
      expressionApply(e, RemoteSend(computationContext));
      csem.incr();
    }
    else
    {
      EngineView<RemoteView> view;
      Reduction<SinglePatchEvaluatorTag>().
 evaluate(ret, op,
   forEach(e, view, TreeCombine()), csem);
    }
    csem.wait();
    Pooma::scheduler().endGeneration();
    Pooma::blockAndEvaluate();
    Pooma::scheduler().beginGeneration();
    RemoteProxy<T> globalRet(ret, computationContext);
    ret = globalRet;
  }
};
template <>
struct Reduction<RemoteMultiPatchEvaluatorTag>
{
  Reduction() { }
  ~Reduction() { }
  template<class T, class Op, class Expr>
  void evaluate(T &ret, const Op &op, const Expr &e) const
  {
    typedef Intersector<Expr::dimensions> Inter_t;
    Inter_t inter;
    expressionApply(e, IntersectorTag<Inter_t>(inter));
    std::vector<bool> present(inter.size());
    std::vector<int> computationalContext(inter.size());
    typename Inter_t::const_iterator i = inter.begin();
    int j, k, n = 0;
    for (j = 0; j < inter.size(); j++)
      {
        present[j] = i->contextParticipates(Pooma::context());
 if (present[j])
          {
            computationalContext[j] = i->context();
            if (computationalContext[j] == Pooma::context())
              ++n;
          }
 ++i;
      }
    Pooma::CountingSemaphore csem;
    csem.height(n);
    T *vals = new T[n];
    i = inter.begin();
    k = 0;
    for (j = 0; j < inter.size(); j++)
      {
 if (present[j])
   {
     if (computationalContext[j] == Pooma::context())
       {
  EngineView<RemoteView> view;
  Reduction<SinglePatchEvaluatorTag>().
    evaluate(vals[k++], op,
      forEach(e(*i).engine(), view, TreeCombine()), csem);
       }
     else
       {
         expressionApply(e(*i), RemoteSend(computationalContext[j]));
       }
   }
 ++i;
      }
    ;
    csem.wait();
    Pooma::scheduler().endGeneration();
    Pooma::blockAndEvaluate();
    Pooma::scheduler().beginGeneration();
    if (n > 0)
      {
 ret = vals[0];
 for (j = 1; j < n; j++)
   op(ret, vals[j]);
      }
    delete [] vals;
    ReduceOverContexts<T, Op> finalReduction(ret, 0, n > 0);
    if (Pooma::context() == 0)
      ret = finalReduction;
    RemoteProxy<T> broadcast(ret, 0);
    ret = broadcast;
  }
};
template <int Dim, class T, class LayoutTag, class Tag>
struct EngineFunctor<Engine<Dim, T, MultiPatch<LayoutTag, Remote<Tag> > >,
  EnginePatch >
{
  typedef Engine<Dim, T, MultiPatch<LayoutTag, Remote<Tag> > > Subject_t;
  typedef Engine<Dim, T, Tag> Type_t;
  static inline
  Type_t apply(const Subject_t &engine, const EnginePatch &tag)
  {
    return engine.localPatch(tag.patch_m).localEngine();
  }
};
template <int Dim, class T, class Eng>
struct ElementProperties<Engine<Dim, T, Remote<Eng> > >
  : public MakeOwnCopyProperties<Engine<Dim, T, Remote<Eng> > >
{ };
class Full;
template<int D1, int D2, class T, class E> class TinyMatrix;
template<int D1, int D2, class T, class E> class TinyMatrixEngine;
template<class V, int I, int J>
struct TinyMatrixElem
{
  typedef V Element_t;
  typedef const V& ConstElementRef_t;
  typedef V& ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x; }
  static ElementRef_t get( V& x) { return x; }
};
template<int D1, int D2, class T, class E, int I, int J>
struct TinyMatrixEngineElem
{
  typedef TinyMatrixEngine<D1,D2,T,E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::ConstElementRef_t ConstElementRef_t;
  typedef typename V::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x(I,J); }
  static ElementRef_t get( V& x) { return x(I,J); }
};
template<int D1, int D2, class T, class E, int I, int J>
struct TinyMatrixElem< TinyMatrix<D1,D2,T,E> , I , J>
{
  typedef TinyMatrix<D1,D2,T,E> V;
  typedef TinyMatrixEngineElem<D1,D2,T,E,I,J> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x.engine()); }
  static ElementRef_t get(V& x) { return TE::get(x.engine()); }
};
template<class T1, class T2, class Op, int B1, int L1, int B2, int L2>
struct TinyMatrixAssign
{
  enum { B11=B1 , L11=L1/2 , B12=B1+L1/2 , L12 = L1-L1/2 };
  enum { B21=B2 , L21=L2/2 , B22=B2+L2/2 , L22 = L2-L2/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TinyMatrixAssign<T1,T2,Op,B11,L11,B21,L21>::apply(x,y,op);
      TinyMatrixAssign<T1,T2,Op,B12,L12,B21,L21>::apply(x,y,op);
      TinyMatrixAssign<T1,T2,Op,B11,L11,B22,L22>::apply(x,y,op);
      TinyMatrixAssign<T1,T2,Op,B12,L12,B22,L22>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int L1, int B2>
struct TinyMatrixAssign<T1,T2,Op,B1,L1,B2,1>
{
  enum { B11=B1 , L11=L1/2 , B12=B1+L1/2 , L12 = L1-L1/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TinyMatrixAssign<T1,T2,Op,B11,L11,B2,1>::apply(x,y,op);
      TinyMatrixAssign<T1,T2,Op,B12,L12,B2,1>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int B2, int L2>
struct TinyMatrixAssign<T1,T2,Op,B1,1,B2,L2>
{
  enum { B21=B2 , L21=L2/2 , B22=B2+L2/2 , L22 = L2-L2/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TinyMatrixAssign<T1,T2,Op,B1,1,B21,L21>::apply(x,y,op);
      TinyMatrixAssign<T1,T2,Op,B1,1,B22,L22>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TinyMatrixAssign<T1,T2,Op,B1,1,B2,1>
{
  static void apply(T1& x, const T2& y,Op op=Op())
    {
      op(TinyMatrixElem<T1,B1,B2>::get(x), TinyMatrixElem<T2,B1,B2>::get(y));
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TinyMatrixAssign<T1,T2,Op,B1,2,B2,2>
{
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      op(TinyMatrixElem<T1,B1 ,B2 >::get(x), TinyMatrixElem<T2,B1 ,B2 >::get(y));
      op(TinyMatrixElem<T1,B1+1,B2 >::get(x), TinyMatrixElem<T2,B1+1,B2 >::get(y));
      op(TinyMatrixElem<T1,B1 ,B2+1>::get(x), TinyMatrixElem<T2,B1 ,B2+1>::get(y));
      op(TinyMatrixElem<T1,B1+1,B2+1>::get(x), TinyMatrixElem<T2,B1+1,B2+1>::get(y));
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TinyMatrixAssign<T1,T2,Op,B1,3,B2,3>
{
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      op(TinyMatrixElem<T1,B1 ,B2 >::get(x), TinyMatrixElem<T2,B1 ,B2 >::get(y));
      op(TinyMatrixElem<T1,B1+1,B2 >::get(x), TinyMatrixElem<T2,B1+1,B2 >::get(y));
      op(TinyMatrixElem<T1,B1+2,B2 >::get(x), TinyMatrixElem<T2,B1+2,B2 >::get(y));
      op(TinyMatrixElem<T1,B1 ,B2+1>::get(x), TinyMatrixElem<T2,B1 ,B2+1>::get(y));
      op(TinyMatrixElem<T1,B1+1,B2+1>::get(x), TinyMatrixElem<T2,B1+1,B2+1>::get(y));
      op(TinyMatrixElem<T1,B1+2,B2+1>::get(x), TinyMatrixElem<T2,B1+2,B2+1>::get(y));
      op(TinyMatrixElem<T1,B1 ,B2+2>::get(x), TinyMatrixElem<T2,B1 ,B2+2>::get(y));
      op(TinyMatrixElem<T1,B1+1,B2+2>::get(x), TinyMatrixElem<T2,B1+1,B2+2>::get(y));
      op(TinyMatrixElem<T1,B1+2,B2+2>::get(x), TinyMatrixElem<T2,B1+2,B2+2>::get(y));
    }
};
template<class V1, class V2, class Op>
class BinaryTinyMatrixOp;
template<int D1, int D2, class T, class V1, class V2, class Op>
class TinyMatrixEngine<D1,D2,T,BinaryTinyMatrixOp<V1,V2,Op> >
{
public:
  enum { dimensions=2 };
  typedef T Element_t;
  typedef BinaryTinyMatrixOp<V1,V2,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef TinyMatrixEngine<D1,D2,T, BinaryTinyMatrixOp<V1,V2,Op> > This_t;
  TinyMatrixEngine(const V1& v1, const V2& v2)
    : v1_m(v1), v2_m(v2) {}
  Element_t operator()(int i, int j) const
  {
    return Op()(v1_m(i,j), v2_m(i,j));
  }
  template<int DD1,int DD2, class TT, class EE, int I, int J>
    friend struct TinyMatrixEngineElem;
private:
  const V1& v1_m;
  const V2& v2_m;
};
template<int D1, int D2, class T, class V1, class V2, class Op, int I, int J>
struct TinyMatrixEngineElem<D1,D2,T,BinaryTinyMatrixOp<V1,V2,Op>, I, J >
{
  typedef TinyMatrixEngine<D1,D2,T,BinaryTinyMatrixOp<V1,V2,Op> > V;
  typedef typename TinyMatrixElem<V1,I,J>::Element_t T1;
  typedef typename TinyMatrixElem<V2,I,J>::Element_t T2;
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(
        TinyMatrixElem<V1,I,J>::get(x.v1_m),
        TinyMatrixElem<V2,I,J>::get(x.v2_m));
    }
};
template<class V1, class Op>
class UnaryTinyMatrixOp;
template<int D1, int D2, class T, class V1, class Op>
class TinyMatrixEngine<D1,D2,T,UnaryTinyMatrixOp<V1,Op> >
{
public:
  enum { dimensions=2 };
  typedef T Element_t;
  typedef UnaryTinyMatrixOp<V1,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef TinyMatrixEngine<D1,D2,T, UnaryTinyMatrixOp<V1,Op> > This_t;
  explicit TinyMatrixEngine(const V1& v1)
    : v1_m(v1) {}
  Element_t operator()(int i, int j) const
  {
    return Op()(v1_m(i,j));
  }
  template<int DD1, int DD2, class TT, class EE, int I, int J>
    friend struct TinyMatrixEngineElem;
private:
  const V1& v1_m;
};
template<int D1, int D2, class T, class V1, class Op, int I, int J>
struct TinyMatrixEngineElem<D1,D2,T,UnaryTinyMatrixOp<V1,Op>, I, J >
{
  typedef TinyMatrixEngine<D1,D2,T,UnaryTinyMatrixOp<V1,Op> > V;
  typedef typename TinyMatrixElem<V1,I,J>::Element_t T1;
  typedef typename UnaryReturn<T1,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(TinyMatrixElem<V1,I,J>::get(x.v1_m));
    }
};
template<int D1, int D2, class T, class E> class TinyMatrix;
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcCos > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnArcCos>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcCos >::Type_t acos( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnArcCos>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnArcCos> > Expr_t; typedef typename UnaryReturn<V1,FnArcCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcSin > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnArcSin>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcSin >::Type_t asin( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnArcSin>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnArcSin> > Expr_t; typedef typename UnaryReturn<V1,FnArcSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcTan > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnArcTan>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnArcTan >::Type_t atan( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnArcTan>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnArcTan> > Expr_t; typedef typename UnaryReturn<V1,FnArcTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnCeil > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnCeil>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnCeil >::Type_t ceil( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnCeil>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnCeil> > Expr_t; typedef typename UnaryReturn<V1,FnCeil>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnCos > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnCos>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnCos >::Type_t cos( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnCos>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnCos> > Expr_t; typedef typename UnaryReturn<V1,FnCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypCos > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnHypCos>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypCos >::Type_t cosh( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnHypCos>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnHypCos> > Expr_t; typedef typename UnaryReturn<V1,FnHypCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnExp > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnExp>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnExp >::Type_t exp( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnExp>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnExp> > Expr_t; typedef typename UnaryReturn<V1,FnExp>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnFabs > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnFabs>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnFabs >::Type_t fabs( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnFabs>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnFabs> > Expr_t; typedef typename UnaryReturn<V1,FnFabs>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnFloor > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnFloor>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnFloor >::Type_t floor( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnFloor>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnFloor> > Expr_t; typedef typename UnaryReturn<V1,FnFloor>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnLog > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnLog>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnLog >::Type_t log( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnLog>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnLog> > Expr_t; typedef typename UnaryReturn<V1,FnLog>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnLog10 > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnLog10>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnLog10 >::Type_t log10( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnLog10>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnLog10> > Expr_t; typedef typename UnaryReturn<V1,FnLog10>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnSin > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnSin>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnSin >::Type_t sin( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnSin>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnSin> > Expr_t; typedef typename UnaryReturn<V1,FnSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypSin > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnHypSin>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypSin >::Type_t sinh( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnHypSin>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnHypSin> > Expr_t; typedef typename UnaryReturn<V1,FnHypSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnSqrt > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnSqrt>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnSqrt >::Type_t sqrt( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnSqrt>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnSqrt> > Expr_t; typedef typename UnaryReturn<V1,FnSqrt>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnTan > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnTan>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnTan >::Type_t tan( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnTan>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnTan> > Expr_t; typedef typename UnaryReturn<V1,FnTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypTan > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,FnHypTan>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, FnHypTan >::Type_t tanh( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,FnHypTan>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,FnHypTan> > Expr_t; typedef typename UnaryReturn<V1,FnHypTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, OpUnaryMinus > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,OpUnaryMinus>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, OpUnaryMinus >::Type_t operator-( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,OpUnaryMinus>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,OpUnaryMinus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryMinus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, OpUnaryPlus > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,OpUnaryPlus>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, OpUnaryPlus >::Type_t operator+( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,OpUnaryPlus>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,OpUnaryPlus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryPlus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T, class E> struct UnaryReturn< TinyMatrix<D1,D2,T,E>, OpBitwiseNot > { typedef TinyMatrix< D1, D2, typename UnaryReturn<T,OpBitwiseNot>::Type_t, E > Type_t; }; template <int D1, int D2, class T, class E> inline typename UnaryReturn< TinyMatrix<D1,D2,T,E>, OpBitwiseNot >::Type_t operator~( const TinyMatrix<D1,D2,T,E>& v1 ) { typedef TinyMatrix<D1,D2,T,E> V1; typedef typename UnaryReturn<T,OpBitwiseNot>::Type_t T3; typedef TinyMatrix< D1, D2, T3, UnaryTinyMatrixOp<V1,OpBitwiseNot> > Expr_t; typedef typename UnaryReturn<V1,OpBitwiseNot>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpAdd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpAdd >::Type_t operator+( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpAdd>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpAdd> > Expr_t; typedef typename BinaryReturn<V1,V2,OpAdd>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpAdd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpAdd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpAdd >::Type_t operator+( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpAdd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpAdd >::Type_t operator+( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpAdd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpSubtract > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpSubtract >::Type_t operator-( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpSubtract>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpSubtract> > Expr_t; typedef typename BinaryReturn<V1,V2,OpSubtract>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpSubtract > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpSubtract > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpSubtract >::Type_t operator-( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpSubtract> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpSubtract >::Type_t operator-( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpSubtract> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpMultiply > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpMultiply >::Type_t operator*( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpMultiply> > Expr_t; typedef typename BinaryReturn<V1,V2,OpMultiply>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpMultiply > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpMultiply > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpMultiply >::Type_t operator*( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpMultiply> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpMultiply >::Type_t operator*( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpMultiply> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpDivide > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpDivide >::Type_t operator/( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpDivide>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpDivide> > Expr_t; typedef typename BinaryReturn<V1,V2,OpDivide>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpDivide > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpDivide > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpDivide >::Type_t operator/( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpDivide> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpDivide >::Type_t operator/( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpDivide> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpMod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpMod >::Type_t operator%( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpMod>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpMod> > Expr_t; typedef typename BinaryReturn<V1,V2,OpMod>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpMod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpMod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpMod >::Type_t operator%( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpMod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpMod >::Type_t operator%( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpMod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpBitwiseAnd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpBitwiseAnd >::Type_t operator&( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpBitwiseAnd> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseAnd>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseAnd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseAnd > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseAnd >::Type_t operator&( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseAnd >::Type_t operator&( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpBitwiseOr > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpBitwiseOr >::Type_t operator|( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpBitwiseOr> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseOr>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseOr > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseOr > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseOr >::Type_t operator|( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseOr >::Type_t operator|( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, OpBitwiseXor > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, OpBitwiseXor >::Type_t operator^( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,OpBitwiseXor> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseXor>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseXor > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseXor > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, OpBitwiseXor >::Type_t operator^( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, OpBitwiseXor >::Type_t operator^( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, FnLdexp > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, FnLdexp >::Type_t ldexp( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnLdexp>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,FnLdexp> > Expr_t; typedef typename BinaryReturn<V1,V2,FnLdexp>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnLdexp > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnLdexp > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnLdexp >::Type_t ldexp( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,FnLdexp> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnLdexp >::Type_t ldexp( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,FnLdexp> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, FnPow > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, FnPow >::Type_t pow( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnPow>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,FnPow> > Expr_t; typedef typename BinaryReturn<V1,V2,FnPow>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnPow > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnPow > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnPow >::Type_t pow( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,FnPow> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnPow >::Type_t pow( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,FnPow> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, FnFmod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, FnFmod >::Type_t fmod( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnFmod>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,FnFmod> > Expr_t; typedef typename BinaryReturn<V1,V2,FnFmod>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnFmod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnFmod > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnFmod >::Type_t fmod( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,FnFmod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnFmod >::Type_t fmod( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,FnFmod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, TinyMatrix<D1,D2,T2,E>, FnArcTan2 > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E1, class E2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>, TinyMatrix<D1,D2,T2,E2>, FnArcTan2 >::Type_t atan2( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> V1; typedef TinyMatrix<D1,D2,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnArcTan2>::Type_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,V2,FnArcTan2> > Expr_t; typedef typename BinaryReturn<V1,V2,FnArcTan2>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnArcTan2 > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class T2, class E> struct BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnArcTan2 > { typedef TinyMatrix< D1, D2, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D1, int D2, class T1, class E, class T2> inline typename BinaryReturn< TinyMatrix<D1,D2,T1,E>, T2, FnArcTan2 >::Type_t atan2( const TinyMatrix<D1,D2,T1,E>& v1, const T2& x ) { typedef TinyMatrix<D1,D2,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<V1,T2,FnArcTan2> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D1, int D2, class T1, class T2, class E> inline typename BinaryReturn< T1, TinyMatrix<D1,D2,T2,E>, FnArcTan2 >::Type_t atan2( const T1& x, const TinyMatrix<D1,D2,T2,E>& v2 ) { typedef TinyMatrix<D1,D2,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef TinyMatrix< D1, D2, T3, BinaryTinyMatrixOp<T1,V2,FnArcTan2> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template<int D1, int D2, class T, class V1, class V2>
class TinyMatrixEngine<D1,D2,T,BinaryTinyMatrixOp<V1,V2,FnDot> >
{
public:
  enum { dimensions=2 };
  typedef T Element_t;
  typedef FnDot Op;
  typedef BinaryTinyMatrixOp<V1,V2,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef TinyMatrixEngine<D1,D2,T, BinaryTinyMatrixOp<V1,V2,Op> > This_t;
  TinyMatrixEngine(const V1& v1, const V2& v2, Op op)
    : v1_m(v1), v2_m(v2), op_m(op) {}
  TinyMatrixEngine(const V1& v1, const V2& v2)
    : v1_m(v1), v2_m(v2) {}
  TinyMatrixEngine(const This_t& x)
    : v1_m(x.v1_m), v2_m(x.v2_m), op_m(x.op_m) {}
  ~TinyMatrixEngine() {}
  template<int DD1,int DD2, class TT, class EE, int I, int J>
    friend struct TinyMatrixEngineElem;
private:
  const V1& v1_m;
  const V2& v2_m;
  Op op_m;
};
template<class T1, class T2, int I, int J, int K, int L>
struct TinyMatrixDotTinyMatrix
{
  typedef typename TinyMatrixDotTinyMatrix<T1,T2,I,J,K,L/2>::Type_t Left_t;
  typedef typename TinyMatrixDotTinyMatrix<T1,T2,I,J,K+L/2,L-L/2>::Type_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpAdd>::Type_t Type_t;
  static Type_t get(const T1& x, const T2& y)
    {
      return
        TinyMatrixDotTinyMatrix<T1,T2,I,J,K,L/2>::get(x,y) +
        TinyMatrixDotTinyMatrix<T1,T2,I,J,K+L/2,L-L/2>::get(x,y);
    }
};
template<class T1, class T2, int I, int J, int K>
struct TinyMatrixDotTinyMatrix<T1,T2,I,J,K,1>
{
  typedef typename TinyMatrixElem<T1,I,K>::Element_t Left_t;
  typedef typename TinyMatrixElem<T2,K,J>::Element_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpMultiply>::Type_t Type_t;
  static Type_t get(const T1& x, const T2& y)
    {
      return TinyMatrixElem<T1,I,K>::get(x) * TinyMatrixElem<T2,K,J>::get(y);
    }
};
template<int D1, int D2, class T, class T1, class T2, int I, int J>
struct TinyMatrixEngineElem<D1,D2,T,BinaryTinyMatrixOp<T1,T2,FnDot>, I, J >
{
  typedef BinaryTinyMatrixOp<T1,T2,FnDot> E;
  typedef TinyMatrixEngine<D1,D2,T,E> T0;
  typedef typename TinyMatrixDotTinyMatrix<T1,T2,I,J,0,T1::d1>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const T0& x)
    {
      return TinyMatrixDotTinyMatrix<T1,T2,I,J,0,T1::d2>::get(x.v1_m,x.v2_m);
    }
};
template<int D1, int D2, int D3, class T1, class T2, class E1, class E2>
struct BinaryReturn< TinyMatrix<D1,D2,T1,E1> , TinyMatrix<D2,D3,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef TinyMatrix<D1,D3,T0,Full> Type_t;
};
template<int D1, int D2, int D3, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< TinyMatrix<D1,D2,T1,E1>,TinyMatrix<D2,D3,T2,E2> , FnDot >::Type_t
dot( const TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D2,D3,T2,E2>& v2 )
{
  typedef TinyMatrix<D1,D2,T1,E1> V1;
  typedef TinyMatrix<D2,D3,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef TinyMatrix<D1,D3,T3,BinaryTinyMatrixOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<int D1, int D2, class T1, class T2, class E1, class E2>
struct BinaryReturn< TinyMatrix<D1,D2,T1,E1>,TinyMatrix<D1,D2,T2,E2> , OpEQ >
{
  typedef bool Type_t;
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
struct BinaryReturn< TinyMatrix<D1,D2,T1,E1>,TinyMatrix<D1,D2,T2,E2> , OpNE >
{
  typedef bool Type_t;
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< TinyMatrix<D1,D2,T1,E1>,TinyMatrix<D1,D2,T2,E2> , OpEQ >::Type_t
operator==(const TinyMatrix<D1,D2,T1,E1>& t1, const TinyMatrix<D1,D2,T2,E2>& t2)
{
  for (int i = 0; i < D1; i++)
    for (int j = 0; j < D2; j++)
      if (t1(i,j) != t2(i,j)) return false;
  return true;
}
template<int D1, int D2, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< TinyMatrix<D1,D2,T1,E1>,TinyMatrix<D1,D2,T2,E2> , OpNE >::Type_t
operator!=(const TinyMatrix<D1,D2,T1,E1>& t1, const TinyMatrix<D1,D2,T2,E2>& t2)
{
  return !(t1 == t2);
}
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator+=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpAddAssign,0,D1,0,D2>::apply(v1,v2,OpAddAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator+=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpAddAssign,0,D1,0,D2>:: apply(v1,v2,OpAddAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator-=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpSubtractAssign,0,D1,0,D2>::apply(v1,v2,OpSubtractAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator-=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpSubtractAssign,0,D1,0,D2>:: apply(v1,v2,OpSubtractAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator*=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpMultiplyAssign,0,D1,0,D2>::apply(v1,v2,OpMultiplyAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator*=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpMultiplyAssign,0,D1,0,D2>:: apply(v1,v2,OpMultiplyAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator/=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpDivideAssign,0,D1,0,D2>::apply(v1,v2,OpDivideAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator/=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpDivideAssign,0,D1,0,D2>:: apply(v1,v2,OpDivideAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator%=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpModAssign,0,D1,0,D2>::apply(v1,v2,OpModAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator%=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpModAssign,0,D1,0,D2>:: apply(v1,v2,OpModAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator|=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpBitwiseOrAssign,0,D1,0,D2>::apply(v1,v2,OpBitwiseOrAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator|=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpBitwiseOrAssign,0,D1,0,D2>:: apply(v1,v2,OpBitwiseOrAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator&=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpBitwiseAndAssign,0,D1,0,D2>::apply(v1,v2,OpBitwiseAndAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator&=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpBitwiseAndAssign,0,D1,0,D2>:: apply(v1,v2,OpBitwiseAndAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator^=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpBitwiseXorAssign,0,D1,0,D2>::apply(v1,v2,OpBitwiseXorAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator^=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpBitwiseXorAssign,0,D1,0,D2>:: apply(v1,v2,OpBitwiseXorAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator<<=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpLeftShiftAssign,0,D1,0,D2>::apply(v1,v2,OpLeftShiftAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator<<=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpLeftShiftAssign,0,D1,0,D2>:: apply(v1,v2,OpLeftShiftAssign()); return v1; }
template <int D1, int D2, class T1, class T2, class E1, class E2> inline const TinyMatrix<D1,D2,T1,E1>& operator>>=( TinyMatrix<D1,D2,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 ) { typedef TinyMatrix<D1,D2,T1,E1> Left_t; typedef TinyMatrix<D1,D2,T2,E2> Right_t; TinyMatrixAssign<Left_t,Right_t,OpRightShiftAssign,0,D1,0,D2>::apply(v1,v2,OpRightShiftAssign()); return v1; } template <int D1, int D2, class T1, class T2, class E1> inline const TinyMatrix<D1,D2,T1,E1>& operator>>=( TinyMatrix<D1,D2,T1,E1>& v1, const T2& v2 ) { TinyMatrixAssign<TinyMatrix<D1,D2,T1,E1>,T2,OpRightShiftAssign,0,D1,0,D2>:: apply(v1,v2,OpRightShiftAssign()); return v1; }
template<int D1, int D2, class T, class E> class TinyMatrix;
template<int D1, int D2, class T, class E> class TinyMatrixEngine;
template <class T>
void reverseBytes(T&);
template<int D1, int D2=D1, class T=double, class EngineTag=Full>
class TinyMatrix
{
public:
  enum { dimensions=2 };
  enum { d1=D1, d2=D2 };
  typedef T Element_t;
  typedef EngineTag EngineTag_t;
  typedef TinyMatrixEngine<D1,D2,T,EngineTag> Engine_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef typename Engine_t::ConstElementRef_t ConstElementRef_t;
  typedef TinyMatrix<D1,D2,T,EngineTag> This_t;
  TinyMatrix() {}
  TinyMatrix(const This_t& x) : engine_m(x.engine_m) {}
  template<int D3, int D4, class T2, class EngineTag2>
  TinyMatrix(const TinyMatrix<D3, D4, T2, EngineTag2>& x) : engine_m(x) {}
  template<class X>
  explicit TinyMatrix(const X& x) : engine_m(x) {}
  template<class X1, class X2>
    TinyMatrix(const X1& x1, const X2& x2) : engine_m(x1,x2) {}
  template<class X1, class X2, class X3>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3)
    : engine_m(x1,x2,x3) {}
  template<class X1, class X2, class X3, class X4>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4)
    : engine_m(x1,x2,x3,x4) {}
  template<class X1, class X2, class X3, class X4, class X5>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5)
    : engine_m(x1,x2,x3,x4,x5) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6)
    : engine_m(x1,x2,x3,x4,x5,x6) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7)
    : engine_m(x1,x2,x3,x4,x5,x6,x7) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7, class X8>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7, const X8& x8)
    : engine_m(x1,x2,x3,x4,x5,x6,x7,x8) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7, class X8, class X9>
    TinyMatrix(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7, const X8& x8, const X9& x9)
    : engine_m(x1,x2,x3,x4,x5,x6,x7,x8,x9) {}
  ~TinyMatrix() {}
  This_t& operator=(const This_t& x)
    {
      if ( this != &x )
        engine() = x.engine();
      return *this;
    }
  template<class V>
    This_t& operator=(const V& x)
        {
          engine() = x;
          return *this;
        }
  ConstElementRef_t operator()(int i,int j) const
    {
      return engine()(i,j);
    }
  ElementRef_t operator()(int i,int j)
    {
      return engine()(i,j);
    }
  ConstElementRef_t operator()(int i) const { return engine()(i); }
  ElementRef_t operator()(int i) { return engine()(i); }
  const Engine_t& engine() const { return engine_m; }
  Engine_t& engine() { return engine_m; }
  template<class Out>
  void print(Out &out) const;
  inline void reverseBytes() { engine_m.reverseBytes(); }
private:
  Engine_t engine_m;
};
template<int D1, int D2, class T, class EngineTag>
template<class Out>
void TinyMatrix<D1, D2, T, EngineTag>::print(Out &out) const
{
  std::ios::fmtflags incomingFormatFlags = out.flags();
  long width = out.width();
  long precision = out.precision();
  out.width(0);
  out << "(";
  for (int i = 0; i < D1; i++) {
    out << "(";
    out.flags(incomingFormatFlags);
    out.width(width);
    out.precision(precision);
    out << (*this)(i, 0);
    for (int j = 1; j < D2; j++) {
      out << " ";
      out.flags(incomingFormatFlags);
      out.width(width);
      out.precision(precision);
      out << (*this)(i, j);
    }
    out << ")";
  }
  out << ")";
}
template<int D1, int D2, class T, class E>
std::ostream &operator<<(std::ostream &out, const TinyMatrix<D1,D2,T,E> &t)
{
  t.print(out);
  return out;
}
template <int D1, int D2, class T, class E>
struct ElementProperties< TinyMatrix<D1,D2,T,E> >
  : public TrivialElementProperties< TinyMatrix<D1,D2,T,E> >
{ };
template<int D1, int D2, class T>
class TinyMatrixEngine<D1,D2,T,Full>
{
public:
  enum { dimensions=2 };
  enum { d1=D1, d2=D2 };
  typedef T Element_t;
  typedef Full EngineTag_t;
  typedef T& ElementRef_t;
  typedef const T& ConstElementRef_t;
  typedef TinyMatrixEngine<D1,D2,T,Full> This_t;
  TinyMatrixEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
  }
  TinyMatrixEngine(const TinyMatrixEngine<D1,D2,T,Full>& x)
    {
      TinyMatrixAssign<This_t,This_t,OpAssign,0,D1,0,D2>
 ::apply(*this,x,OpAssign());
    }
  template<class X>
  explicit TinyMatrixEngine(const X& x)
      {
        TinyMatrixAssign<This_t,X,OpAssign,0,D1,0,D2>::apply(*this,x,OpAssign());
      }
  template<class X1, class X2>
    TinyMatrixEngine(const X1& x1, const X2& x2)
      {
        PoomaCTAssert<(D1*D2 == 2)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
      }
  template<class X1, class X2, class X3>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3)
      {
        PoomaCTAssert<(D1*D2 == 3)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
      }
  template<class X1, class X2, class X3, class X4>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4)
      {
        PoomaCTAssert<(D1*D2 == 4)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
      }
  template<class X1, class X2, class X3, class X4, class X5>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5)
      {
        PoomaCTAssert<(D1*D2 == 5)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
        (*this)(4) = x5;
      }
  template<class X1, class X2, class X3, class X4, class X5, class X6>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6)
      {
        PoomaCTAssert<(D1*D2 == 6)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
        (*this)(4) = x5;
        (*this)(5) = x6;
      }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7)
      {
        PoomaCTAssert<(D1*D2 == 7)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
        (*this)(4) = x5;
        (*this)(5) = x6;
        (*this)(6) = x7;
      }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7, class X8>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7, const X8& x8)
      {
        PoomaCTAssert<(D1*D2 == 8)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
        (*this)(4) = x5;
        (*this)(5) = x6;
        (*this)(6) = x7;
        (*this)(7) = x8;
      }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
           class X7, class X8, class X9>
    TinyMatrixEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
           const X5& x5, const X6& x6, const X7& x7, const X8& x8, const X9& x9)
      {
        PoomaCTAssert<(D1*D2 == 9)>::test();
        (*this)(0) = x1;
        (*this)(1) = x2;
        (*this)(2) = x3;
        (*this)(3) = x4;
        (*this)(4) = x5;
        (*this)(5) = x6;
        (*this)(6) = x7;
        (*this)(7) = x8;
        (*this)(8) = x9;
      }
  ~TinyMatrixEngine() {}
  const This_t&
    operator=(const This_t& x)
      {
        if ( this != &x )
          TinyMatrixAssign<This_t,This_t,OpAssign,0,D1,0,D2>
     ::apply(*this,x,OpAssign());
        return *this;
      }
  template<class V>
    const This_t&
      operator=(const V& x)
        {
          TinyMatrixAssign<This_t,V,OpAssign,0,D1,0,D2>::apply(*this,x,OpAssign());
          return *this;
        }
  ConstElementRef_t operator()(int i,int j) const
    {
      ;
      return x_m[i+D1*j];
    }
  ElementRef_t operator()(int i,int j)
    {
      ;
      return x_m[i+D1*j];
    }
  ConstElementRef_t operator()(int i) const
    {
      ;
      return x_m[i];
    }
  ElementRef_t operator()(int i)
    {
      ;
      return x_m[i];
    }
  inline void reverseBytes()
  {
    for (int d = 0; d < D1*D2; ++d) ::reverseBytes(x_m[d]);
  }
private:
  T x_m[D1*D2];
};
template<class T, class Components> struct ComponentAccess;
template<int D1, int D2, class T, class E, int N>
struct ComponentAccess< TinyMatrix<D1, D2, T, E>, Loc<N> >
{
  typedef TinyMatrix<D1, D2, T, E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::ElementRef_t ElementRef_t;
  static inline ElementRef_t indexRef(V &t, const Loc<N> &l)
    {
      PoomaCTAssert<(N==2)>::test();
      return t(l[0].first(), l[1].first());
    }
  static inline Element_t index(const V &t, const Loc<N> &l)
    {
      PoomaCTAssert<(N==2)>::test();
      return t(l[0].first(), l[1].first());
    }
};
template<int D1, int D2, class T, int I, int J>
struct TinyMatrixElem< TinyMatrixEngine<D1,D2,T,Full> , I , J>
{
  typedef TinyMatrixEngine<D1,D2,T,Full> V;
  typedef TinyMatrixEngineElem<D1,D2,T,Full,I,J> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x); }
  static ElementRef_t get(V& x) { return TE::get(x); }
};
template<int D, class T, class E> class Tensor;
template<int D, class T, class E> class TensorEngine;
class Antisymmetric;
class Symmetric;
class Diagonal;
struct Unwritable
{
public:
  template<class T>
  void operator=(const T&) { }
  void operator=(const Unwritable&) { }
};
template<int D, class E, int I, int J>
class Writable
{
public:
  enum { value = 1 };
};
template<int D, int I, int J>
class Writable<D, Antisymmetric, I, J>
{
public:
  enum { value = (I > J) };
};
template<int D, int I, int J>
class Writable<D, Symmetric, I, J>
{
public:
  enum { value = (I >= J) };
};
template<int D, int I, int J>
class Writable<D, Diagonal, I, J>
{
public:
  enum { value = (I == J) };
};
template<int D, class T, class E, int I, int J, int B=1>
struct TensorEngineElem;
template<int D, class T, class E, int I, int J>
struct TensorEngineElem<D, T, E, I, J, 1>
{
  typedef TensorEngine<D,T,E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::CTConstElementRef_t ConstElementRef_t;
  typedef typename V::CTElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x.template getIJ<I,J>(); }
  static ElementRef_t get( V& x) { return x.template getIJ<I,J>(); }
};
template<int D, class T, class E, int I, int J>
struct TensorEngineElem<D, T, E, I, J, 0>
{
  typedef TensorEngine<D,T,E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::CTConstElementRef_t ConstElementRef_t;
  typedef Unwritable ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x.template getIJ<I,J>(); }
  static ElementRef_t get( V& x) { return Unwritable(); }
};
template<class V, int I, int J>
struct TensorElem
{
  typedef V Element_t;
  typedef const V& ConstElementRef_t;
  typedef V& ElementRef_t;
  static ConstElementRef_t get(const V& x) { return x; }
  static ElementRef_t get( V& x) { return x; }
};
template<int D, class T, class E, int I, int J>
struct TensorElem< Tensor<D,T,E> , I , J>
{
  typedef Tensor<D,T,E> V;
  typedef TensorEngineElem<D,T,E,I,J,Writable<D,E,I,J>::value> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x.engine()); }
  static ElementRef_t get(V& x) { return TE::get(x.engine()); }
};
template<int D, class T, class E, int I, int J>
struct TensorElem< TensorEngine<D,T,E> , I , J>
{
};
template<class T1, class T2, class Op, int B1, int L1, int B2, int L2>
struct TensorAssign
{
  enum { B11=B1 , L11=L1/2 , B12=B1+L1/2 , L12 = L1-L1/2 };
  enum { B21=B2 , L21=L2/2 , B22=B2+L2/2 , L22 = L2-L2/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TensorAssign<T1,T2,Op,B11,L11,B21,L21>::apply(x,y,op);
      TensorAssign<T1,T2,Op,B12,L12,B21,L21>::apply(x,y,op);
      TensorAssign<T1,T2,Op,B11,L11,B22,L22>::apply(x,y,op);
      TensorAssign<T1,T2,Op,B12,L12,B22,L22>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int L1, int B2>
struct TensorAssign<T1,T2,Op,B1,L1,B2,1>
{
  enum { B11=B1 , L11=L1/2 , B12=B1+L1/2 , L12 = L1-L1/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TensorAssign<T1,T2,Op,B11,L11,B2,1>::apply(x,y,op);
      TensorAssign<T1,T2,Op,B12,L12,B2,1>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int B2, int L2>
struct TensorAssign<T1,T2,Op,B1,1,B2,L2>
{
  enum { B21=B2 , L21=L2/2 , B22=B2+L2/2 , L22 = L2-L2/2 };
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      TensorAssign<T1,T2,Op,B1,1,B21,L21>::apply(x,y,op);
      TensorAssign<T1,T2,Op,B1,1,B22,L22>::apply(x,y,op);
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TensorAssign<T1,T2,Op,B1,1,B2,1>
{
  static void apply(T1& x, const T2& y,Op op=Op())
    {
      op(TensorElem<T1,B1,B2>::get(x), TensorElem<T2,B1,B2>::get(y));
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TensorAssign<T1,T2,Op,B1,2,B2,2>
{
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      op(TensorElem<T1,B1 ,B2 >::get(x), TensorElem<T2,B1 ,B2 >::get(y));
      op(TensorElem<T1,B1+1,B2 >::get(x), TensorElem<T2,B1+1,B2 >::get(y));
      op(TensorElem<T1,B1 ,B2+1>::get(x), TensorElem<T2,B1 ,B2+1>::get(y));
      op(TensorElem<T1,B1+1,B2+1>::get(x), TensorElem<T2,B1+1,B2+1>::get(y));
    }
};
template<class T1, class T2, class Op, int B1, int B2>
struct TensorAssign<T1,T2,Op,B1,3,B2,3>
{
  static void apply(T1& x, const T2& y, Op op=Op())
    {
      op(TensorElem<T1,B1 ,B2 >::get(x), TensorElem<T2,B1 ,B2 >::get(y));
      op(TensorElem<T1,B1+1,B2 >::get(x), TensorElem<T2,B1+1,B2 >::get(y));
      op(TensorElem<T1,B1+2,B2 >::get(x), TensorElem<T2,B1+2,B2 >::get(y));
      op(TensorElem<T1,B1 ,B2+1>::get(x), TensorElem<T2,B1 ,B2+1>::get(y));
      op(TensorElem<T1,B1+1,B2+1>::get(x), TensorElem<T2,B1+1,B2+1>::get(y));
      op(TensorElem<T1,B1+2,B2+1>::get(x), TensorElem<T2,B1+2,B2+1>::get(y));
      op(TensorElem<T1,B1 ,B2+2>::get(x), TensorElem<T2,B1 ,B2+2>::get(y));
      op(TensorElem<T1,B1+1,B2+2>::get(x), TensorElem<T2,B1+1,B2+2>::get(y));
      op(TensorElem<T1,B1+2,B2+2>::get(x), TensorElem<T2,B1+2,B2+2>::get(y));
    }
};
template<class V1, class V2, class Op>
class BinaryTensorOp;
template<int D, class T, class V1, class V2, class Op>
class TensorEngine<D,T,BinaryTensorOp<V1,V2,Op> >
{
public:
  enum { dimensions=2 };
  typedef T Element_t;
  typedef BinaryTensorOp<V1,V2,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef TensorEngine<D,T, BinaryTensorOp<V1,V2,Op> > This_t;
  TensorEngine(const V1& v1, const V2& v2)
    : v1_m(v1), v2_m(v2) {}
  Element_t operator()(int i, int j) const
  {
    return Op()(v1_m(i,j), v2_m(i,j));
  }
  template<int DD, class TT, class EE, int I, int J, int BB>
  friend struct TensorEngineElem;
private:
  const V1& v1_m;
  const V2& v2_m;
};
template<int D, class T, class V1, class V2, class Op, int I, int J>
struct TensorEngineElem<D,T,BinaryTensorOp<V1,V2,Op>, I, J, 1>
{
  typedef TensorEngine<D,T,BinaryTensorOp<V1,V2,Op> > V;
  typedef typename TensorElem<V1,I,J>::Element_t T1;
  typedef typename TensorElem<V2,I,J>::Element_t T2;
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(
        TensorElem<V1,I,J>::get(x.v1_m),
        TensorElem<V2,I,J>::get(x.v2_m));
    }
};
template<class V1, class Op>
class UnaryTensorOp;
template<int D, class T, class V1, class Op>
class TensorEngine<D,T,UnaryTensorOp<V1,Op> >
{
public:
  enum { dimensions=2 };
  typedef T Element_t;
  typedef UnaryTensorOp<V1,Op> EngineTag_t;
  typedef T ConstElementRef_t;
  typedef T ElementRef_t;
  typedef TensorEngine<D,T, UnaryTensorOp<V1,Op> > This_t;
  explicit TensorEngine(const V1& v1)
    : v1_m(v1) {}
  Element_t operator()(int i, int j) const
  {
    return Op()(v1_m(i, j));
  }
  template<int DD, class TT, class EE, int I, int J, int BB>
  friend struct TensorEngineElem;
private:
  const V1& v1_m;
};
template<int D, class T, class V1, class Op, int I, int J>
struct TensorEngineElem<D,T,UnaryTensorOp<V1,Op>, I, J, 1>
{
  typedef TensorEngine<D,T,UnaryTensorOp<V1,Op> > V;
  typedef typename TensorElem<V1,I,J>::Element_t T1;
  typedef typename UnaryReturn<T1,Op>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const V& x)
    {
      return Op()(TensorElem<V1,I,J>::get(x.v1_m));
    }
};
template<int D, class T, class E> class Tensor;
class Full;
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnArcCos > { typedef Tensor< D, typename UnaryReturn<T,FnArcCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnArcCos >::Type_t acos( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnArcCos>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnArcCos> > Expr_t; typedef typename UnaryReturn<V1,FnArcCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnArcSin > { typedef Tensor< D, typename UnaryReturn<T,FnArcSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnArcSin >::Type_t asin( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnArcSin>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnArcSin> > Expr_t; typedef typename UnaryReturn<V1,FnArcSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnArcTan > { typedef Tensor< D, typename UnaryReturn<T,FnArcTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnArcTan >::Type_t atan( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnArcTan>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnArcTan> > Expr_t; typedef typename UnaryReturn<V1,FnArcTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnCeil > { typedef Tensor< D, typename UnaryReturn<T,FnCeil>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnCeil >::Type_t ceil( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnCeil>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnCeil> > Expr_t; typedef typename UnaryReturn<V1,FnCeil>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnCos > { typedef Tensor< D, typename UnaryReturn<T,FnCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnCos >::Type_t cos( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnCos>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnCos> > Expr_t; typedef typename UnaryReturn<V1,FnCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnHypCos > { typedef Tensor< D, typename UnaryReturn<T,FnHypCos>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnHypCos >::Type_t cosh( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnHypCos>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnHypCos> > Expr_t; typedef typename UnaryReturn<V1,FnHypCos>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnExp > { typedef Tensor< D, typename UnaryReturn<T,FnExp>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnExp >::Type_t exp( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnExp>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnExp> > Expr_t; typedef typename UnaryReturn<V1,FnExp>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnFabs > { typedef Tensor< D, typename UnaryReturn<T,FnFabs>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnFabs >::Type_t fabs( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnFabs>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnFabs> > Expr_t; typedef typename UnaryReturn<V1,FnFabs>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnFloor > { typedef Tensor< D, typename UnaryReturn<T,FnFloor>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnFloor >::Type_t floor( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnFloor>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnFloor> > Expr_t; typedef typename UnaryReturn<V1,FnFloor>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnLog > { typedef Tensor< D, typename UnaryReturn<T,FnLog>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnLog >::Type_t log( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnLog>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnLog> > Expr_t; typedef typename UnaryReturn<V1,FnLog>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnLog10 > { typedef Tensor< D, typename UnaryReturn<T,FnLog10>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnLog10 >::Type_t log10( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnLog10>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnLog10> > Expr_t; typedef typename UnaryReturn<V1,FnLog10>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnSin > { typedef Tensor< D, typename UnaryReturn<T,FnSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnSin >::Type_t sin( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnSin>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnSin> > Expr_t; typedef typename UnaryReturn<V1,FnSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnHypSin > { typedef Tensor< D, typename UnaryReturn<T,FnHypSin>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnHypSin >::Type_t sinh( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnHypSin>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnHypSin> > Expr_t; typedef typename UnaryReturn<V1,FnHypSin>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnSqrt > { typedef Tensor< D, typename UnaryReturn<T,FnSqrt>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnSqrt >::Type_t sqrt( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnSqrt>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnSqrt> > Expr_t; typedef typename UnaryReturn<V1,FnSqrt>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnTan > { typedef Tensor< D, typename UnaryReturn<T,FnTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnTan >::Type_t tan( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnTan>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnTan> > Expr_t; typedef typename UnaryReturn<V1,FnTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, FnHypTan > { typedef Tensor< D, typename UnaryReturn<T,FnHypTan>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, FnHypTan >::Type_t tanh( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,FnHypTan>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,FnHypTan> > Expr_t; typedef typename UnaryReturn<V1,FnHypTan>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, OpUnaryMinus > { typedef Tensor< D, typename UnaryReturn<T,OpUnaryMinus>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, OpUnaryMinus >::Type_t operator-( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,OpUnaryMinus>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,OpUnaryMinus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryMinus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, OpUnaryPlus > { typedef Tensor< D, typename UnaryReturn<T,OpUnaryPlus>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, OpUnaryPlus >::Type_t operator+( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,OpUnaryPlus>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,OpUnaryPlus> > Expr_t; typedef typename UnaryReturn<V1,OpUnaryPlus>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T, class E> struct UnaryReturn< Tensor<D,T,E>, OpBitwiseNot > { typedef Tensor< D, typename UnaryReturn<T,OpBitwiseNot>::Type_t, E > Type_t; }; template <int D, class T, class E> inline typename UnaryReturn< Tensor<D,T,E>, OpBitwiseNot >::Type_t operator~( const Tensor<D,T,E>& v1 ) { typedef Tensor<D,T,E> V1; typedef typename UnaryReturn<T,OpBitwiseNot>::Type_t T3; typedef Tensor< D, T3, UnaryTensorOp<V1,OpBitwiseNot> > Expr_t; typedef typename UnaryReturn<V1,OpBitwiseNot>::Type_t Return_t; return Return_t( Expr_t(v1) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpAdd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpAdd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpAdd >::Type_t operator+( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpAdd>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpAdd> > Expr_t; typedef typename BinaryReturn<V1,V2,OpAdd>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpAdd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpAdd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpAdd>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpAdd >::Type_t operator+( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpAdd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpAdd >::Type_t operator+( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpAdd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpAdd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpSubtract > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpSubtract > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpSubtract >::Type_t operator-( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpSubtract>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpSubtract> > Expr_t; typedef typename BinaryReturn<V1,V2,OpSubtract>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpSubtract > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpSubtract > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpSubtract>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpSubtract >::Type_t operator-( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpSubtract> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpSubtract >::Type_t operator-( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpSubtract>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpSubtract> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpMultiply > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpMultiply > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpMultiply >::Type_t operator*( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpMultiply> > Expr_t; typedef typename BinaryReturn<V1,V2,OpMultiply>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpMultiply > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpMultiply > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMultiply>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpMultiply >::Type_t operator*( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpMultiply> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpMultiply >::Type_t operator*( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMultiply>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpMultiply> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpDivide > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpDivide > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpDivide >::Type_t operator/( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpDivide>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpDivide> > Expr_t; typedef typename BinaryReturn<V1,V2,OpDivide>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpDivide > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpDivide > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpDivide>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpDivide >::Type_t operator/( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpDivide> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpDivide >::Type_t operator/( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpDivide>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpDivide> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpMod > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpMod > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpMod >::Type_t operator%( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpMod>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpMod> > Expr_t; typedef typename BinaryReturn<V1,V2,OpMod>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpMod > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpMod > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpMod>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpMod >::Type_t operator%( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpMod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpMod >::Type_t operator%( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpMod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpMod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpBitwiseAnd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseAnd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseAnd >::Type_t operator&( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpBitwiseAnd> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseAnd>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseAnd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseAnd > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseAnd>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseAnd >::Type_t operator&( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseAnd >::Type_t operator&( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseAnd>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpBitwiseAnd> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpBitwiseOr > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseOr > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseOr >::Type_t operator|( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpBitwiseOr> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseOr>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseOr > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseOr > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseOr>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseOr >::Type_t operator|( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseOr >::Type_t operator|( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseOr>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpBitwiseOr> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, OpBitwiseXor > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseXor > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpBitwiseXor >::Type_t operator^( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,OpBitwiseXor> > Expr_t; typedef typename BinaryReturn<V1,V2,OpBitwiseXor>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseXor > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseXor > { typedef Tensor< D, typename BinaryReturn<T1,T2,OpBitwiseXor>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, OpBitwiseXor >::Type_t operator^( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, OpBitwiseXor >::Type_t operator^( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,OpBitwiseXor>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,OpBitwiseXor> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, FnLdexp > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnLdexp > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnLdexp >::Type_t ldexp( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnLdexp>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,FnLdexp> > Expr_t; typedef typename BinaryReturn<V1,V2,FnLdexp>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, FnLdexp > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, FnLdexp > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnLdexp>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, FnLdexp >::Type_t ldexp( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,FnLdexp> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, FnLdexp >::Type_t ldexp( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnLdexp>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,FnLdexp> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, FnPow > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnPow > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnPow >::Type_t pow( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnPow>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,FnPow> > Expr_t; typedef typename BinaryReturn<V1,V2,FnPow>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, FnPow > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, FnPow > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnPow>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, FnPow >::Type_t pow( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,FnPow> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, FnPow >::Type_t pow( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnPow>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,FnPow> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, FnFmod > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnFmod > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnFmod >::Type_t fmod( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnFmod>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,FnFmod> > Expr_t; typedef typename BinaryReturn<V1,V2,FnFmod>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, FnFmod > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, FnFmod > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnFmod>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, FnFmod >::Type_t fmod( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,FnFmod> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, FnFmod >::Type_t fmod( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnFmod>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,FnFmod> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, Tensor<D,T2,E>, FnArcTan2 > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E1, class E2> struct BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnArcTan2 > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, Full > Type_t; }; template <int D, class T1, class T2, class E1, class E2> inline typename BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, FnArcTan2 >::Type_t atan2( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 ) { typedef Tensor<D,T1,E1> V1; typedef Tensor<D,T2,E2> V2; typedef typename BinaryReturn<T1,T2,FnArcTan2>::Type_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,V2,FnArcTan2> > Expr_t; typedef typename BinaryReturn<V1,V2,FnArcTan2>::Type_t Return_t; return Return_t( Expr_t(v1,v2) ); } template <int D, class T1, class T2, class E> struct BinaryReturn< Tensor<D,T1,E>, T2, FnArcTan2 > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class T2, class E> struct BinaryReturn< T1, Tensor<D,T2,E>, FnArcTan2 > { typedef Tensor< D, typename BinaryReturn<T1,T2,FnArcTan2>::Type_t, E > Type_t; }; template <int D, class T1, class E, class T2> inline typename BinaryReturn< Tensor<D,T1,E>, T2, FnArcTan2 >::Type_t atan2( const Tensor<D,T1,E>& v1, const T2& x ) { typedef Tensor<D,T1,E> V1; typedef typename BinaryReturn<V1,T2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<V1,T2,FnArcTan2> > Expr_t; return Return_t( Expr_t(v1,x) ); } template <int D, class T1, class T2, class E> inline typename BinaryReturn< T1, Tensor<D,T2,E>, FnArcTan2 >::Type_t atan2( const T1& x, const Tensor<D,T2,E>& v2 ) { typedef Tensor<D,T2,E> V2; typedef typename BinaryReturn<T1,V2,FnArcTan2>::Type_t Return_t; typedef typename Return_t::Element_t T3; typedef Tensor< D, T3, BinaryTensorOp<T1,V2,FnArcTan2> > Expr_t; return Return_t( Expr_t(x,v2) ); }
template<class T1, class T2, int I, int J, int K, int L>
struct TensorDotTensor
{
  typedef typename TensorDotTensor<T1,T2,I,J,K,L/2>::Type_t Left_t;
  typedef typename TensorDotTensor<T1,T2,I,J,K+L/2,L-L/2>::Type_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpAdd>::Type_t Type_t;
  static Type_t get(const T1& x, const T2& y)
    {
      return
        TensorDotTensor<T1,T2,I,J,K,L/2>::get(x,y) +
        TensorDotTensor<T1,T2,I,J,K+L/2,L-L/2>::get(x,y);
    }
};
template<class T1, class T2, int I, int J, int K>
struct TensorDotTensor<T1,T2,I,J,K,1>
{
  typedef typename TensorElem<T1,I,K>::Element_t Left_t;
  typedef typename TensorElem<T2,K,J>::Element_t Right_t;
  typedef typename BinaryReturn<Left_t,Right_t,OpMultiply>::Type_t Type_t;
  static Type_t get(const T1& x, const T2& y)
    {
      return TensorElem<T1,I,K>::get(x) * TensorElem<T2,K,J>::get(y);
    }
};
template<int D, class T, class T1, class T2, int I, int J>
struct TensorEngineElem<D,T,BinaryTensorOp<T1,T2,FnDot>, I, J,
  1>
{
  typedef BinaryTensorOp<T1,T2,FnDot> E;
  typedef TensorEngine<D,T,E> T0;
  typedef typename TensorDotTensor<T1,T2,I,J,0,T1::d>::Type_t Element_t;
  typedef Element_t ElementRef_t;
  typedef Element_t ConstElementRef_t;
  static Element_t get(const T0& x)
    {
      return TensorDotTensor<T1,T2,I,J,0,T1::d>::get(x.v1_m,x.v2_m);
    }
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Tensor<D,T1,E1> , Tensor<D,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef Tensor<D,T0,Full> Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< Tensor<D,T1,E1>,Tensor<D,T2,E2> , FnDot >::Type_t
dot( const Tensor<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 )
{
  typedef Tensor<D,T1,E1> V1;
  typedef Tensor<D,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef Tensor<D,T3,BinaryTensorOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<int D, class T, class E>
struct UnaryReturn< Tensor<D,T,E> , FnTrace >
{
  typedef T Type_t;
};
template<int D, class T, class E>
inline T
trace(const Tensor<D,T,E>& t)
{
  T result(0.0);
  for (int d = 0; d < D; d++) {
    result += t(d,d);
  }
  return result;
}
template<int D, class T>
inline T
trace(const Tensor<D,T,Diagonal>& t)
{
  T result(0.0);
  for (int d = 0; d < D; d++) {
    result += t(d);
  }
  return result;
}
template<int D, class T>
inline T
trace(const Tensor<D,T,Antisymmetric>& t)
{
  return T(0.0);
}
template<int D, class T, class E>
struct UnaryReturn< Tensor<D,T,E> , FnDet >
{
  typedef T Type_t;
};
template<int D, class T, class E>
inline T
det(const Tensor<D,T,E>& t)
{
  if (__builtin_expect(!!(D<4), true)) {} else Pooma::toss_cookies("Tensor det() function not implemented for D>3!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Tiny/TensorOperators.h", 405);
  return T(-999999.999999);
}
template<class T, class E>
inline T
det(const Tensor<3,T,E>& t)
{
  T result;
  result =
    t(0,0)*(t(1,1)*t(2,2) - t(1,2)*t(2,1)) +
    t(0,1)*(t(1,2)*t(2,0) - t(1,0)*t(2,2)) +
    t(0,2)*(t(1,0)*t(2,1) - t(1,1)*t(2,0));
  return result;
}
template<class T, class E>
inline T
det(const Tensor<2,T,E>& t)
{
  T result;
  result = t(0,0)*t(1,1) - t(0,1)*t(1,0);
  return result;
}
template<class T, class E>
inline T
det(const Tensor<1,T,E>& t)
{
  T result = t(0,0);
  return result;
}
template<class T>
inline T
det(const Tensor<3,T,Diagonal>& t)
{
  T result;
  result = t(0)*t(1)*t(2);
  return result;
}
template<class T>
inline T
det(const Tensor<2,T,Diagonal>& t)
{
  T result;
  result = t(0)*t(1);
  return result;
}
template<class T>
inline T
det(const Tensor<1,T,Diagonal>& t)
{
  T result = t(0);
  return result;
}
template<class T>
inline T
det(const Tensor<3,T,Antisymmetric>& t)
{
  return T(0.0);
}
template<class T>
inline T
det(const Tensor<2,T,Antisymmetric>& t)
{
  T result;
  result = t(0)*t(0);
  return result;
}
template<class T>
inline T
det(const Tensor<1,T,Antisymmetric>& t)
{
  return T(0.0);
}
template<int D, class T, class E>
struct UnaryReturn< Tensor<D,T,E> , FnTranspose >
{
  typedef Tensor<D,T,E> Type_t;
};
template<int D, class T, class E>
inline Tensor<D,T,E>
transpose(const Tensor<D,T,E>& t)
{
  Tensor<D,T,E> result;
  for (int i = 0; i < D; i++) {
    for (int j = 0; j < D; j++) {
      result(i,j) = t(j,i);
    }
  }
  return result;
}
template<int D, class T>
inline Tensor<D,T,Symmetric>
transpose(const Tensor<D,T,Symmetric>& t)
{
  Tensor<D,T,Symmetric> result;
  result = t;
  return result;
}
template<int D, class T>
inline Tensor<D,T,Antisymmetric>
transpose(const Tensor<D,T,Antisymmetric>& t)
{
  Tensor<D,T,Antisymmetric> result;
  result = -t;
  return result;
}
template<int D, class T>
inline Tensor<D,T,Diagonal>
transpose(const Tensor<D,T,Diagonal>& t)
{
  Tensor<D,T,Diagonal> result;
  result = t;
  return result;
}
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Tensor<D,T1,E1>,Tensor<D,T2,E2> , OpEQ >
{
  typedef bool Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Tensor<D,T1,E1>,Tensor<D,T2,E2> , OpNE >
{
  typedef bool Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpEQ >::Type_t
operator==(const Tensor<D,T1,E1>& t1, const Tensor<D,T2,E2>& t2)
{
  for (int i = 0; i < D; i++)
    for (int j = 0; j < D; j++)
      if (t1(i,j) != t2(i,j)) return false;
  return true;
}
template<int D, class T1, class T2, class E1, class E2>
inline typename
BinaryReturn< Tensor<D,T1,E1>, Tensor<D,T2,E2>, OpNE >::Type_t
operator!=(const Tensor<D,T1,E1>& t1, const Tensor<D,T2,E2>& t2)
{
  return !(t1 == t2);
}
template <int D, class T1, class T2, class E1> inline Tensor<D,T1,E1>& operator+=( Tensor<D,T1,E1>& v1, const Tensor<D,T2,E1>& v2 ) { typedef typename Tensor<D,T1,E1>::Engine_t Left_t; typedef typename Tensor<D,T2,E1>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Symmetric>& operator+=( Tensor<D,T1,Symmetric>& v1, const Tensor<D,T2,Symmetric>& v2 ) { typedef typename Tensor<D,T1,Symmetric>::Engine_t Left_t; typedef typename Tensor<D,T2,Symmetric>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Antisymmetric>& operator+=( Tensor<D,T1,Antisymmetric>& v1, const Tensor<D,T2,Antisymmetric>& v2 ) { typedef typename Tensor<D,T1,Antisymmetric>::Engine_t Left_t; typedef typename Tensor<D,T2,Antisymmetric>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Diagonal>& operator+=( Tensor<D,T1,Diagonal>& v1, const Tensor<D,T2,Diagonal>& v2 ) { typedef typename Tensor<D,T1,Diagonal>::Engine_t Left_t; typedef typename Tensor<D,T2,Diagonal>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Tensor<D,T1,E1>& operator+=( Tensor<D,T1,E1>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,E1>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Symmetric>& operator+=( Tensor<D,T1,Symmetric>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Symmetric>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Antisymmetric>& operator+=( Tensor<D,T1,Antisymmetric>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Antisymmetric>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Diagonal>& operator+=( Tensor<D,T1,Diagonal>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Diagonal>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpAddAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpAddAssign()); return v1; }
template <int D, class T1, class T2, class E1> inline Tensor<D,T1,E1>& operator-=( Tensor<D,T1,E1>& v1, const Tensor<D,T2,E1>& v2 ) { typedef typename Tensor<D,T1,E1>::Engine_t Left_t; typedef typename Tensor<D,T2,E1>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Symmetric>& operator-=( Tensor<D,T1,Symmetric>& v1, const Tensor<D,T2,Symmetric>& v2 ) { typedef typename Tensor<D,T1,Symmetric>::Engine_t Left_t; typedef typename Tensor<D,T2,Symmetric>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Antisymmetric>& operator-=( Tensor<D,T1,Antisymmetric>& v1, const Tensor<D,T2,Antisymmetric>& v2 ) { typedef typename Tensor<D,T1,Antisymmetric>::Engine_t Left_t; typedef typename Tensor<D,T2,Antisymmetric>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Diagonal>& operator-=( Tensor<D,T1,Diagonal>& v1, const Tensor<D,T2,Diagonal>& v2 ) { typedef typename Tensor<D,T1,Diagonal>::Engine_t Left_t; typedef typename Tensor<D,T2,Diagonal>::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2, class E1> inline Tensor<D,T1,E1>& operator-=( Tensor<D,T1,E1>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,E1>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Symmetric>& operator-=( Tensor<D,T1,Symmetric>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Symmetric>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Antisymmetric>& operator-=( Tensor<D,T1,Antisymmetric>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Antisymmetric>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; } template <int D, class T1, class T2> inline Tensor<D,T1,Diagonal>& operator-=( Tensor<D,T1,Diagonal>& v1, const T2& v2 ) { typedef typename Tensor<D,T1,Diagonal>::Engine_t Left_t; typedef typename T2::Engine_t Right_t; TensorAssign<Left_t,Right_t,OpSubtractAssign,0,D,0,D>:: apply(v1.engine(),v2.engine(),OpSubtractAssign()); return v1; }
template<int D, class T, class EngineTag> class Tensor;
template<int D, class T, class EngineTag> class TensorEngine;
template <class T>
void reverseBytes(T&);
class Full;
class Antisymmetric;
class Symmetric;
class Diagonal;
template<int D, class EngineTag>
class TensorStorageSize {};
template<int D>
class TensorStorageSize<D, Full>
{
public:
  enum { Size = D*D };
};
template<int D>
class TensorStorageSize<D, Antisymmetric>
{
public:
  enum { Size = (D*D - D)/2 + 1/D };
};
template<int D>
class TensorStorageSize<D, Symmetric>
{
public:
  enum { Size = (D*D - D)/2 + D };
};
template<int D>
class TensorStorageSize<D, Diagonal>
{
public:
  enum { Size = D };
};
template<int D, class T=double, class EngineTag=Full>
class Tensor
{
public:
  enum { dimensions=2 };
  enum { d=D };
  typedef T Element_t;
  typedef EngineTag EngineTag_t;
  typedef TensorEngine<D,T,EngineTag> Engine_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef typename Engine_t::ConstElementRef_t ConstElementRef_t;
  typedef Tensor<D,T,EngineTag> This_t;
  Tensor() {}
  Tensor(const This_t& x) : engine_m(x.engine_m) {}
  template<int D2, class T2, class EngineTag2>
  Tensor(const Tensor<D2, T2, EngineTag2>& x) : engine_m(x) {}
  template<class X>
  explicit Tensor(const X& x) : engine_m(x) {}
  template<class X1, class X2>
  Tensor(const X1& x, const X2& y) : engine_m(x,y) {}
  template<class X1, class X2, class X3>
  Tensor(const X1& x, const X2& y, const X3& z) : engine_m(x,y,z) {}
  template<class X1, class X2, class X3, class X4>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4)
    : engine_m(x1,x2,x3,x4) {}
  template<class X1, class X2, class X3, class X4, class X5>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
         const X5& x5)
    : engine_m(x1,x2,x3,x4,x5) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
         const X5& x5, const X6& x6)
    : engine_m(x1,x2,x3,x4,x5,x6) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
    class X7>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
         const X5& x5, const X6& x6, const X7& x7)
    : engine_m(x1,x2,x3,x4,x5,x6,x7) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
    class X7, class X8>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
         const X5& x5, const X6& x6, const X7& x7, const X8& x8)
    : engine_m(x1,x2,x3,x4,x5,x6,x7,x8) {}
  template<class X1, class X2, class X3, class X4, class X5, class X6,
    class X7, class X8, class X9>
  Tensor(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
         const X5& x5, const X6& x6, const X7& x7, const X8& x8, const X9& x9)
    : engine_m(x1,x2,x3,x4,x5,x6,x7,x8,x9) {}
  ~Tensor() {}
  This_t& operator=(const This_t& x)
  {
    if ( this != &x )
      engine() = x.engine();
    return *this;
  }
  template<class T1, class EngineTag1>
  This_t& operator=(const Tensor<d,T1,EngineTag1> &x)
  {
    engine() = x.engine();
    return *this;
  }
  template<class V>
  This_t&
  operator=(const V& x)
  {
    engine() = x;
    return *this;
  }
  ConstElementRef_t operator()(int i, int j) const
  {
    return engine()(i,j);
  }
  ElementRef_t operator()(int i, int j)
  {
    return engine()(i,j);
  }
  ConstElementRef_t operator()(int i) const { return engine()(i); }
  ElementRef_t operator()(int i) { return engine()(i); }
  const Engine_t& engine() const { return engine_m; }
  Engine_t& engine() { return engine_m; }
  template<class Out>
  void print(Out &out) const;
  inline void reverseBytes() { engine_m.reverseBytes(); }
private:
  Engine_t engine_m;
};
template<int D, class T, class EngineTag>
template<class Out>
void Tensor<D, T, EngineTag>::print(Out &out) const
{
  std::ios::fmtflags incomingFormatFlags = out.flags();
  long width = out.width();
  long precision = out.precision();
  out.width(0);
  out << "(";
  for (int i = 0; i < D; i++) {
    out << "(";
    out.flags(incomingFormatFlags);
    out.width(width);
    out.precision(precision);
    out << (*this)(i,0);
    for (int j = 1; j < D; j++) {
      out << " ";
      out.flags(incomingFormatFlags);
      out.width(width);
      out.precision(precision);
      out << (*this)(i,j);
    }
    out << ")";
  }
  out << ")";
}
template<int D, class T, class E>
std::ostream &operator<<(std::ostream &out, const Tensor<D,T,E> &t)
{
  t.print(out);
  return out;
}
template <int D, class T, class E>
struct ElementProperties< Tensor<D,T,E> >
  : public TrivialElementProperties< Tensor<D,T,E> >
{ };
template<int D, class T>
class TensorEngine<D, T, Full>
{
public:
  enum { dimensions=2 };
  enum { d=D };
  typedef T Element_t;
  typedef Full EngineTag_t;
  typedef T& ElementRef_t;
  typedef const T& ConstElementRef_t;
  typedef T& CTElementRef_t;
  typedef const T& CTConstElementRef_t;
  typedef TensorEngine<D,T,Full> This_t;
  TensorEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
  }
  TensorEngine(const TensorEngine<D,T,Full>& x)
  {
    TensorAssign<This_t,This_t,OpAssign,0,D,0,D>
      ::apply(*this,x,OpAssign());
  }
  template<class X>
  explicit TensorEngine(const X& x)
  {
    TensorAssign<This_t,X,OpAssign,0,D,0,D>::apply(*this,x,OpAssign());
  }
  explicit TensorEngine(const T& x)
  {
    for (int i = 0 ; i < D*D ; i++) {
      (*this)(i) = x;
    }
  }
  template<class X1, class X2, class X3, class X4>
  TensorEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4)
  {
    PoomaCTAssert<(D == 2)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
    class X7, class X8, class X9>
  TensorEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
               const X5& x5, const X6& x6, const X7& x7, const X8& x8,
               const X9& x9)
  {
    PoomaCTAssert<(D == 3)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
    (*this)(5) = x6;
    (*this)(6) = x7;
    (*this)(7) = x8;
    (*this)(8) = x9;
  }
  ~TensorEngine() {}
  This_t&
  operator=(const This_t& x)
  {
    if (this != &x) {
      TensorAssign<This_t,This_t,OpAssign,0,D,0,D>::apply(*this,x,OpAssign());
    }
    return *this;
  }
  template<class V>
  This_t&
  operator=(const V& x)
  {
    TensorAssign<This_t,V,OpAssign,0,D,0,D>::apply(*this,x,OpAssign());
    return *this;
  }
  template<int I, int J>
  CTConstElementRef_t getIJ() const
  {
    PoomaCTAssert<((I >= 0) && (I < D) && (J >= 0) && (J < D))>::test();
    return x_m[I + D*J];
  }
  template<int I, int J>
  CTElementRef_t getIJ()
  {
    PoomaCTAssert<((I >= 0) && (I < D) && (J >= 0) && (J < D))>::test();
    return x_m[I + D*J];
  }
  ConstElementRef_t operator()(int i,int j) const
  {
    ;
    return x_m[i + D*j];
  }
  ElementRef_t operator()(int i,int j)
  {
    ;
    return x_m[i + D*j];
  }
  ConstElementRef_t operator()(int i) const
  {
    ;
    return x_m[i];
  }
  ElementRef_t operator()(int i)
  {
    ;
    return x_m[i];
  }
  const T* data() const{
    return (const T*) &x_m[0];
  }
  T* data(){
    return (T*) &x_m[0];
  }
  inline void reverseBytes()
  {
    const int sz = TensorStorageSize<d, EngineTag_t>::Size;
    for (int i = 0; i < sz; ++i)
      ::reverseBytes(x_m[i]);
  }
private:
  T x_m[TensorStorageSize<d, EngineTag_t>::Size];
};
template<int D, class T>
class TensorEngine<D, T, Antisymmetric>
{
public:
  enum { dimensions=2 };
  enum { d=D };
  typedef T Element_t;
  typedef Antisymmetric EngineTag_t;
  class AssignProxy {
  public:
    AssignProxy(Element_t &elem, int where)
      : elem_m(elem), where_m(where) { }
    AssignProxy(const AssignProxy &model)

      : elem_m(model.elem_m), where_m(model.where_m) { }
    AssignProxy &operator=(const AssignProxy &a) const
    {
      ;
      elem_m = where_m < 0 ? -a.elem_m : a.elem_m;
      return const_cast<AssignProxy &>(*this);
    }
    AssignProxy &operator=(const Element_t &e) const
    {
      ;
      elem_m = where_m < 0 ? -e : e;
      return const_cast<AssignProxy &>(*this);
    }
    operator Element_t() const
    {
      return (where_m < 0 ? -elem_m : elem_m);
    }
  private:

    Element_t &elem_m;
    mutable int where_m;
  };
  typedef AssignProxy ElementRef_t;
  typedef T ConstElementRef_t;
  typedef T& CTElementRef_t;
  typedef T CTConstElementRef_t;
  typedef TensorEngine<d,T,Antisymmetric> This_t;
  TensorEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
  }
  TensorEngine(const TensorEngine<d,T,Antisymmetric> &x)
  {
    TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
  }
  template<class X>
  explicit TensorEngine(const X& x)
  {
    TensorAssign<This_t,X,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
  }
  explicit TensorEngine(const T &x) {
    for (int i = 0; i < TensorStorageSize<d, EngineTag_t>::Size; i++) {
      x_m[i] = x;
    }
  }
  template<class X1, class X2, class X3>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3)
  {
    PoomaCTAssert<(D == 3)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  TensorEngine(const X1& x1, const X2& x2, const X3& x3, const X4& x4,
               const X5& x5, const X6& x6)
  {
    PoomaCTAssert<(D == 4)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
    (*this)(5) = x6;
  }
  ~TensorEngine() {}
  This_t&
  operator=(const This_t& x)
  {
    if (this != &x) {
      TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
        apply(*this,x,OpAssign());
    }
    return *this;
  }
  template<class V>
  This_t&
  operator=(const V& x)
  {
    TensorAssign<This_t,V,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
    return *this;
  }
  template<int I, int J>
  CTConstElementRef_t getIJ() const
  {
    PoomaCTAssert<((I >= 0) && (I < d) && (J >= 0) && (J < d))>::test();
    if (I == J) {
      return This_t::Zero;
    } else {
      int lo = I < J ? I : J;
      int hi = I > J ? I : J;
      int symmetrySign = I < J ? -1 : 1;
      return symmetrySign * x_m[((hi - 1)*hi/2) + lo];
    }
  }
  template<int I, int J>
  CTElementRef_t getIJ()
  {
    PoomaCTAssert<((I >= 0) && (I < d) && (J >= 0) && (J < d) && (I > J))>::test();
    return x_m[((I - 1)*I/2) + J];
  }
  ConstElementRef_t operator()(int i,int j) const
  {
    ;
    if (i == j) {
      return This_t::Zero;
    } else if (i < j) {
      return -x_m[((j - 1)*j/2) + i];
    } else {
      return x_m[((i - 1)*i/2) + j];
    }
  }
  ElementRef_t operator()(int i,int j)
  {
    ;
    if (i == j) {
      return AssignProxy(This_t::Zero, 0);
    } else {
      int lo = i < j ? i : j;
      int hi = i > j ? i : j;
      return AssignProxy(x_m[((hi-1)*hi/2) + lo], i - j);
    }
  }
  ConstElementRef_t operator()(int i) const
  {
    ;
    return x_m[i];
  }
  ElementRef_t operator()(int i)
  {
    ;
    return AssignProxy(x_m[i], 1);
  }
  const T* data() const{
    return (const T*) &x_m[0];
  }
  T* data(){
    return (T*) &x_m[0];
  }
  inline void reverseBytes()
  {
    const int sz = TensorStorageSize<d, EngineTag_t>::Size;
    for (int i = 0; i < sz; ++i)
      ::reverseBytes(x_m[i]);
  }
private:
  T x_m[TensorStorageSize<d, EngineTag_t>::Size];
  static T Zero;
};
template<int D, class T>
T TensorEngine<D,T,Antisymmetric>::Zero = 0.0;
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<1,T,Antisymmetric>,T2,Op,0,1,0,1>
{
  static void apply(TensorEngine<1,T,Antisymmetric> &x, const T2 &y,
                    Op op=Op())
  { }
};
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<2,T,Antisymmetric>,T2,Op,0,2,0,2>
{
  static void apply(TensorEngine<2,T,Antisymmetric> &x, const T2 &y,
                    Op op=Op())
  {
    TensorAssign<TensorEngine<2,T,Antisymmetric>,T2,Op,1,1,0,1>::apply(x,y,op);
  }
};
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<3,T,Antisymmetric>,T2,Op,0,3,0,3>
{
  static void apply(TensorEngine<3,T,Antisymmetric> &x, const T2 &y,
      Op op=Op())
  {
    TensorAssign<TensorEngine<3,T,Antisymmetric>,T2,Op,1,1,0,1>::apply(x,y,op);
    TensorAssign<TensorEngine<3,T,Antisymmetric>,T2,Op,2,1,0,2>::apply(x,y,op);
  }
};
template<int D, class T>
class TensorEngine<D, T, Symmetric>
{
public:
  enum { dimensions=2 };
  enum { d=D };
  typedef T Element_t;
  typedef Symmetric EngineTag_t;
  typedef T& ElementRef_t;
  typedef const T& ConstElementRef_t;
  typedef T& CTElementRef_t;
  typedef const T& CTConstElementRef_t;
  typedef TensorEngine<D,T,Symmetric> This_t;
  TensorEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
  }
  TensorEngine(const TensorEngine<D,T,Symmetric> &x)
  {
    TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
  }
  template<class X>
  explicit TensorEngine(const X &x)
  {
    *this = x;
  }
  explicit TensorEngine(const T &x) {
    for (int i = 0; i < TensorStorageSize<d, EngineTag_t>::Size; i++) {
      x_m[i] = x;
    }
  }
  template<class X1, class X2, class X3>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3)
  {
    PoomaCTAssert<(D == 2)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3, const X4 &x4,
               const X5 &x5, const X6 &x6)
  {
    PoomaCTAssert<(D == 3)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
    (*this)(5) = x6;
  }
  ~TensorEngine() {}
  This_t&
  operator=(const This_t &x)
  {
    if (this != &x) {
      TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
        apply(*this,x,OpAssign());
    }
    return *this;
  }
  template<class V>
  This_t&
  operator=(const V &x)
  {
    TensorAssign<This_t,V,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
    return *this;
  }
  template<int I, int J>
  CTConstElementRef_t getIJ() const
  {
    PoomaCTAssert<((I >= 0) && (I < D) && (J >= 0) && (J < D))>::test();
    int lo = I < J ? I : J;
    int hi = I > J ? I : J;
    return x_m[((hi + 1)*hi/2) + lo];
  }
  template<int I, int J>
  CTElementRef_t getIJ()
  {
    PoomaCTAssert<((I >= 0) && (I < D) && (J >= 0) && (J < D))>::test();
    int lo = I < J ? I : J;
    int hi = I > J ? I : J;
    return x_m[((hi + 1)*hi/2) + lo];
  }
  ConstElementRef_t operator()(int i,int j) const
  {
    ;
    int lo = i < j ? i : j;
    int hi = i > j ? i : j;
    return x_m[((hi + 1)*hi/2) + lo];
  }
  ElementRef_t operator()(int i,int j)
  {
    ;
    int lo = i < j ? i : j;
    int hi = i > j ? i : j;
    return x_m[((hi + 1)*hi/2) + lo];
  }
  ConstElementRef_t operator()(int i) const
  {
    ;
    return x_m[i];
  }
  ElementRef_t operator()(int i)
  {
    ;
    return x_m[i];
  }
  const T* data() const{
    return (const T*) &x_m[0];
  }
  T* data(){
    return (T*) &x_m[0];
  }
  inline void reverseBytes()
  {
    const int sz = TensorStorageSize<d, EngineTag_t>::Size;
    for (int i = 0; i < sz; ++i)
      ::reverseBytes(x_m[i]);
  }
private:
  T x_m[TensorStorageSize<d, EngineTag_t>::Size];
};
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<2,T,Symmetric>,T2,Op,0,2,0,2>
{
  static void apply(TensorEngine<2,T,Symmetric> &x, const T2 &y,
                    Op op=Op())
  {
    TensorAssign<TensorEngine<2,T,Symmetric>,T2,Op,0,1,0,1>::apply(x,y,op);
    TensorAssign<TensorEngine<2,T,Symmetric>,T2,Op,1,1,0,2>::apply(x,y,op);
  }
};
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<3,T,Symmetric>,T2,Op,0,3,0,3>
{
  static void apply(TensorEngine<3,T,Symmetric> &x, const T2 &y,
                    Op op=Op())
  {
    TensorAssign<TensorEngine<3,T,Symmetric>,T2,Op,0,1,0,1>::apply(x,y,op);
    TensorAssign<TensorEngine<3,T,Symmetric>,T2,Op,1,1,0,2>::apply(x,y,op);
    TensorAssign<TensorEngine<3,T,Symmetric>,T2,Op,2,1,0,3>::apply(x,y,op);
  }
};
template<int D, class T>
class TensorEngine<D, T, Diagonal>
{
public:
  enum { dimensions=2 };
  enum { d=D };
  typedef T Element_t;
  typedef Diagonal EngineTag_t;
  class AssignProxy {
  public:
    AssignProxy(Element_t &elem, int where)
      : elem_m(elem), where_m(where) { }
    AssignProxy(const AssignProxy &model)

      : elem_m(model.elem_m), where_m(model.where_m) { }
    AssignProxy &operator=(const AssignProxy &a) const
    {
      ;
      elem_m = a.elem_m;
      return const_cast<AssignProxy &>(*this);
    }
    AssignProxy &operator=(const Element_t &e) const
    {
      ;
      elem_m = e;
      return const_cast<AssignProxy &>(*this);
    }
    operator Element_t() const
    {
      return (elem_m);
    }
  private:

    Element_t &elem_m;
    mutable int where_m;
  };
  typedef AssignProxy ElementRef_t;
  typedef T ConstElementRef_t;
  typedef T& CTElementRef_t;
  typedef T CTConstElementRef_t;
  typedef TensorEngine<D,T,Diagonal> This_t;
  TensorEngine()
  {
    PoomaCTAssert<(ElementProperties<T>::hasTrivialDefaultConstructor && ElementProperties<T>::hasTrivialDestructor && ElementProperties<T>::concrete)>::test();
  }
  TensorEngine(const TensorEngine<D,T,Diagonal> &x)
  {
    TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
  }
  template<class X>
  explicit TensorEngine(const X &x)
  {
    *this = x;
  }
  explicit TensorEngine(const T &x) {
    for (int i = 0; i < TensorStorageSize<d, EngineTag_t>::Size; i++) {
      x_m[i] = x;
    }
  }
  template<class X1, class X2>
  TensorEngine(const X1 &x1, const X2 &x2)
  {
    PoomaCTAssert<(D == 2)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
  }
  template<class X1, class X2, class X3>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3)
  {
    PoomaCTAssert<(D == 3)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
  }
  template<class X1, class X2, class X3, class X4>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3, const X4 &x4)
  {
    PoomaCTAssert<(D == 4)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
  }
  template<class X1, class X2, class X3, class X4, class X5>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3, const X4 &x4,
               const X5 &x5)
  {
    PoomaCTAssert<(D == 5)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3, const X4 &x4,
               const X5 &x5, const X6 &x6)
  {
    PoomaCTAssert<(D == 6)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
    (*this)(5) = x6;
  }
  template<class X1, class X2, class X3, class X4, class X5, class X6,
    class X7>
  TensorEngine(const X1 &x1, const X2 &x2, const X3 &x3, const X4 &x4,
               const X5 &x5, const X6 &x6, const X7 &x7)
  {
    PoomaCTAssert<(D == 7)>::test();
    (*this)(0) = x1;
    (*this)(1) = x2;
    (*this)(2) = x3;
    (*this)(3) = x4;
    (*this)(4) = x5;
    (*this)(5) = x6;
    (*this)(6) = x7;
  }
  ~TensorEngine() {}
  This_t&
  operator=(const This_t &x)
  {
    if (this != &x) {
      TensorAssign<This_t,This_t,OpAssign,0,d,0,d>::
        apply(*this,x,OpAssign());
    }
    return *this;
  }
  template<class V>
  This_t&
  operator=(const V &x)
  {
    TensorAssign<This_t,V,OpAssign,0,d,0,d>::
      apply(*this,x,OpAssign());
    return *this;
  }
  template<int I, int J>
  CTConstElementRef_t getIJ() const
  {
    PoomaCTAssert<((I >= 0) && (I < d) && (J >= 0) && (J < d))>::test();
    if (I != J) {
      return This_t::Zero;
    } else {
      return x_m[I];
    }
  }
  template<int I, int J>
  CTElementRef_t getIJ()
  {
    PoomaCTAssert<((I >= 0) && (I < d) && (J >= 0) && (J < d))>::test();
    PoomaCTAssert<(I == J)>::test();
    return x_m[I];
  }
  ConstElementRef_t operator()(int i, int j) const
  {
    ;
    if (i != j) {
      return This_t::Zero;
    } else {
      return x_m[i];
    }
  }
  ElementRef_t operator()(int i, int j)
  {
    ;
    if (i != j) {
      return AssignProxy(This_t::Zero, 0);
    } else {
      return AssignProxy(x_m[i], 1);
    }
  }
  ConstElementRef_t operator()(int i) const
  {
    ;
    return x_m[i];
  }
  ElementRef_t operator()(int i)
  {
    ;
    return AssignProxy(x_m[i], 1);
  }
  const T* data() const{
    return (const T*) &x_m[0];
  }
  T* data(){
    return (T*) &x_m[0];
  }
  inline void reverseBytes()
  {
    const int sz = TensorStorageSize<d, EngineTag_t>::Size;
    for (int i = 0; i < sz; ++i)
      ::reverseBytes(x_m[i]);
  }
private:
  T x_m[TensorStorageSize<d, EngineTag_t>::Size];
  static T Zero;
};
template<int D, class T>
T TensorEngine<D,T,Diagonal>::Zero = 0.0;
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<2,T,Diagonal>,T2,Op,0,2,0,2>
{
  static void apply(TensorEngine<2,T,Diagonal> &x, const T2 &y, Op op=Op())
  {
    TensorAssign<TensorEngine<2,T,Diagonal>,T2,Op,0,1,0,1>::apply(x,y,op);
    TensorAssign<TensorEngine<2,T,Diagonal>,T2,Op,1,1,1,1>::apply(x,y,op);
  }
};
template<class T, class T2, class Op>
struct TensorAssign<TensorEngine<3,T,Diagonal>,T2,Op,0,3,0,3>
{
  static void apply(TensorEngine<3,T,Diagonal> &x, const T2 &y, Op op=Op())
  {
    TensorAssign<TensorEngine<3,T,Diagonal>,T2,Op,0,1,0,1>::apply(x,y,op);
    TensorAssign<TensorEngine<3,T,Diagonal>,T2,Op,1,1,1,1>::apply(x,y,op);
    TensorAssign<TensorEngine<3,T,Diagonal>,T2,Op,2,1,2,1>::apply(x,y,op);
  }
};
template<class T, class Components> struct ComponentAccess;
template<int D, class T, class E, int N>
struct ComponentAccess< Tensor<D, T, E>, Loc<N> >
{
  typedef Tensor<D, T, E> V;
  typedef typename V::Element_t Element_t;
  typedef typename V::ElementRef_t ElementRef_t;
  static inline ElementRef_t indexRef(V &t, const Loc<N> &l)
  {
    PoomaCTAssert<(N==2)>::test();
    return t(l[0].first(), l[1].first());
  }
  static inline Element_t index(const V &t, const Loc<N> &l)
  {
    PoomaCTAssert<(N==2)>::test();
    return t(l[0].first(), l[1].first());
  }
};
template<int D, class T, int I, int J>
struct TensorElem< TensorEngine<D,T,Full> , I , J>
{
  typedef TensorEngine<D,T,Full> V;
  typedef TensorEngineElem<D,T,Full,I,J,
    Writable<D,Full,I,J>::value> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x); }
  static ElementRef_t get(V& x) { return TE::get(x); }
};
template<int D, class T, int I, int J>
struct TensorElem< TensorEngine<D,T,Antisymmetric> , I , J>
{
  typedef TensorEngine<D,T,Antisymmetric> V;
  typedef TensorEngineElem<D,T,Antisymmetric,I,J,
    Writable<D,Antisymmetric,I,J>::value> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x); }
  static ElementRef_t get(V& x) { return TE::get(x); }
};
template<int D, class T, int I, int J>
struct TensorElem< TensorEngine<D,T,Symmetric> , I , J>
{
  typedef TensorEngine<D,T,Symmetric> V;
  typedef TensorEngineElem<D,T,Symmetric,I,J,
    Writable<D,Symmetric,I,J>::value> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x); }
  static ElementRef_t get(V& x) { return TE::get(x); }
};
template<int D, class T, int I, int J>
struct TensorElem< TensorEngine<D,T,Diagonal> , I , J>
{
  typedef TensorEngine<D,T,Diagonal> V;
  typedef TensorEngineElem<D,T,Diagonal,I,J,
    Writable<D,Diagonal,I,J>::value> TE;
  typedef typename TE::Element_t Element_t;
  typedef typename TE::ConstElementRef_t ConstElementRef_t;
  typedef typename TE::ElementRef_t ElementRef_t;
  static ConstElementRef_t get(const V& x) { return TE::get(x); }
  static ElementRef_t get(V& x) { return TE::get(x); }
};
template<class OutputEngineTag, int D, class T, class EngineTag>
class Symmetrize;
template<class OutputEngineTag, int D, class T, class EngineTag>
Tensor<D, T, OutputEngineTag>
symmetrize(const Tensor<D, T, EngineTag> &x)
{
  Symmetrize<OutputEngineTag, D, T, EngineTag> s;
  return s.apply(x);
}
template<class OutputEngineTag, int D, class T, class E>
struct UnaryReturn< Tensor<D,T,E> , FnSymmetrize<OutputEngineTag> >
{
  typedef Tensor<D,T,OutputEngineTag> Type_t;
};
template<class OutputEngineTag, int D, class T, class EngineTag>
class Symmetrize
{
public:
  Symmetrize() {};
  Tensor<D, T, OutputEngineTag>
  apply(const Tensor<D, T, EngineTag> &x) {
    Tensor<D, T, OutputEngineTag> y(-99.99);
    return y;
  }
};
template<int D, class T, class EngineTag>
class Symmetrize<Symmetric, D, T, EngineTag>
{
public:
  Tensor<D, T, Symmetric>
  apply(const Tensor<D, T, EngineTag> &x)
  {
    Tensor<D, T, Symmetric> y;
    for (int i = 0; i < D; i++) {
      y(i,i) = x(i,i);
      for (int j = i + 1; j < D; j++) {
        y(i,j) = (x(i,j) + x(j,i))*0.5;
      }
    }
    return y;
  }
};
template<int D, class T>
class Symmetrize<Symmetric, D, T, Antisymmetric>
{
public:
  Tensor<D, T, Symmetric>
  apply(const Tensor<D, T, Antisymmetric> &x)
  {
    Tensor<D, T, Symmetric> y(0.0);
    return y;
  }
};
template<int D, class T>
class Symmetrize<Symmetric, D, T, Diagonal>
{
public:
  Tensor<D, T, Symmetric>
  apply(const Tensor<D, T, Diagonal> &x)
  {
    Tensor<D, T, Symmetric> y(0.0);
    for (int i = 0; i < D; i++) {
      y(i,i) = x(i,i);
    }
    return y;
  }
};
template<int D, class T, class EngineTag>
class Symmetrize<Antisymmetric, D, T, EngineTag>
{
public:
  Tensor<D, T, Antisymmetric>
  apply(const Tensor<D, T, EngineTag> &x)
  {
    Tensor<D, T, Antisymmetric> y;
    for (int i = 1; i < D; i++) {
      for (int j = 0; j < i; j++) {
        y(((i - 1)*i/2)+j) = (x(i,j) - x(j,i))*0.5;
      }
    }
    return y;
  }
};
template<int D, class T>
class Symmetrize<Antisymmetric, D, T, Symmetric>
{
public:
  Tensor<D, T, Antisymmetric>
  apply(const Tensor<D, T, Symmetric> &x)
  {
    Tensor<D, T, Antisymmetric> y(0.0);
    return y;
  }
};
template<int D, class T>
class Symmetrize<Antisymmetric, D, T, Diagonal>
{
public:
  Tensor<D, T, Antisymmetric>
  apply(const Tensor<D, T, Diagonal> &x)
  {
    Tensor<D, T, Antisymmetric> y(0.0);
    return y;
  }
};
template<int D, class T, class EngineTag>
class Symmetrize<Diagonal, D, T, EngineTag>
{
public:
  Tensor<D, T, Diagonal>
  apply(const Tensor<D, T, EngineTag> &x)
  {
    Tensor<D, T, Diagonal> y;
    for (int i = 0; i < D; i++) {
      y(i) = x(i,i);
    }
    return y;
  }
};
template<int D, class T>
class Symmetrize<Diagonal, D, T, Antisymmetric>
{
public:
  Tensor<D, T, Diagonal>
  apply(const Tensor<D, T, Antisymmetric> &x)
  {
    Tensor<D, T, Diagonal> y(0.0);
    return y;
  }
};
template<int D, class T>
class Symmetrize<Diagonal, D, T, Symmetric>
{
public:
  Tensor<D, T, Diagonal>
  apply(const Tensor<D, T, Symmetric> &x)
  {
    Tensor<D, T, Diagonal> y(0.0);
    for (int i = 0; i < D; i++) {
      y(i) = x(i,i);
    }
    return y;
  }
};
template<int D, class T, class EngineTag>
class Symmetrize<Full, D, T, EngineTag>
{
public:
  Tensor<D, T, Full>
  apply(const Tensor<D, T, EngineTag> &x)
  {
    Tensor<D, T, Full> y;
    for (int i = 0; i < D; i++) {
      for (int j = 0; j < D; j++) {
        y(i,j) = x(i,j);
      }
    }
    return y;
  }
};
template<int D, class T, class E> class Tensor;
template<int D, class T, class E> class TensorEngine;
template<int D, class T, class E> class Vector;
template<int D, class T, class E> class VectorEngine;
template<class V1, class T2, int I, int B, int L>
struct VectorDotTensor
{
  typedef typename VectorDotTensor<V1,T2,I,B,L/2>::Type_t E1;
  typedef typename VectorDotTensor<V1,T2,I,B+L/2,L-L/2>::Type_t E2;
  typedef typename BinaryReturn<E1,E2,OpAdd>::Type_t Type_t;
  static Type_t get(const V1& v1, const T2& t2)
    {
      return
        VectorDotTensor<V1,T2,I,B,L/2>::get(v1,t2) +
        VectorDotTensor<V1,T2,I,B+L/2,L-L/2>::get(v1,t2);
    }
};
template<class V1, class T2, int I, int B>
struct VectorDotTensor<V1,T2,I,B,1>
{
  typedef typename VectorElem<V1,B>::Element_t E1;
  typedef typename TensorElem<T2,B,I>::Element_t E2;
  typedef typename BinaryReturn<E1,E2,OpMultiply>::Type_t Type_t;
  static Type_t get(const V1& v1, const T2& t2)
    {
      return VectorElem<V1,B>::get(v1) * TensorElem<T2,B,I>::get(t2);
    }
};
template<int D, class T1, class T2, class T3, class E1, class E2, int I>
struct VectorEngineElem<D,T3,
  BinaryVectorOp<Vector<D,T1,E1>,Tensor<D,T2,E2>,FnDot>,I>
{
  typedef Vector<D,T1,E1> V1;
  typedef Tensor<D,T2,E2> V2;
  typedef VectorEngine<D,T3,BinaryVectorOp<V1,V2,FnDot> > V;
  typedef typename VectorDotTensor<V1,V2,I,0,D>::Type_t T0;
  typedef T0 Element_t;
  typedef T0 ConstElementRef_t;
  typedef T0 ElementRef_t;
  static T0 get(const V& x)
    {
      return VectorDotTensor<V1,V2,I,0,D>::get(x.v1_m,x.v2_m);
    }
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Tensor<D,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef Vector<D,T0,Full> Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< Vector<D,T1,E1>,Tensor<D,T2,E2> , FnDot >::Type_t
dot( const Vector<D,T1,E1>& v1, const Tensor<D,T2,E2>& v2 )
{
  typedef Vector<D,T1,E1> V1;
  typedef Tensor<D,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef Vector<D,T3,BinaryVectorOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<class T1, class V2, int I, int B, int L>
struct TensorDotVector
{
  typedef typename TensorDotVector<T1,V2,I,B,L/2>::Type_t E1;
  typedef typename TensorDotVector<T1,V2,I,B+L/2,L-L/2>::Type_t E2;
  typedef typename BinaryReturn<E1,E2,OpAdd>::Type_t Type_t;
  static Type_t get(const T1& t1, const V2& v2)
    {
      return
        TensorDotVector<T1,V2,I,B,L/2>::get(t1,v2) +
        TensorDotVector<T1,V2,I,B+L/2,L-L/2>::get(t1,v2);
    }
};
template<class T1, class V2, int I, int B>
struct TensorDotVector<T1,V2,I,B,1>
{
  typedef typename TensorElem<T1,I,B>::Element_t E1;
  typedef typename VectorElem<V2,B>::Element_t E2;
  typedef typename BinaryReturn<E1,E2,OpMultiply>::Type_t Type_t;
  static Type_t get(const T1& t1, const V2& v2)
    {
      return TensorElem<T1,I,B>::get(t1) * VectorElem<V2,B>::get(v2);
    }
};
template<int D, class T1, class T2, class T3, class E1, class E2, int I>
struct VectorEngineElem<D,T3,
  BinaryVectorOp<Tensor<D,T1,E1>,Vector<D,T2,E2>,FnDot>,I>
{
  typedef Tensor<D,T1,E1> V1;
  typedef Vector<D,T2,E2> V2;
  typedef VectorEngine<D,T3,BinaryVectorOp<V1,V2,FnDot> > V;
  typedef typename TensorDotVector<V1,V2,I,0,D>::Type_t T0;
  typedef T0 Element_t;
  typedef T0 ConstElementRef_t;
  typedef T0 ElementRef_t;
  static T0 get(const V& x)
    {
      return TensorDotVector<V1,V2,I,0,D>::get(x.v1_m,x.v2_m);
    }
};
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Tensor<D,T1,E1> , Vector<D,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef Vector<D,T0,Full> Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< Tensor<D,T1,E1> , Vector<D,T2,E2>, FnDot >::Type_t
dot( const Tensor<D,T1,E1>& v1 , const Vector<D,T2,E2>& v2 )
{
  typedef Tensor<D,T1,E1> V1;
  typedef Vector<D,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef Vector<D,T3,BinaryVectorOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Vector<D,T2,E2>, FnOuterProduct >
{
  typedef typename BinaryReturn<T1, T2, OpMultiply>::Type_t T0;
  typedef Tensor<D, T0> Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn<Vector<D,T1,E1>, Vector<D,T2,E2>, FnOuterProduct>::Type_t
outerProduct(const Vector<D,T1,E1> &v1, const Vector<D,T2,E2> &v2 )
{
  typedef typename
    BinaryReturn<Vector<D,T1,E1>, Vector<D,T2,E2>, FnOuterProduct>::Type_t
    Return_t;
  Return_t ret;
  for (int i = 0; i < D; ++i)
    for (int j = 0; j < D; ++j)
      ret(i, j) = v1(i) * v2(j);
  return ret;
}
template<int D1, int D2, class T, class E> class TinyMatrix;
template<int D1, int D2, class T, class E> class TinyMatrixEngine;
template<int D, class T, class E> class Vector;
template<int D, class T, class E> class VectorEngine;
template<class V1, class T2, int I, int B, int L>
struct VectorDotTinyMatrix
{
  typedef typename VectorDotTinyMatrix<V1,T2,I,B,L/2>::Type_t E1;
  typedef typename VectorDotTinyMatrix<V1,T2,I,B+L/2,L-L/2>::Type_t E2;
  typedef typename BinaryReturn<E1,E2,OpAdd>::Type_t Type_t;
  static Type_t get(const V1& v1, const T2& t2)
    {
      return
        VectorDotTinyMatrix<V1,T2,I,B,L/2>::get(v1,t2) +
        VectorDotTinyMatrix<V1,T2,I,B+L/2,L-L/2>::get(v1,t2);
    }
};
template<class V1, class T2, int I, int B>
struct VectorDotTinyMatrix<V1,T2,I,B,1>
{
  typedef typename VectorElem<V1,B>::Element_t E1;
  typedef typename TinyMatrixElem<T2,B,I>::Element_t E2;
  typedef typename BinaryReturn<E1,E2,OpMultiply>::Type_t Type_t;
  static Type_t get(const V1& v1, const T2& t2)
    {
      return VectorElem<V1,B>::get(v1) * TinyMatrixElem<T2,B,I>::get(t2);
    }
};
template<int D1, int D2, class T1, class T2, class T3, class E1, class E2, int I>
struct VectorEngineElem<D2,T3,
  BinaryVectorOp<Vector<D1,T1,E1>,TinyMatrix<D1,D2,T2,E2>,FnDot>,I>
{
  typedef Vector<D1,T1,E1> V1;
  typedef TinyMatrix<D1,D2,T2,E2> V2;
  typedef VectorEngine<D2,T3,BinaryVectorOp<V1,V2,FnDot> > V;
  typedef typename VectorDotTinyMatrix<V1,V2,I,0,D1>::Type_t T0;
  typedef T0 Element_t;
  typedef T0 ConstElementRef_t;
  typedef T0 ElementRef_t;
  static T0 get(const V& x)
    {
      return VectorDotTinyMatrix<V1,V2,I,0,D1>::get(x.v1_m,x.v2_m);
    }
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D1,T1,E1> , TinyMatrix<D1,D2,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef Vector<D2,T0,Full> Type_t;
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< Vector<D1,T1,E1>,TinyMatrix<D1,D2,T2,E2> , FnDot >::Type_t
dot( const Vector<D1,T1,E1>& v1, const TinyMatrix<D1,D2,T2,E2>& v2 )
{
  typedef Vector<D1,T1,E1> V1;
  typedef TinyMatrix<D1,D2,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef Vector<D2,T3,BinaryVectorOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<class T1, class V2, int I, int B, int L>
struct TinyMatrixDotVector
{
  typedef typename TinyMatrixDotVector<T1,V2,I,B,L/2>::Type_t E1;
  typedef typename TinyMatrixDotVector<T1,V2,I,B+L/2,L-L/2>::Type_t E2;
  typedef typename BinaryReturn<E1,E2,OpAdd>::Type_t Type_t;
  static Type_t get(const T1& t1, const V2& v2)
    {
      return
        TinyMatrixDotVector<T1,V2,I,B,L/2>::get(t1,v2) +
        TinyMatrixDotVector<T1,V2,I,B+L/2,L-L/2>::get(t1,v2);
    }
};
template<class T1, class V2, int I, int B>
struct TinyMatrixDotVector<T1,V2,I,B,1>
{
  typedef typename TinyMatrixElem<T1,I,B>::Element_t E1;
  typedef typename VectorElem<V2,B>::Element_t E2;
  typedef typename BinaryReturn<E1,E2,OpMultiply>::Type_t Type_t;
  static Type_t get(const T1& t1, const V2& v2)
    {
      return TinyMatrixElem<T1,I,B>::get(t1) * VectorElem<V2,B>::get(v2);
    }
};
template<int D1, int D2, class T1, class T2, class T3, class E1, class E2, int I>
struct VectorEngineElem<D1,T3,
  BinaryVectorOp<TinyMatrix<D1,D2,T1,E1>,Vector<D2,T2,E2>,FnDot>,I>
{
  typedef TinyMatrix<D1,D2,T1,E1> V1;
  typedef Vector<D2,T2,E2> V2;
  typedef VectorEngine<D1,T3,BinaryVectorOp<V1,V2,FnDot> > V;
  typedef typename TinyMatrixDotVector<V1,V2,I,0,D2>::Type_t T0;
  typedef T0 Element_t;
  typedef T0 ConstElementRef_t;
  typedef T0 ElementRef_t;
  static T0 get(const V& x)
    {
      return TinyMatrixDotVector<V1,V2,I,0,D2>::get(x.v1_m,x.v2_m);
    }
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
struct BinaryReturn< TinyMatrix<D1,D2,T1,E1> , Vector<D2,T2,E2> , FnDot >
{
  typedef typename BinaryReturn<T1,T2,OpMultiply>::Type_t T0;
  typedef Vector<D1,T0,Full> Type_t;
};
template<int D1, int D2, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn< TinyMatrix<D1,D2,T1,E1> , Vector<D2,T2,E2>, FnDot >::Type_t
dot( const TinyMatrix<D1,D2,T1,E1>& v1 , const Vector<D2,T2,E2>& v2 )
{
  typedef TinyMatrix<D1,D2,T1,E1> V1;
  typedef Vector<D2,T2,E2> V2;
  typedef typename BinaryReturn<V1,V2,FnDot>::Type_t Return_t;
  typedef typename Return_t::Element_t T3;
  typedef Vector<D1,T3,BinaryVectorOp<V1,V2,FnDot> > Expr_t;
  return Return_t( Expr_t(v1,v2) );
}
template<int D, class T1, class T2, class E1, class E2>
struct BinaryReturn< Vector<D,T1,E1> , Vector<D,T2,E2>, FnOuterProductAsTinyMatrix >
{
  typedef typename BinaryReturn<T1, T2, OpMultiply>::Type_t T0;
  typedef TinyMatrix<D, D, T0> Type_t;
};
template<int D, class T1, class T2, class E1, class E2>
inline
typename BinaryReturn<Vector<D,T1,E1>, Vector<D,T2,E2>, FnOuterProductAsTinyMatrix>::Type_t
outerProductAsTinyMatrix(const Vector<D,T1,E1> &v1, const Vector<D,T2,E2> &v2 )
{
  typedef typename
    BinaryReturn<Vector<D,T1,E1>, Vector<D,T2,E2>, FnOuterProduct>::Type_t
    Return_t;
  Return_t ret;
  for (int i = 0; i < D; ++i)
    for (int j = 0; j < D; ++j)
      ret(i, j) = v1(i) * v2(j);
  return ret;
}
template<int Dim, class T, class EngineTag, class Op>
inline T globalReduction(const Vector<Dim, T, EngineTag> &v,
  const Op &op)
{
  T val = v(0);
  for (int i = 1; i < Dim; i++)
    op(val, v(i));
  return val;
}
template<int Dim, class T, class EngineTag, class Op>
inline T globalReduction(const Tensor<Dim, T, EngineTag> &t,
  const Op &op)
{
  T val = t(0, 0);
  for (int k = 1; k < Dim; k++)
    op(val, t(k, 0));
  for (int j = 1; j < Dim; j++)
    for (int i = 0; i < Dim; i++)
      op(val, t(i, j));
  return val;
}
template<int Dim, class T, class Op>
inline T globalReduction(const Tensor<Dim, T, Full> &t,
  const Op &op)
{
  T val = t(0, 0);
  for (int i = 1; i < TensorStorageSize<Dim, Full>::Size; i++)
    op(val, t(i));
  return val;
}
template<int Dim, class T, class Op>
inline T globalReduction(const Tensor<Dim, T, Antisymmetric> &t,
  const Op &op)
{
  T val = t(0,0);
  for (int i = 0; i < TensorStorageSize<Dim, Antisymmetric>::Size - 1 / Dim; i++)
    {
      op(val, t(i));
      op(val, -t(i));
    }
  return val;
}
template<int Dim, class T, class Op>
inline T globalReduction(const Tensor<Dim, T, Diagonal> &t,
  const Op &op)
{
  T val = t(0);
  for (int i = 1; i < TensorStorageSize<Dim, Diagonal>::Size; i++)
    op(val, t(i));
  if (Dim > 1)
    op(val, T(0));
  return val;
}
template<int Dim1, int Dim2, class T, class EngineTag, class Op>
inline T globalReduction(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m,
  const Op &op)
{
  T val = m(0, 0);
  for (int k = 1; k < Dim1; k++)
    op(val, m(k, 0));
  for (int j = 1; j < Dim2; j++)
    for (int i = 0; i < Dim1; i++)
      op(val, m(i, j));
  return val;
}
template<int Dim1, int Dim2, class T, class Op>
inline T globalReduction(const TinyMatrix<Dim1, Dim2, T, Full> &m,
  const Op &op)
{
  T val = m(0, 0);
  for (int i = 1; i < Dim1 * Dim2; i++)
    op(val, m(i));
  return val;
}
template<int Dim, class T, class EngineTag>
T sum(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, OpAddAssign());
}
template<int Dim, class T, class EngineTag>
T prod(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, OpMultiplyAssign());
}
template<int Dim, class T, class EngineTag>
T min(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, FnMinAssign());
}
template<int Dim, class T, class EngineTag>
T max(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, FnMaxAssign());
}
template<int Dim, class T, class EngineTag>
bool all(const Vector<Dim, T, EngineTag> &v)
{
  for (int i = 0; i < Dim; i++)
    if (!v(i))
      return false;
  return true;
}
template<int Dim, class T, class EngineTag>
bool any(const Vector<Dim, T, EngineTag> &v)
{
  for (int i = 0; i < Dim; i++)
    if (v(i))
      return true;
  return false;
}
template<int Dim, class T, class EngineTag>
T bitOr(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, OpBitwiseOrAssign());
}
template<int Dim, class T, class EngineTag>
T bitAnd(const Vector<Dim, T, EngineTag> &v)
{
  return globalReduction(v, OpBitwiseAndAssign());
}
template<int Dim, class T, class EngineTag>
T sum(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, OpAddAssign());
}
template<int Dim, class T>
T sum(const Tensor<Dim, T, Antisymmetric> &t)
{
  return T(0);
}
template<int Dim, class T, class EngineTag>
T prod(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, OpMultiplyAssign());
}
template<int Dim, class T>
T prod(const Tensor<Dim, T, Antisymmetric> &t)
{
  return T(0);
}
template<int Dim, class T, class EngineTag>
T min(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, FnMinAssign());
}
template<int Dim, class T, class EngineTag>
T max(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, FnMaxAssign());
}
template<int Dim, class T, class EngineTag>
bool all(const Tensor<Dim, T, EngineTag> &t)
{
  for (int j = 0; j < Dim; j++)
    for (int i = 0; i < Dim; i++)
      if (!t(i, j))
        return false;
  return true;
}
template<int Dim, class T>
bool all(const Tensor<Dim, T, Antisymmetric> &t)
{
  return false;
}
template<int Dim, class T, class EngineTag>
bool any(const Tensor<Dim, T, EngineTag> &t)
{
  for (int j = 0; j < Dim; j++)
    for (int i = 0; i < Dim; i++)
      if (t(i, j))
        return true;
  return false;
}
template<int Dim, class T, class EngineTag>
T bitOr(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, OpBitwiseOrAssign());
}
template<int Dim, class T, class EngineTag>
T bitAnd(const Tensor<Dim, T, EngineTag> &t)
{
  return globalReduction(t, OpBitwiseAndAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
T sum(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, OpAddAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
T prod(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, OpMultiplyAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
T min(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, FnMinAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
T max(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, FnMaxAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
bool all(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  for (int j = 0; j < Dim2; j++)
    for (int i = 0; i < Dim1; i++)
      if (!m(i, j))
        return false;
  return true;
}
template<int Dim1, int Dim2, class T, class EngineTag>
bool any(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  for (int j = 0; j < Dim2; j++)
    for (int i = 0; i < Dim1; i++)
      if (m(i, j))
        return true;
  return false;
}
template<int Dim1, int Dim2, class T, class EngineTag>
T bitOr(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, OpBitwiseOrAssign());
}
template<int Dim1, int Dim2, class T, class EngineTag>
T bitAnd(const TinyMatrix<Dim1, Dim2, T, EngineTag> &m)
{
  return globalReduction(m, OpBitwiseAndAssign());
}
template<class T>
struct Zero
{
  operator T() const { return T(0); }
  bool operator==(const Zero<T>&) const { return true; }
  Zero() {}
  Zero(const Zero<T>&) {}
  Zero<T>& operator=(const Zero<T>&) { return *this; }
};
template<class T, class Op> struct UnaryReturn;
template<class T1, class T2, class Op> struct BinaryReturn;
template<class T>
  inline Zero<T> operator*(Zero<T>, const T&) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator*(const T&, Zero<T>) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator*(Zero<T>, Zero<T>) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator/(Zero<T>, const T&) { return Zero<T>(); }
template<class T>
struct BinaryReturn< Zero<T> , T , OpMultiply >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< T, Zero<T> , OpMultiply >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< Zero<T>, Zero<T> , OpMultiply >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< Zero<T> , T , OpDivide >
{
  typedef Zero<T> Type_t;
};
template<class T>
  inline const T& operator+(Zero<T>, const T& x) { return x; }
template<class T>
  inline const T& operator+(const T& x, Zero<T>) { return x; }
template<class T>
  inline Zero<T> operator+(Zero<T>, Zero<T>) { return Zero<T>(); }
template<class T>
  inline T operator-(Zero<T>, const T& x) { return -x; }
template<class T>
  inline const T& operator-(const T& x, Zero<T>) { return x; }
template<class T>
  inline Zero<T> operator-(Zero<T>, Zero<T>) { return Zero<T>(); }
template<class T>
struct BinaryReturn< Zero<T> , T , OpAdd >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< T, Zero<T> , OpAdd >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< Zero<T>, Zero<T> , OpAdd >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< Zero<T> , T , OpSubtract >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< T, Zero<T> , OpSubtract >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< Zero<T>, Zero<T> , OpSubtract >
{
  typedef Zero<T> Type_t;
};
template<class T>
  inline Zero<T> operator-(Zero<T>) { return Zero<T>(); }
template<class T>
struct UnaryReturn< Zero<T> , OpUnaryMinus >
{
  typedef Zero<T> Type_t;
};
template<class T>
  inline Zero<T> operator+(Zero<T>) { return Zero<T>(); }
template<class T>
struct UnaryReturn< Zero<T> , OpUnaryPlus >
{
  typedef Zero<T> Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< Zero<T1> , Zero<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2>
struct BinaryReturn< Zero<T1> , Zero<T2>, OpEQ >
{
  typedef typename BinaryReturn<T1,T2,OpEQ>::Type_t Type_t;
};
template<class T> struct Zero;
template<class T, class Op> struct UnaryReturn;
template<class T1, class T2, class Op> struct BinaryReturn;
template<class T>
struct One
{
  operator T() const { return T(1); }
  bool operator==(const One<T>&) const { return true; }
  One() {}
  One(const One<T>&) {}
  One<T>& operator=(const One<T>&) { return *this; }
};
template<class T>
struct MinusOne
{
  operator T() const { return T(-1); }
  bool operator==(const MinusOne<T>&) const { return true; }
  MinusOne() {}
  MinusOne(const One<T>&) {}
  MinusOne<T>& operator=(const MinusOne<T>&) { return *this; }
};
template<class T>
  inline MinusOne<T> operator-(One<T>) { return MinusOne<T>(); }
template<class T>
  inline One<T> operator-(MinusOne<T>) { return One<T>(); }
template<class T>
  inline T operator*(One<T>, const T& val) { return val; }
template<class T>
  inline T operator*(const T& val, One<T>) { return val; }
template<class T>
  inline One<T> operator*(One<T>, One<T>) { return One<T>(); }
template<class T>
  inline One<T> operator/(One<T>, One<T>) { return One<T>(); }
template<class T>
  inline T operator/(const T& val, One<T>) { return val; }
template<class T>
  inline T operator*(MinusOne<T>, const T& val) { return -val; }
template<class T>
  inline T operator*(const T& val, MinusOne<T>) { return -val; }
template<class T>
  inline One<T> operator*(MinusOne<T>, MinusOne<T>) { return One<T>(); }
template<class T>
  inline One<T> operator/(MinusOne<T>, MinusOne<T>) { return One<T>(); }
template<class T>
  inline T operator/(const T& val, MinusOne<T>) { return -val; }
template<class T>
  inline MinusOne<T> operator*(MinusOne<T>, One<T>) { return MinusOne<T>(); }
template<class T>
  inline MinusOne<T> operator*(One<T>, MinusOne<T>) { return MinusOne<T>(); }
template<class T>
  inline MinusOne<T> operator/(MinusOne<T>, One<T>) { return MinusOne<T>(); }
template<class T>
  inline MinusOne<T> operator/(One<T>, MinusOne<T>) { return MinusOne<T>(); }
template<class T>
  inline Zero<T> operator-(One<T>, One<T>) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator-(MinusOne<T>, MinusOne<T>) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator+(One<T>, MinusOne<T>) { return Zero<T>(); }
template<class T>
  inline Zero<T> operator+(MinusOne<T>, One<T>) { return Zero<T>(); }
template<class T>
  inline MinusOne<T> operator-(Zero<T>, One<T>) { return MinusOne<T>(); }
template<class T>
  inline One<T> operator-(Zero<T>, MinusOne<T>) { return One<T>(); }
template<class T>
struct UnaryReturn< One<T> , OpUnaryMinus >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct UnaryReturn< MinusOne<T> , OpUnaryMinus >
{
  typedef One<T> Type_t;
};
template<class T>
struct BinaryReturn< One<T> , T , OpMultiply >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< T, One<T> , OpMultiply >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< One<T>, One<T> , OpMultiply >
{
  typedef One<T> Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T> , T , OpMultiply >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< T, MinusOne<T> , OpMultiply >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, MinusOne<T> , OpMultiply >
{
  typedef One<T> Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, One<T> , OpMultiply >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct BinaryReturn< One<T>, MinusOne<T> , OpMultiply >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct BinaryReturn< T, One<T> , OpDivide >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< T, MinusOne<T> , OpDivide >
{
  typedef T Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, One<T> , OpDivide >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct BinaryReturn< One<T>, MinusOne<T> , OpDivide >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct BinaryReturn< One<T>, One<T> , OpSubtract >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, MinusOne<T> , OpSubtract >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< Zero<T>, One<T>, OpSubtract >
{
  typedef MinusOne<T> Type_t;
};
template<class T>
struct BinaryReturn< Zero<T>, MinusOne<T>, OpSubtract >
{
  typedef One<T> Type_t;
};
template<class T>
struct BinaryReturn< One<T>, MinusOne<T> , OpAdd >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, One<T> , OpAdd >
{
  typedef Zero<T> Type_t;
};
template<class T>
struct BinaryReturn< MinusOne<T>, MinusOne<T>, OpEQ>
{
  typedef bool Type_t;
};
template<class T>
struct BinaryReturn< One<T>, One<T>, OpEQ>
{
  typedef bool Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< One<T1> , One<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< MinusOne<T1> , MinusOne<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< One<T1>, Zero<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< Zero<T1>, One<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< MinusOne<T1>, Zero<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< Zero<T1>, MinusOne<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< One<T1>, MinusOne<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class T1, class T2, class Op>
struct BinaryReturn< MinusOne<T1>, One<T2>, Op >
{
  typedef typename BinaryReturn<T1,T2,Op>::Type_t Type_t;
};
template<class A1> struct MultiArg1;
template<class A1, class A2> struct MultiArg2;
template<class A1, class A2, class A3> struct MultiArg3;
template<class A1, class A2, class A3, class A4> struct MultiArg4;
template<class A1, class A2, class A3, class A4, class A5> struct MultiArg5;
template<class A1, class A2, class A3, class A4, class A5, class A6> struct MultiArg6;
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct MultiArg7;
template<class A1, class Dom>
struct MultiArgView1
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef MultiArg1<A1_t> Type_t;
};
template<class A1, class A2, class Dom>
struct MultiArgView2
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef MultiArg2<A1_t, A2_t> Type_t;
};
template<class A1, class A2, class A3, class Dom>
struct MultiArgView3
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef typename View1<A3, Dom>::Type_t A3_t;
  typedef MultiArg3<A1_t, A2_t, A3_t> Type_t;
};
template<class A1, class A2, class A3, class A4, class Dom>
struct MultiArgView4
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef typename View1<A3, Dom>::Type_t A3_t;
  typedef typename View1<A4, Dom>::Type_t A4_t;
  typedef MultiArg4<A1_t, A2_t, A3_t, A4_t> Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class Dom>
struct MultiArgView5
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef typename View1<A3, Dom>::Type_t A3_t;
  typedef typename View1<A4, Dom>::Type_t A4_t;
  typedef typename View1<A5, Dom>::Type_t A5_t;
  typedef MultiArg5<A1_t, A2_t, A3_t, A4_t, A5_t> Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class Dom>
struct MultiArgView6
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef typename View1<A3, Dom>::Type_t A3_t;
  typedef typename View1<A4, Dom>::Type_t A4_t;
  typedef typename View1<A5, Dom>::Type_t A5_t;
  typedef typename View1<A6, Dom>::Type_t A6_t;
  typedef MultiArg6<A1_t, A2_t, A3_t, A4_t, A5_t, A6_t> Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Dom>
struct MultiArgView7
{
  typedef typename View1<A1, Dom>::Type_t A1_t;
  typedef typename View1<A2, Dom>::Type_t A2_t;
  typedef typename View1<A3, Dom>::Type_t A3_t;
  typedef typename View1<A4, Dom>::Type_t A4_t;
  typedef typename View1<A5, Dom>::Type_t A5_t;
  typedef typename View1<A6, Dom>::Type_t A6_t;
  typedef typename View1<A7, Dom>::Type_t A7_t;
  typedef MultiArg7<A1_t, A2_t, A3_t, A4_t, A5_t, A6_t, A7_t> Type_t;
};
template<class A1, class Dom>
struct View1<MultiArg1<A1>, Dom>
{
  typedef typename MultiArgView1<A1, Dom>::Type_t Type_t;
};
template<class A1, class A2, class Dom>
struct View1<MultiArg2<A1, A2>, Dom>
{
  typedef typename MultiArgView2<A1, A2, Dom>::Type_t Type_t;
};
template<class A1, class A2, class A3, class Dom>
struct View1<MultiArg3<A1, A2, A3>, Dom>
{
  typedef typename MultiArgView3<A1, A2, A3, Dom>::Type_t Type_t;
};
template<class A1, class A2, class A3, class A4, class Dom>
struct View1<MultiArg4<A1, A2, A3, A4>, Dom>
{
  typedef typename MultiArgView4<A1, A2, A3, A4, Dom>::Type_t Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class Dom>
struct View1<MultiArg5<A1, A2, A3, A4, A5>, Dom>
{
  typedef typename MultiArgView5<A1, A2, A3, A4, A5, Dom>::Type_t Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class Dom>
struct View1<MultiArg6<A1, A2, A3, A4, A5, A6>, Dom>
{
  typedef typename MultiArgView6<A1, A2, A3, A4, A5, A6, Dom>::Type_t Type_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Dom>
struct View1<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Dom>
{
  typedef typename MultiArgView7<A1, A2, A3, A4, A5, A6, A7, Dom>::Type_t Type_t;
};
template<class A1>
struct MultiArg1
{
  enum { size = 1 };
  MultiArg1(const A1 &a1)
    : a1_m(a1)
  {
  }
  template<class Dom>
  typename View1<MultiArg1<A1>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg1<A1>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom));
  }
  A1 a1_m;
};
template<class A1, class A2>
struct MultiArg2
{
  enum { size = 2 };
  MultiArg2(const A1 &a1, const A2 &a2)
    : a1_m(a1), a2_m(a2)
  {
  }
  template<class Dom>
  typename View1<MultiArg2<A1, A2>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg2<A1, A2>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
};
template<class A1, class A2, class A3>
struct MultiArg3
{
  enum { size = 3 };
  MultiArg3(const A1 &a1, const A2 &a2, const A3 &a3)
    : a1_m(a1), a2_m(a2), a3_m(a3)
  {
  }
  template<class Dom>
  typename View1<MultiArg3<A1, A2, A3>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg3<A1, A2, A3>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
  A3 a3_m;
};
template<class A1, class A2, class A3, class A4>
struct MultiArg4
{
  enum { size = 4 };
  MultiArg4(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
    : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4)
  {
  }
  template<class Dom>
  typename View1<MultiArg4<A1, A2, A3, A4>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg4<A1, A2, A3, A4>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
  A3 a3_m;
  A4 a4_m;
};
template<class A1, class A2, class A3, class A4, class A5>
struct MultiArg5
{
  enum { size = 5 };
  MultiArg5(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
    : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4), a5_m(a5)
  {
  }
  template<class Dom>
  typename View1<MultiArg5<A1, A2, A3, A4, A5>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg5<A1, A2, A3, A4, A5>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
  A3 a3_m;
  A4 a4_m;
  A5 a5_m;
};
template<class A1, class A2, class A3, class A4, class A5, class A6>
struct MultiArg6
{
  enum { size = 6 };
  MultiArg6(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
    : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4), a5_m(a5), a6_m(a6)
  {
  }
  template<class Dom>
  typename View1<MultiArg6<A1, A2, A3, A4, A5, A6>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg6<A1, A2, A3, A4, A5, A6>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom), a6_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
  A3 a3_m;
  A4 a4_m;
  A5 a5_m;
  A6 a6_m;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
struct MultiArg7
{
  enum { size = 7 };
  MultiArg7(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
    : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4), a5_m(a5), a6_m(a6), a7_m(a7)
  {
  }
  template<class Dom>
  typename View1<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Dom>::Type_t
  operator()(const Dom &dom) const
  {
    typedef typename View1<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Dom>::Type_t Ret_t;
    return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom), a6_m(dom), a7_m(dom));
  }
  A1 a1_m;
  A2 a2_m;
  A3 a3_m;
  A4 a4_m;
  A5 a5_m;
  A6 a6_m;
  A7 a7_m;
};
template<class A1, class Function>
void applyMultiArg(const MultiArg1<A1> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
}
template<class A1, class A2, class Function>
void applyMultiArg(const MultiArg2<A1, A2> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
}
template<class A1, class A2, class A3, class Function>
void applyMultiArg(const MultiArg3<A1, A2, A3> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
  f(node.a3_m, condition[2]);
}
template<class A1, class A2, class A3, class A4, class Function>
void applyMultiArg(const MultiArg4<A1, A2, A3, A4> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
  f(node.a3_m, condition[2]);
  f(node.a4_m, condition[3]);
}
template<class A1, class A2, class A3, class A4, class A5, class Function>
void applyMultiArg(const MultiArg5<A1, A2, A3, A4, A5> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
  f(node.a3_m, condition[2]);
  f(node.a4_m, condition[3]);
  f(node.a5_m, condition[4]);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class Function>
void applyMultiArg(const MultiArg6<A1, A2, A3, A4, A5, A6> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
  f(node.a3_m, condition[2]);
  f(node.a4_m, condition[3]);
  f(node.a5_m, condition[4]);
  f(node.a6_m, condition[5]);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function>
void applyMultiArg(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &node,
     const Function &f,
     const std::vector<bool> &condition)
{
  f(node.a1_m, condition[0]);
  f(node.a2_m, condition[1]);
  f(node.a3_m, condition[2]);
  f(node.a4_m, condition[3]);
  f(node.a5_m, condition[4]);
  f(node.a6_m, condition[5]);
  f(node.a7_m, condition[6]);
}
template<class A1, class Function>
void applyMultiArg(const MultiArg1<A1> &node,
     const Function &f)
{
  f(node.a1_m);
}
template<class A1, class A2, class Function>
void applyMultiArg(const MultiArg2<A1, A2> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
}
template<class A1, class A2, class A3, class Function>
void applyMultiArg(const MultiArg3<A1, A2, A3> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
  f(node.a3_m);
}
template<class A1, class A2, class A3, class A4, class Function>
void applyMultiArg(const MultiArg4<A1, A2, A3, A4> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
  f(node.a3_m);
  f(node.a4_m);
}
template<class A1, class A2, class A3, class A4, class A5, class Function>
void applyMultiArg(const MultiArg5<A1, A2, A3, A4, A5> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
  f(node.a3_m);
  f(node.a4_m);
  f(node.a5_m);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class Function>
void applyMultiArg(const MultiArg6<A1, A2, A3, A4, A5, A6> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
  f(node.a3_m);
  f(node.a4_m);
  f(node.a5_m);
  f(node.a6_m);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function>
void applyMultiArg(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &node,
     const Function &f)
{
  f(node.a1_m);
  f(node.a2_m);
  f(node.a3_m);
  f(node.a4_m);
  f(node.a5_m);
  f(node.a6_m);
  f(node.a7_m);
}
template<class A1, class Function>
void applyMultiArgIf(const MultiArg1<A1> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
}
template<class A1, class A2, class Function>
void applyMultiArgIf(const MultiArg2<A1, A2> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
}
template<class A1, class A2, class A3, class Function>
void applyMultiArgIf(const MultiArg3<A1, A2, A3> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
  if (condition[2])
    f(node.a3_m);
}
template<class A1, class A2, class A3, class A4, class Function>
void applyMultiArgIf(const MultiArg4<A1, A2, A3, A4> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
  if (condition[2])
    f(node.a3_m);
  if (condition[3])
    f(node.a4_m);
}
template<class A1, class A2, class A3, class A4, class A5, class Function>
void applyMultiArgIf(const MultiArg5<A1, A2, A3, A4, A5> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
  if (condition[2])
    f(node.a3_m);
  if (condition[3])
    f(node.a4_m);
  if (condition[4])
    f(node.a5_m);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class Function>
void applyMultiArgIf(const MultiArg6<A1, A2, A3, A4, A5, A6> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
  if (condition[2])
    f(node.a3_m);
  if (condition[3])
    f(node.a4_m);
  if (condition[4])
    f(node.a5_m);
  if (condition[5])
    f(node.a6_m);
}
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function>
void applyMultiArgIf(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &node,
   const Function &f,
   const std::vector<bool> &condition)
{
  if (condition[0])
    f(node.a1_m);
  if (condition[1])
    f(node.a2_m);
  if (condition[2])
    f(node.a3_m);
  if (condition[3])
    f(node.a4_m);
  if (condition[4])
    f(node.a5_m);
  if (condition[5])
    f(node.a6_m);
  if (condition[6])
    f(node.a7_m);
}
struct LoopApplyEvaluator
{
  template<class Op, class Dom>
  static
  void evaluate(const Op &op, const Dom &domain)
  {
    PoomaCTAssert<(Dom::unitStride)>::test();
    evaluate(op, domain, WrappedInt<Dom::dimensions>());
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<1>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int e0 = domain[0].last();
;
#pragma omp parallel for if (e0-f0 > 512)
    for (int i0 = f0; i0 <= e0; ++i0)
      localOp(i0);
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<2>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
#pragma omp parallel for
    for (int i1 = f1; i1 <= e1; ++i1) {
;
      for (int i0 = f0; i0 <= e0; ++i0)
 localOp(i0, i1);
    }
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<3>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int f2 = domain[2].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
    int e2 = domain[2].last();
#pragma omp parallel for
    for (int i2 = f2; i2 <= e2; ++i2)
      for (int i1 = f1; i1 <= e1; ++i1) {
;
 for (int i0 = f0; i0 <= e0; ++i0)
   localOp(i0,i1,i2);
      }
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<4>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int f2 = domain[2].first();
    int f3 = domain[3].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
    int e2 = domain[2].last();
    int e3 = domain[3].last();
#pragma omp parallel for
    for (int i3 = f3; i3 <= e3; ++i3)
      for (int i2 = f2; i2 <= e2; ++i2)
 for (int i1 = f1; i1 <= e1; ++i1) {
;
   for (int i0 = f0; i0 <= e0; ++i0)
     localOp(i0,i1,i2,i3);
 }
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<5>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int f2 = domain[2].first();
    int f3 = domain[3].first();
    int f4 = domain[4].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
    int e2 = domain[2].last();
    int e3 = domain[3].last();
    int e4 = domain[4].last();
#pragma omp parallel for
    for (int i4 = f4; i4 <= e4; ++i4)
      for (int i3 = f3; i3 <= e3; ++i3)
 for (int i2 = f2; i2 <= e2; ++i2)
   for (int i1 = f1; i1 <= e1; ++i1) {
;
     for (int i0 = f0; i0 <= e0; ++i0)
       localOp(i0,i1,i2,i3,i4);
   }
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<6>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int f2 = domain[2].first();
    int f3 = domain[3].first();
    int f4 = domain[4].first();
    int f5 = domain[5].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
    int e2 = domain[2].last();
    int e3 = domain[3].last();
    int e4 = domain[4].last();
    int e5 = domain[5].last();
#pragma omp parallel for
    for (int i5 = f5; i5 <= e5; ++i5)
      for (int i4 = f4; i4 <= e4; ++i4)
 for (int i3 = f3; i3 <= e3; ++i3)
   for (int i2 = f2; i2 <= e2; ++i2)
     for (int i1 = f1; i1 <= e1; ++i1) {
;
       for (int i0 = f0; i0 <= e0; ++i0)
  localOp(i0,i1,i2,i3,i4,i5);
     }
  }
  template<class Op, class Domain>
  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<7>)
  {
    Op localOp(op);
    int f0 = domain[0].first();
    int f1 = domain[1].first();
    int f2 = domain[2].first();
    int f3 = domain[3].first();
    int f4 = domain[4].first();
    int f5 = domain[5].first();
    int f6 = domain[6].first();
    int e0 = domain[0].last();
    int e1 = domain[1].last();
    int e2 = domain[2].last();
    int e3 = domain[3].last();
    int e4 = domain[4].last();
    int e5 = domain[5].last();
    int e6 = domain[6].last();
#pragma omp parallel for
    for (int i6 = f6; i6 <= e6; ++i6)
      for (int i5 = f5; i5 <= e5; ++i5)
 for (int i4 = f4; i4 <= e4; ++i4)
   for (int i3 = f3; i3 <= e3; ++i3)
     for (int i2 = f2; i2 <= e2; ++i2)
       for (int i1 = f1; i1 <= e1; ++i1) {
;
  for (int i0 = f0; i0 <= e0; ++i0)
    localOp(i0,i1,i2,i3,i4,i5,i6);
       }
  }
};
template<class MultiArg, class Function>
class MultiArgKernel
  : public Pooma::Iterate_t
{
public:
  MultiArgKernel(const MultiArg &multiArg,
    const Function &function,
    std::vector<bool> &write,
    std::vector<bool> &read)
    : Pooma::Iterate_t(Pooma::scheduler()),
      multiArg_m(multiArg), function_m(function),
      write_m(write), read_m(read)
  {
    DataObjectRequest<BlockAffinity> getAffinity;
    hintAffinity(engineFunctor(multiArg.a1_m.engine(), getAffinity));
    typedef DataObjectRequest<WriteRequest> WriteRequest_t;
    typedef DataObjectRequest<ReadRequest> ReadRequest_t;
    WriteRequest_t writeReq(*this);
    applyMultiArgIf(multiArg, ExpressionApply<WriteRequest_t>(writeReq),
      write_m);
    ReadRequest_t readReq(writeReq);
    applyMultiArgIf(multiArg, ExpressionApply<ReadRequest_t>(readReq),
      read_m);
  }
  virtual ~MultiArgKernel()
  {
    typedef DataObjectRequest<WriteRelease> WriteRequest_t;
    typedef DataObjectRequest<ReadRelease> ReadRequest_t;
    WriteRequest_t writeReq;
    applyMultiArgIf(multiArg_m, ExpressionApply<WriteRequest_t>(writeReq),
      write_m);
    ReadRequest_t readReq(writeReq);
    applyMultiArgIf(multiArg_m, ExpressionApply<ReadRequest_t>(readReq),
      read_m);
  }
  virtual void run()
  {
    function_m(multiArg_m);
  }
private:
  MultiArg multiArg_m;
  Function function_m;
  std::vector<bool> write_m;
  std::vector<bool> read_m;
};
template<int Dim>
class SimpleIntersectorData
  : public RefCounted
{
public:
  typedef SimpleIntersectorData<Dim> This_t;
  typedef INode<Dim> INode_t;
  typedef std::vector<INode_t> INodeContainer_t;
  typedef typename INodeContainer_t::const_iterator const_iterator;
  typedef Unique::Value_t LayoutID_t;
  enum { dimensions = Dim };
  inline SimpleIntersectorData(const Interval<Dim> &domain, const GuardLayers<Dim> &extent)
    : seenFirst_m(false), domain_m(domain), extent_m(extent)
  {
  }
  inline ~SimpleIntersectorData() { }
  template<class Engine>
  void intersect(const Engine &engine, bool useGuards)
  {
    typedef typename Engine::Layout_t Layout_t;
    typedef typename NewEngine<Engine, Interval<Dim> >::Type_t NewEngine_t;
    const Layout_t &layout(engine.layout());
    if (!seenFirst_m)
    {
      firstID_m = layout.ID();
      seenFirst_m = true;
      int key = GlobalIDDataBase::nullNodeKey();
      layout.touches(domain_m, std::back_inserter(inodes_m),
       TouchesConstructINode<Dim>(firstID_m, key, &gidStore_m));
    }
    else
    {
      shared(layout.ID(), firstID_m);
    }
    if (useGuards) {
      expressionApply(NewEngine_t(engine, grow(domain_m, extent_m)),
        IntersectorTag<Intersector<Dim> >(lhsi_m));
    } else {
      expressionApply(NewEngine_t(engine, domain_m),
        IntersectorTag<Intersector<Dim> >(lhsi_m));
    }
  }
  inline
  void shared(LayoutID_t id1, LayoutID_t id2)
  {
    gidStore_m.shared(id1,id2);
  }
  SimpleIntersectorData(const This_t &);
  This_t &operator=(const This_t &);
  LayoutID_t firstID_m;
  bool seenFirst_m;
  INodeContainer_t inodes_m;
  GlobalIDDataBase gidStore_m;
  Interval<Dim> domain_m;
  GuardLayers<Dim> extent_m;
  Intersector<Dim> lhsi_m;
};
template<int Dim>
class SimpleIntersector
{
public:
  typedef SimpleIntersectorData<Dim> SimpleIntersectorData_t;
  typedef SimpleIntersector<Dim> This_t;
  typedef typename SimpleIntersectorData_t::INode_t INode_t;
  typedef typename SimpleIntersectorData_t::INodeContainer_t INodeContainer_t;
  typedef typename SimpleIntersectorData_t::const_iterator const_iterator;
  typedef RefCountedPtr<SimpleIntersectorData_t> DataPtr_t;
  typedef NullCombine Combine_t;
  enum { dimensions = Dim };
  SimpleIntersector(const Interval<Dim> &domain, const GuardLayers<Dim> &extent)
    : pdata_m(new SimpleIntersectorData_t(domain, extent)), useGuards_m(true)
  { }
  SimpleIntersector(const This_t &model)
    : pdata_m(model.pdata_m), useGuards_m(model.useGuards())
  { }
  This_t &operator=(const This_t &model)
  {
    if (this != &model) {
      pdata_m = model.pdata_m;
      useGuards_m = model.useGuards_m;
    }
    return *this;
  }
  ~SimpleIntersector() { }
  inline DataPtr_t &data() { return pdata_m; }
  inline const DataPtr_t &data() const { return pdata_m; }
  inline const_iterator begin() const { return data()->inodes_m.begin(); }
  inline const_iterator end() const { return data()->inodes_m.end(); }
  inline int size() const { return data()->inodes_m.size(); }
  template<class Engine>
  inline
  void intersect(const Engine &l) const
  {
    data()->intersect(l, useGuards());
  }
  inline
  bool useGuards() const
  {
    return useGuards_m;
  }
  inline
  void useGuards(bool f) const
  {
    useGuards_m = f;
  }
  template<class A>
  void operator()(const A &a, bool f) const
  {
    useGuards(f);
    expressionApply(a, *this);
  }
private:
  DataPtr_t pdata_m;
  mutable bool useGuards_m;
};
template<class Eng, int Dim>
struct DefaultExpressionApply<Eng, SimpleIntersector<Dim> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const Eng &,
        const ExpressionApply<SimpleIntersector<Dim> > &)
  {
    PoomaCTAssert<(!(Eng::multiPatch))>::test();
    return true;
  }
};
template<class LT, class PT>
struct MultiPatch;
template <int Dim, class T, class LayoutTag, class PatchTag>
struct LeafFunctor<Engine<Dim, T, MultiPatch<LayoutTag,PatchTag> >,
  ExpressionApply<SimpleIntersector<Dim> > >
{
  typedef int Type_t;
  static Type_t
  apply(const Engine<Dim,T,MultiPatch<LayoutTag,PatchTag> > &engine,
 const ExpressionApply<SimpleIntersector<Dim> > &apply)
  {
    apply.tag().intersect(engine);
    if (apply.tag().useGuards())
      engine.fillGuards(apply.tag().data()->extent_m);
    return 0;
  }
};
template <int Dim, class T, class LT, class PatchTag, int BD>
struct LeafFunctor<Engine<Dim, T, MultiPatchView<LT,PatchTag,BD> >,
  ExpressionApply<SimpleIntersector<Dim> > >
{
  typedef int Type_t;
  static Type_t
  apply(const Engine<Dim,T,MultiPatchView<LT,PatchTag,BD> > &engine,
 const ExpressionApply<SimpleIntersector<Dim> > &apply)
  {
    apply.tag().intersect(engine);
    if (apply.tag().useGuards())
      engine.fillGuards(apply.tag().data()->extent_m);
    return 0;
  }
};
template <int Dim, int size>
class ScalarCodeInfo
{
public:
  enum { dimensions = Dim };
  enum { arguments = size };
  typedef std::vector<bool> BoolVector_t;
  ScalarCodeInfo()
    : extent_m(GuardLayers<Dim>(0)),
      useGuards_m(arguments, true),
      writers_m(arguments, false),
      readers_m(arguments, true)
  {
    useGuards_m[0] = false;
    writers_m[0] = true;
    readers_m[0] = true;
  }
  void extent(const GuardLayers<Dim> &g)
  {
    extent_m = g;
  }
  GuardLayers<Dim>& extent()
  {
    return extent_m;
  }
  const GuardLayers<Dim>& extent() const
  {
    return extent_m;
  }
  void write(int i, bool f, bool r = true)
  {
    writers_m[i] = f;
    readers_m[i] = r;
  }
  BoolVector_t &writers()
  {
    return writers_m;
  }
  BoolVector_t &readers()
  {
    return readers_m;
  }
  void useGuards(int i, bool f)
  {
    useGuards_m[i] = f;
  }
  BoolVector_t &useGuards()
  {
    return useGuards_m;
  }
  inline Interval<Dim> extendDomain(const Interval<Dim> &domain) const
  {
    return grow(domain, extent_m);
  }
  inline Interval<Dim> evaluationDomain(const Interval<Dim> &domain) const
  {
    Interval<Dim> ret;
    for (int d = 0; d < Dim; ++d)
    {
      ret[d] = Interval<1>(extent_m.lower(d),
      domain[d].last() - domain[d].first()
      + extent_m.lower(d));
    }
    return ret;
  }
  inline INode<Dim> extendDomain(const INode<Dim> &inode) const
  {
    return INode<Dim>(inode, extendDomain(inode.domain()));
  }
private:
  GuardLayers<Dim> extent_m;
  BoolVector_t useGuards_m;
  BoolVector_t writers_m;
  BoolVector_t readers_m;
};
template<class MultiArg> struct MultiArgEvaluatorTag;
template<class MeshTag, class T, class EngineTag> class Field;
template<int Dim, class T, class EngineTag> class Array;
template<class EvalTag>
struct MultiArgEvaluator
{
};
struct EngineWriteNotifier
{
  EngineWriteNotifier()
  {
  }
  template<class A>
  inline void dirtyRelations(const A &a, const WrappedInt<true>&) const
  {
    a.notifyPostWrite();
  }
  template<class A>
  inline void dirtyRelations(const A &, const WrappedInt<false>&) const
  {
  }
  template<class A>
  void operator()(const A &a) const
  {
    notifyEngineWrite(a.engine());
    dirtyRelations(a, WrappedInt<A::hasRelations>());
  }
  template<class MeshTag, class T, class Expr>
  void operator()(const Field<MeshTag, T, ExpressionTag<Expr> >&) const
  {
    if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("writing to expression engine?", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Evaluator/MultiArgEvaluator.h", 124);
  }
  template<int Dim, class T, class Expr>
  void operator()(const Array<Dim, T, ExpressionTag<Expr> >&) const
  {
    if (__builtin_expect(!!(false), true)) {} else Pooma::toss_cookies("writing to expression engine?", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Evaluator/MultiArgEvaluator.h", 130);
  }
};
struct UpdateNotifier
{
  UpdateNotifier()
  {
  }
  template<class A>
  void operator()(const A &a) const
  {
    forEach(a, PerformUpdateTag(), NullCombine());
  }
};
template <int Dim>
struct CheckDomain
{
  CheckDomain(const Interval<Dim>&d) : d_m(d) {}
  template <class A>
  void operator()(const A &a) const
  {
    a(d_m);
  }
  Interval<Dim> d_m;
};
template<>
struct MultiArgEvaluator<MainEvaluatorTag>
{
public:
  MultiArgEvaluator() {}
  ~MultiArgEvaluator() {}
  template<class MultiArg, class Function, int Dim, class Kernel>
  static void
  evaluate(const MultiArg &multiArg,
    const Function &function,
    const Interval<Dim> &domain,
    const Kernel &kernel)
  {
    typedef typename MultiArgEvaluatorTag<MultiArg>::Evaluator_t Evaluator_t;
    ScalarCodeInfo<Dim, MultiArg::size> info;
    function.scalarCodeInfo(info);
    Pooma::beginExpression();
    applyMultiArgIf(multiArg, UpdateNotifier(), info.readers());
    MultiArgEvaluator<Evaluator_t>::evaluate(multiArg, function,
          domain, info, kernel);
    applyMultiArgIf(multiArg, EngineWriteNotifier(), info.writers());
    Pooma::endExpression();
  }
  template<class A1, class Function, int Dim, class Kernel>
  static void
  createIterate(const A1& a1,
  const Function& function,
  const Interval<Dim> &domain,
  ScalarCodeInfo<Dim, A1::size> &info,
  const Kernel &)
  {
    Kernel kernelf(function, domain);
    Pooma::Iterate_t *iterate =
      new MultiArgKernel<A1, Kernel>(a1, kernelf,
         info.writers(), info.readers());
    Pooma::scheduler().handOff(iterate);
  }
};
template<>
struct MultiArgEvaluator<SinglePatchEvaluatorTag>
{
public:
  MultiArgEvaluator() {}
  ~MultiArgEvaluator() {}
  template<class MultiArg, class Function, int Dim, class Kernel>
  static void
  evaluate(const MultiArg& multiArg,
    const Function& function,
    Interval<Dim> domain,
    ScalarCodeInfo<Dim, MultiArg::size> &info,
    const Kernel &kernel)
  {
    Interval<Dim> newDom = info.extendDomain(domain);
    Interval<Dim> evalDom = info.evaluationDomain(domain);
    MultiArgEvaluator<MainEvaluatorTag>::createIterate(multiArg(newDom),
             function,
             evalDom, info,
             kernel);
  }
};
template<>
struct MultiArgEvaluator<MultiPatchEvaluatorTag>
{
public:
  MultiArgEvaluator() {}
  ~MultiArgEvaluator() {}
  template<class MultiArg, class Function, int Dim, class Kernel>
  static void
  evaluate(const MultiArg &multiArg,
    const Function &function,
    const Interval<Dim> &domain,
    ScalarCodeInfo<Dim, MultiArg::size> &info,
    const Kernel &kernel)
  {
    typedef SimpleIntersector<Dim> Inter_t;
    Inter_t inter(domain, info.extent());
    applyMultiArg(multiArg, inter, info.useGuards());
    typename Inter_t::const_iterator i = inter.begin();
    while (i != inter.end())
    {
      INode<Dim> inode = info.extendDomain(*i);
      Interval<Dim> evalDom = info.evaluationDomain((*i).domain());
      MultiArgEvaluator<MainEvaluatorTag>::createIterate(multiArg(inode),
        function,
        evalDom, info,
        kernel);
      ++i;
    }
  }
};
template <>
struct MultiArgEvaluator<RemoteSinglePatchEvaluatorTag>
{
  MultiArgEvaluator() { }
  ~MultiArgEvaluator() { }
  template<class MultiArg, class Function, int Dim, class Kernel>
  static void
  evaluate(const MultiArg &multiArg,
    const Function &function,
    const Interval<Dim> &domain,
    ScalarCodeInfo<Dim, MultiArg::size> &info,
    const Kernel &kernel)
  {
    GatherContexts gtag;
    engineFunctor(multiArg.a1_m.engine(), gtag);
    int lhsContext = gtag.mostCommonContext();
    expressionApply(multiArg, RemoteSend(lhsContext));
    EngineView<RemoteView> view;
    if (lhsContext == -1 || Pooma::context() == lhsContext)
    {
      MultiArgEvaluator<SinglePatchEvaluatorTag> speval;
      speval.evaluate(
        forEach(multiArg, view, TreeCombine()),
        function, domain, info, kernel
        );
    }
  }
};
template <>
struct MultiArgEvaluator<RemoteMultiPatchEvaluatorTag>
{
  MultiArgEvaluator() { }
  ~MultiArgEvaluator() { }
  template<class MultiArg, class Function, int Dim, class Kernel>
  static void
  evaluate(const MultiArg &multiArg,
    const Function &function,
    const Interval<Dim> &domain,
    ScalarCodeInfo<Dim, MultiArg::size> &info,
    const Kernel &kernel)
  {
    typedef SimpleIntersector<Dim> Inter_t;
    Inter_t inter(domain, info.extent());
    applyMultiArg(multiArg, inter, info.useGuards());
    typename Inter_t::const_iterator i = inter.begin();
    while (i != inter.end())
    {
      INode<Dim> inode = info.extendDomain(*i);
      Interval<Dim> evalDom = info.evaluationDomain((*i).domain());
      MultiArgEvaluator<RemoteSinglePatchEvaluatorTag>().
 evaluate(multiArg(inode),
   function, evalDom, info, kernel);
      ++i;
    }
  }
};
template<class A1>
struct MultiArgEvaluatorTag<MultiArg1<A1> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Evaluator_t;
};
template<class A1, class A2>
struct MultiArgEvaluatorTag<MultiArg2<A1, A2> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Evaluator_t;
};
template<class A1, class A2, class A3>
struct MultiArgEvaluatorTag<MultiArg3<A1, A2, A3> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorTag1<A3>::Evaluator_t Eval3_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Eval12_t;
  typedef typename EvaluatorCombine<Eval3_t, Eval12_t>::Evaluator_t
  Evaluator_t;
};
template<class A1, class A2, class A3, class A4>
struct MultiArgEvaluatorTag<MultiArg4<A1, A2, A3, A4> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorTag1<A3>::Evaluator_t Eval3_t;
  typedef typename EvaluatorTag1<A4>::Evaluator_t Eval4_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Eval12_t;
  typedef typename EvaluatorCombine<Eval3_t, Eval4_t>::Evaluator_t Eval34_t;
  typedef typename EvaluatorCombine<Eval12_t, Eval34_t>::Evaluator_t Evaluator_t;
};
template<class A1, class A2, class A3, class A4, class A5>
struct MultiArgEvaluatorTag<MultiArg5<A1, A2, A3, A4, A5> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorTag1<A3>::Evaluator_t Eval3_t;
  typedef typename EvaluatorTag1<A4>::Evaluator_t Eval4_t;
  typedef typename EvaluatorTag1<A5>::Evaluator_t Eval5_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Eval12_t;
  typedef typename EvaluatorCombine<Eval3_t, Eval4_t>::Evaluator_t Eval34_t;
  typedef typename EvaluatorCombine<Eval12_t, Eval34_t>::Evaluator_t Eval1234_t;
  typedef typename EvaluatorCombine<Eval1234_t, Eval5_t>::Evaluator_t Evaluator_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6>
struct MultiArgEvaluatorTag<MultiArg6<A1, A2, A3, A4, A5, A6> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorTag1<A3>::Evaluator_t Eval3_t;
  typedef typename EvaluatorTag1<A4>::Evaluator_t Eval4_t;
  typedef typename EvaluatorTag1<A5>::Evaluator_t Eval5_t;
  typedef typename EvaluatorTag1<A6>::Evaluator_t Eval6_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Eval12_t;
  typedef typename EvaluatorCombine<Eval3_t, Eval4_t>::Evaluator_t Eval34_t;
  typedef typename EvaluatorCombine<Eval5_t, Eval6_t>::Evaluator_t Eval56_t;
  typedef typename EvaluatorCombine<Eval12_t, Eval34_t>::Evaluator_t Eval1234_t;
  typedef typename EvaluatorCombine<Eval1234_t, Eval56_t>::Evaluator_t Evaluator_t;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
struct MultiArgEvaluatorTag<MultiArg7<A1, A2, A3, A4, A5, A6, A7> >
{
  typedef typename EvaluatorTag1<A1>::Evaluator_t Eval1_t;
  typedef typename EvaluatorTag1<A2>::Evaluator_t Eval2_t;
  typedef typename EvaluatorTag1<A3>::Evaluator_t Eval3_t;
  typedef typename EvaluatorTag1<A4>::Evaluator_t Eval4_t;
  typedef typename EvaluatorTag1<A5>::Evaluator_t Eval5_t;
  typedef typename EvaluatorTag1<A6>::Evaluator_t Eval6_t;
  typedef typename EvaluatorTag1<A7>::Evaluator_t Eval7_t;
  typedef typename EvaluatorCombine<Eval1_t, Eval2_t>::Evaluator_t Eval12_t;
  typedef typename EvaluatorCombine<Eval3_t, Eval12_t>::Evaluator_t Eval123_t;
  typedef typename EvaluatorCombine<Eval4_t, Eval123_t>::Evaluator_t Eval1234_t;
  typedef typename EvaluatorCombine<Eval5_t, Eval1234_t>::Evaluator_t Eval12345_t;
  typedef typename EvaluatorCombine<Eval6_t, Eval12345_t>::Evaluator_t Eval123456_t;
  typedef typename EvaluatorCombine<Eval7_t, Eval123456_t>::Evaluator_t
  Evaluator_t;
};
template<class A1, class Tag>
struct LeafFunctor<MultiArg1<A1>, ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg1<A1> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    return 0;
  }
};
template<class A1, class Tag>
struct LeafFunctor<MultiArg1<A1>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef MultiArg1<Type1_t> Type_t;
  inline static
  Type_t apply(const MultiArg1<A1> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag)
    );
  }
};
template<class A1, class A2, class Tag>
struct LeafFunctor<MultiArg2<A1, A2>, ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg2<A1, A2> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    return 0;
  }
};
template<class A1, class A2, class Tag>
struct LeafFunctor<MultiArg2<A1, A2>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef MultiArg2<Type1_t, Type2_t> Type_t;
  inline static
  Type_t apply(const MultiArg2<A1, A2> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag)
    );
  }
};
template<class A1, class A2, class A3, class Tag>
struct LeafFunctor<MultiArg3<A1, A2, A3>,
  ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg3<A1, A2, A3> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    leafFunctor(multiarg.a3_m, tag);
    return 0;
  }
};
template<class A1, class A2, class A3, class Tag>
struct LeafFunctor<MultiArg3<A1, A2, A3>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef typename LeafFunctor<A3, EngineView<Tag> >::Type_t Type3_t;
  typedef MultiArg3<Type1_t, Type2_t, Type3_t> Type_t;
  inline static
  Type_t apply(const MultiArg3<A1, A2, A3> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag),
    leafFunctor(multiarg.a3_m, tag)
    );
  }
};
template<class A1, class A2, class A3, class A4, class Tag>
struct LeafFunctor<MultiArg4<A1, A2, A3, A4>,
  ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg4<A1, A2, A3, A4> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    leafFunctor(multiarg.a3_m, tag);
    leafFunctor(multiarg.a4_m, tag);
    return 0;
  }
};
template<class A1, class A2, class A3, class A4, class Tag>
struct LeafFunctor<MultiArg4<A1, A2, A3, A4>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef typename LeafFunctor<A3, EngineView<Tag> >::Type_t Type3_t;
  typedef typename LeafFunctor<A4, EngineView<Tag> >::Type_t Type4_t;
  typedef MultiArg4<Type1_t, Type2_t, Type3_t, Type4_t> Type_t;
  inline static
  Type_t apply(const MultiArg4<A1, A2, A3, A4> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag),
    leafFunctor(multiarg.a3_m, tag),
    leafFunctor(multiarg.a4_m, tag)
    );
  }
};
template<class A1, class A2, class A3, class A4, class A5, class Tag>
struct LeafFunctor<MultiArg5<A1, A2, A3, A4, A5>,
  ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg5<A1, A2, A3, A4, A5> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    leafFunctor(multiarg.a3_m, tag);
    leafFunctor(multiarg.a4_m, tag);
    leafFunctor(multiarg.a5_m, tag);
    return 0;
  }
};
template<class A1, class A2, class A3, class A4, class A5, class Tag>
struct LeafFunctor<MultiArg5<A1, A2, A3, A4, A5>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef typename LeafFunctor<A3, EngineView<Tag> >::Type_t Type3_t;
  typedef typename LeafFunctor<A4, EngineView<Tag> >::Type_t Type4_t;
  typedef typename LeafFunctor<A5, EngineView<Tag> >::Type_t Type5_t;
  typedef MultiArg5<Type1_t, Type2_t, Type3_t, Type4_t, Type5_t> Type_t;
  inline static
  Type_t apply(const MultiArg5<A1, A2, A3, A4, A5> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag),
    leafFunctor(multiarg.a3_m, tag),
    leafFunctor(multiarg.a4_m, tag),
    leafFunctor(multiarg.a5_m, tag)
    );
  }
};
template<class A1, class A2, class A3, class A4, class A5,
  class A6, class Tag>
struct LeafFunctor<MultiArg6<A1, A2, A3, A4, A5, A6>,
  ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg6<A1, A2, A3, A4, A5, A6> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    leafFunctor(multiarg.a3_m, tag);
    leafFunctor(multiarg.a4_m, tag);
    leafFunctor(multiarg.a5_m, tag);
    leafFunctor(multiarg.a6_m, tag);
    return 0;
  }
};
template<class A1, class A2, class A3, class A4, class A5,
  class A6, class Tag>
struct LeafFunctor<MultiArg6<A1, A2, A3, A4, A5, A6>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef typename LeafFunctor<A3, EngineView<Tag> >::Type_t Type3_t;
  typedef typename LeafFunctor<A4, EngineView<Tag> >::Type_t Type4_t;
  typedef typename LeafFunctor<A5, EngineView<Tag> >::Type_t Type5_t;
  typedef typename LeafFunctor<A6, EngineView<Tag> >::Type_t Type6_t;
  typedef MultiArg6<Type1_t, Type2_t, Type3_t, Type4_t, Type5_t,
    Type6_t> Type_t;
  inline static
  Type_t apply(const MultiArg6<A1, A2, A3, A4, A5, A6> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag),
    leafFunctor(multiarg.a3_m, tag),
    leafFunctor(multiarg.a4_m, tag),
    leafFunctor(multiarg.a5_m, tag),
    leafFunctor(multiarg.a6_m, tag)
    );
  }
};
template<class A1, class A2, class A3, class A4, class A5,
  class A6, class A7, class Tag>
struct LeafFunctor<MultiArg7<A1, A2, A3, A4, A5, A6, A7>,
  ExpressionApply<Tag> >
{
  typedef int Type_t;
  inline static
  Type_t apply(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiarg,
        const ExpressionApply<Tag> &tag)
  {
    leafFunctor(multiarg.a1_m, tag);
    leafFunctor(multiarg.a2_m, tag);
    leafFunctor(multiarg.a3_m, tag);
    leafFunctor(multiarg.a4_m, tag);
    leafFunctor(multiarg.a5_m, tag);
    leafFunctor(multiarg.a6_m, tag);
    leafFunctor(multiarg.a7_m, tag);
    return 0;
  }
};
template<class A1, class A2, class A3, class A4, class A5,
  class A6, class A7, class Tag>
struct LeafFunctor<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, EngineView<Tag> >
{
  typedef typename LeafFunctor<A1, EngineView<Tag> >::Type_t Type1_t;
  typedef typename LeafFunctor<A2, EngineView<Tag> >::Type_t Type2_t;
  typedef typename LeafFunctor<A3, EngineView<Tag> >::Type_t Type3_t;
  typedef typename LeafFunctor<A4, EngineView<Tag> >::Type_t Type4_t;
  typedef typename LeafFunctor<A5, EngineView<Tag> >::Type_t Type5_t;
  typedef typename LeafFunctor<A6, EngineView<Tag> >::Type_t Type6_t;
  typedef typename LeafFunctor<A7, EngineView<Tag> >::Type_t Type7_t;
  typedef MultiArg7<Type1_t, Type2_t, Type3_t, Type4_t, Type5_t,
    Type6_t, Type7_t> Type_t;
  inline static
  Type_t apply(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiarg,
        const EngineView<Tag> &tag)
  {
    return Type_t(
    leafFunctor(multiarg.a1_m, tag),
    leafFunctor(multiarg.a2_m, tag),
    leafFunctor(multiarg.a3_m, tag),
    leafFunctor(multiarg.a4_m, tag),
    leafFunctor(multiarg.a5_m, tag),
    leafFunctor(multiarg.a6_m, tag),
    leafFunctor(multiarg.a7_m, tag)
    );
  }
};
template<class MA, class Function>
struct ApplyMultiArgLoc;
template<class A1, class Function>
struct ApplyMultiArgLoc<MultiArg1<A1>, Function>
{
  ApplyMultiArgLoc(const MultiArg1<A1> &multiArg, const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg1<A1> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class Function>
struct ApplyMultiArgLoc<MultiArg2<A1, A2>, Function>
{
  ApplyMultiArgLoc(const MultiArg2<A1, A2> &multiArg,const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg2<A1, A2> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class A3, class Function>
struct ApplyMultiArgLoc<MultiArg3<A1, A2, A3>, Function>
{
  ApplyMultiArgLoc(const MultiArg3<A1, A2, A3> &multiArg,
     const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
        Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
        Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
        Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
        Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg3<A1, A2, A3> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function>
struct ApplyMultiArgLoc<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Function>
{
  ApplyMultiArgLoc(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg,
     const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               multiArg_m.a7_m, Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               multiArg_m.a7_m, Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               multiArg_m.a7_m, Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               multiArg_m.a7_m, Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class A3, class A4, class A5, class A6, class Function>
struct ApplyMultiArgLoc<MultiArg6<A1, A2, A3, A4, A5, A6>, Function>
{
  ApplyMultiArgLoc(const MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg,
     const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
               Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class A3, class A4, class Function>
struct ApplyMultiArgLoc<MultiArg4<A1, A2, A3, A4>, Function>
{
  ApplyMultiArgLoc(const MultiArg4<A1, A2, A3, A4> &multiArg,
     const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m,
               Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m,
                Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m,
               Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m,
               Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg4<A1, A2, A3, A4> &multiArg_m;
  const Function &function_m;
};
template<class A1, class A2, class A3, class A4, class A5, class Function>
struct ApplyMultiArgLoc<MultiArg5<A1, A2, A3, A4, A5>, Function>
{
  ApplyMultiArgLoc(const MultiArg5<A1, A2, A3, A4, A5> &multiArg,
     const Function &function)
    : multiArg_m(multiArg), function_m(function)
  {
  }
  void operator()(int i0) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m,
               Loc<1>(i0));
  }
  void operator()(int i0, int i1) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m,
                Loc<2>(i0, i1));
  }
  void operator()(int i0, int i1, int i2) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m,
               Loc<3>(i0, i1, i2));
  }
  void operator()(int i0, int i1, int i2, int i3) const
  {
    function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
               multiArg_m.a4_m, multiArg_m.a5_m,
               Loc<4>(i0, i1, i2, i3));
  }
  const MultiArg5<A1, A2, A3, A4, A5> &multiArg_m;
  const Function &function_m;
};
template<class Function, int Dim>
struct EvaluateLocLoop
{
  EvaluateLocLoop()
  {
  }
  EvaluateLocLoop(const Function &function, const Interval<Dim> &domain)
    : function_m(function), domain_m(domain)
  {
  }
  template<class MultiArg>
  void operator()(MultiArg &multiArg) const
  {
    ApplyMultiArgLoc<MultiArg, Function> op(multiArg, function_m);
    LoopApplyEvaluator::evaluate(op, domain_m);
  }
  Function function_m;
  Interval<Dim> domain_m;
};
template<class Function>
struct ScalarCode
{
  ScalarCode()
  {
  }
  ScalarCode(const Function &function)
    : function_m(function)
  {
  }
  template <class LHS>
  ScalarCode(const ScalarCode<Function>& sc, const LHS&)
    : function_m(sc.function_m)
  {
  }
  template<class F>
  static inline bool checkValidity(const F& f, WrappedInt<false>)
  {
    return true;
  }
  template<class F>
  static inline bool checkValidity(const F& f, WrappedInt<true>)
  {
    return f.centeringSize() == 1 && f.numMaterials() == 1;
  }
  template<class F1>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom) const
  {
    ;
    MultiArg1<F1> multiArg(f1);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1>
  inline void operator()(const F1 &f1) const
  {
    (*this)(f1, f1.physicalDomain());
  }
  template<class F1, class F2>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
                  const F2 &f2) const
  {
    ;
    MultiArg2<F1, F2> multiArg(f1, f2);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2>
  inline void operator()(const F1 &f1, const F2 &f2) const
  {
    (*this)(f1, f1.physicalDomain(), f2);
  }
  template<class F1, class F2, class F3>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
                  const F2 &f2, const F3 &f3) const
  {
    ;
    MultiArg3<F1, F2, F3> multiArg(f1, f2, f3);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2, class F3>
  inline void operator()(const F1 &f1, const F2 &f2, const F3 &f3) const
  {
    (*this)(f1, f1.physicalDomain(), f2, f3);
  }
  template<class F1, class F2, class F3, class F4>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
    const F2 &f2, const F3 &f3, const F4 &f4) const
  {
    ;
    MultiArg4<F1, F2, F3, F4> multiArg(f1, f2, f3, f4);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2, class F3, class F4>
  inline void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4) const
  {
    (*this)(f1, f1.physicalDomain(), f2, f3, f4);
  }
  template<class F1, class F2, class F3, class F4, class F5>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
    const F2 &f2, const F3 &f3, const F4 &f4, const F5 &f5) const
  {
    ;
    MultiArg5<F1, F2, F3, F4, F5> multiArg(f1, f2, f3, f4, f5);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2, class F3, class F4, class F5>
  inline void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
    const F5 &f5) const
  {
    (*this)(f1, f1.physicalDomain(), f2, f3, f4, f5);
  }
  template<class F1, class F2, class F3, class F4, class F5, class F6>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
    const F2 &f2, const F3 &f3, const F4 &f4, const F5 &f5,
    const F6 &f6) const
  {
    ;
    MultiArg6<F1, F2, F3, F4, F5, F6> multiArg(f1, f2, f3, f4, f5, f6);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2, class F3, class F4, class F5, class F6>
  inline void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
    const F5 &f5, const F6 &f6) const
  {
    (*this)(f1, f1.physicalDomain(), f2, f3, f4, f5, f6);
  }
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7>
  void operator()(const F1 &f1, const Interval<F1::dimensions> &evalDom,
    const F2 &f2, const F3 &f3, const F4 &f4,
    const F5 &f5, const F6 &f6, const F7 &f7) const
  {
    ;
    MultiArg7<F1, F2, F3, F4, F5, F6, F7> multiArg(f1, f2, f3, f4, f5, f6, f7);
    EvaluateLocLoop<Function, F1::dimensions> kernel(function_m, evalDom);
    MultiArgEvaluator<MainEvaluatorTag>::
      evaluate(multiArg, function_m, evalDom, kernel);
  }
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7>
  inline void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
    const F5 &f5, const F6 &f6, const F7 &f7) const
  {
    (*this)(f1, f1.physicalDomain(), f2, f3, f4, f5, f6, f7);
  }
  Function function_m;
};
template<class InputField>
struct PackLocalPatches
{
  typedef typename InputField::Element_t Element_t;
  PackLocalPatches(RefCountedBlockPtr<Element_t> block)
    : block_m(block)
  {
  }
  inline void operator()(const Element_t &t)
  {
    *block_m = t;
    ++block_m;
  }
  RefCountedBlockPtr<Element_t> block_m;
  int total_m;
};
template<class InputField>
RefCountedBlockPtr<typename InputField::Element_t>
pack(const InputField &field)
{
  Pooma::blockAndEvaluate();
  typedef typename InputField::Element_t Element_t;
  int size, i;
  size = 0;
  for (i = 0; i < field.numPatchesLocal(); ++i)
  {
    size += field.patchLocal(i).domain().size();
  }
  RefCountedBlockPtr<Element_t> ret(size);
  RefCountedBlockPtr<Element_t> current = ret;
  for (i = 0; i < field.numPatchesLocal(); ++i)
  {
    typedef typename Patch<InputField>::Type_t PatchField_t;
    PatchField_t patch = field.patchLocal(i);
    PackLocalPatches<PatchField_t> packFunctor(current);
    EngineBlockSerialize::apply(packFunctor, patch, patch.domain());
    current += patch.domain().size();
  }
  return ret;
}
template<class InputField>
struct UnPackLocalPatches
{
  typedef typename InputField::Element_t Element_t;
  UnPackLocalPatches(RefCountedBlockPtr<Element_t> block)
    : block_m(block)
  {
  }
  inline void operator()(Element_t &t)
  {
    t = *block_m;
    ++block_m;
  }
  RefCountedBlockPtr<Element_t> block_m;
  int total_m;
};
template<class InputField, class T>
void
unpack(const InputField &field, RefCountedBlockPtr<T> block)
{
  Pooma::blockAndEvaluate();
  int i;
  RefCountedBlockPtr<T> current = block;
  for (i = 0; i < field.numPatchesLocal(); ++i)
  {
    typedef typename Patch<InputField>::Type_t PatchField_t;
    PatchField_t patch = field.patchLocal(i);
    UnPackLocalPatches<PatchField_t> unpackFunctor(current);
    EngineBlockSerialize::apply(unpackFunctor, patch, patch.physicalDomain());
    current += patch.physicalDomain().size();
  }
}
struct FarLeftTag;
template<class G, class T, class E> class Field;
template<class Expr>
struct MakeFieldReturn;
template<class Op, class Leaf>
struct MakeFieldReturn<UnaryNode<Op, Leaf> >
{
  typedef UnaryNode<Op, Leaf> Tree_t;
  typedef typename
    ForEach<Tree_t, DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
  typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
  typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
    Type_t::MeshTag_t MeshTag_t;
  typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class Op, class Left, class Right>
struct MakeFieldReturn<BinaryNode<Op, Left, Right> >
{
  typedef BinaryNode<Op, Left, Right> Tree_t;
  typedef typename
    ForEach<Tree_t, DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
  typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
  typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
    Type_t::MeshTag_t MeshTag_t;
  typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> >
    Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class Op, class Left, class Middle, class Right>
struct MakeFieldReturn<TrinaryNode<Op, Left, Middle, Right> >
{
  typedef TrinaryNode<Op, Left, Middle, Right> Tree_t;
  typedef typename
    ForEach<Tree_t, DomainFunctorTag, DomainFunctorTag>::Type_t Domain_t;
  enum { dim = Domain_t::dimensions };
  typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
  typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
  typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
    Type_t::MeshTag_t MeshTag_t;
  typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  inline static
  Expression_t make(const Tree_t &tree)
    {
      return Expression_t(Engine_t(tree));
    }
};
template<class G, class T, class E> class Field;
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnArcCos,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
acos(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnArcCos,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnArcSin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
asin(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnArcSin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnArcTan,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
atan(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnArcTan,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnCeil,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
ceil(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnCeil,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnCos,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
cos(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnCos,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnHypCos,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
cosh(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnHypCos,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnExp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
exp(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnExp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnFabs,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
fabs(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnFabs,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnFloor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
floor(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnFloor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnLog,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
log(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnLog,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnLog10,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
log10(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnLog10,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnSin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
sin(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnSin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnHypSin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
sinh(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnHypSin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnSqrt,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
sqrt(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnSqrt,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnTan,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
tan(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnTan,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnHypTan,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
tanh(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnHypTan,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<OpUnaryMinus,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<OpUnaryPlus,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<OpBitwiseNot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
operator~(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<OpIdentity,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
PETE_identity(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<OpIdentity,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<OpNot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
operator!(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<OpNot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<UnaryNode<OpCast<T1>,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
peteCast(const T1&, const Field<G2,T2,E2> & l)
{
  typedef UnaryNode<OpCast<T1>,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G2,T2,E2> >::make(l)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<<(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>>(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpLT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpLE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<=(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpGT,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpGE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>=(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator&&(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator||(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator<<(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator<<(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
operator>>(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
operator>>(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator<=(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator>=(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAnd,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAnd,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&&(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpOr,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpOr,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator||(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2,class T3>
inline typename MakeFieldReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t,
  typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
where(const Field<G1,T1,E1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t,
    typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(c),
    CreateLeaf<T2 >::make(t),
    CreateLeaf<T3 >::make(f)));
}
template<int D, class T, class EngineTag> class Tensor;
template<class OutputEngineTag, int D, class T, class EngineTag>
Tensor<D, T, OutputEngineTag>
symmetrize(const Tensor<D, T, EngineTag> &x);
template<class G, class T, class E> class Field;
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnReal,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
real(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnReal,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnImag,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
imag(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnImag,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnAbs,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
abs(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnAbs,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnArg,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
arg(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnArg,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnNorm,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
norm(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnNorm,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnConj,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
conj(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnConj,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnPow2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
pow2(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnPow2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnPow3,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
pow3(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnPow3,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnPow4,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
pow4(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnPow4,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnMagnitude,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
magnitude(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnMagnitude,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnTrace,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
trace(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnTrace,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnDet,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
det(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnDet,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnTranspose,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
transpose(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnTranspose,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class OutputSymmetry,class G1,class T1,class E1>
inline typename MakeFieldReturn<UnaryNode<FnSymmetrize<OutputSymmetry>,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> >::Expression_t
symmetrize(const Field<G1,T1,E1> & l)
{
  typedef UnaryNode<FnSymmetrize<OutputSymmetry>,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
polar(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
min(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMax,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
max(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LT(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LE(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GT(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GE(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
NE(const Field<G1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
polar(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
polar(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProduct(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dotdot(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
min(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnMin,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
min(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMax,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
max(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<FnMax,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
max(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LT(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LT(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LE(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LE(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GT(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GT(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GE(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GE(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
EQ(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
NE(const Field<G1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,class T2>
inline typename MakeFieldReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
NE(const Field<G1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
polar(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPolar,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
polar(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMin,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
min(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnMax,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
max(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LT(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LT(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LE(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpLE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
LE(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GT(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GT(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GE(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpGE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
GE(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
NE(const Array<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class T1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
NE(const T1 & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<class G, class T, class E> class Field;
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const Vector<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Vector<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Vector<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const Tensor<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Tensor<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<Tensor<D2,T2,E2> >::make(r)));
}
template<class G1,class T1,class E1,int DR2,int DC2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
  typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Field<G1,T1,E1> & l,const TinyMatrix<DR2,DC2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Field<G1,T1,E1> >::Leaf_t,
    typename CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<G1,T1,E1> >::make(l),
    CreateLeaf<TinyMatrix<DR2,DC2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpAdd,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator+(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator-(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator*(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpDivide,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator/(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpMod,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator%(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator&(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator|(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator^(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnDot,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
dot(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
ldexp(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnPow,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
pow(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnFmod,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
fmod(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
atan2(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpEQ,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator==(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Vector<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Vector<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Vector<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int D1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const Tensor<D1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<Tensor<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Tensor<D1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
template<int DR1,int DC1,class T1,class E1,class G2,class T2,class E2>
inline typename MakeFieldReturn<BinaryNode<OpNE,
  typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> >::Expression_t
operator!=(const TinyMatrix<DR1,DC1,T1,E1> & l,const Field<G2,T2,E2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<G2,T2,E2> >::Leaf_t> Tree_t;
  return MakeFieldReturn<Tree_t>::make(Tree_t(
    CreateLeaf<TinyMatrix<DR1,DC1,T1,E1> >::make(l),
    CreateLeaf<Field<G2,T2,E2> >::make(r)));
}
struct FarLeftTag;
template<class G, class T, class E> class Field;
template<class GeometryTag, class T, class Expr>
struct CreateLeaf<Field<GeometryTag, T, ExpressionTag<Expr> > >
{
  typedef Field<GeometryTag, T, ExpressionTag<Expr> > Input_t;
  typedef Expr Leaf_t;
  typedef const Leaf_t &Return_t;
  inline static
  Return_t make(const Input_t &f)
    {
      return f.engine().expression();
    }
};
template<class GeometryTag, class T, class EngineTag>
struct CreateLeaf<Field<GeometryTag, T, EngineTag> >
{
  typedef Field<GeometryTag, T, EngineTag> Input_t;
  typedef Reference<Input_t> Leaf_t;
  typedef Leaf_t Return_t;
  inline static
  Return_t make(const Input_t &f)
    {
      return Leaf_t(f);
    }
};
template<class GeometryTag, class T, class EngineTag>
struct CreateLeaf<Scalar<Field<GeometryTag, T, EngineTag> > >
{
  typedef Scalar<Field<GeometryTag, T, EngineTag> > Input_t;
  typedef Scalar<ErrorType> Leaf_t;
  typedef Leaf_t Return_t;
  inline static
  Return_t make(const Input_t &)
    {
      return ErrorType();
    }
};
template <int Dim>
class Centering;
template <int Dim>
class CanonicalCentering;
enum CenteringType {
 VertexType,
 EdgeType,
 FaceType,
 CellType
};
enum ContinuityType {
 Continuous = 0,
 Discontinuous
};
enum {
 XDim = 1,
 YDim = XDim << 1,
 ZDim = YDim << 1,
 AllDim = XDim | YDim | ZDim
};
template <int Dim>
class Centering
{
public:
  typedef Loc<Dim> Orientation;
  typedef Vector<Dim> Position;
  typedef std::vector<Orientation> Orientations;
  typedef std::vector<Position> Positions;
  Centering(CenteringType cent = CellType, ContinuityType cont = Continuous)
    : centering_type_m(cent), discontinuous_m(cont),
      orientations_m(0), positions_m(0)
    { }
  Centering(CenteringType cent, ContinuityType cont,
     const Orientations &orientations, const Positions &positions)
    : centering_type_m(cent), discontinuous_m(cont),
      orientations_m(orientations), positions_m(positions)
  {
      return;
  }
  Centering(const Centering<Dim>& model, int c)
    : centering_type_m(model.centering_type_m),
      discontinuous_m(model.discontinuous_m),
      orientations_m(1, model.orientations_m[c]),
      positions_m(1, model.positions_m[c])
    { }
  Centering<Dim> operator[](int iSubField) const
  {
    return Centering<Dim>(*this, iSubField);
  }
  ~Centering() { }
  inline CenteringType centeringType() const
    {
      return centering_type_m;
    }
  inline ContinuityType continuityType() const
    {
      return discontinuous_m;
    }
  inline bool discontinuous() const
  {
    return discontinuous_m == Discontinuous;
  }
  inline bool continuous() const
  {
    return discontinuous_m == Continuous;
  }
  inline const Orientations &orientations() const
  {
    return orientations_m;
  }
  inline const Positions &positions() const
  {
    return positions_m;
  }
  inline const Orientation &orientation(int i) const
  {
    return orientations_m[i];
  }
  inline const Position &position(int i) const
  {
    return positions_m[i];
  }
  inline int size() const
  {
    return orientations_m.size();
  }
  inline void
  addValue(const Orientation &orientation,
    const Position &position)
    {
      orientations_m.push_back(orientation);
      positions_m.push_back(position);
      return;
    }
private:
  CenteringType centering_type_m;
  ContinuityType discontinuous_m;
  Orientations orientations_m;
  Positions positions_m;
};
template <int Dim>
class CanonicalCentering {
public:
  CanonicalCentering();
  ~CanonicalCentering () {
    if (--class_count_m == 0) {
      for (int i = 0; i <= CellType; ++i) {
 for (int j = 0; j < 2; ++j)
   delete [] centering_table_m[i][j];
 delete [] centering_table_m[i];
      }
      delete [] centering_table_m;
    }
  }
  inline Centering<Dim> operator()
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     int dimension = 0) const
  {
    if (dimension == 0)
      dimension = AllDim;
    dimension %= (1<<Dim);
    return centering_table_m[type][discontinuous][dimension];
  }
private:
  inline static void addValue(typename Centering<Dim>::Orientations &os,
         typename Centering<Dim>::Positions &pos,
         const typename Centering<Dim>::Orientation &o,
         const typename Centering<Dim>::Position &p)
  {
    os.push_back(o);
    pos.push_back(p);
    return;
  }
  template <class T>
  inline static
  T combine(const T &op1, const T &op2)
  {
    T answer(op1);
    answer.insert(answer.end(), op2.begin(), op2.end());
    return answer;
  }
  static int class_count_m;
  static Centering<Dim>*** centering_table_m;
};
template <int Dim>
std::ostream &operator<<(std::ostream &o,
                         const Centering<Dim> &centering)
{
  switch (centering.centeringType())
  {
  case VertexType:
    o << "Vertex";
    break;
  case EdgeType:
    o << "Edge";
    break;
  case FaceType:
    o << "Face";
    break;
  case CellType:
    o << "Cell";
    break;
  }
  o << "," << (centering.continuous() ? "Continuous" : "Discontinuous")
    << ",{";
  for (int i = 0; i < centering.size();)
  {
    o << "[" << centering.orientation(i)
      << "," << centering.position(i) << "]";
    ++i;
    if (i < centering.size())
      o << ",";
  }
  o << "}";
  return o;
}
template <int Dim>
bool operator==(const Centering<Dim> &centering1, const Centering<Dim> &centering2)
{
  return
    centering1.centeringType() == centering2.centeringType() &&
    centering1.discontinuous() == centering2.discontinuous() &&
    centering1.orientations() == centering2.orientations() &&
    centering1.positions() == centering2.positions();
}
template <int Dim>
bool operator!=(const Centering<Dim> &centering1, const Centering<Dim> &centering2)
{
  return !(centering1 == centering2);
}
template <int Dim>
int CanonicalCentering<Dim>::class_count_m = 0;
template <int Dim>
Centering<Dim>*** CanonicalCentering<Dim>::centering_table_m = 0;
extern const CanonicalCentering<1> canonicalCenteringOne_g;
extern const CanonicalCentering<2> canonicalCenteringTwo_g;
extern const CanonicalCentering<3> canonicalCenteringThree_g;
template <int Dim>
const Centering<Dim> canonicalCentering
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension = 0);
template <>
const Centering<1> canonicalCentering<1>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension);
template <>
const Centering<2> canonicalCentering<2>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension);
template <>
const Centering<3> canonicalCentering<3>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension);
template<int Dim>
inline Interval<Dim>
cellDomainToCenteringDomain(const Interval<Dim> &cellDom,
                            const Centering<Dim> &centering, int i)
{
  if (centering.discontinuous())
  {
    return cellDom;
  }
  else
  {
    return shrinkRight(growRight(cellDom, 1), centering.orientation(i));
  }
}
template<int Dim>
inline Interval<Dim>
centeringDomainToCellDomain(const Interval<Dim> &cDom,
                            const Centering<Dim> &centering, int i)
{
  if (centering.discontinuous())
  {
    return cDom;
  }
  else
  {
    return shrinkRight(growRight(cDom, centering.orientation(i)), 1);
  }
}
template <int Dim>
class FieldOffset;
template <int Dim>
class FieldOffsetList;
template <int Dim>
class FieldOffset {
public:
  FieldOffset(const Loc<Dim> &loc, const int subFieldNumber = 0)
    : cell_offset_m(loc), subfield_number_m(subFieldNumber)
  {
    return;
  }
  FieldOffset()
    : cell_offset_m(Loc<Dim>()), subfield_number_m(0)
  {}
  inline void setSubFieldNumber(int subFieldNumber)
    {
      subfield_number_m = subFieldNumber;
      return;
    }
  inline Loc<Dim> &modifyCellOffset()
    {
      return cell_offset_m;
    }
  inline const Loc<Dim> &cellOffset() const
    {
      return cell_offset_m;
    }
  inline int subFieldNumber() const
    {
      return subfield_number_m;
    }
private:
  Loc<Dim> cell_offset_m;
  int subfield_number_m;
};
template <int Dim>
std::ostream &operator<<(std::ostream &o,
    const FieldOffset<Dim> &fieldOffset)
{
  return o << "FieldOffset: (" << fieldOffset.cellOffset()
    << ", " << fieldOffset.subFieldNumber() << ")";
}
template <int Dim>
inline bool
operator==(const FieldOffset<Dim> &fieldOffset1,
    const FieldOffset<Dim> &fieldOffset2)
{
  return
    fieldOffset1.cellOffset() == fieldOffset2.cellOffset() &&
    fieldOffset1.subFieldNumber() == fieldOffset2.subFieldNumber();
}
template <int Dim>
inline bool
operator!=(const FieldOffset<Dim> &fieldOffset1,
    const FieldOffset<Dim> &fieldOffset2)
{
  return !(fieldOffset1 == fieldOffset2);
}
template <int Dim>
class FieldOffsetList
{
public:
  typedef size_t size_type;
  typedef FieldOffset<Dim>& reference;
  typedef const FieldOffset<Dim>& const_reference;
  size_type size() const
  {
    return v_m.size();
  }
  const_reference operator[](const size_type n) const
  {
    return v_m[n];
  }
  FieldOffsetList() {}
  FieldOffsetList(const size_type sz)
  {
    v_m.reserve(sz);
  }
  FieldOffsetList(const std::vector<FieldOffset<Dim> > &v) {
    v_m.resize(v.size());
    std::copy(v.begin(), v.end(), v_m.begin());
  }
  FieldOffsetList &operator=(const std::vector<FieldOffset<Dim> > &v)
  {
    v_m.resize(v.size());
    std::copy(v.begin(), v.end(), v_m.begin());
    return *this;
  }
  reference operator[](const size_type n)
  {
    return v_m[n];
  }
private:
  std::vector<FieldOffset<Dim> > v_m;
};
template <int Dim>
std::ostream &operator<<(std::ostream &o,
    const FieldOffsetList<Dim> &fieldOffsetList)
{
  o << "FieldOffsetList:\n";
  for (int index = 0; index < fieldOffsetList.size(); ++index)
    o << fieldOffsetList[index] << std::endl;
  return o;
}
template<class GeometryTag, class T, class Expr, int Dim,
         class BinaryFunction>
inline
T
accumulate(BinaryFunction binary_op,
    const Field<GeometryTag, T, Expr>& field,
    const FieldOffsetList<Dim> &lst,
    const Loc<Dim> &loc)
{
  typedef typename Field<GeometryTag, T, Expr>::T_t T_t;
  typedef typename FieldOffsetList<Dim>::size_type size_type;
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  const size_type lstLength = lst.size();
  if (__builtin_expect(!!(lstLength > 0), true)) {} else Pooma::toss_cookies("accumulate must be given a nonempty list.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/FieldOffset.h", 334);
  T_t init = field(lst[0], loc);
  for (size_type i = 1; i < lstLength ; ++i)
    init = binary_op(init, field(lst[i], loc));
  return init;
}
template<class GeometryTag, class T, class Expr, int Dim>
inline
T
sum(const Field<GeometryTag, T, Expr>& field,
    const FieldOffsetList<Dim> &lst,
    const Loc<Dim> &loc)
{
  typedef typename Field<GeometryTag, T, Expr>::T_t T_t;
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  return accumulate(std::plus<T_t>(), field, lst, loc);
}
template<class GeometryTag, class T, class Expr, int Dim>
inline
T
av(const Field<GeometryTag, T, Expr>& field,
   const FieldOffsetList<Dim> &lst,
   const Loc<Dim> &loc)
{
  typedef typename Field<GeometryTag, T, Expr>::T_t T_t;
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  return sum(field, lst, loc) / lst.size();
}
template <class T>
struct fomin : public std::binary_function<T, T, T>
{
  T operator()(const T &op1, const T &op2) const {
    return std::min(op1, op2);
  }
};
template<class GeometryTag, class T, class Expr, int Dim>
inline
T
min(const Field<GeometryTag, T, Expr>& field,
    const FieldOffsetList<Dim> &lst,
    const Loc<Dim> &loc)
{
  typedef typename Field<GeometryTag, T, Expr>::T_t T_t;
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  return accumulate(fomin<T_t>(), field, lst, loc);
}
template <class T>
struct fomax : public std::binary_function<T, T, T>
{
  T operator()(const T &op1, const T &op2) const {
    return std::max(op1, op2);
  }
};
template<class GeometryTag, class T, class Expr, int Dim>
inline
T
max(const Field<GeometryTag, T, Expr>& field,
    const FieldOffsetList<Dim> &lst,
    const Loc<Dim> &loc)
{
  typedef typename Field<GeometryTag, T, Expr>::T_t T_t;
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  return accumulate(fomax<T_t>(), field, lst, loc);
}
template <class GeometryTag, class T, class Expr, int Dim>
inline
typename
View2<Field<GeometryTag, T, Expr>, std::vector<FieldOffset<Dim> >,
      Centering<Dim> >::Type_t
replicate(const Field<GeometryTag, T, Expr>& field,
          const std::vector<FieldOffsetList<Dim> > &vec,
          const Centering<Dim> &centering)
{
  PoomaCTAssert<((Field<GeometryTag, T, Expr>::dimensions == Dim))>::test();
  typedef typename std::vector<FieldOffsetList<Dim> >::size_type vsize_type;
  if (__builtin_expect(!!(vec.size() > 0), true)) {} else Pooma::toss_cookies("Cannot replicate no values.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/FieldOffset.h", 445);
  if (__builtin_expect(!!(vec.size() == centering.size()), true)) {} else Pooma::toss_cookies("Vector and output centering sizes must match.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/FieldOffset.h", 447);
  std::vector<FieldOffset<Dim> > vecFO(vec.size());
  for (vsize_type i = 0; i < vec.size(); ++i) {
    if (__builtin_expect(!!(vec[i].size() == 1), true)) {} else Pooma::toss_cookies("Can replicate only one value.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/FieldOffset.h", 451);
    vecFO[i] = vec[i][0];
  }
  return field(vecFO, centering);
}
# 1 "/usr/include/c++/6/numeric" 1 3
# 58 "/usr/include/c++/6/numeric" 3
       
# 59 "/usr/include/c++/6/numeric" 3



# 1 "/usr/include/c++/6/bits/stl_numeric.h" 1 3
# 65 "/usr/include/c++/6/bits/stl_numeric.h" 3

# 65 "/usr/include/c++/6/bits/stl_numeric.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {

     

     

      ;

      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {

     
      ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
# 144 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {

     
      ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
# 172 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
# 203 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
# 235 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
# 275 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
# 315 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
# 357 "/usr/include/c++/6/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }


}
# 63 "/usr/include/c++/6/numeric" 2 3
# 44111 "tramp3d-v4.cpp" 2

# 44111 "tramp3d-v4.cpp"
template <int Dim, bool IntraCellOnly = false>
class NearestNeighborClass {
public:
  typedef FieldOffset<Dim> FieldOffset_t;
  typedef FieldOffsetList<Dim> FieldOffsetList_t;
  typedef std::vector<FieldOffset_t> FieldOffset_vt;
  typedef std::vector<FieldOffsetList_t> Answer_t;
  typedef Centering<Dim> Center;
  typedef typename Center::Positions Positions;
  typedef typename Center::Position Position;
  typedef std::pair<int, Position> MinimumPair;
  typedef std::vector<MinimumPair> MinimumSet;
  NearestNeighborClass() {}
  inline Answer_t
  operator()(const Center &inputCentering, const Center &outputCentering)
  {
    if (__builtin_expect(!!(inputCentering.size() > 0), true)) {} else Pooma::toss_cookies("The input centering must be non-empty.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 95);
    Answer_t answer;
    answer.resize(outputCentering.size());
    const Positions inputPositions = inputCentering.positions();
    const Positions outputPositions = outputCentering.positions();
    for (typename Answer_t::size_type outputIndex = 0;
  outputIndex < outputCentering.size();
  ++outputIndex)
      answer[outputIndex] = nearestNeighbors(inputPositions,
          outputPositions[outputIndex]);
    return answer;
  }
  inline FieldOffsetList_t
  operator()(const Center &inputCentering,
      const FieldOffset_t &fieldOffset,
      const Center &outputCentering)
  {
    if (__builtin_expect(!!(inputCentering.size() > 0), true)) {} else Pooma::toss_cookies("The input centering must be non-empty.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 122);
    if (__builtin_expect(!!(fieldOffset.subFieldNumber() < outputCentering.size()), true)) {} else Pooma::toss_cookies("The field offset must correspond to the output centering.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 124);
    return nearestNeighbors(inputCentering.positions(),
       outputCentering.position(fieldOffset.subFieldNumber()));
  }
  inline std::vector<FieldOffsetList_t>
  operator()(const Center &inputCentering,
      const FieldOffsetList_t &fieldOffsetList,
      const Center &outputCentering)
  {
    if (__builtin_expect(!!(inputCentering.size() > 0), true)) {} else Pooma::toss_cookies("The input centering must be non-empty.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 140);
    Answer_t answer;
    answer.resize(fieldOffsetList.size());
    const Positions inputPositions = inputCentering.positions();
    for (typename FieldOffsetList_t::size_type folIndex = 0;
  folIndex < outputCentering.size();
  ++folIndex) {
      if (__builtin_expect(!!(fieldOffsetList[folIndex].subFieldNumber() < outputCentering.size()), true)) {} else Pooma::toss_cookies("The field offset must correspond to the output centering.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 152);
      answer[folIndex] =
 nearestNeighbors(inputPositions,
    outputCentering.position(fieldOffsetList[folIndex].subFieldNumber()));
    }
    return answer;
  }
private:
  inline FieldOffsetList_t
  nearestNeighbors(const Positions &inputPositions,
     const Position outputValue)
  {
    MinimumSet minimumSet;
    typename Positions::size_type inputIndex = 0;
    Position positionDifference = inputPositions[inputIndex] - outputValue;
    double minimumDistance =
      (IntraCellOnly ?
       manhattanDistance<Manhattan>(positionDifference) :
       manhattanDistance<ManhattanGrid>(positionDifference));
    minimumSet.push_back(std::make_pair(inputIndex, positionDifference));
    for (++inputIndex;
  inputIndex < inputPositions.size();
  ++inputIndex) {
      positionDifference = inputPositions[inputIndex] - outputValue;
      const double distance =
 (IntraCellOnly ?
  manhattanDistance<Manhattan>(positionDifference) :
  manhattanDistance<ManhattanGrid>(positionDifference));
      if (distance < minimumDistance + epsilon) {
 if (distance < minimumDistance) {
   minimumSet.clear();
   minimumDistance = distance;
 }
 minimumSet.push_back(std::make_pair(inputIndex,
         positionDifference));
      }
    }
    FieldOffset_vt answerHolder;
    if (IntraCellOnly) {
      for (typename MinimumSet::size_type minIndex = 0;
    minIndex < minimumSet.size();
    ++minIndex)
 answerHolder.push_back(FieldOffset_t(Loc<Dim>(0),
          minimumSet[minIndex].first));
    }
    else {
      FieldOffset_vt partialAnswer;
      for (typename MinimumSet::size_type minIndex = 0;
    minIndex < minimumSet.size();
    ++minIndex)
 {
   partialAnswer = computeCellOffsets(minimumSet[minIndex].first,
          minimumSet[minIndex].second);
   answerHolder.insert(answerHolder.end(),
         partialAnswer.begin(), partialAnswer.end());
 }
      std::sort(answerHolder.begin(), answerHolder.end(),
  CompareFieldOffset());
      answerHolder.erase(std::unique(answerHolder.begin(),
         answerHolder.end(),
         EqualFieldOffset()),
    answerHolder.end());
    }
    return answerHolder;
  }
  struct ManhattanGrid : public std::binary_function<double, double, double>
  {
    double operator()(const double totalSoFar, double coordinate) const {
      const double absCoordinate = std::abs(coordinate);
      return totalSoFar + std::min(absCoordinate, 1-absCoordinate);
    }
  };
  struct Manhattan : public std::binary_function<double, double, double>
  {
    double operator()(const double totalSoFar, double coordinate) const {
      return totalSoFar + std::abs(coordinate);
    }
  };
  template <class Distance>
  inline static
  double manhattanDistance(const Position &difference)
  {
    double answer = 0.0;;
    for (int coordinate = Dim-1; coordinate >= 0; --coordinate)
      answer = Distance()(answer, difference(coordinate));
    return answer;
  }
  inline static const FieldOffset_vt
  computeCellOffsets(const int inputValueIndex, const Position &difference)
  {
    FieldOffset_vt answer(1);
    int numTuples = 1;
    int cellOffsetCoordinates[2];
    int numOffsets;
    for (int dimension = 0; dimension < Dim; ++dimension) {
      numOffsets =
 convertDifferenceToCellOffsets(difference(dimension),
           cellOffsetCoordinates);
      if (__builtin_expect(!!(numOffsets >= 1 && numOffsets <= 2), true)) {} else Pooma::toss_cookies("Incorrect number of cell offsets", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 309);
      if (numOffsets == 2)
 answer.insert(answer.end(), answer.begin(), answer.end());
      for (int coc = 0; coc < numOffsets; ++coc)
 for (int tuple = 0; tuple < numTuples; ++tuple)
   answer[numTuples * coc + tuple].modifyCellOffset()[dimension] =
     cellOffsetCoordinates[coc];
      numTuples *= numOffsets;
    }
    for (int i = numTuples-1; i >= 0; --i)
      answer[i].setSubFieldNumber(inputValueIndex);
    return answer;
  }
  inline static
  int convertDifferenceToCellOffsets(const double difference,
         int cellOffsetCoordinate[])
  {
    if (difference < -0.5 - epsilon) {
      cellOffsetCoordinate[0] = +1;
      return 1;
    }
    else if (std::abs(difference + 0.5) < epsilon) {
      cellOffsetCoordinate[0] = +1;
      cellOffsetCoordinate[1] = 0;
      return 2;
    }
    else if (difference <= 0.5 - epsilon) {
      cellOffsetCoordinate[0] = 0;
      return 1;
    }
    else if (std::abs(difference - 0.5) < epsilon) {
      cellOffsetCoordinate[0] = 0;
      cellOffsetCoordinate[1] = -1;
      return 2;
    }
    else if (difference < 1.0 + epsilon) {
      cellOffsetCoordinate[0] = -1;
      return 1;
    }
    else {
      if (__builtin_expect(!!(0), true)) {} else Pooma::toss_cookies("Out of range difference", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/NearestNeighbors.h", 361);
      return 0;
    }
  }
  struct CompareFieldOffset :
    public std::binary_function<FieldOffset_t, FieldOffset_t, bool> {
    bool operator()(const FieldOffset_t &op1, const FieldOffset_t &op2) {
      return (op1.cellOffset() < op2.cellOffset()) ||
 (op1.cellOffset() == op2.cellOffset() &&
  op1.subFieldNumber() < op2.subFieldNumber());
    }
  };
  struct EqualFieldOffset :
    public std::binary_function<FieldOffset_t, FieldOffset_t, bool> {
    bool operator()(const FieldOffset_t &op1, const FieldOffset_t &op2) {
      return op1.cellOffset() == op2.cellOffset() &&
 op1.subFieldNumber() == op2.subFieldNumber();
    }
  };
  static const double epsilon;
};
template <int Dim, bool IntraCellOnly>
const double
NearestNeighborClass<Dim, IntraCellOnly>::epsilon = 1.0e-08;
template <int Dim>
inline
std::vector<FieldOffsetList<Dim> >
nearestNeighbors(const Centering<Dim> &inputCentering,
   const Centering<Dim> &outputCentering)
{
  return NearestNeighborClass<Dim>()(inputCentering, outputCentering);
}
template <int Dim>
inline
std::vector<FieldOffsetList<Dim> >
nearestNeighbors(const Centering<Dim> &inputCentering,
   const Centering<Dim> &outputCentering,
   const bool)
{
  return NearestNeighborClass<Dim, true>()(inputCentering, outputCentering);
}
template <int Dim>
inline
std::vector<FieldOffsetList<Dim> >
nearestNeighbors(const Centering<Dim> &inputCentering,
   const FieldOffsetList<Dim> &fOL,
   const Centering<Dim> &outputCentering)
{
  return NearestNeighborClass<Dim>()(inputCentering, fOL, outputCentering);
}
template <int Dim>
inline
std::vector<FieldOffsetList<Dim> >
nearestNeighbors(const Centering<Dim> &inputCentering,
   const FieldOffsetList<Dim> &fOL,
   const Centering<Dim> &outputCentering,
   const bool)
{
  return NearestNeighborClass<Dim, true>()
    (inputCentering, fOL, outputCentering);
}
template <int Dim>
inline
FieldOffsetList<Dim>
nearestNeighbors(const Centering<Dim> &inputCentering,
   const FieldOffset<Dim> &fieldOffset,
   const Centering<Dim> &outputCentering)
{
  return NearestNeighborClass<Dim>()
    (inputCentering, fieldOffset, outputCentering);
}
template <int Dim>
inline
FieldOffsetList<Dim>
nearestNeighbors(const Centering<Dim> &inputCentering,
   const FieldOffset<Dim> &fieldOffset,
   const Centering<Dim> &outputCentering,
   const bool)
{
  return NearestNeighborClass<Dim, true>()
    (inputCentering, fieldOffset, outputCentering);
}
template<int Dim>
inline Vector<Dim, double>
inputPosition(const Centering<Dim> &inputCentering,
              const FieldOffset<Dim> &fieldOffset)
{
  Vector<Dim, double> ret =
    inputCentering.position(fieldOffset.subFieldNumber());
  for (int i = 0; i < Dim; ++i)
    ret(i) += fieldOffset.cellOffset()[i].first();
  return ret;
}
class PrintField;
template<int Dim>
struct PerformPrintField
{
  template <class S, class A>
  static void print(const PrintField &, S &, const A &);
};
template<>
struct PerformPrintField<1>
{
  template<class S, class A>
  static void print(const PrintField &, S &, const A &);
};
class PrintField
{
public:
  PrintField(int domainWidth = 3, int dataWidth = 10,
      int dataPrecision = 4, int carReturn = -1,
      bool scientific = false, int spacing = 1)
    : domainwidth_m(domainWidth), datawidth_m(dataWidth),
      dataprecision_m(dataPrecision), carreturn_m(carReturn),
      spacing_m(spacing), scientific_m(scientific)
    {
      ;
      ;
      ;
      ;
    }
  PrintField(const PrintField &a)
    : domainwidth_m(a.domainwidth_m), datawidth_m(a.datawidth_m),
      dataprecision_m(a.dataprecision_m), carreturn_m(a.carreturn_m),
      scientific_m(a.scientific_m)
    {
    }
  ~PrintField()
    {
    }
  template<class S, class A>
  void print(S &s, const A &a) const
    {
      forEach(a, PerformUpdateTag(), NullCombine());
      Pooma::blockAndEvaluate();
      for (int m = 0; m < a.numMaterials(); m++)
        for (int c = 0; c < a.centeringSize(); c++)
          {
            s << "Material #" << m << ", Centering #" << c << " " << a.centering(c)
              << "\n"<< "-------------\n";
            PerformPrintField<A::dimensions>::print(*this, s, a.subField(m, c));
          }
    }
  int domainWidth() const
    {
      return domainwidth_m;
    }
  void setDomainWidth(int val)
    {
      domainwidth_m = val;
      ;
    }
  int dataWidth() const
    {
      return datawidth_m;
    }
  void setDataWidth(int val)
    {
      datawidth_m = val;
      ;
    }
  int dataPrecision() const
    {
      return dataprecision_m;
    }
  void setDataPrecision(int val)
    {
      dataprecision_m = val;
      ;
    }
  int carReturn() const
    {
      return carreturn_m;
    }
  void setCarReturn(int val)
    {
      carreturn_m = val;
    }
  bool scientific() const
    {
      return scientific_m;
    }
  void setScientific(bool val)
    {
      scientific_m = val;
    }
  int spacing() const
    {
      return spacing_m;
    }
  void setSpacing(int val)
    {
      spacing_m = val;
      ;
    }
private:
  int domainwidth_m;
  int datawidth_m;
  int dataprecision_m;
  int carreturn_m;
  int spacing_m;
  bool scientific_m;
};
template<class S, class A>
void
PerformPrintField<1>::print(const PrintField &p, S &s, const A &a)
{
  PoomaCTAssert<(A::dimensions == 1)>::test();
  typedef typename A::Domain_t Domain_t;
  typedef typename Domain_t::const_iterator Iterator_t;
  Iterator_t griditer = a.domain().begin();
  Iterator_t enditer = a.domain().end();
  s << "[";
  if (a.domain()[0].first() < 0)
    s.fill(' ');
  else
    s.fill('0');
  s.width(p.domainWidth());
  s << a.domain()[0].first() << ":";
  if (a.domain()[0].last() < 0)
    s.fill(' ');
  else
    s.fill('0');
  s.width(p.domainWidth());
  s << a.domain()[0].last() << "] = ";
  s.fill(' ');
  int i, printed = 0;
  while (griditer != enditer)
    {
      int spacing = 0;
      if (printed > 0)
     {
       spacing = p.spacing();
       if (p.carReturn() >= 0 && printed >= p.carReturn())
            {
              s << "\n";
           spacing = 2*p.domainWidth() + 6;
           printed = 0;
         }
     }
      for (i=0; i < spacing; ++i)
        s << " ";
      if (p.scientific())
        s.setf(std::ios::scientific);
      s.precision(p.dataPrecision());
      s.width(p.dataWidth());
      s << a.read(*griditer);
      ++griditer;
      ++printed;
    }
  s << "\n";
}
template<int Dim>
template<class S, class A>
void
PerformPrintField<Dim>::print(const PrintField &p, S &s, const A &a)
{
  int i, j, k;
  PoomaCTAssert<(A::dimensions == Dim && Dim > 1)>::test();
  typedef typename A::Domain_t Domain_t;
  typedef typename Domain_t::Element_t Element_t;
  typedef typename Domain_t::const_iterator Iterator_t;
  Iterator_t griditer = a.domain().begin();
  Iterator_t enditer = a.domain().end();
  Element_t x0 = a.domain()[0].first();
  Element_t x1 = a.domain()[0].last();
  Element_t xs = a.domain()[0].stride();
  Element_t y0 = a.domain()[1].first();
  Element_t y1 = a.domain()[1].last();
  Element_t ys = a.domain()[1].stride();
  while (griditer != enditer)
    {
      if (Dim > 2)
     {
       s << '\n' << a.domain()[0] << a.domain()[1];
       for (i=2; i < Dim; ++i)
         s << "[" << (*griditer)[i].first() << "]";
       s << ":" << '\n';
       s << "----------------------------------------------------\n";
        }
      for (j=y0; j <= y1; j += ys)
     {
       s << "[";
          if (x0 < 0)
            s.fill(' ');
          else
            s.fill('0');
          s.width(p.domainWidth());
          s << x0 << ":";
          if (x1 < 0)
            s.fill(' ');
          else
            s.fill('0');
          s.width(p.domainWidth());
       s << x1 << "]";
       for (i=1; i < Dim; ++i)
         {
           s << "[";
              if ((*griditer)[i].first() < 0)
                s.fill(' ');
              else
                s.fill('0');
              s.width(p.domainWidth());
           s << (*griditer)[i].first() << "]";
         }
       s.fill(' ');
          s << " = ";
       int printed = 0;
       for (i=x0; i <= x1; i += xs)
         {
           int spacing = 0;
           if (printed > 0)
          {
            spacing = p.spacing();
            if (p.carReturn() >= 0 && printed >= p.carReturn())
              {
                s << '\n';
                spacing = (Dim + 1)*(p.domainWidth() + 2) + 4;
                printed = 0;
              }
          }
           for (k=0; k < spacing; ++k)
          s << ' ';
           if (p.scientific())
          s.setf(std::ios::scientific);
           s.precision(p.dataPrecision());
           s.width(p.dataWidth());
           s << a.read(*griditer);
           ++griditer;
           ++printed;
         }
       s << '\n';
        }
    }
}
template<int Dim>
struct FieldEnginePatch
{
  FieldEnginePatch(int patch, Interval<Dim> domain)
    : patch_m(patch), domain_m(domain)
  { }
  int patch_m;
  Interval<Dim> domain_m;
};
namespace Pooma {
  unsigned int activeRelationGroups();
  bool isRelationGroupActive(unsigned int groups);
  void activateRelationGroup(unsigned int group);
  void deactivateRelationGroup(unsigned int group);
  unsigned int newRelationGroup();
}
class RelationListItem {
public:
  RelationListItem()
  : priority_m(0),
    groups_m(Pooma::activeRelationGroups()),
    dirty_m(true)
    { }
  RelationListItem(const RelationListItem &model)
  : priority_m(model.priority_m),
    groups_m(model.groups_m),
    dirty_m(model.dirty_m)
    { }
  virtual ~RelationListItem() { }
  virtual void apply() = 0;
  virtual void notifyPreRead()
    {
      if (Pooma::isRelationGroupActive(groups_m) && dirty_m)
        {
          apply();
          clearDirty();
        }
    }
  virtual void notifyPostWrite()
    {
      setDirty();
    }
  inline bool dirty() const { return dirty_m; }
  inline unsigned int priority() const { return priority_m; }
  virtual void setDirty()
    {
      dirty_m = true;
    }
  virtual void clearDirty()
    {
      dirty_m = false;
    }
  inline void setPriority(unsigned int p)
    {
      priority_m = p;
    }
private:
  unsigned int priority_m;
  unsigned int groups_m;
  bool dirty_m;
};
namespace Pooma {
  struct DontCopyRelations { };
}
template<class Target>
class RelationRetargetBase : public RelationListItem {
public:
  RelationRetargetBase(const Target &target)
  : target_m(target, Pooma::DontCopyRelations())
    { }
  RelationRetargetBase(const RelationRetargetBase<Target> &model)
  : RelationListItem(model),
    target_m(model.target_m)
    { }
  virtual ~RelationRetargetBase() { }
  Target &target() { return target_m; }
  const Target &target() const { return target_m; }
  virtual RelationListItem *retarget(const Target &target) const = 0;
protected:
  Target target_m;
};
template<class Target, class Functor>
class RelationBase : public RelationRetargetBase<Target> {
public:
  RelationBase(const Target &t, const Functor &f)
  : RelationRetargetBase<Target>(t),
    functor_m(f, t)
    { }
  RelationBase(const RelationBase<Target, Functor> &model)
  : RelationRetargetBase<Target>(model),
    functor_m(model.functor_m)
    { }
  virtual ~RelationBase() { }
  Functor &functor() { return functor_m; }
  const Functor &functor() const { return functor_m; }
protected:
  Functor functor_m;
};
class RelationListData : public RefCounted
{
public:
  RelationListData()
    { }
  RelationListData(const RelationListData &model)
  : data_m(model.data_m)
    { }
  RelationListData &operator=(const RelationListData &rhs)
    {
      data_m = rhs.data_m;
      return *this;
    }
  ~RelationListData()
    {
      typedef List_t::size_type size_type;
      for (size_type i = 0; i < data_m.size(); i++)
        delete data_m[i];
    }
  inline int size() const
    {
      return data_m.size();
    }
  inline RelationListItem *elem(int i) const
    {
      return data_m[i];
    }
  inline RelationListItem* &elem(int i)
    {
      return data_m[i];
    }
  void add(RelationListItem *item)
    {
      data_m.push_back(item);
      int i = size() - 1;
      while (i > 0)
        {
          if (data_m[i]->priority() <= data_m[i]->priority())
            break;
          data_m[i] = data_m[i - 1];
          data_m[i - 1] = item;
          --i;
        }
    }
private:
  typedef std::vector<RelationListItem *> List_t;
  List_t data_m;
};
class RelationList {
public:
  RelationList()
  : list_m(new RelationListData)
    { }
  RelationList(const RelationList &model)
  : list_m(model.list_m)
    { }
  ~RelationList() { }
  template<class Target>
  void makeOwnCopy(const Target &t)
    {
      list_m = new RelationListData(*list_m);
      for (int i = 0; i < list_m->size(); i++)
        {
          RelationRetargetBase<Target> *u =
            dynamic_cast<RelationRetargetBase<Target> *>(list_m->elem(i));
          if (u != 
# 44797 "tramp3d-v4.cpp" 3 4
                  __null
# 44797 "tramp3d-v4.cpp"
                      )
            list_m->elem(i) = u->retarget(t);
        }
    }
  inline void erase()
    {
     list_m = new RelationListData;
    }
  void addRelation(RelationListItem *item)
    {
      list_m->add(item);
    }
  void notifyPreRead() const
    {
      for (int i = 0; i < list_m->size(); ++i)
        list_m->elem(i)->notifyPreRead();
    }
  void notifyPostWrite() const
    {
      for (int i = 0; i < list_m->size(); ++i)
        list_m->elem(i)->notifyPostWrite();
    }
  void setDirty() const
    {
      for (int i = 0; i < list_m->size(); ++i)
        list_m->elem(i)->setDirty();
    }
  void clearDirty() const
    {
      for (int i = 0; i < list_m->size(); ++i)
        list_m->elem(i)->clearDirty();
    }
  bool dirty() const
    {
      for (int i = 0; i < list_m->size(); ++i)
        if (list_m->elem(i)->dirty())
   return true;
      return false;
    }
  inline RelationListItem *operator()(int i) const
    {
      return list_m->elem(i);
    }
  inline RelationListItem *operator()(int i)
    {
      return list_m->elem(i);
    }
  inline int size() const { return list_m->size(); }
private:
  RefCountedPtr<RelationListData> list_m;
};
template<int Dim, class T, class EngineTag> class Engine;
template<class Components> class ComponentWrapper;
namespace Pooma {
  struct MaterialViewTag {};
  struct CenteringViewTag {};
}
template <int Dim, class T, class EngineTag>
class FieldEngineBaseData
{
public:
  FieldEngineBaseData()
    : engine_m()
  { }
  template<class Initializer>
  FieldEngineBaseData(const Initializer &init)
    : engine_m(init)
  { }
  FieldEngineBaseData(const Pooma::NoInit &)
    : engine_m()
  { }
  template<class Initializer>
  FieldEngineBaseData(const Initializer &init, const RelationList &l)
    : engine_m(init),
      relations_m(l)
  { }
  template<class Engine, class Domain>
  FieldEngineBaseData(const Engine &e,
                      const Domain &d, const RelationList &l)
    : engine_m(NewEngineEngine<Engine, Domain>::apply(e, d),
               NewEngineDomain<Engine, Domain>::apply(e, d)),
      relations_m(l)
  {
  }
  const Engine<Dim, T, EngineTag> &engine() const { return engine_m; }
  Engine<Dim, T, EngineTag> &engine() { return engine_m; }
  RelationList &relations() const { return relations_m; }
private:
  Engine<Dim, T, EngineTag> engine_m;
  mutable RelationList relations_m;
};
template<class Mesh, class T, class EngineTag>
class FieldEngine
{
public:
  enum { dimensions = Mesh::dimensions };
  enum { Dim = dimensions };
  typedef FieldEngine<Mesh, T, EngineTag> This_t;
  typedef FieldEngineBaseData<Dim, T, EngineTag> Data_t;
  typedef Engine<Dim, T, EngineTag> Engine_t;
  typedef typename Engine_t::Domain_t Domain_t;
  typedef typename Engine_t::Layout_t Layout_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  FieldEngine()
    : num_materials_m(0),
      physicalCellDomain_m(Pooma::NoInit()),
      guards_m(0)
  { }
  template<class Layout2>
  FieldEngine(const Centering<Dim> &centering, const Layout2 &layout,
              const Mesh &mesh, int materials = 1)
    : num_materials_m(materials),
      centering_m(centering),
      stride_m(centering.size()),
      physicalCellDomain_m(layout.domain()),
      guards_m(layout.externalGuards()),
      mesh_m(mesh)
  {
    physicalCellDomain_m = shrinkRight(shrink(physicalCellDomain_m, guards_m), 1);
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering.size(); ++ c)
      {
        data(m, c) = Data_t(layout);
      }
    }
  }
  FieldEngine(const This_t &model)
    : num_materials_m(model.num_materials_m),
      centering_m(model.centering_m),
      stride_m(model.stride_m),
      data_m(model.data_m),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guards_m),
      mesh_m(model.mesh_m)
  {
  }
  FieldEngine(const This_t &model, int subField)
    : num_materials_m(1),
      centering_m(model.centering_m, subField % model.centeringSize()),
      stride_m(model.stride_m),
      data_m(model.data_m + subField),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guards_m),
      mesh_m(model.mesh_m)
  {
  }
  FieldEngine(const This_t &model, int m, int c)
    : num_materials_m(1),
      centering_m(model.centering_m, c),
      stride_m(model.stride_m),
      data_m(model.data_m + model.stride_m * m + c),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guards_m),
      mesh_m(model.mesh_m)
  {
  }
  FieldEngine(const This_t &model, int c, const Pooma::CenteringViewTag&)
    : num_materials_m(model.num_materials_m),
      centering_m(model.centering_m, c),
      stride_m(model.stride_m),
      data_m(model.data_m + c),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guards_m),
      mesh_m(model.mesh_m)
  {
  }
  FieldEngine(const This_t &model, int m, const Pooma::MaterialViewTag&)
    : num_materials_m(1),
      centering_m(model.centering_m),
      stride_m(model.stride_m),
      data_m(model.data_m + m * model.stride_m),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guards_m),
      mesh_m(model.mesh_m)
  {
  }
  template<class T2, class EngineTag2>
  FieldEngine(const FieldEngine<Mesh, T2, EngineTag2> &model,
              const Domain_t &d)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      guards_m(0),
      mesh_m(model.mesh(), inputDomainToVertexDomain(d))
  {
    addSubFields();
    physicalCellDomain_m = d;
    if (centeringSize() == 1)
    {
      physicalCellDomain_m =
        centeringDomainToCellDomain(physicalCellDomain_m, centering_m, 0);
    }
    for (int c = 0; c < centeringSize(); ++c)
    {
      Domain_t dc(cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, c));
      for (int m = 0; m < numMaterials(); ++m)
      {
        data(m, c) = Data_t(model.data(m, c).engine(), dc, model.data(m, c).relations());
      }
    }
    physicalCellDomain_m -= d.firsts();
  }
  template<class Mesh2, class T2, class EngineTag2, class Domain>
  FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model,
              const Domain &d)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      guards_m(0)
  {
    addSubFields();
    ;
    for (int m = 0; m < numMaterials(); ++m)
    {
      data(m, 0) = Data_t(model.data(m, 0).engine(), d,
                          model.data(m, 0).relations());
    }
    mesh_m = Mesh(DomainLayout<Dim>(inputDomainToVertexDomain(data(0,0).engine().domain())));
    physicalCellDomain_m = mesh_m.physicalCellDomain();
  }
  template<class Mesh2, class EngineTag2>
  FieldEngine(const FieldEngine<Mesh2, T, EngineTag2> &model,
              const SliceInterval<Mesh2::dimensions, Dim> &d)
  {
    initSlice(model, d);
  }
  template<class Mesh2, class EngineTag2>
  FieldEngine(const FieldEngine<Mesh2, T, EngineTag2> &model,
              const SliceRange<Mesh2::dimensions, Dim> &d)
  {
    initSlice(model, d);
  }
  template<class Mesh2, class EngineTag2>
  FieldEngine(const FieldEngine<Mesh2, T, EngineTag2> &model,
       const SliceInterval<Dim, Mesh2::dimensions> &d,
       const Interval<Dim>& totalDomain)
  {
    initSlice(model, d, totalDomain);
  }
  template<class T2, class EngineTag2>
  FieldEngine(const FieldEngine<Mesh, T2, EngineTag2> &model,
              const INode<Dim> &i)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      guards_m(0),
      mesh_m(model.mesh(),
             inputDomainToVertexDomain(i.domain()))
  {
    addSubFields();
    physicalCellDomain_m = i.domain();
    if (centeringSize() == 1)
    {
      physicalCellDomain_m =
        centeringDomainToCellDomain(physicalCellDomain_m, centering_m, 0);
    }
    for (int c = 0; c < centeringSize(); ++ c)
    {
      INode<Dim> ic(i, cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, c));
      for (int m = 0; m < numMaterials(); ++m)
      {
        data(m, c) = Data_t(model.data(m, c).engine(), ic, model.data(m, c).relations());
      }
    }
    physicalCellDomain_m -= i.domain().firsts();
  }
  template<class Mesh2, class T2, class EngineTag2, class Tag>
  FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model,
              const EngineView<Tag> &ev)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      physicalCellDomain_m(model.physicalCellDomain()),
      guards_m(model.guardLayers()),
      mesh_m(model.mesh())
  {
    typedef typename FieldEngine<Mesh2, T2, EngineTag2>::Engine_t EngIn_t;
    typedef LeafFunctor<EngIn_t, EngineView<Tag> > Functor_t;
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centeringSize(); ++c)
      {
        data(m, c)
          = Data_t(Functor_t::apply(model.data(m, c).engine(), ev),
                   model.data(m, c).relations());
      }
    }
  }
  template<class EngineTag2>
  FieldEngine(const FieldEngine<Mesh, T, EngineTag2> &model,
              const FieldEnginePatch<Dim> &p)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      guards_m(model.guardLayers()),
      mesh_m(model.mesh())
  {
    ;
    addSubFields();
    data(0, 0) = Data_t(engineFunctor(model.engine(), EnginePatch(p.patch_m)));
    physicalCellDomain_m =
      centeringDomainToCellDomain(p.domain_m, centering_m, 0);
  }
  template<class Mesh2, class T2, class EngineTag2, class Components>
  FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model,
              const ComponentWrapper<Components> &cw)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      physicalCellDomain_m(model.physicalCellDomain()),
      guards_m(model.guardLayers()),
      mesh_m(model.mesh())
  {
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centeringSize(); ++ c)
      {
        data(m, c) =
          Data_t(Engine_t(model.data(m, c).engine(), cw.components()),
                 model.data(m, c).relations());
      }
    }
  }
  FieldEngine(const This_t &model,
              const Pooma::DontCopyRelations &d)
    : num_materials_m(model.numMaterials()),
      centering_m(model.centering()),
      stride_m(model.centeringSize()),
      physicalCellDomain_m(model.physicalCellDomain_m),
      guards_m(model.guardLayers()),
      mesh_m(model.mesh())
  {
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centeringSize(); ++ c)
      {
        data(m, c) = Data_t(model.data(m, c).engine());
      }
    }
  }
  void initialize(const This_t &model)
  {
    num_materials_m = model.num_materials_m;
    stride_m = model.stride_m;
    centering_m = model.centering_m;
    data_m = model.data_m;
    physicalCellDomain_m = model.physicalCellDomain_m;
    guards_m = model.guards_m;
    mesh_m = model.mesh_m;
  }
  void addSubFields()
  {
    ;
    int size = numMaterials() * centeringSize();
    data_m.reserve(size);
    data_m.resize(size);
  }
  int numSubFields() const
  {
    return numMaterials() * centeringSize();
  }
  Engine_t &engine()
  {
    ;
    return data_m->engine();
  }
  const Engine_t &engine() const
  {
    ;
    return data_m->engine();
  }
  Engine_t &engine(int m, int c)
  {
    ;
    return data(m,c).engine();
  }
  const Engine_t &engine(int m, int c) const
  {
    ;
    return data(m,c).engine();
  }
  RelationList &relations() const
  {
    ;
    return data_m->relations();
  }
  RelationList &relations(int m, int c) const
  {
    ;
    return data(m, c).relations();
  }
  const GuardLayers_t &guardLayers() const
  {
    return guards_m;
  }
  GuardLayers_t &guardLayers()
  {
    return guards_m;
  }
  int numMaterials() const
  {
    return num_materials_m;
  }
  Domain_t &physicalCellDomain()
  {
    return physicalCellDomain_m;
  }
  const Domain_t &physicalCellDomain() const
  {
    return physicalCellDomain_m;
  }
  Domain_t totalCellDomain() const
  {
    return grow(physicalCellDomain_m, guards_m);
  }
  Domain_t physicalDomain() const
  {
    if (centeringSize() == 1)
      return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, 0);
    else
      return physicalCellDomain_m;
  }
  Domain_t physicalDomain(int i) const
  {
    return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, i);
  }
  Domain_t totalDomain() const
  {
    if (centeringSize() == 1)
      return cellDomainToCenteringDomain(totalCellDomain(), centering_m, 0);
    else
      return totalCellDomain();
  }
  Domain_t totalDomain(int i) const
  {
    return cellDomainToCenteringDomain(totalCellDomain(), centering_m, i);
  }
  const Centering<Dim> &centering() const
  {
    return centering_m;
  }
  int centeringSize() const
  {
    return centering_m.size();
  }
  Mesh &mesh()
  {
    return mesh_m;
  }
  const Mesh &mesh() const
  {
    return mesh_m;
  }
  template<class Subject>
  void makeOwnCopy(const Subject &s)
  {
    ;
    RefCountedBlockPtr<Data_t> model = data_m;
    data_m = RefCountedBlockPtr<Data_t>();
    stride_m = centeringSize();
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centeringSize(); ++ c)
      {
        data(m, c) = model[m*stride_m + c];
        data(m, c).engine().makeOwnCopy();
        data(m, c).relations().makeOwnCopy(s.subField(m, c));
      }
    }
  }
  Domain_t
  inputDomainToVertexDomain(const Domain_t &d) const
  {
    if (centeringSize() == 1)
      return growRight(centeringDomainToCellDomain(d, centering(), 0), 1);
    else
      return growRight(d, 1);
  }
  inline Data_t &
  data(int material, int centering)
  {
    ;
    return data_m[material * stride_m + centering];
  }
  inline const Data_t &
  data(int material, int centering) const
  {
    ;
    return data_m[material * stride_m + centering];
  }
private:
  template <class FE, class Domain>
  void initSlice(const FE& model, const Domain& d)
  {
    ;
    num_materials_m = model.numMaterials();
    stride_m = 1;
    typename Centering<Dim>::Orientation orientation;
    typename Centering<Dim>::Position position;
    int j=0;
    for (int i=0; i<FE::dimensions; ++i)
      {
 if (d.ignorable(i))
   continue;
 orientation[j] = model.centering().orientation(0)[i];
 position(j) = model.centering().position(0)(i);
 guards_m.lower(j) = model.guardLayers().lower(i);
 guards_m.upper(j) = model.guardLayers().upper(i);
 physicalCellDomain_m[j] = model.physicalCellDomain()[i];
 ++j;
      }
    centering_m.addValue(orientation, position);
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      data(m, 0) = Data_t(model.data(m, 0).engine(), d,
                          model.data(m, 0).relations());
    }
    mesh_m = Mesh(DomainLayout<Dim>(growRight(physicalCellDomain(), 1),
        guardLayers()));
  }
  template <class FE>
  void initSlice(const FE& model,
   const SliceInterval<Dim, FE::dimensions>& d,
   const Interval<Dim>& totalDomain)
  {
    ;
    num_materials_m = model.numMaterials();
    stride_m = 1;
    typename Centering<Dim>::Orientation orientation;
    typename Centering<Dim>::Position position;
    int j=0;
    for (int i=0; i<Dim; ++i)
      {
 if (d.ignorable(i)) {
   if (model.centering().centeringType() == CellType) {
     orientation[i] = 1;
     position(i) = 0.5;
   } else {
     orientation[i] = 0;
     position(i) = 0.0;
   }
   guards_m.lower(i) = 0;
   guards_m.upper(i) = 0;
   physicalCellDomain_m[i] = totalDomain[i];
 } else {
   orientation[i] = model.centering().orientation(0)[j];
   position(i) = model.centering().position(0)(j);
   guards_m.lower(i) = model.guardLayers().lower(j);
   guards_m.upper(i) = model.guardLayers().upper(j);
   physicalCellDomain_m[i] = model.physicalCellDomain()[j];
   ++j;
 }
      }
    centering_m.addValue(orientation, position);
    addSubFields();
    for (int m = 0; m < numMaterials(); ++m)
    {
      typedef typename NewEngine<typename FE::Engine_t, SliceInterval<Dim, FE::dimensions> >::Type_t NewEngine_t;
      data(m, 0) = Data_t(NewEngine_t(model.data(m, 0).engine(), d, totalDomain),
                          model.data(m, 0).relations());
    }
    mesh_m = Mesh(DomainLayout<Dim>(growRight(physicalCellDomain(), 1),
        guardLayers()));
  }
  unsigned int num_materials_m;
  Centering<Dim> centering_m;
  int stride_m;
  RefCountedBlockPtr<Data_t> data_m;
  Domain_t physicalCellDomain_m;
  GuardLayers_t guards_m;
  Mesh mesh_m;
};
template<class Mesh, class T, class EngineTag, class Tag>
struct LeafFunctor<FieldEngine<Mesh, T, EngineTag>,
                   ExpressionApply<Tag> >
{
  typedef FieldEngine<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Subject_t &fieldEngineBase,
        const ExpressionApply<Tag> &tag)
  {
    for (int m = 0; m < fieldEngineBase.numMaterials(); ++m)
    {
      for (int c = 0; c < fieldEngineBase.centeringSize(); ++ c)
      {
        LeafFunctor_t::apply(fieldEngineBase.data(m, c).engine(), tag);
      }
    }
    return 0;
  }
};
struct CompressibleBrick;
template<class Mesh, class T, class EngineTag>
class Field;
template<class LTag, class EngineTag>
struct MultiPatch;
template<int Dim> struct NoMesh;
struct Brick;
template<class Subject> class SubFieldView;
template<class Subject, class Domain, bool SV>
struct View1Implementation;
template <class Subject, class Domain>
struct ReverseSliceView;
class RelationListItem;
template <int Dim>
class FieldOffset;
template <int Dim>
class FieldOffsetList;
template<class Mesh, class T, class EngineTag,
  class MeshTag2, class T2, class EngineTag2, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const Field<MeshTag2, T2, EngineTag2> &rhs,
       const Op &op);
template<class Mesh, class T, class EngineTag,
 int Dim2, class T2, class EngineTag2, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const Array<Dim2, T2, EngineTag2> &rhs, const Op &op);
template<class Mesh, class T, class EngineTag, class T1, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const T1 &rhs, const Op &op);
template<class Mesh, class T, class EngineTag,
 int Dim2, class T2, class EngineTag2, class Op>
const Array<Dim2, T2, EngineTag2> &
assign(const Array<Dim2, T2, EngineTag2> &lhs,
       const Field<Mesh, T, EngineTag> &rhs, const Op &op);
template<class Mesh, class T, class EngineTag,
 class F, class B, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const WhereProxy<F, B> &rhs,
       const Op &op);
struct SubFieldViewFunctorTag;
template<class Mesh, class T, class EngineTag>
class SubFieldView<Field<Mesh, T, EngineTag> > {
public:
  typedef Field<Mesh, T, EngineTag> Type_t;
  inline static Type_t make(const Type_t &s, int iSubField)
    {
      ;
      return Type_t(s, iSubField);
    }
  inline static Type_t make(const Type_t &s, int m, int c)
  {
    ;
    return Type_t(s, m, c);
  }
  inline static Type_t make(const Type_t &s, int c, const Pooma::CenteringViewTag &tag)
  {
    ;
    return Type_t(s, c, tag);
  }
  inline static Type_t make(const Type_t &s, int m, const Pooma::MaterialViewTag &tag)
  {
    ;
    return Type_t(s, m, tag);
  }
};
template<class Mesh, class T, class Expr>
class SubFieldView<Field<Mesh, T, ExpressionTag<Expr> > > {
public:
  typedef Field<Mesh, T, ExpressionTag<Expr> > Subject_t;
  typedef
    typename ForEach<Expr, SubFieldViewFunctorTag, TreeCombine>::Type_t
      Expr_t;
  typedef Field<Mesh, T, ExpressionTag<Expr_t> > Type_t;
  inline static Type_t make(const Subject_t &s, int iSubField)
    {
      ;
      return Type_t(s, iSubField);
    }
  inline static Type_t make(const Subject_t &s, int m, int c)
  {
    ;
    return Type_t(s, m, c);
  }
  inline static Type_t make(const Subject_t &s, int c, const Pooma::CenteringViewTag &tag)
  {
    ;
    return Type_t(s, c, tag);
  }
  inline static Type_t make(const Subject_t &s, int m, const Pooma::MaterialViewTag &tag)
  {
    ;
    return Type_t(s, m, tag);
  }
};
template<class Mesh, class T, class EngineTag, class Domain>
struct View1Implementation<Field<Mesh, T, EngineTag>, Domain, true>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  template<class S1, class Combine>
  inline static
  Type_t make(const Subject_t &f, const S1 &s1,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1));
      ;
      return f.engine()(s);
    }
  template<class S1, class S2, class Combine>
  inline static
  Type_t make(const Subject_t &f,
       const S1 &s1, const S2 &s2,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1, s2));
      ;
      return f.engine()(s);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  Type_t make(const Subject_t &f,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1, s2, s3));
      ;
      return f.engine()(s);
    }
  template<class S1, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &f, const S1 &s1,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1));
      ;
      return f.engine().read(s);
    }
  template<class S1, class S2, class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &f,
       const S1 &s1, const S2 &s2,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1, s2));
      ;
      return f.engine().read(s);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  ReadType_t makeRead(const Subject_t &f,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const Combine &)
    {
      ;
      Domain s(Combine::make(f, s1, s2, s3));
      ;
      return f.engine().read(s);
    }
};
template<int Dim, class Mesh, class Domain>
struct NewMeshTag
{
  typedef NoMesh<Dim> Type_t;
};
template<int Dim, class Mesh>
struct NewMeshTag<Dim, Mesh, Interval<Dim> >
{
  typedef Mesh Type_t;
};
template<int Dim, class Mesh>
struct NewMeshTag<Dim, Mesh, INode<Dim> >
{
  typedef Mesh Type_t;
};
template<class Mesh, class T, class EngineTag, class Domain>
struct View1Implementation<Field<Mesh, T, EngineTag>, Domain, false>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef typename NewEngine<Engine_t, Domain>::Type_t NewEngine_t;
  typedef typename NewEngine_t::Element_t NewT_t;
  typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  typedef typename
    NewMeshTag<NewEngine_t::dimensions, Mesh, Domain>::Type_t
      NewMeshTag_t;
  typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> ReadType_t;
  typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> Type_t;
  template<class S1, class Combine>
  static
  Type_t make(const Subject_t &f, const S1 &s1,
       const Combine &)
    {
      Domain s(Combine::make(f, s1));
      ;
      return Type_t(f, s);
    }
  template<class S1, class S2, class Combine>
  static
  Type_t make(const Subject_t &f, const S1 &s1,
       const S2 &s2, const Combine &)
    {
      Domain s(Combine::make(f, s1, s2));
      ;
      return Type_t(f, s);
    }
  template<class S1, class S2, class S3,
    class Combine>
  static
  Type_t make(const Subject_t &f,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const Combine &)
    {
      Domain s(Combine::make(f, s1, s2, s3));
      ;
      return Type_t(f, s);
    }
  template<class S1, class Combine>
  inline static
  Type_t makeRead(const Subject_t &f, const S1 &s1,
       const Combine &c)
    {
      return make(f, s1, c);
    }
  template<class S1, class S2, class Combine>
  inline static
  Type_t makeRead(const Subject_t &f, const S1 &s1,
       const S2 &s2, const Combine &c)
    {
      return make(f, s1, s2, c);
    }
  template<class S1, class S2, class S3,
    class Combine>
  inline static
  Type_t makeRead(const Subject_t &f,
       const S1 &s1, const S2 &s2, const S3 &s3,
       const Combine &c)
    {
      return make(f, s1, s2, s3, c);
    }
};
template<class Mesh, class T, class EngineTag, class Sub1>
struct View1<Field<Mesh, T, EngineTag>, Sub1>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef TemporaryNewDomain1<Domain_t, Sub1> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  typedef typename Dispatch_t::Type_t Type_t;
  inline static
  Type_t make(const Subject_t &f, const Sub1 &s1)
    {
      return Dispatch_t::make(f, s1, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, const Sub1 &s1)
    {
      return Dispatch_t::makeRead(f, s1, Combine_t());
    }
};
template<class Mesh, class T, class EngineTag>
struct View1<Field<Mesh, T, EngineTag>, int>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &f, int s1)
    {
      ;
      ;
      return f.engine()(s1);
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, int s1)
    {
      ;
      ;
      return f.engine().read(s1);
    }
};
template<class Mesh, class T, class EngineTag>
struct View1<Field<Mesh, T, EngineTag>, Loc<Mesh::dimensions> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &f, const Loc<Mesh::dimensions>& s1)
    {
      ;
      return f.engine()(s1);
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, const Loc<Mesh::dimensions>& s1)
    {
      ;
      return f.engine().read(s1);
    }
};
template<class Mesh, class T, class EngineTag,
  class Sub1, class Sub2>
struct View2<Field<Mesh, T, EngineTag>, Sub1, Sub2>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain2<Sub1, Sub2> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  typedef typename Dispatch_t::Type_t Type_t;
  inline static
  Type_t make(const Subject_t &f, const Sub1 &s1, const Sub2 &s2)
    {
      return Dispatch_t::make(f, s1, s2, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, const Sub1 &s1, const Sub2 &s2)
    {
      return Dispatch_t::makeRead(f, s1, s2, Combine_t());
    }
};
template<class Mesh, class T, class EngineTag>
struct View2<Field<Mesh, T, EngineTag>, int, int>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &f, int s1, int s2)
    {
      ;
      ;
      return f.engine()(s1, s2);
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, int s1, int s2)
    {
      ;
      ;
      return f.engine().read(s1, s2);
    }
};
template<class Mesh, class T, class EngineTag, int Dim>
struct View2<Field<Mesh, T, EngineTag>,
             FieldOffset<Dim>,
             Loc<Dim> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  enum { dimensions = Subject_t::dimensions };
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &f,
       const FieldOffset<dimensions> &fo,
       const Loc<dimensions> &loc)
    {
      PoomaCTAssert<(dimensions == Dim)>::test();
      if (f.numSubFields() > 1) {
 ;
 return f[fo.subFieldNumber()].engine()(loc + fo.cellOffset());
      }
      else {
 ;
 return f.engine()(loc + fo.cellOffset());
      }
    }
  inline static
  ReadType_t makeRead(const Subject_t &f,
        const FieldOffset<dimensions> &fo,
        const Loc<dimensions> &loc)
    {
      if (f.numSubFields() > 1) {
 ;
 return f[fo.subFieldNumber()].engine().read(loc + fo.cellOffset());
      }
      else {
 ;
 return f.engine().read(loc + fo.cellOffset());
      }
    }
};
template<class Mesh, class T, class EngineTag,
  class Sub1, class Sub2, class Sub3>
struct View3<Field<Mesh, T, EngineTag>, Sub1, Sub2, Sub3>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Domain_t Domain_t;
  typedef NewDomain3<Sub1, Sub2, Sub3> NewDomain_t;
  typedef typename NewDomain_t::SliceType_t SDomain_t;
  enum { sv = DomainTraits<SDomain_t>::singleValued };
  typedef View1Implementation<Subject_t, SDomain_t, sv> Dispatch_t;
  typedef CombineDomainOpt<NewDomain_t, sv> Combine_t;
  typedef typename Dispatch_t::ReadType_t ReadType_t;
  typedef typename Dispatch_t::Type_t Type_t;
  inline static
  Type_t make(const Subject_t &f, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3)
    {
      return Dispatch_t::make(f, s1, s2, s3, Combine_t());
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, const Sub1 &s1, const Sub2 &s2,
    const Sub3 &s3)
    {
      return Dispatch_t::makeRead(f, s1, s2, s3, Combine_t());
    }
};
template<class Mesh, class T, class EngineTag>
struct View3<Field<Mesh, T, EngineTag>, int, int, int>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Element_t ReadType_t;
  typedef typename Subject_t::ElementRef_t Type_t;
  inline static
  Type_t make(const Subject_t &f, int s1, int s2, int s3)
    {
      ;
      ;
      return f.engine()(s1, s2, s3);
    }
  inline static
  ReadType_t makeRead(const Subject_t &f, int s1, int s2, int s3)
    {
      ;
      ;
      return f.engine().read(s1, s2, s3);
    }
};
template <int SliceDim, class Mesh, class T, class EngineTag, int Dim>
struct ReverseSliceView<Field<Mesh, T, EngineTag>, SliceInterval<Dim, SliceDim> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef SliceInterval<Dim, SliceDim> Domain_t;
  typedef typename NewEngine<typename Subject_t::Engine_t, Domain_t>::Type_t NewEngine_t;
  typedef Field<NoMesh<Dim>, T, typename NewEngine_t::Tag_t> Type_t;
  inline static
  Type_t make(const Subject_t &a, const SliceInterval<Dim, SliceDim>& dom,
       const Interval<Dim>& totalDom)
  {
    PoomaCTAssert<(Mesh::dimensions == SliceDim)>::test();
    ;
    return Type_t(typename Type_t::FieldEngine_t(a.fieldEngine(), dom, totalDom));
  }
};
template<class Subject> struct Patch;
template<class Mesh, class T, class EngineTag>
struct Patch<Field<Mesh, T, EngineTag> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t OldEngine_t;
  typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  typedef Field<Mesh, T, typename Engine_t::Tag_t> Type_t;
  enum { dim = OldEngine_t::dimensions };
  inline static
  Type_t make(const Subject_t &f, int i)
  {
    ;
    return Type_t(f, FieldEnginePatch<dim>(i, f.physicalDomain()));
  }
};
template<class Mesh, class T, class LTag, class EngineTag>
struct Patch<Field<Mesh, T, MultiPatch<LTag, EngineTag> > >
{
  typedef Field<Mesh, T, MultiPatch<LTag, EngineTag> > Subject_t;
  typedef typename Subject_t::Engine_t OldEngine_t;
  typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  typedef Field<Mesh, T, typename Engine_t::Tag_t> Type_t;
  enum { dim = OldEngine_t::dimensions };
  typedef typename OldEngine_t::Layout_t Layout_t;
  typedef typename Layout_t::Value_t Node_t;
  inline static
  Type_t make(const Subject_t &f, int i)
  {
    ;
    Node_t *node = f.engine().layout().nodeListLocal()[i];
    return Type_t(f, FieldEnginePatch<dim>(i, intersect(f.physicalDomain(),
                                                        node->domain())));
  }
};
template<class Components, class Subject> struct ComponentView;
template<class Components, class Mesh, class T, class EngineTag>
struct ComponentView<Components, Field<Mesh, T, EngineTag> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef Engine<Mesh::dimensions, T, EngineTag> Engine_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename ComponentAccess<Element_t, Components>::Element_t NewT_t;
  typedef CompFwd<Engine_t, Components> NewEngineTag_t;
  typedef Field<Mesh, NewT_t, NewEngineTag_t> Type_t;
  inline static
  Type_t make(const Subject_t &f, const Components &c)
    {
      return Type_t(f, ComponentWrapper<Components>(c));
    }
};
template<class Mesh,
         class T = double,
         class EngineTag = Brick>
class Field {
public:
  typedef Mesh MeshTag_t;
  typedef Mesh Mesh_t;
  typedef T T_t;
  typedef EngineTag EngineTag_t;
  typedef Field<Mesh, T, EngineTag> This_t;
  typedef FieldEngine<Mesh, T, EngineTag> FieldEngine_t;
  enum { dimensions = FieldEngine_t::dimensions };
  enum { coordinateDimensions = MeshTag_t::coordinateDimensions };
  typedef Engine<dimensions, T, EngineTag> Engine_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef typename Engine_t::Layout_t Layout_t;
  typedef typename Engine_t::Domain_t Domain_t;
  typedef Centering<dimensions> Centering_t;
  enum { hasRelations = true };
  Field()
  : fieldEngine_m()
    { }
  template<class I1>
  explicit Field(const I1 &i1)
    : fieldEngine_m(i1)
  { }
  template<class Layout2>
  Field(const Centering_t &centering, const Layout2 &layout, const Mesh_t &mesh)
    : fieldEngine_m(centering, layout, mesh)
  { }
  template<class Layout2>
  Field(int materials, const Centering_t &centering, const Layout2 &layout, const Mesh_t &mesh)
    : fieldEngine_m(centering, layout, mesh, materials)
  { }
  template<class I1, class I2>
  Field(const Centering_t &centering, const Layout_t &layout, const I1 &i1, const I2 &i2)
    : fieldEngine_m(centering, layout, Mesh_t(layout, i1, i2))
  { }
  Field(const Centering_t &centering, const Layout_t &layout)
    : fieldEngine_m(centering, layout, Mesh_t(layout))
  { }
  template<class I1, class I2>
  Field(int materials, const Centering_t &centering, const Layout_t &layout,
        const I1 &i1, const I2 &i2)
    : fieldEngine_m(centering, layout, Mesh_t(layout, i1, i2), materials)
  { }
  Field(const This_t &model)
  : fieldEngine_m(model.fieldEngine())
  { }
  void initialize(const This_t &model)
  {
    fieldEngine_m = model.fieldEngine();
  }
  template<class Layout2>
  void
  initialize(const Centering_t &centering, const Layout2 &layout,
             const Mesh_t &mesh)
  {
    fieldEngine_m = FieldEngine_t(centering, layout, mesh);
  }
  template<class Layout2>
  void
  initialize(int materials, const Centering_t &centering,
             const Layout2 &layout, const Mesh_t &mesh)
  {
    fieldEngine_m = FieldEngine_t(centering, layout, mesh, materials);
  }
  void
  initialize(const Centering_t &centering, const Layout_t &layout)
  {
    fieldEngine_m = FieldEngine_t(centering, layout, Mesh_t(layout));
  }
  template<class GT2, class T2, class ET2, class Initializer>
  Field(const Field<GT2, T2, ET2> &model, const Initializer &i)
  : fieldEngine_m(model.fieldEngine(), i)
  { }
  template<class ET2>
  Field(const Field<Mesh, T, ET2> &model, int m, int c)
    : fieldEngine_m(model.fieldEngine(), m, c)
  { }
  template<class ET2>
  Field(const Field<Mesh, T, ET2> &model, int c, const Pooma::CenteringViewTag &tag)
    : fieldEngine_m(model.fieldEngine(), c, tag)
  { }
  template<class ET2>
  Field(const Field<Mesh, T, ET2> &model, int m, const Pooma::MaterialViewTag &tag)
    : fieldEngine_m(model.fieldEngine(), m, tag)
  { }
  ~Field() { }
  inline const Engine_t &engine() const
    {
      return fieldEngine_m.engine();
    }
  inline Engine_t &engine()
    {
      return fieldEngine_m.engine();
    }
  inline const FieldEngine_t &fieldEngine() const
    {
      return fieldEngine_m;
    }
  inline FieldEngine_t &fieldEngine()
    {
      return fieldEngine_m;
    }
  inline int numSubFields() const
    {
      return fieldEngine_m.numSubFields();
    }
  const Centering<dimensions> &centering() const
  {
    return fieldEngine().centering();
  }
  const Centering<dimensions> centering(int c) const
  {
    return fieldEngine().centering()[c];
  }
  inline int centeringSize() const
  {
    return fieldEngine().centeringSize();
  }
  inline int numMaterials() const
    {
      return fieldEngine().numMaterials();
    }
  inline const Domain_t& physicalCellDomain() const
    {
      return fieldEngine_m.physicalCellDomain();
    }
  inline Domain_t totalCellDomain() const
    {
      return fieldEngine_m.totalCellDomain();
    }
  Domain_t physicalDomain(int iSubfield) const
    {
      return fieldEngine_m.physicalDomain(iSubfield);
    }
  Domain_t totalDomain(int iSubfield) const
    {
      return fieldEngine_m.totalDomain(iSubfield);
    }
  Domain_t physicalDomain() const
    {
      return fieldEngine_m.physicalDomain();
    }
  Domain_t totalDomain() const
    {
      return fieldEngine_m.totalDomain();
    }
  Domain_t domain() const
    {
      return fieldEngine_m.physicalDomain();
    }
  inline
  const Mesh_t &mesh() const
  {
    return fieldEngine_m.mesh();
  }
  inline Layout_t layout() const
  {
    return fieldEngine_m.engine(0, 0).layout();
  }
  void makeOwnCopy()
  {
    fieldEngine_m.makeOwnCopy(*this);
  }
  inline typename SubFieldView<This_t>::Type_t
  operator[](int iSubfield) const
    {
      typedef SubFieldView<This_t> Ret_t;
      return Ret_t::make(*this, iSubfield);
    }
  inline typename SubFieldView<This_t>::Type_t
  subField(int m, int c) const
  {
    typedef SubFieldView<This_t> Ret_t;
    return Ret_t::make(*this, m, c);
  }
  inline typename SubFieldView<This_t>::Type_t
  center(int c) const
  {
    typedef SubFieldView<This_t> Ret_t;
    return Ret_t::make(*this, c, Pooma::CenteringViewTag());
  }
  inline typename SubFieldView<This_t>::Type_t
  material(int m) const
  {
    ;
    typedef SubFieldView<This_t> Ret_t;
    return Ret_t::make(*this, m, Pooma::MaterialViewTag());
  }
  inline typename View1<This_t, Domain_t>::ReadType_t
  read() const
    {
      typedef View1<This_t, Domain_t> Ret_t;
      return Ret_t::makeRead(*this, physicalDomain());
    }
  inline typename View1<This_t, Domain_t>::ReadType_t
  readAll() const
    {
      typedef View1<This_t, Domain_t> Ret_t;
      return Ret_t::makeRead(*this, totalDomain());
    }
  template<class Sub1>
  inline typename View1<This_t, Sub1>::ReadType_t
  read(const Sub1 &s1) const
    {
      typedef View1<This_t, Sub1> Ret_t;
      return Ret_t::makeRead(*this, s1);
    }
  template<class Sub1, class Sub2>
  inline typename View2<This_t, Sub1, Sub2>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2) const
    {
      typedef View2<This_t, Sub1, Sub2> Ret_t;
      return Ret_t::makeRead(*this, s1, s2);
    }
  template<class Sub1, class Sub2, class Sub3>
  inline typename View3<This_t, Sub1, Sub2, Sub3>::ReadType_t
  read(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3) const
    {
      typedef View3<This_t, Sub1, Sub2, Sub3> Ret_t;
      return Ret_t::makeRead(*this, s1, s2, s3);
    }
  inline typename View1<This_t, Domain_t>::Type_t
  operator()() const
    {
      typedef View1<This_t, Domain_t> Ret_t;
      return Ret_t::make(*this, physicalDomain());
    }
  inline typename View1<This_t, Domain_t>::Type_t
  all() const
    {
      typedef View1<This_t, Domain_t> Ret_t;
      return Ret_t::make(*this, totalDomain());
    }
  template<class Sub1>
  inline typename View1<This_t, Sub1>::Type_t
  operator()(const Sub1 &s1) const
    {
      typedef View1<This_t, Sub1> Ret_t;
      return Ret_t::make(*this, s1);
    }
  template<class Sub1, class Sub2>
  inline typename View2<This_t, Sub1, Sub2>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2) const
    {
      typedef View2<This_t, Sub1, Sub2> Ret_t;
      return Ret_t::make(*this, s1, s2);
    }
  template<class Sub1, class Sub2, class Sub3>
  inline typename View3<This_t, Sub1, Sub2, Sub3>::Type_t
  operator()(const Sub1 &s1, const Sub2 &s2, const Sub3 &s3) const
    {
      typedef View3<This_t, Sub1, Sub2, Sub3> Ret_t;
      return Ret_t::make(*this, s1, s2, s3);
    }
  inline typename ComponentView<Loc<1>, This_t>::Type_t
  comp(int i1) const
  {
    return ComponentView<Loc<1>, This_t>::make(*this, Loc<1>(i1));
  }
  inline typename ComponentView<Loc<2>, This_t>::Type_t
  comp(int i1, int i2) const
  {
    return ComponentView<Loc<2>, This_t>::make(*this, Loc<2>(i1, i2));
  }
  template<class Components>
  inline typename ComponentView<Components, This_t>::Type_t
  comp(const Components &loc) const
  {
    return ComponentView<Components, This_t>::make(*this, loc);
  }
  inline typename Patch<This_t>::Type_t
  patchLocal(EnginePatch::PatchID_t i) const
    {
      return Patch<This_t>::make(*this, i);
    }
  inline int
  numPatchesLocal() const
  {
    return engineFunctor(engine(), EngineNumPatches());
  }
  This_t &operator=(const This_t &rhs)
    {
      assign(*this, rhs, OpAssign());
      return *this;
    }
  const This_t &operator=(const This_t &rhs) const
    {
      return assign(*this, rhs, OpAssign());
    }
  template<class T1>
  const This_t &operator=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpAssign());
    }
  template<class T1>
  const This_t &operator+=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpAddAssign());
    }
  template<class T1>
  const This_t &operator-=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpSubtractAssign());
    }
  template<class T1>
  const This_t &operator*=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpMultiplyAssign());
    }
  template<class T1>
  const This_t &operator/=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpDivideAssign());
    }
  template<class T1>
  const This_t &operator%=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpModAssign());
    }
  template<class T1>
  const This_t &operator|=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseOrAssign());
    }
  template<class T1>
  const This_t &operator&=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseAndAssign());
    }
  template<class T1>
  const This_t &operator^=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpBitwiseXorAssign());
    }
  template<class T1>
  const This_t &operator<<=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpLeftShiftAssign());
    }
  template<class T1>
  const This_t &operator>>=(const T1 &rhs) const
    {
      return assign(*this, rhs, OpRightShiftAssign());
    }
  void addRelation(RelationListItem *item) const
  {
    ;
    fieldEngine_m.relations().addRelation(item);
  }
  void removeRelations()
  {
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering().size(); ++ c)
      {
        fieldEngine_m.data(m, c).relations().erase();
      }
    }
  }
  void applyRelations(bool makeDirty = false) const
  {
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering().size(); ++ c)
      {
        if (makeDirty)
          fieldEngine_m.data(m, c).relations().setDirty();
        fieldEngine_m.data(m, c).relations().notifyPreRead();
      }
    }
  }
  void notifyPreRead() const
  {
    for (int m = 0; m < numMaterials(); ++m)
      for (int c = 0; c < centering().size(); ++c)
        fieldEngine_m.data(m, c).relations().notifyPreRead();
  }
  void notifyPostWrite() const
  {
    for (int m = 0; m < numMaterials(); ++m)
      for (int c = 0; c < centering().size(); ++c)
        fieldEngine_m.data(m, c).relations().notifyPostWrite();
  }
  void setDirty() const
  {
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering().size(); ++ c)
      {
        fieldEngine_m.data(m, c).relations().setDirty();
      }
    }
  }
  void clearDirty() const
  {
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering().size(); ++ c)
      {
        fieldEngine_m.data(m, c).relations().clearDirty();
      }
    }
  }
  bool isDirty() const
  {
    for (int m = 0; m < numMaterials(); ++m)
    {
      for (int c = 0; c < centering().size(); ++ c)
      {
        if (fieldEngine_m.data(m, c).relations().dirty())
   return true;
      }
    }
    return false;
  }
private:
  FieldEngine_t fieldEngine_m;
};
template<class Op>
struct AssignOpReadWriteTraits
{
  enum { readLHS = true };
};
template<>
struct AssignOpReadWriteTraits<OpAssign>
{
  enum { readLHS = false };
};
template<class Mesh, class T, class EngineTag, int Dim>
struct LeafFunctor<Field<Mesh, T, EngineTag>, ConformTag<Dim> >
{
  typedef bool Type_t;
  static Type_t apply1(const Interval<Dim> &d,
    const ConformTag<Dim> &ct)
    {
      return conforms(d, ct);
    }
  template<int Dim2>
  static Type_t apply1(const Interval<Dim2> &d,
    const ConformTag<Dim> &ct)
    {
      return false;
    }
  static Type_t apply(const Field<Mesh, T, EngineTag> &f,
    const ConformTag<Dim> &ct)
    {
      return apply1(f.physicalDomain(), ct);
    }
};
template<class Mesh, class T, class EngineTag, class RequestType>
struct LeafFunctor<Field<Mesh, T, EngineTag>,
  DataObjectRequest<RequestType> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::FieldEngine_t FieldEngine_t;
  typedef LeafFunctor<FieldEngine_t, DataObjectRequest<RequestType> >
    LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t Type_t;
  enum { dataObject = LeafFunctor_t::dataObject };
  inline static
  Type_t apply(const Subject_t &f,
            const DataObjectRequest<RequestType> &functor)
    {
      return LeafFunctor_t::apply(f.fieldEngine(), functor);
    }
};
template<class Mesh, class T, class EngineTag, class RequestType>
struct LeafFunctor<FieldEngine<Mesh, T, EngineTag>,
  DataObjectRequest<RequestType> >
{
  typedef typename FieldEngine<Mesh, T, EngineTag>::Engine_t
    Engine_t;
  enum { dataObject = Engine_t::dataObject };
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  inline static
  Type_t apply(const FieldEngine<Mesh, T, EngineTag> &f,
            const DataObjectRequest<RequestType> &functor)
    {
      return DataObjectApply<dataObject>::apply(f.engine(), functor);
    }
};
template<class Mesh, class T, class EngineTag>
struct LeafFunctor<Field<Mesh, T, EngineTag>, DomainFunctorTag>
{
  typedef typename Field<Mesh, T, EngineTag>::Domain_t Type_t;
  inline static Type_t apply(const Field<Mesh, T, EngineTag> &f,
    const DomainFunctorTag &)
    {
      return f.physicalDomain() - f.physicalDomain().firsts();
    }
};
template<class Mesh, class T, class EngineTag, class Tag>
struct LeafFunctor<Field<Mesh, T, EngineTag>, ExpressionApply<Tag> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::FieldEngine_t FieldEngine_t;
  typedef LeafFunctor<FieldEngine_t, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Subject_t &field,
        const ExpressionApply<Tag> &tag)
    {
      return LeafFunctor_t::apply(field.fieldEngine(), tag);
    }
};
template<class Mesh, class T, class EngineTag, class Tag>
struct LeafFunctor<Field<Mesh, T, EngineTag>, EngineView<Tag> >
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef typename LeafFunctor<Engine_t, EngineView<Tag> >::Type_t NewEngine_t;
  typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  typedef Field<Mesh, T, NewEngineTag_t> Type_t;
  inline static
  Type_t apply(const Subject_t &field,
        const EngineView<Tag> &tag)
  {
    return Type_t(field, tag);
  }
};
template<class Mesh, class T, class EngineTag, class Tag>
struct LeafFunctor<Field<Mesh, T, EngineTag>, EngineFunctorTag<Tag> >
{
  typedef typename Field<Mesh,T,EngineTag>::Engine_t Engine_t;
  typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Field<Mesh, T, EngineTag> &field,
        const EngineFunctorTag<Tag> &tag)
  {
    return EngineFunctor<Engine_t,Tag>::apply(field.engine(), tag.tag());
  }
};
template<class Mesh, class T, class EngineTag, class Tag>
struct EngineFunctor<Field<Mesh, T, EngineTag>, Tag>
{
  typedef typename Field<Mesh, T, EngineTag>::Engine_t Engine_t;
  typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;
  inline static
  Type_t apply(const Field<Mesh, T, EngineTag> &field,
            const Tag &tag)
    {
      return engineFunctor(field.engine(), tag);
    }
};
template<class Mesh, class T, class EngineTag, int Dim>
struct LeafFunctor<Field<Mesh, T, EngineTag>, EvalLeaf<Dim> >
{
  typedef typename Field<Mesh, T, EngineTag>::Element_t Type_t;
  inline static
  Type_t apply(const Field<Mesh, T, EngineTag> &f,
    const EvalLeaf<Dim> &t)
    {
      return t.eval(f.engine());
    }
};
template<class Mesh, class T, class EngineTag>
struct LeafFunctor<Field<Mesh, T, EngineTag>,
  PerformUpdateTag>
{
  typedef Field<Mesh, T, EngineTag> Subject_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Subject_t &f, const PerformUpdateTag &)
    {
      f.notifyPreRead();
      return 0;
    }
};
template<class Mesh, class T, class Expr>
struct LeafFunctor<Field<Mesh, T, ExpressionTag<Expr> >,
  PerformUpdateTag>
{
  typedef Field<Mesh, T, ExpressionTag<Expr> > Subject_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Subject_t &f, const PerformUpdateTag &tag)
    {
      forEach(f.engine().expression(), tag, NullCombine());
      return 0;
    }
};
template<class Mesh, class T, class EngineTag>
struct LeafFunctor<Field<Mesh, T, EngineTag>, SubFieldViewFunctorTag>
{
  typedef Field<Mesh, T, EngineTag> Type_t;
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, SubFieldViewFunctorTag>
{
  typedef Array<Dim, T, EngineTag> Type_t;
};
template<class T>
struct LeafFunctor<Scalar<T>, SubFieldViewFunctorTag>
{
  typedef Scalar<T> Type_t;
};
template<class Mesh, class T, class EngineTag, class Domain>
struct LeafFunctor<Field<Mesh, T, EngineTag>, ViewFunctorTag<Domain> >
{
  typedef typename View1<Field<Mesh, T, EngineTag>, Domain>::Type_t
    Type_t;
};
template <class Mesh, class T, class EngineTag>
std::ostream &operator<<(std::ostream &o,
  const Field<Mesh, T, EngineTag> &cf)
{
  Pooma::blockAndEvaluate();
  PrintField().print(o, cf);
  return o;
}
template <class Mesh, class T, class EngineTag>
std::fstream &operator<<(std::fstream &f,
  const Field<Mesh, T, EngineTag> &cf)
{
  Pooma::blockAndEvaluate();
  PrintField().print(f, cf);
  return f;
}
struct ExpressionIsField { };
template<class Mesh, class T, class EngineTag>
struct ExpressionTraits<Field<Mesh, T, EngineTag> >
{
  typedef ExpressionIsField Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsField, ExpressionIsField>
{
  typedef ExpressionIsField Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsField, ExpressionIsScalar>
{
  typedef ExpressionIsField Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsScalar, ExpressionIsField>
{
  typedef ExpressionIsField Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsField, ExpressionIsArray>
{
  typedef ExpressionIsField Type_t;
};
template<>
struct CombineExpressionTraits<ExpressionIsArray, ExpressionIsField>
{
  typedef ExpressionIsField Type_t;
};
template<class Mesh, class T, class EngineTag,
 int Dim2, class T2, class EngineTag2, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const Array<Dim2, T2, EngineTag2> &rhs, const Op &op)
{
  for (int m = 0; m < lhs.numMaterials(); ++m)
    {
      for (int c = 0; c < lhs.centeringSize(); ++c)
        {
          const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);
          if (AssignOpReadWriteTraits<Op>::readLHS)
            l.notifyPreRead();
          Evaluator<MainEvaluatorTag>().evaluate(l, op, rhs);
          l.notifyPostWrite();
        }
    }
  return lhs;
}
template<class Mesh, class T, class EngineTag,
  class Mesh2, class T2, class EngineTag2, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const Field<Mesh2, T2, EngineTag2> &rhs,
       const Op &op)
{
  ;
  for (int m = 0; m < lhs.numMaterials(); ++m)
    {
      for (int c = 0; c < lhs.centeringSize(); ++c)
        {
          const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);
          const typename SubFieldView<Field<Mesh2, T2, EngineTag2> >::Type_t &r =
            rhs.subField(m, c);
          forEach(r, PerformUpdateTag(), NullCombine());
          if (AssignOpReadWriteTraits<Op>::readLHS)
            l.notifyPreRead();
          Evaluator<MainEvaluatorTag>().evaluate(l, op, r);
          l.notifyPostWrite();
        }
    }
  return lhs;
}
template<class Mesh, class T, class EngineTag, class T1, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs, const T1 &rhs,
       const Op &op)
{
  for (int m = 0; m < lhs.numMaterials(); ++m)
    {
      for (int c = 0; c < lhs.centeringSize(); ++c)
        {
          const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);
          if (AssignOpReadWriteTraits<Op>::readLHS)
            l.notifyPreRead();
          typedef Field<Mesh, T, EngineTag> LHS_t;
          Array<LHS_t::dimensions, T1, ConstantFunction> rhsExpr(l.physicalDomain());
          rhsExpr.engine().setConstant(rhs);
          Evaluator<MainEvaluatorTag>().evaluate(l, op, rhsExpr);
          l.notifyPostWrite();
        }
    }
  return lhs;
}
template<class Mesh, class T, class EngineTag,
 int Dim2, class T2, class EngineTag2, class Op>
const Array<Dim2, T2, EngineTag2> &
assign(const Array<Dim2, T2, EngineTag2> &lhs,
       const Field<Mesh, T, EngineTag> &rhs, const Op &op)
{
  ;
  forEach(rhs, PerformUpdateTag(), NullCombine());
  Evaluator<MainEvaluatorTag>().evaluate(lhs, op, rhs);
  return lhs;
}
template<class Tree>
struct ConvertWhereProxy<ExpressionIsField, Tree>
{
  typedef MakeFieldReturn<Tree> Make_t;
};
template<class Mesh, class T, class EngineTag,
 class F, class B, class Op>
const Field<Mesh, T, EngineTag> &
assign(const Field<Mesh, T, EngineTag> &lhs,
       const WhereProxy<F, B> &rhs, const Op &op)
{
  assign(lhs, rhs.whereMask(), rhs.opMask(op));
  return lhs;
}
template<class Mesh, class T, class EngineTag>
inline bool compressed(const Field<Mesh, T, EngineTag> &f)
{
  ;
  return compressed(f.engine());
}
template<class Mesh, class T, class EngineTag>
inline long elementsCompressed(const Field<Mesh, T, EngineTag> &f)
{
  ;
  return elementsCompressed(f.engine());
}
template<class Mesh, class T, class LTag>
void
compress(Field<Mesh, T, MultiPatch<LTag,CompressibleBrick> > &f)
{
  for (int m = 0; m < f.numMaterials(); ++m)
  {
    for (int c = 0; c < f.centeringSize(); ++c)
    {
      compress(f.fieldEngine().data(m, c).engine());
    }
  }
}
template<class Mesh, class T, class LTag>
void
uncompress(Field<Mesh, T, MultiPatch<LTag,CompressibleBrick> > &f)
{
  for (int m = 0; m < f.numMaterials(); ++m)
  {
    for (int c = 0; c < f.centeringSize(); ++c)
    {
      uncompress(f.fieldEngine().data(m, c).engine());
    }
  }
}
template<int Dim, class T, class EngineTag>
inline int numMaterials(const Array<Dim, T, EngineTag> &a)
{
  return 1;
}
template<class Mesh, class T, class EngineTag>
inline int numMaterials(const Field<Mesh, T, EngineTag> &f)
{
  return f.numMaterials();
}
template<int Dim, class T, class EngineTag>
inline int centeringSize(const Array<Dim, T, EngineTag> &a)
{
  return 1;
}
template<class Mesh, class T, class EngineTag>
inline int centeringSize(const Field<Mesh, T, EngineTag> &f)
{
  return f.centeringSize();
}
template<int Dim, class T, class EngineTag>
inline Array<Dim, T, EngineTag> &subField(Array<Dim, T, EngineTag> &a, int, int)
{
  return a;
}
template<class Mesh, class T, class EngineTag>
inline typename SubFieldView<Field<Mesh, T, EngineTag> >::Type_t
subField(Field<Mesh, T, EngineTag> &f, int m, int c)
{
  return f.subField(m, c);
}
template<class Mesh, class T, class EngineTag> class Field;
struct FarLeftTag
{

};
template<class G1, class T1, class E1, class Op>
struct Combine1<Field<G1, T1, E1>, Op, FarLeftTag>
{
  typedef Field<G1, T1, E1> Type_t;
  inline static
  const Type_t &combine(const Field<G1, T1, E1> &a,
   const FarLeftTag &)
    {
      return a;
    }
};
template<class G1, class T1, class E1, class G2, class T2, class E2,
  class Op>
struct Combine2<Field<G1, T1, E1>, Field<G2, T2, E2>, Op, FarLeftTag>
{
  typedef Field<G1, T1, E1> Type_t;
  inline static
  const Type_t &combine(const Field<G1, T1, E1> &a,
                        const Field<G2, T2, E2> &, FarLeftTag)
    {
      return a;
    }
};
template<class T, class G2, class T2, class E2, class Op>
struct Combine2<T, Field<G2, T2, E2>, Op, FarLeftTag>
{
  typedef Field<G2, T2, E2> Type_t;
  inline static
  const Type_t &combine(const T &,
                        const Field<G2, T2, E2> &b, FarLeftTag)
    {
      return b;
    }
};
template<class G1, class T1, class E1, class T, class Op>
struct Combine2<Field<G1, T1, E1>, T, Op, FarLeftTag>
{
  typedef Field<G1, T1, E1> Type_t;
  inline static
  const Type_t &combine(const Field<G1, T1, E1> &a,
                        const T &, FarLeftTag)
    {
      return a;
    }
};
template<class T, class Op>
struct Combine2<ErrorType, T, Op, FarLeftTag>
{
  typedef T Type_t;
  inline static
  const Type_t &combine(const ErrorType& e, const T& t,
          FarLeftTag)
  {
    return t;
  }
};
template<class T, class Op>
struct Combine2<T, ErrorType, Op, FarLeftTag>
{
  typedef T Type_t;
  inline static
  const Type_t &combine(const T& t, const ErrorType& e,
          FarLeftTag)
  {
    return t;
  }
};
template<class A,class B,class C,class Op>
struct Combine3<A, B, C, Op, FarLeftTag>
{
  typedef typename Combine2<A, B, Op, FarLeftTag>::Type_t Type1_t;
  typedef typename Combine2<Type1_t, C, Op, FarLeftTag>::Type_t Type_t;
  inline static
  const Type_t &combine(const A& a, const B& b, const C& c,
   const FarLeftTag& t)
  {
    return
      Combine2<Type1_t, C,
      Op, FarLeftTag>::combine(Combine2<A, B, Op,
          FarLeftTag>::combine(a, b, t), c, t);
  }
};
template<class GeometryTag, class T, class EngineTag>
struct LeafFunctor<Field<GeometryTag, T, EngineTag>, FarLeftTag>
{
  typedef Field<GeometryTag, T, EngineTag> Type_t;
  inline static
  const Type_t &apply(const Field<GeometryTag, T, EngineTag> &f,
    const FarLeftTag &)
    {
      return f;
    }
};
template<int Dim, class T, class EngineTag>
struct LeafFunctor<Array<Dim, T, EngineTag>, FarLeftTag>
{
  typedef ErrorType Type_t;
  inline static
  const Type_t &apply(const Array<Dim, T, EngineTag> &a,
    const FarLeftTag &)
    {
      return Type_t();
    }
};
template<class T>
struct LeafFunctor<Scalar<T>, FarLeftTag>
{
  typedef Scalar<T> Type_t;
  inline static
  const Type_t &apply(const Scalar<T> &s, const FarLeftTag &)
    {
      return s;
    }
};
template<class Mesh, class T, class Expr>
class FieldEngine<Mesh, T, ExpressionTag<Expr> >
{
public:
  enum { dimensions = Mesh::dimensions };
  enum { Dim = dimensions };
  typedef ExpressionTag<Expr> EngineTag_t;
  typedef FieldEngine<Mesh, T, EngineTag_t> This_t;
  typedef Engine<Dim, T, EngineTag_t> Engine_t;
  typedef typename Engine_t::Domain_t Domain_t;
  typedef typename Engine_t::Layout_t Layout_t;
  typedef typename Engine_t::Element_t Element_t;
  typedef typename Engine_t::ElementRef_t ElementRef_t;
  typedef GuardLayers<Dim> GuardLayers_t;
  typedef typename ForEach<Expr, FarLeftTag, FarLeftTag>::Type_t
    ReferenceField_t;
  FieldEngine(const Engine_t &e)
  : engine_m(e),
    referenceField_m(
      forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
    { }
  template<class Expr2, class Domain>
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model,
    const Domain &d)
  : engine_m(NewEngineEngine<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d),
      NewEngineDomain<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d)
      ),
    referenceField_m(
      forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
    { }
  template<class Expr2>
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, int m, int c)
    : engine_m(Expr(model.engine().expression(), m, c)),
      referenceField_m(forEachRef(engine_m.expression(),
                                  FarLeftTag(), FarLeftTag()))
  { }
  template<class Expr2>
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, int m,
       const Pooma::MaterialViewTag& tag)
    : engine_m(Expr(model.engine().expression(), m, tag)),
      referenceField_m(forEachRef(engine_m.expression(),
                                  FarLeftTag(), FarLeftTag()))
  { }
  template<class Expr2>
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, int c,
       const Pooma::CenteringViewTag& tag)
    : engine_m(Expr(model.engine().expression(), c, tag)),
      referenceField_m(forEachRef(engine_m.expression(),
                                  FarLeftTag(), FarLeftTag()))
  { }
  template<class Expr2>
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, int iSubField)
    : engine_m(Expr(model.engine().expression, iSubField)),
      referenceField_m(forEachRef(engine_m.expression(),
                                  FarLeftTag(), FarLeftTag()))
  { }
  FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr> > &other)
  : engine_m(other.engine()),
    referenceField_m(forEachRef(engine_m.expression(),
    FarLeftTag(), FarLeftTag()))
  { }
  int numSubFields() const
    {
      return referenceField().numSubFields();
    }
  const Engine_t &engine() const
    {
      return engine_m;
    }
  Engine_t &engine()
    {
      return engine_m;
    }
  const ReferenceField_t &referenceField() const
  {
    return referenceField_m;
  }
  const Domain_t &physicalCellDomain() const
    {
      return referenceField().physicalCellDomain();
    }
  Domain_t totalCellDomain() const
    {
      return referenceField().totalCellDomain();
    }
  Domain_t physicalDomain() const
    {
      return referenceField().physicalDomain();
    }
  Domain_t totalDomain() const
    {
      return referenceField().totalDomain();
    }
  Domain_t physicalDomain(int iSubField) const
    {
      return referenceField().physicalDomain(iSubField);
    }
  Domain_t totalDomain(int iSubField) const
    {
      return referenceField().totalDomain(iSubField);
    }
  const Centering<Dim> &centering() const
  {
    return referenceField().centering();
  }
  int centeringSize() const
    {
      return referenceField().centeringSize();
    }
  int numMaterials() const
    {
      return referenceField().numMaterials();
    }
  Mesh &mesh()
  {
    return referenceField().mesh();
  }
  const Mesh &mesh() const
  {
    return referenceField().mesh();
  }
private:
  This_t &operator=(const This_t &other);
  Engine_t engine_m;
  const ReferenceField_t &referenceField_m;
};
template<class Mesh, class T, class Expr, class Tag>
struct LeafFunctor<FieldEngine<Mesh, T, ExpressionTag<Expr> >,
  ExpressionApply<Tag> >
{
  typedef FieldEngine<Mesh, T, ExpressionTag<Expr> > Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  inline static
  Type_t apply(const Subject_t &fieldEngineBase,
        const ExpressionApply<Tag> &tag)
  {
    LeafFunctor_t::apply(fieldEngineBase.engine(), tag);
    return 0;
  }
};
struct RectilinearTag {};
struct UniformRectilinearTag {};
struct CartesianTag {
  enum { x = 0, y = 1, z = 2 };
};
struct CylindricalTag {
  enum { r = 0, z = 1, phi = 2 };
};
struct SphericalTag {
  enum { r = 0, theta = 1, phi = 2};
};
template<class MeshTraits> struct CartesianRM;
template<class MeshTraits> struct CartesianURM;
template<class MeshTraits> struct CylindricalRM;
template<class MeshTraits> struct CylindricalURM;
template<class MeshTraits> struct SphericalRM;
template<class MeshTraits> struct SphericalURM;
template<class MeshTraits> class RectilinearMeshData;
template<class MeshTraits> class RectilinearMesh;
template<class MeshTraits> class UniformRectilinearMeshData;
template<class MeshTraits> class UniformRectilinearMesh;
template <int Dim, typename T = double, class MeshTag = UniformRectilinearTag, class CoordinateSystemTag = CartesianTag, int CDim = Dim>
struct MeshTraits;
template <int Dim, typename T, class MeshTag, class CoordinateSystemTag, int CDim>
struct MeshTraitsBase
{
  typedef MeshTraits<Dim, T, MeshTag, CoordinateSystemTag, CDim> MeshTraits_t;
  typedef MeshTag MeshTag_t;
  typedef CoordinateSystemTag CoordinateSystemTag_t;
  typedef T T_t;
  enum { dimensions = Dim };
  enum { coordinateDimensions = CDim };
  typedef T Scalar_t;
  typedef Loc<Dim> Loc_t;
  typedef Interval<Dim> Domain_t;
  typedef Vector<CDim, T> PointType_t;
  typedef Vector<CDim, T> VectorType_t;
  typedef Vector<CDim, int> CIndexType_t;
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, RectilinearTag, CartesianTag, CDim>
  : MeshTraitsBase<Dim, T, RectilinearTag, CartesianTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, RectilinearTag, CartesianTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef CartesianRM<MeshTraits_t> CoordinateSystem_t;
  typedef RectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef RectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Array<1, T, Brick> SpacingsType_t[CDim];
  typedef Array<1, T, Brick> PositionsType_t[CDim];
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, UniformRectilinearTag, CartesianTag, CDim>
  : public MeshTraitsBase<Dim, T, UniformRectilinearTag, CartesianTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, UniformRectilinearTag, CartesianTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef CartesianURM<MeshTraits_t> CoordinateSystem_t;
  typedef UniformRectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef UniformRectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Vector<CDim, T> SpacingsType_t;
  typedef Vector<CDim, T> PositionsType_t;
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, RectilinearTag, CylindricalTag, CDim>
  : public MeshTraitsBase<Dim, T, RectilinearTag, CylindricalTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, RectilinearTag, CylindricalTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef CylindricalRM<MeshTraits_t> CoordinateSystem_t;
  typedef RectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef RectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Array<1, T, Brick> SpacingsType_t[CDim];
  typedef Array<1, T, Brick> PositionsType_t[CDim];
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, UniformRectilinearTag, CylindricalTag, CDim>
  : public MeshTraitsBase<Dim, T, UniformRectilinearTag, CylindricalTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, UniformRectilinearTag, CylindricalTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef CylindricalURM<MeshTraits_t> CoordinateSystem_t;
  typedef UniformRectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef UniformRectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Vector<CDim, T> SpacingsType_t;
  typedef Vector<CDim, T> PositionsType_t;
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, RectilinearTag, SphericalTag, CDim>
  : MeshTraitsBase<Dim, T, RectilinearTag, SphericalTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, RectilinearTag, SphericalTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef SphericalRM<MeshTraits_t> CoordinateSystem_t;
  typedef RectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef RectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Array<1, T, Brick> SpacingsType_t[CDim];
  typedef Array<1, T, Brick> PositionsType_t[CDim];
};
template <int Dim, typename T, int CDim>
struct MeshTraits<Dim, T, UniformRectilinearTag, SphericalTag, CDim>
  : MeshTraitsBase<Dim, T, UniformRectilinearTag, SphericalTag, CDim>
{
  typedef typename MeshTraitsBase<Dim, T, UniformRectilinearTag, SphericalTag, CDim>::MeshTraits_t MeshTraits_t;
  typedef SphericalURM<MeshTraits_t> CoordinateSystem_t;
  typedef UniformRectilinearMeshData<MeshTraits_t> MeshData_t;
  typedef UniformRectilinearMesh<MeshTraits_t> Mesh_t;
  typedef Vector<CDim, T> SpacingsType_t;
  typedef Vector<CDim, T> PositionsType_t;
};
template <int Dim>
class NoMeshData : public RefCounted
{
public:
  NoMeshData()
    {
    }
  template<class Layout>
  explicit NoMeshData(const Layout &layout)
  : physicalVertexDomain_m(layout.innerDomain()),
    physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),
    totalVertexDomain_m(layout.domain()),
    totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))
    {
    }
  NoMeshData(const NoMeshData<Dim> &model)
  : physicalVertexDomain_m(model.physicalVertexDomain_m),
    physicalCellDomain_m(model.physicalCellDomain_m),
    totalVertexDomain_m(model.totalVertexDomain_m),
    totalCellDomain_m(model.totalCellDomain_m)
    {
    }
  NoMeshData(const Interval<Dim> &d)
  : physicalVertexDomain_m(d - d.firsts()),
    physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),
    totalVertexDomain_m(d - d.firsts()),
    totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))
    {
    }
  NoMeshData(const NoMeshData<Dim> &model, const FieldEnginePatch<Dim> &p)
  : physicalVertexDomain_m(p.domain_m),
    physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),
    totalVertexDomain_m(p.domain_m),
    totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))
    {
    }
  NoMeshData<Dim> &operator=(const NoMeshData<Dim> &rhs)
    {
      if (this != &rhs)
        {
          physicalVertexDomain_m = rhs.physicalVertexDomain_m;
          physicalCellDomain_m = rhs.physicalCellDomain_m;
          totalVertexDomain_m = rhs.totalVertexDomain_m;
          totalCellDomain_m = rhs.totalCellDomain_m;
        }
      return *this;
    }
  ~NoMeshData()
    {
    }
  inline const Interval<Dim> &physicalVertexDomain() const
    {
      return physicalVertexDomain_m;
    }
  inline const Interval<Dim> &physicalCellDomain() const
    {
      return physicalCellDomain_m;
    }
  inline const Interval<Dim> &totalVertexDomain() const
    {
      return totalVertexDomain_m;
    }
  inline const Interval<Dim> &totalCellDomain() const
    {
      return totalCellDomain_m;
    }
private:
  Interval<Dim> physicalVertexDomain_m, physicalCellDomain_m;
  Interval<Dim> totalVertexDomain_m, totalCellDomain_m;
};
template<int Dim>
class NoMesh
{
public:
  enum { dimensions = Dim };
  enum { coordinateDimensions = Dim };
  inline NoMesh()
  : data_m(new NoMeshData<Dim>)
    {
    }
  template<class Layout>
  inline explicit NoMesh(const Layout &layout)
  : data_m(new NoMeshData<Dim>(layout))
    {
    }
  inline explicit NoMesh(const NoMeshData<Dim> &data)
  : data_m(new NoMeshData<Dim>(data))
    {
    }
  inline NoMesh(const NoMesh<Dim> &model)
  : data_m(model.data_m)
    {
    }
  inline NoMesh(const NoMesh<Dim> &model, const Interval<Dim> &d)
  : data_m(new NoMeshData<Dim>(d))
    {
    }
  NoMesh(const NoMesh<Dim> &model, const INode<Dim> &i)
  : data_m(new NoMeshData<Dim>(i.domain()))
    {
    }
  inline NoMesh(const NoMesh<Dim> &model, const FieldEnginePatch<Dim> &p)
  : data_m(new NoMeshData<Dim>(*model.data_m, p))
    {
    }
  template<class Mesh, class Domain>
  inline NoMesh(const Mesh &, const Domain &d)
    {
      Interval<Dim> dom;
      for (int i = 0; i < Dim; i++)
        dom[i] = d[i].size();
      data_m = new NoMeshData<Dim>(dom);
    }
  ~NoMesh() { }
  const NoMeshData<Dim>& data() const
    {
      return *data_m;
    }
  NoMesh<Dim> &
  operator=(const NoMesh<Dim> &rhs)
    {
      if (&rhs != this)
        {
          data_m = rhs.data_m;
        }
      return *this;
    }
  inline const Interval<Dim> &physicalVertexDomain() const
    {
      return data_m->physicalVertexDomain();
    }
  inline const Interval<Dim> &physicalCellDomain() const
    {
      return data_m->physicalCellDomain();
    }
  inline const Interval<Dim> &totalVertexDomain() const
    {
      return data_m->totalVertexDomain();
    }
  inline const Interval<Dim> &totalCellDomain() const
    {
      return data_m->totalCellDomain();
    }
private:
  RefCountedPtr<NoMeshData<Dim> > data_m;
};
template <class MeshTraits>
class UniformRectilinearMeshData : public NoMeshData<MeshTraits::dimensions>
{
public:
  typedef typename MeshTraits::MeshData_t MeshData_t;
  typedef typename MeshTraits::Domain_t Domain_t;
  typedef typename MeshTraits::Scalar_t Scalar_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  UniformRectilinearMeshData()
    {
    }
  template<class Layout>
  UniformRectilinearMeshData(
    const Layout &layout,
    const PointType_t &origin,
    const SpacingsType_t &spacings)
  : NoMeshData<dimensions>(layout),
    origin_m(origin),
    spacings_m(spacings)
    {
    }
  UniformRectilinearMeshData(const MeshData_t &model)
  : NoMeshData<dimensions>(model),
    origin_m(model.origin_m),
    spacings_m(model.spacings_m)
    {
    }
  UniformRectilinearMeshData(const MeshData_t &model,
                             const Domain_t &d)
  : NoMeshData<dimensions>(d),
    origin_m(model.origin_m),
    spacings_m(model.spacings_m)
    {
      for (int i = 0; i < dimensions; i++)
        origin_m(i) +=
          spacings_m(i) *
            (d[i].first() - model.physicalCellDomain()[i].first());
    }
  MeshData_t &
  operator=(const MeshData_t &rhs)
    {
      if (this != &rhs)
        {
          NoMeshData<dimensions>::operator=(rhs);
          origin_m = rhs.origin_m;
          spacings_m = rhs.spacings_m;
        }
      return *this;
    }
  ~UniformRectilinearMeshData() { }
  inline const SpacingsType_t &spacings() const
    {
      return spacings_m;
    }
  inline const PointType_t &origin() const
    {
      return origin_m;
    }
private:
  PointType_t origin_m;
  SpacingsType_t spacings_m;
};
template<class MeshTraits>
class UniformRectilinearMesh : public MeshTraits::CoordinateSystem_t
{
public:
  typedef MeshTraits MeshTraits_t;
  typedef typename MeshTraits::CoordinateSystem_t CoordinateSystem_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::MeshData_t MeshData_t;
  typedef typename MeshTraits::Loc_t Loc_t;
  typedef typename MeshTraits::Domain_t Domain_t;
  typedef typename MeshTraits::Scalar_t Scalar_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::T_t T_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  UniformRectilinearMesh()
  : data_m(new MeshData_t())
    {
    }
  template<class Layout>
  inline UniformRectilinearMesh(const Layout &layout,
                                const PointType_t &origin,
                                const SpacingsType_t &spacings)
  : data_m(new MeshData_t(layout, origin, spacings))
    {
    }
  template<class Layout>
  inline explicit UniformRectilinearMesh(const Layout &layout)
  : data_m(new MeshData_t(layout,
                                                  PointType_t(0),
                                                  SpacingsType_t(1)))
    {
    }
  inline UniformRectilinearMesh(const Mesh_t &model)
  : data_m(model.data_m)
    {
    }
  inline UniformRectilinearMesh(const Mesh_t &model,
                                const Domain_t &d)
  : data_m(new MeshData_t(*model.data_m, d))
    {
    }
  inline UniformRectilinearMesh(const Mesh_t &model,
                                const INode<dimensions> &i)
  : data_m(new MeshData_t(*model.data_m, i.domain()))
    {
    }
  inline Mesh_t &
  operator=(const Mesh_t &rhs)
    {
      if (&rhs != this)
        {
          data_m = rhs.data_m;
        }
      return *this;
    }
  ~UniformRectilinearMesh()
    {
    }
  const MeshData_t& data() const
    {
      return *data_m;
    }
  inline const Domain_t &physicalVertexDomain() const
    {
      return data_m->physicalVertexDomain();
    }
  inline const Domain_t &physicalCellDomain() const
    {
      return data_m->physicalCellDomain();
    }
  inline const Domain_t &totalVertexDomain() const
    {
      return data_m->totalVertexDomain();
    }
  inline const Domain_t &totalCellDomain() const
    {
      return data_m->totalCellDomain();
    }
  inline const PointType_t &origin() const
    {
      return data_m->origin();
    }
  inline const SpacingsType_t &spacings() const
    {
      return data_m->spacings();
    }
  inline Loc_t cellContaining(const PointType_t &point) const
    {
      Loc_t loc((Pooma::NoInit()));
      for (int i = 0; i < dimensions; i++)
        loc[i] =
          Loc<1>(static_cast<int>((point(i) - origin()(i)) / spacings()(i)));
      return loc;
    }
  inline PointType_t vertexPosition(const Loc_t &loc) const
    {
      PointType_t point;
      for (int i = 0; i < dimensions; i++)
        point(i) = origin()(i) + spacings()(i) *
          (loc[i].first() - physicalCellDomain()[i].first());
      return point;
    }
  inline Scalar_t vertexPosition(int dim, int i) const
    {
      return origin()(dim) + spacings()(dim)
              * (i - physicalCellDomain()[dim].first());
    }
  inline PointType_t cellPosition(const Loc_t &loc) const
    {
      PointType_t point;
      for (int i=0; i<dimensions; i++)
 point(i) = origin()(i) + spacings()(i)
   * (loc[i].first() - physicalCellDomain()[i].first() + 0.5);
      return point;
    }
  inline Scalar_t cellPosition(int dim, int i) const
    {
      return origin()(dim) + spacings()(dim)
               * (i - physicalCellDomain()[dim].first() + 0.5);
    }
  inline VectorType_t vertexSpacing(const Loc_t &loc) const
    {
      return spacings();
    }
  inline Scalar_t vertexSpacing(int dim, int = 0) const
    {
      return spacings()(dim);
    }
  inline VectorType_t cellSpacing(const Loc_t &loc) const
    {
      return spacings();
    }
  inline Scalar_t cellSpacing(int dim, int = 0) const
    {
      return spacings()(dim);
    }
private:
  RefCountedPtr<MeshData_t > data_m;
};
template <class MeshTraits>
struct GenericURM {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::Loc_t Loc_t;
  typedef typename MeshTraits::CIndexType_t CIndexType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  class PositionsFunctor {
  public:
    PositionsFunctor() { }
    PositionsFunctor(const Mesh_t &m,
                     const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
      {
        for (int i = 0; i < dimensions; i++)
          origin_m(i) += spacings_m(i) *
            (c.position(0)(i) - m.physicalCellDomain()[i].first());
      }
    inline PointType_t operator()(int i0) const
      {
 CIndexType_t i(0);
 i(0) = i0;
        return origin_m + i * spacings_m;
      }
    inline PointType_t operator()(int i0, int i1) const
      {
 CIndexType_t i(0);
 i(0) = i0;
 i(1) = i1;
        return origin_m + i * spacings_m;
      }
    inline PointType_t operator()(int i0, int i1, int i2) const
      {
 CIndexType_t i(0);
 i(0) = i0;
 i(1) = i1;
 i(2) = i2;
        return origin_m + i * spacings_m;
      }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  typedef IndexFunction<PositionsFunctor> PositionsEngineTag_t;
  template <class PositionsEngineTag>
  void initializePositions(
    Engine<dimensions, PointType_t, PositionsEngineTag> &e,
    const Centering<dimensions> &c) const
    {
      e.setFunctor(typename PositionsEngineTag::Functor_t(static_cast<const Mesh_t&>(*this), c));
    }
  typedef ConstantFunction SpacingsEngineTag_t;
  void initializeSpacings(
    Engine<dimensions, VectorType_t, SpacingsEngineTag_t> &e,
    const Centering<dimensions> &) const
    {
      e.setConstant(static_cast<const Mesh_t&>(*this).spacings());
    }
  typedef ConstantFunction NormalsEngineTag_t;
  void initializeNormals(
    Engine<dimensions, VectorType_t, NormalsEngineTag_t> &e,
    const Centering<dimensions> &c,
    bool outward = true) const
    {
      ;
      ;
      VectorType_t normal;
      for (int i = 0; i < dimensions; i++)
        {
          normal(i) = static_cast<T_t>(1 - c.orientation(0)[i].first());
          if (outward && c.position(0)(i) == 0.0)
            normal(i) *= static_cast<T_t>(-1);
        }
      e.setConstant(normal);
    }
  inline T_t DDX0(int) const { return 0.5; }
  inline T_t DDX0(const Loc_t&) const { return 0.5; }
  inline T_t DDX1(int) const { return 0.5; }
  inline T_t DDX1(const Loc_t&) const { return 0.5; }
  inline T_t DDY0(int) const { return 0.5; }
  inline T_t DDY0(const Loc_t&) const { return 0.5; }
  inline T_t DDY1(int) const { return 0.5; }
  inline T_t DDY1(const Loc_t&) const { return 0.5; }
  inline T_t DDZ0(int) const { return 0.5; }
  inline T_t DDZ0(const Loc_t&) const { return 0.5; }
  inline T_t DDZ1(int) const { return 0.5; }
  inline T_t DDZ1(const Loc_t&) const { return 0.5; }
};
template <class MeshTraits>
class RectilinearMeshData : public NoMeshData<MeshTraits::dimensions>
{
public:
  typedef typename MeshTraits::Domain_t Domain_t;
  typedef typename MeshTraits::MeshData_t MeshData_t;
  typedef typename MeshTraits::Scalar_t Scalar_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  RectilinearMeshData()
    {
    }
  template<class Layout>
  RectilinearMeshData(
    const Layout &layout,
    const PointType_t &origin,
    const SpacingsType_t &spacings)
  : NoMeshData<dimensions>(layout),
    origin_m(origin)
    {
      typedef Engine<1, Scalar_t, Brick> Engine_t;
      for (int i=0; i<dimensions; i++) {
 Interval<1> dom(layout.domain()[i]), idom(layout.innerDomain()[i]);
 spacings_m[i].engine() = Engine_t(dom);
 spacings_m[i] = spacings[i];
 Pooma::blockAndEvaluate();
 positions_m[i].engine() = Engine_t(dom);
 positions_m[i](idom.min()) = origin_m(i);
 for (int j=idom.min()-1; j>=dom.min(); j--)
   positions_m[i](j) = positions_m[i].read(j+1) - spacings_m[i].read(j);
 for (int j=idom.min()+1; j<=dom.max(); j++)
   positions_m[i](j) = positions_m[i].read(j-1) + spacings_m[i].read(j-1);
      }
    }
  template<class Layout>
  RectilinearMeshData(
    const Layout &layout,
    const PointType_t &origin,
    const VectorType_t &spacings)
  : NoMeshData<dimensions>(layout),
    origin_m(origin)
    {
      for (int i=0; i<dimensions; i++) {
 Interval<1> dom(layout.domain()[i]), idom(layout.innerDomain()[i]);
 spacings_m[i].engine() = Engine<1, Scalar_t, Brick>(dom, spacings(i));
 positions_m[i].engine() = Engine<1, Scalar_t, Brick>(dom);
 positions_m[i](idom.min()) = origin_m(i);
 for (int j=idom.min()-1; j>=dom.min(); j--)
   positions_m[i](j) = positions_m[i].read(j+1) - spacings_m[i].read(j);
 for (int j=idom.min()+1; j<=dom.max(); j++)
   positions_m[i](j) = positions_m[i].read(j-1) + spacings_m[i].read(j-1);
      }
    }
  RectilinearMeshData(const MeshData_t &model)
  : NoMeshData<dimensions>(model),
    origin_m(model.origin_m)
    {
      for (int i=0; i<dimensions; i++) {
 spacings_m[i].engine() = model.spacings_m[i].engine();
 positions_m[i].engine() = model.positions_m[i].engine();
      }
    }
  RectilinearMeshData(const MeshData_t &model,
        const Interval<dimensions> &d)
  : NoMeshData<dimensions>(d)
    {
      typedef Engine<1, Scalar_t, Brick> Engine_t;
      for (int i = 0; i < dimensions; i++) {
 Interval<1> dom(d[i]);
 Interval<1> viewdom(dom.size());
 spacings_m[i].engine() = Engine_t(&model.spacings_m[i](dom)(0),
       viewdom);
 positions_m[i].engine() = Engine_t(&model.positions_m[i](dom)(0),
        viewdom);
 origin_m(i) = model.positions_m[i].read(dom.min());
      }
    }
  MeshData_t &
  operator=(const MeshData_t &rhs)
    {
      if (this != &rhs)
        {
          NoMeshData<dimensions>::operator=(rhs);
          origin_m = rhs.origin_m;
   for (int i=0; i<dimensions; i++) {
     spacings_m[i].engine() = rhs.spacings_m[i].engine();
     positions_m[i].engine() = rhs.positions_m[i].engine();
   }
        }
      return *this;
    }
  ~RectilinearMeshData() { }
  inline const SpacingsType_t &spacings() const
    {
      return spacings_m;
    }
  inline const PositionsType_t &positions() const
    {
      return positions_m;
    }
  inline const PointType_t &origin() const
    {
      return origin_m;
    }
private:
  PointType_t origin_m;
  SpacingsType_t spacings_m;
  PositionsType_t positions_m;
};
template<class MeshTraits>
class RectilinearMesh : public MeshTraits::CoordinateSystem_t
{
public:
  typedef MeshTraits MeshTraits_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::MeshData_t MeshData_t;
  typedef typename MeshTraits::CoordinateSystem_t CoordinateSystem_t;
  typedef typename MeshTraits::Domain_t Domain_t;
  typedef typename MeshTraits::Loc_t Loc_t;
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Scalar_t Scalar_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  RectilinearMesh()
  : data_m(new MeshData_t)
    {
    }
  template<class Layout>
  inline RectilinearMesh(const Layout &layout,
    const PointType_t &origin,
    const SpacingsType_t &spacings)
  : data_m(new MeshData_t(layout, origin, spacings))
    {
    }
  template<class Layout>
  inline RectilinearMesh(const Layout &layout,
    const PointType_t &origin,
    const PointType_t &spacings)
  : data_m(new MeshData_t(layout, origin, spacings))
    {
    }
  template<class Layout>
  inline explicit RectilinearMesh(const Layout &layout)
  : data_m(new MeshData_t(layout,
        PointType_t(0),
        PointType_t(1)))
    {
    }
  inline RectilinearMesh(const Mesh_t &model)
  : data_m(model.data_m)
    {
    }
  inline RectilinearMesh(const Mesh_t &model,
    const Domain_t &d)
  : data_m(new MeshData_t(*model.data_m, d))
    {
    }
  inline RectilinearMesh(const Mesh_t &model,
    const INode<dimensions> &i)
  : data_m(new MeshData_t(*model.data_m, i.domain()))
    {
    }
  inline Mesh_t &
  operator=(const Mesh_t &rhs)
    {
      if (&rhs != this)
        {
          data_m = rhs.data_m;
        }
      return *this;
    }
  ~RectilinearMesh()
    {
    }
  const MeshData_t& data() const
    {
      return *data_m;
    }
  inline const Domain_t &physicalVertexDomain() const
    {
      return data_m->physicalVertexDomain();
    }
  inline const Domain_t &physicalCellDomain() const
    {
      return data_m->physicalCellDomain();
    }
  inline const Domain_t &totalVertexDomain() const
    {
      return data_m->totalVertexDomain();
    }
  inline const Domain_t &totalCellDomain() const
    {
      return data_m->totalCellDomain();
    }
  inline const PointType_t &origin() const
    {
      return data_m->origin();
    }
  inline const SpacingsType_t &spacings() const
    {
      return data_m->spacings();
    }
  inline const PositionsType_t &positions() const
    {
      return data_m->positions();
    }
  inline Loc_t cellContaining(const PointType_t &point) const
    {
      Loc_t loc((Pooma::NoInit()));
      for (int i = 0; i < dimensions; i++)
 {
   const T_t *start = &positions()[i](0);
   const T_t *finish = start + positions()[i].physicalDomain()[i].length();
   const T_t *p = std::lower_bound(start, finish, point(i));
   int j = static_cast<int>(std::distance(start, p));
   if (*p == point(i))
     loc[i] = j;
   else
     loc[i] = j-1;
 }
      return loc;
    }
  inline PointType_t vertexPosition(const Loc_t &loc) const
    {
      PointType_t point;
      for (int i = 0; i < dimensions; i++)
        point(i) = positions()[i](loc[i]);
      return point;
    }
  inline Scalar_t vertexPosition(int dim, int i) const
    {
      return positions()[dim](i);
    }
  inline PointType_t cellPosition(const Loc_t &loc) const
    {
      PointType_t point;
      for (int i=0; i<dimensions; i++)
 point(i) = positions()[i](loc[i]) + 0.5*spacings()[i](loc[i]);
      return point;
    }
  inline Scalar_t cellPosition(int dim, int i) const
    {
      return positions()[dim](i) + 0.5*spacings()[dim](i);
    }
  inline VectorType_t vertexSpacing(const Loc_t &loc) const
    {
      VectorType_t delta;
      for (int i=0; i<dimensions; i++)
 delta(i) = spacings()[i](loc[i]);
      return delta;
    }
  inline Scalar_t vertexSpacing(int dim, int i) const
    {
      return spacings()[dim](i);
    }
  inline VectorType_t cellSpacing(const Loc_t &loc) const
    {
      VectorType_t delta;
      for (int i=0; i<dimensions; i++)
 delta(i) = 0.5 * (spacings()[i](loc[i]) + spacings()[i](loc[i]+1));
      return delta;
    }
  inline Scalar_t cellSpacing(int dim, int i) const
    {
      return 0.5*(spacings()[dim](i) + spacings()[dim](i+1));
    }
private:
  RefCountedPtr<MeshData_t> data_m;
};
template <class MeshTraits>
struct GenericRM {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  typedef typename MeshTraits::Loc_t Loc_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  class PositionsFunctor {
  public:
    PositionsFunctor() { }
    PositionsFunctor(const Mesh_t &m,
                     const Centering<dimensions> &c)
      : centering_m(c.position(0))
      {
 for (int i=0; i<dimensions; i++) {
   positions_m[i].engine() = m.positions()[i].engine();
   spacings_m[i].engine() = m.spacings()[i].engine();
 }
      }
    PositionsFunctor(const PositionsFunctor &m)
      : centering_m(m.centering_m)
    {
      for (int i=0; i<dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
    }
    PositionsFunctor& operator=(const PositionsFunctor &m)
    {
      centering_m = m.centering_m;
      for (int i=0; i<dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
      {
        return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
      }
    inline PointType_t operator()(int i0, int i1) const
      {
        return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
      }
    inline PointType_t operator()(int i0, int i1, int i2) const
      {
        return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  typedef IndexFunction<PositionsFunctor> PositionsEngineTag_t;
  template <class PositionsEngineTag>
  void initializePositions(
    Engine<dimensions, PointType_t, PositionsEngineTag> &e,
    const Centering<dimensions> &c) const
    {
      e.setFunctor(typename PositionsEngineTag::Functor_t(static_cast<const Mesh_t&>(*this), c));
    }
  class SpacingsFunctor {
  public:
    SpacingsFunctor() { }
    SpacingsFunctor(const Mesh_t &m,
      const Centering<dimensions> &c)
      : centering_m(c.position(0))
      {
 for (int i=0; i<dimensions; i++)
   spacings_m[i].engine() = m.spacings()[i].engine();
      }
    SpacingsFunctor(const SpacingsFunctor &m)
      : centering_m(m.centering_m)
    {
      for (int i=0; i<dimensions; i++)
 spacings_m[i].engine() = m.spacings_m[i].engine();
    }
    SpacingsFunctor& operator=(const SpacingsFunctor &m)
    {
      centering_m = m.centering_m;
      for (int i=0; i<dimensions; i++)
 spacings_m[i].engine() = m.spacings_m[i].engine();
      return *this;
    }
    inline VectorType_t operator()(int i0) const
      {
        return VectorType_t(spacings_m[0].read(i0)
      + (spacings_m[0].read(i0+1)-spacings_m[0].read(i0))*centering_m(0));
      }
    inline VectorType_t operator()(int i0, int i1) const
      {
        return VectorType_t(spacings_m[0].read(i0)
      + (spacings_m[0].read(i0+1)-spacings_m[0].read(i0))*centering_m(0),
      spacings_m[1].read(i1)
      + (spacings_m[1].read(i1+1)-spacings_m[1].read(i1))*centering_m(1));
      }
    inline VectorType_t operator()(int i0, int i1, int i2) const
      {
        return VectorType_t(spacings_m[0].read(i0)
      + (spacings_m[0].read(i0+1)-spacings_m[0].read(i0))*centering_m(0),
      spacings_m[1].read(i1)
      + (spacings_m[1].read(i1+1)-spacings_m[1].read(i1))*centering_m(1),
      spacings_m[2].read(i2)
      + (spacings_m[2].read(i2+1)-spacings_m[2].read(i2))*centering_m(2));
      }
  private:
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  typedef IndexFunction<SpacingsFunctor> SpacingsEngineTag_t;
  void initializeSpacings(
    Engine<dimensions, PointType_t, SpacingsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      e.setFunctor(SpacingsFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef ConstantFunction NormalsEngineTag_t;
  void initializeNormals(
    Engine<dimensions, VectorType_t, NormalsEngineTag_t> &e,
    const Centering<dimensions> &c,
    bool outward = true) const
    {
      ;
      ;
      VectorType_t normal;
      for (int i = 0; i < dimensions; i++)
        {
          normal(i) = static_cast<T_t>(1 - c.orientation(0)[i].first());
          if (outward && c.position(0)(i) == 0.0)
            normal(i) *= static_cast<T_t>(-1);
        }
      e.setConstant(normal);
    }
  inline T_t DDX0(int i) const
  {
    return (static_cast<const Mesh_t&>(*this).cellPosition( 0, i)
     - static_cast<const Mesh_t&>(*this).vertexPosition( 0, i))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 0, i-1);
  }
  inline T_t DDX0(const Loc_t& l) const { return DDX0(l[0].first()); }
  inline T_t DDX1(int i) const
  {
    return (static_cast<const Mesh_t&>(*this).vertexPosition( 0, i)
     - static_cast<const Mesh_t&>(*this).cellPosition( 0, i-1))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 0, i-1);
  }
  inline T_t DDX1(const Loc_t& l) const { return DDX0(l[0].first()); }
  inline T_t DDY0(int j) const
  {
    return (static_cast<const Mesh_t&>(*this).cellPosition( 1, j)
     - static_cast<const Mesh_t&>(*this).vertexPosition( 1, j))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 1, j-1);
  }
  inline T_t DDY0(const Loc_t& l) const { return DDX0(l[0].first()); }
  inline T_t DDY1(int j) const
  {
    return (static_cast<const Mesh_t&>(*this).vertexPosition( 1, j)
     - static_cast<const Mesh_t&>(*this).cellPosition( 1, j-1))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 1, j-1);
  }
  inline T_t DDY1(const Loc_t& l) const { return DDX0(l[0].first()); }
  inline T_t DDZ0(int k) const
  {
    return (static_cast<const Mesh_t&>(*this).cellPosition( 2, k)
     - static_cast<const Mesh_t&>(*this).vertexPosition( 2, k))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 2, k-1);
  }
  inline T_t DDZ0(const Loc_t& l) const { return DDX0(l[0].first()); }
  inline T_t DDZ1(int k) const
  {
    return (static_cast<const Mesh_t&>(*this).vertexPosition( 1, k)
     - static_cast<const Mesh_t&>(*this).cellPosition( 1, k-1))
      / static_cast<const Mesh_t&>(*this).cellSpacing( 1, k-1);
  }
  inline T_t DDZ1(const Loc_t& l) const { return DDX0(l[0].first()); }
};
template <class MeshTraits>
struct CartesianRM : public GenericRM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  class GeneralVolumesFunctor {
  public:
    GeneralVolumesFunctor() { }
    GeneralVolumesFunctor(const Mesh_t &m,
     const Centering<dimensions> &c)
      : orientation_m(c.orientation(0))
      {
 for (int i=0; i<dimensions; i++)
   spacings_m[i].engine() = m.spacings()[i].engine();
      }
    GeneralVolumesFunctor(const GeneralVolumesFunctor &m)
      : orientation_m(m.orientation_m)
      {
 for (int i=0; i<dimensions; i++)
   spacings_m[i].engine() = m.spacings_m[i].engine();
      }
    GeneralVolumesFunctor& operator=(const GeneralVolumesFunctor &m)
    {
      orientation_m = m.orientation_m;
      for (int i=0; i<dimensions; i++)
 spacings_m[i].engine() = m.spacings_m[i].engine();
      return *this;
    }
    inline T_t operator()(int i0) const
      {
 return spacings_m[0].read(i0);
      }
    inline T_t operator()(int i0, int i1) const
      {
 if (orientation_m[0].first() == 0)
   return spacings_m[1].read(i1);
 else if (orientation_m[1].first() == 0)
   return spacings_m[0].read(i0);
 else
   return spacings_m[0].read(i0) * spacings_m[1].read(i1);
      }
    inline T_t operator()(int i0, int i1, int i2) const
      {
 T_t volume = static_cast<T_t>(1);
 if (orientation_m[0].first() != 0)
   volume *= spacings_m[0].read(i0);
 if (orientation_m[1].first() != 0)
   volume *= spacings_m[1].read(i1);
 if (orientation_m[2].first() != 0)
   volume *= spacings_m[2].read(i2);
 return volume;
      }
  private:
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Orientation orientation_m;
  };
  typedef IndexFunction<GeneralVolumesFunctor> CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  class SphericalPositionsFunctor {
  public:
    SphericalPositionsFunctor() {}
    SphericalPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    SphericalPositionsFunctor& operator=(const SphericalPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t x(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
      return PointType_t(norm(x),
    atan2(x(0), x(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t x(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      T_t r = norm(x);
      return PointType_t(r,
    acos(x(2)/r),
    atan2(x(1), x(0)));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  class CylindricalPositionsFunctor {
  public:
    CylindricalPositionsFunctor() {}
    CylindricalPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    CylindricalPositionsFunctor& operator=(const CylindricalPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
    positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t x(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      return PointType_t(norm(Vector<2, T_t>(x(0), x(1))),
    x(2),
    atan2(x(1), x(0)));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  typedef IndexFunction<typename GenericRM<MeshTraits>::PositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<CylindricalPositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<SphericalPositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 0, i);
  }
  inline T_t VOLXA(const Loc<dimensions>& l) const { return VOLXA(l[0].first()); }
  inline T_t VOLYA(int j) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 1, j);
  }
  inline T_t VOLYA(const Loc<dimensions>& l) const { return VOLYA(l[1].first()); }
  inline T_t VOLZA(int k) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 2, k);
  }
  inline T_t VOLZA(const Loc<dimensions>& l) const { return VOLZA(l[2].first()); }
  inline T_t VOLXB(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 0, i);
  }
  inline T_t VOLXB(const Loc<dimensions>& l) const { return VOLXB(l[0].first()); }
  inline T_t VOLYB(int j) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 1, j);
  }
  inline T_t VOLYB(const Loc<dimensions>& l) const { return VOLYB(l[1].first()); }
  inline T_t VOLZB(int k) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 2, k);
  }
  inline T_t VOLZB(const Loc<dimensions>& l) const { return VOLZB(l[2].first()); }
  inline One<T_t> SURXA(int) const { return One<T_t>(); }
  inline One<T_t> SURXA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURYA(int) const { return One<T_t>(); }
  inline One<T_t> SURYA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURXB(int) const { return One<T_t>(); }
  inline One<T_t> SURXB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURYB(int) const { return One<T_t>(); }
  inline One<T_t> SURYB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCXA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> GEOXG(int) const { return One<T_t>(); }
  inline One<T_t> GEOXG(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXH(int) const { return One<T_t>(); }
  inline One<T_t> GEOXH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOYH(int) const { return One<T_t>(); }
  inline One<T_t> GEOYH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXHA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(const Loc<dimensions>&) const { return One<T_t>(); }
};
template <class MeshTraits>
struct CartesianURM : public GenericURM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  inline void initializeGeneralVolume(
    Engine<dimensions, T_t, ConstantFunction> &e,
    const Centering<dimensions> &c) const
    {
      T_t volume = static_cast<T_t>(1);
      for (int i = 0; i < dimensions; i++)
        {
          if (c.orientation(0)[i].first() != 0)
            volume *= static_cast<const Mesh_t&>(*this).spacings()(i);
        }
      e.setConstant(volume);
    }
  typedef ConstantFunction CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      initializeGeneralVolume(e, c);
    }
  typedef ConstantFunction FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      initializeGeneralVolume(e, c);
    }
  typedef ConstantFunction EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      initializeGeneralVolume(e, c);
    }
  class SphericalPositionsFunctor {
  public:
    SphericalPositionsFunctor() {}
    SphericalPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
 origin_m(i) += spacings_m(i) *
   (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t x(origin_m + PointType_t(i0, i1) * spacings_m);
      return PointType_t(norm(x),
    atan2(x(0), x(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t x(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      T_t r = norm(x);
      return PointType_t(r,
    acos(x(2)/r),
    atan2(x(1), x(0)));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  class CylindricalPositionsFunctor {
  public:
    CylindricalPositionsFunctor() {}
    CylindricalPositionsFunctor(const Mesh_t &m,
           const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
 origin_m(i) += spacings_m(i) *
   (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      return origin_m + PointType_t(i0, i1) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t x(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      return PointType_t(norm(Vector<2, T_t>(x(0), x(1))),
    x(2),
    atan2(x(1), x(0)));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  typedef IndexFunction<typename GenericURM<MeshTraits>::PositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<CylindricalPositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<SphericalPositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(0);
  }
  inline T_t VOLXA(const Loc<dimensions>&) const { return VOLXA(0); }
  inline T_t VOLYA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(1);
  }
  inline T_t VOLYA(const Loc<dimensions>&) const { return VOLYA(0); }
  inline T_t VOLZA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZA(const Loc<dimensions>&) const { return VOLZA(0); }
  inline T_t VOLXB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(0);
  }
  inline T_t VOLXB(const Loc<dimensions>&) const { return VOLXB(0); }
  inline T_t VOLYB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(1);
  }
  inline T_t VOLYB(const Loc<dimensions>&) const { return VOLYB(0); }
  inline T_t VOLZB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZB(const Loc<dimensions>&) const { return VOLZB(0); }
  inline One<T_t> SURXA(int) const { return One<T_t>(); }
  inline One<T_t> SURXA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURYA(int) const { return One<T_t>(); }
  inline One<T_t> SURYA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURXB(int) const { return One<T_t>(); }
  inline One<T_t> SURXB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURYB(int) const { return One<T_t>(); }
  inline One<T_t> SURYB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCXA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCXB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> GEOXG(int) const { return One<T_t>(); }
  inline One<T_t> GEOXG(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXH(int) const { return One<T_t>(); }
  inline One<T_t> GEOXH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOYH(int) const { return One<T_t>(); }
  inline One<T_t> GEOYH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXHA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(const Loc<dimensions>&) const { return One<T_t>(); }
};
template <class MeshTraits>
struct CylindricalRM : public GenericRM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  class GeneralVolumesFunctor {
  public:
    GeneralVolumesFunctor() { }
    GeneralVolumesFunctor(const Mesh_t &m,
     const Centering<dimensions> &c)
      : orientation_m(c.orientation(0))
      {
 for (int i=0; i<dimensions; i++) {
   spacings_m[i].engine() = m.spacings()[i].engine();
   positions_m[i].engine() = m.positions()[i].engine();
 }
      }
    GeneralVolumesFunctor(const GeneralVolumesFunctor &m)
      : orientation_m(m.orientation_m)
      {
 for (int i=0; i<dimensions; i++) {
   spacings_m[i].engine() = m.spacings_m[i].engine();
   positions_m[i].engine() = m.positions_m[i].engine();
 }
      }
    GeneralVolumesFunctor& operator=(const GeneralVolumesFunctor &m)
    {
      orientation_m = m.orientation_m;
      for (int i=0; i<dimensions; i++) {
 spacings_m[i].engine() = m.spacings_m[i].engine();
 positions_m[i].engine() = m.positions_m[i].engine();
      }
      return *this;
    }
    inline T_t r(int i0) const
      {
 return positions_m[0].read(i0);
      }
    inline T_t operator()(int i0) const
      {
 return spacings_m[0].read(i0);
      }
    inline T_t operator()(int i0, int i1) const
      {
 if (orientation_m[0].first() == 0)
   return spacings_m[1].read(i1);
 else if (orientation_m[1].first() == 0)
   return spacings_m[0].read(i0);
 else
   return spacings_m[0].read(i0) * spacings_m[1].read(i1);
      }
    inline T_t operator()(int i0, int i1, int i2) const
      {
 if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0
     && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m[1].read(i1) * spacings_m[2].read(i2);
 } else if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0)
   return spacings_m[0].read(i0)*spacings_m[1].read(i1);
 else if (orientation_m[0].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m[2].read(i2);
 } else if (orientation_m[1].first() != 0
     && orientation_m[2].first() != 0)
   return r(i0)*spacings_m[1].read(i1)*spacings_m[2].read(i2);
 else if (orientation_m[0].first() != 0)
   return spacings_m[0].read(i0);
 else if (orientation_m[1].first() != 0)
   return spacings_m[1].read(i1);
 else if (orientation_m[2].first() != 0)
   return r(i0)*spacings_m[2].read(i2);
      }
  private:
    SpacingsType_t spacings_m;
    PositionsType_t positions_m;
    typename Centering<dimensions>::Orientation orientation_m;
  };
  typedef IndexFunction<GeneralVolumesFunctor> CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  class CartesianPositionsFunctor {
  public:
    CartesianPositionsFunctor() {}
    CartesianPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    CartesianPositionsFunctor& operator=(const CartesianPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
    positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      return PointType_t(r(0)*cos(r(2)),
                         r(0)*sin(r(2)),
                         r(1));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  class SphericalPositionsFunctor {
  public:
    SphericalPositionsFunctor() {}
    SphericalPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    SphericalPositionsFunctor& operator=(const SphericalPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
      T_t R = hypot(r(0), r(1));
      return PointType_t(R,
    acos(r(1)/R));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      T_t R = hypot(r(0), r(1));
      return PointType_t(R,
    acos(r(1)/R),
                         r(2));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  typedef IndexFunction<CartesianPositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<typename GenericRM<MeshTraits>::PositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<SphericalPositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int i) const
  {
    return 0.5*(std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 2)
  - std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i-1), 2));
  }
  inline T_t VOLXA(const Loc<dimensions>& l) const { return VOLXA(l[0].first()); }
  inline T_t VOLYA(int j) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 1, j);
  }
  inline T_t VOLYA(const Loc<dimensions>& l) const { return VOLYA(l[1].first()); }
  inline T_t VOLZA(int k) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 2, k);
  }
  inline T_t VOLZA(const Loc<dimensions>& l) const { return VOLZA(l[2].first()); }
  inline T_t VOLXB(int i) const
  {
    return 0.5*(std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i+1), 2)
  - std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i), 2));
  }
  inline T_t VOLXB(const Loc<dimensions>& l) const { return VOLXB(l[0].first()); }
  inline T_t VOLYB(int j) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 1, j);
  }
  inline T_t VOLYB(const Loc<dimensions>& l) const { return VOLYB(l[1].first()); }
  inline T_t VOLZB(int k) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 2, k);
  }
  inline T_t VOLZB(const Loc<dimensions>& l) const { return VOLZB(l[2].first()); }
  inline T_t SURXA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t SURXA(const Loc<dimensions>& l) const { return SURXA(l[0].first()); }
  inline One<T_t> SURYA(int) const { return One<T_t>(); }
  inline One<T_t> SURYA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t SURXB(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t SURXB(const Loc<dimensions>& l) const { return SURXB(l[0].first()); }
  inline One<T_t> SURYB(int) const { return One<T_t>(); }
  inline One<T_t> SURYB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> CCXA(int) const { return One<T_t>(); }
  inline One<T_t> CCXA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCYA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> CCXB(int) const { return One<T_t>(); }
  inline One<T_t> CCXB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCYB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> GEOXG(int) const { return One<T_t>(); }
  inline One<T_t> GEOXG(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t GEOXH(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXH(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline One<T_t> GEOYH(int) const { return One<T_t>(); }
  inline One<T_t> GEOYH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t GEOXHA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXHA(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline One<T_t> GEOYHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(const Loc<dimensions>&) const { return One<T_t>(); }
};
template <class MeshTraits>
struct CylindricalURM : public GenericURM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  enum { dimensions = MeshTraits::dimensions };
  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
  class GeneralVolumesFunctor {
  public:
    GeneralVolumesFunctor() { }
    GeneralVolumesFunctor(const Mesh_t &m,
     const Centering<dimensions> &c)
      : spacings_m(m.spacings()),
        orientation_m(c.orientation(0)),
        origin_m(m.origin())
      {
      }
    inline T_t r(int i0) const
      {
 return origin_m(0)+i0*spacings_m(0);
      }
    inline T_t operator()(int i0) const
      {
 return spacings_m(0);
      }
    inline T_t operator()(int i0, int i1) const
      {
 if (orientation_m[0].first() == 0)
   return spacings_m(1);
 else if (orientation_m[1].first() == 0)
   return spacings_m(0);
 else
   return spacings_m(0) * spacings_m(1);
      }
    inline T_t operator()(int i0, int i1, int i2) const
      {
 if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0
     && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m(1) * spacings_m(2);
 } else if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0)
   return spacings_m(0) * spacings_m(1);
 else if (orientation_m[0].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m(2);
 } else if (orientation_m[1].first() != 0
     && orientation_m[2].first() != 0)
   return r(i0)*spacings_m(1) * spacings_m(2);
 else if (orientation_m[0].first() != 0)
   return spacings_m(0);
 else if (orientation_m[1].first() != 0)
   return spacings_m(1);
 else if (orientation_m[2].first() != 0)
   return r(i0)*spacings_m(2);
      }
  private:
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Orientation orientation_m;
    PointType_t origin_m;
  };
  typedef IndexFunction<GeneralVolumesFunctor> CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  class CartesianPositionsFunctor {
  public:
    CartesianPositionsFunctor() {}
    CartesianPositionsFunctor(const Mesh_t &m,
                              const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
        origin_m(i) += spacings_m(i) *
          (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      return origin_m + PointType_t(i0, i1) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      return PointType_t(r(0)*cos(r(2)),
                         r(0)*sin(r(2)),
                         r(1));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  class SphericalPositionsFunctor {
  public:
    SphericalPositionsFunctor() {}
    SphericalPositionsFunctor(const Mesh_t &m,
                              const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
        origin_m(i) += spacings_m(i) *
          (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1) * spacings_m);
      T_t R = hypot(r(0), r(1));
      return PointType_t(R,
    acos(r(1)/R));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      T_t R = hypot(r(0), r(1));
      return PointType_t(R,
    acos(r(1)/R),
                         r(2));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  typedef IndexFunction<CartesianPositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<typename GenericURM<MeshTraits>::PositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<SphericalPositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int i) const
  {
    return 0.5*(std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 2)
  - std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i-1), 2));
  }
  inline T_t VOLXA(const Loc<dimensions>& l) const { return VOLXA(l[0].first()); }
  inline T_t VOLYA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(1);
  }
  inline T_t VOLYA(const Loc<dimensions>&) const { return VOLYA(0); }
  inline T_t VOLZA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZA(const Loc<dimensions>&) const { return VOLZA(0); }
  inline T_t VOLXB(int i) const
  {
    return 0.5*(std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i+1), 2)
  - std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i), 2));
  }
  inline T_t VOLXB(const Loc<dimensions>& l) const { return VOLXB(l[0].first()); }
  inline T_t VOLYB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(1);
  }
  inline T_t VOLYB(const Loc<dimensions>&) const { return VOLYB(0); }
  inline T_t VOLZB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZB(const Loc<dimensions>&) const { return VOLZB(0); }
  inline T_t SURXA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t SURXA(const Loc<dimensions>& l) const { return SURXA(l[0].first()); }
  inline One<T_t> SURYA(int) const { return One<T_t>(); }
  inline One<T_t> SURYA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t SURXB(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t SURXB(const Loc<dimensions>& l) const { return SURXB(l[0].first()); }
  inline One<T_t> SURYB(int) const { return One<T_t>(); }
  inline One<T_t> SURYB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> CCXA(int) const { return One<T_t>(); }
  inline One<T_t> CCXA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCYA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> CCXB(int) const { return One<T_t>(); }
  inline One<T_t> CCXB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline Zero<T_t> CCYB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCYB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline One<T_t> GEOXG(int) const { return One<T_t>(); }
  inline One<T_t> GEOXG(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t GEOXH(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXH(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline One<T_t> GEOYH(int) const { return One<T_t>(); }
  inline One<T_t> GEOYH(const Loc<dimensions>&) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(int) const { return One<T_t>(); }
  inline One<T_t> GEOXGA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t GEOXHA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXHA(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline One<T_t> GEOYHA(int) const { return One<T_t>(); }
  inline One<T_t> GEOYHA(const Loc<dimensions>&) const { return One<T_t>(); }
};
template <class MeshTraits>
struct SphericalRM : public GenericRM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  typedef typename MeshTraits::PositionsType_t PositionsType_t;
  enum { dimensions = MeshTraits::dimensions };
  class GeneralVolumesFunctor {
  public:
    GeneralVolumesFunctor() { }
    GeneralVolumesFunctor(const Mesh_t &m,
     const Centering<dimensions> &c)
      : orientation_m(c.orientation(0))
      {
 for (int i=0; i<dimensions; i++) {
   spacings_m[i].engine() = m.spacings()[i].engine();
   positions_m[i].engine() = m.positions()[i].engine();
 }
      }
    GeneralVolumesFunctor(const GeneralVolumesFunctor &m)
      : orientation_m(m.orientation_m)
      {
 for (int i=0; i<dimensions; i++) {
   spacings_m[i].engine() = m.spacings_m[i].engine();
   positions_m[i].engine() = m.positions_m[i].engine();
 }
      }
    GeneralVolumesFunctor& operator=(const GeneralVolumesFunctor &m)
    {
      orientation_m = m.orientation_m;
      for (int i=0; i<dimensions; i++) {
 spacings_m[i].engine() = m.spacings_m[i].engine();
 positions_m[i].engine() = m.positions_m[i].engine();
      }
      return *this;
    }
    inline T_t r(int i0) const
      {
 return positions_m[0].read(i0);
      }
    inline T_t theta(int i1) const
      {
 return positions_m[1].read(i1);
      }
    inline T_t phi(int i2) const
      {
 return positions_m[2].read(i2);
      }
    inline T_t operator()(int i0) const
      {
 return spacings_m[0].read(i0);
      }
    inline T_t operator()(int i0, int i1) const
      {
 if (orientation_m[0].first() == 0)
   return r(i0)*spacings_m[1].read(i1);
 else if (orientation_m[1].first() == 0)
   return spacings_m[0].read(i0);
 else {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m[1].read(i1);
 }
      }
    inline T_t operator()(int i0, int i1, int i2) const
      {
 if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0
     && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return (r2*r2*r2 - r1*r1*r1)/3.0
     * (cos(theta(i1)) - cos(theta(i1+1)))
     * spacings_m[2].read(i2);
 } else if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m[1].read(i1);
 } else if (orientation_m[0].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1)*sin(theta(i1)) * spacings_m[2].read(i2);
 } else if (orientation_m[1].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   return - r1*r1 * spacings_m[2].read(i2) * (cos(theta(i1+1)) - cos(theta(i1)));
 } else if (orientation_m[0].first() != 0)
   return spacings_m[0].read(i0);
 else if (orientation_m[1].first() != 0)
   return r(i0)*spacings_m[1].read(i1);
 else if (orientation_m[2].first() != 0)
   return r(i0)*sin(theta(i1)) * spacings_m[2].read(i2);
      }
  private:
    SpacingsType_t spacings_m;
    SpacingsType_t positions_m;
    typename Centering<dimensions>::Orientation orientation_m;
  };
  typedef IndexFunction<GeneralVolumesFunctor> CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  class CartesianPositionsFunctor {
  public:
    CartesianPositionsFunctor() {}
    CartesianPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    CartesianPositionsFunctor& operator=(const CartesianPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      return PointType_t(r(0)*sin(r(1))*cos(r(2)),
    r(0)*sin(r(1))*sin(r(2)),
    r(0)*cos(r(1)));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  class CylindricalPositionsFunctor {
  public:
    CylindricalPositionsFunctor() {}
    CylindricalPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : centering_m(c.position(0))
    {
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions()[i].engine();
 spacings_m[i].engine() = m.spacings()[i].engine();
      }
    }
    CylindricalPositionsFunctor& operator=(const CylindricalPositionsFunctor& m)
    {
      centering_m = m.centering_m;
      for (int i = 0; i < dimensions; i++) {
 positions_m[i].engine() = m.positions_m[i].engine();
 spacings_m[i].engine() = m.spacings_m[i].engine();
      }
      return *this;
    }
    inline PointType_t operator()(int i0) const
    {
      return PointType_t(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0));
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1));
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(positions_m[0].read(i0) + spacings_m[0].read(i0)*centering_m(0),
      positions_m[1].read(i1) + spacings_m[1].read(i1)*centering_m(1),
      positions_m[2].read(i2) + spacings_m[2].read(i2)*centering_m(2));
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)),
    r(2));
    }
  private:
    PositionsType_t positions_m;
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Position centering_m;
  };
  typedef IndexFunction<CartesianPositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<CylindricalPositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<typename GenericRM<MeshTraits>::PositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int i) const
  {
    return (1.0/3.0)*(std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 3)
        - std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i-1), 3));
  }
  inline T_t VOLXA(const Loc<dimensions>& l) const { return VOLXA(l[0].first()); }
  inline T_t VOLYA(int j) const
  {
    return std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j-1))
      - std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t VOLYA(const Loc<dimensions>& l) const { return VOLYA(l[1].first()); }
  inline T_t VOLZA(int k) const
  {
    return static_cast<const Mesh_t&>(*this).cellSpacing( 2, k-1);
  }
  inline T_t VOLZA(const Loc<dimensions>& l) const { return VOLZA(l[2].first()); }
  inline T_t VOLXB(int i) const
  {
    return (1.0/3.0)*(std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i+1), 3)
        - std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 3));
  }
  inline T_t VOLXB(const Loc<dimensions>& l) const { return VOLXB(l[0].first()); }
  inline T_t VOLYB(int j) const
  {
    return std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j))
      - std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j+1));
   }
  inline T_t VOLYB(const Loc<dimensions>& l) const { return VOLYB(l[1].first()); }
  inline T_t VOLZB(int k) const
  {
    return static_cast<const Mesh_t&>(*this).vertexSpacing( 2, k);
  }
  inline T_t VOLZB(const Loc<dimensions>& l) const { return VOLZB(l[2].first()); }
  inline T_t SURXA(int i) const
  {
    return std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i), 2);
  }
  inline T_t SURXA(const Loc<dimensions>& l) const { return SURXA(l[0].first()); }
  inline T_t SURYA(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t SURYA(const Loc<dimensions>& l) const { return SURYA(l[1].first()); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t SURXB(int i) const
  {
    return std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 2);
  }
  inline T_t SURXB(const Loc<dimensions>& l) const { return SURXB(l[0].first()); }
  inline T_t SURYB(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t SURYB(const Loc<dimensions>& l) const { return SURYB(l[1].first()); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t CCXA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t CCXA(const Loc<dimensions>& l) const { return CCXA(l[0].first()); }
  inline T_t CCYA(int j) const
  {
    return 0.5*std::cos(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t CCYA(const Loc<dimensions>& l) const { return CCYA(l[1].first()); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline T_t CCXB(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t CCXB(const Loc<dimensions>& l) const { return CCXB(l[0].first()); }
  inline T_t CCYB(int j) const
  {
    return 0.5*std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t CCYB(const Loc<dimensions>& l) const { return CCYB(l[1].first()); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline T_t GEOXG(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXG(const Loc<dimensions>& l) const { return GEOXG(l[0].first()); }
  inline T_t GEOXH(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXH(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline T_t GEOYH(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t GEOYH(const Loc<dimensions>& l) const { return GEOYH(l[1].first()); }
  inline T_t GEOXGA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXGA(const Loc<dimensions>& l) const { return GEOXG(l[0].first()); }
  inline T_t GEOXHA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXHA(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline T_t GEOYHA(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t GEOYHA(const Loc<dimensions>& l) const { return GEOYH(l[1].first()); }
};
template <class MeshTraits>
struct SphericalURM : public GenericURM<MeshTraits> {
  typedef typename MeshTraits::T_t T_t;
  typedef typename MeshTraits::Mesh_t Mesh_t;
  typedef typename MeshTraits::PointType_t PointType_t;
  typedef typename MeshTraits::VectorType_t VectorType_t;
  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
  enum { dimensions = MeshTraits::dimensions };
  class GeneralVolumesFunctor {
  public:
    GeneralVolumesFunctor() { }
    GeneralVolumesFunctor(const Mesh_t &m,
     const Centering<dimensions> &c)
      : spacings_m(m.spacings()),
        orientation_m(c.orientation(0)),
        origin_m(m.origin())
      {
      }
    inline T_t r(int i0) const
      {
 return origin_m(0)+i0*spacings_m(0);
      }
    inline T_t theta(int i1) const
      {
 return origin_m(1)+i1*spacings_m(1);
      }
    inline T_t operator()(int i0) const
      {
 return spacings_m(0);
      }
    inline T_t operator()(int i0, int i1) const
      {
 if (orientation_m[0].first() == 0)
   return r(i0)*spacings_m(1);
 else if (orientation_m[1].first() == 0)
   return spacings_m(0);
 else {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1) * spacings_m(1);
 }
      }
    inline T_t operator()(int i0, int i1, int i2) const
      {
 if (orientation_m[0].first() != 0
     && orientation_m[1].first() != 0
     && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r1 + spacings_m(0);
   return (r2*r2*r2 - r1*r1*r1)/3.0
     * (cos(theta(i1)) - cos(theta(i1+1)))
     * spacings_m(2);
 } else if (orientation_m[0].first() != 0
   && orientation_m[1].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r1 + spacings_m(0);
   return 0.5*(r2*r2 - r1*r1) * spacings_m(1);
 } else if (orientation_m[0].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   T_t r2 = r(i0+1);
   return 0.5*(r2*r2 - r1*r1)*sin(theta(i1)) * spacings_m(2);
 } else if (orientation_m[1].first() != 0
   && orientation_m[2].first() != 0) {
   T_t r1 = r(i0);
   return - r1*r1 * spacings_m(2) * (cos(theta(i1+1)) - cos(theta(i1)));
 } else if (orientation_m[0].first() != 0)
   return spacings_m(0);
 else if (orientation_m[1].first() != 0)
   return r(i0)*spacings_m(1);
 else if (orientation_m[2].first() != 0)
   return r(i0)*sin(theta(i1)) * spacings_m(2);
      }
  private:
    SpacingsType_t spacings_m;
    typename Centering<dimensions>::Orientation orientation_m;
    PointType_t origin_m;
  };
  typedef IndexFunction<GeneralVolumesFunctor> CellVolumesEngineTag_t;
  void initializeCellVolumes(
    Engine<dimensions, T_t, CellVolumesEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> FaceAreasEngineTag_t;
  void initializeFaceAreas(
    Engine<dimensions, T_t, FaceAreasEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  typedef IndexFunction<GeneralVolumesFunctor> EdgeLengthsEngineTag_t;
  void initializeEdgeLengths(
    Engine<dimensions, T_t, EdgeLengthsEngineTag_t> &e,
    const Centering<dimensions> &c) const
    {
      ;
      ;
      e.setFunctor(GeneralVolumesFunctor(static_cast<const Mesh_t&>(*this), c));
    }
  class CartesianPositionsFunctor {
  public:
    CartesianPositionsFunctor() {}
    CartesianPositionsFunctor(const Mesh_t &m,
         const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
 origin_m(i) += spacings_m(i) *
   (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1) * spacings_m);
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      return PointType_t(r(0)*sin(r(1))*cos(r(2)),
    r(0)*sin(r(1))*sin(r(2)),
    r(0)*cos(r(1)));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  class CylindricalPositionsFunctor {
  public:
    CylindricalPositionsFunctor() {}
    CylindricalPositionsFunctor(const Mesh_t &m,
           const Centering<dimensions> &c)
      : origin_m(m.origin()), spacings_m(m.spacings())
    {
      for (int i = 0; i < dimensions; i++)
 origin_m(i) += spacings_m(i) *
   (c.position(0)(i) - m.physicalCellDomain()[i].first());
    }
    inline PointType_t operator()(int i0) const
    {
      return origin_m + PointType_t(i0) * spacings_m;
    }
    inline PointType_t operator()(int i0, int i1) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1) * spacings_m);
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)));
    }
    inline PointType_t operator()(int i0, int i1, int i2) const
    {
      PointType_t r(origin_m + PointType_t(i0, i1, i2) * spacings_m);
      return PointType_t(r(0)*sin(r(1)),
    r(0)*cos(r(1)),
    r(2));
    }
  private:
    PointType_t origin_m;
    SpacingsType_t spacings_m;
  };
  typedef IndexFunction<CartesianPositionsFunctor> CartesianPositionsEngineTag_t;
  typedef IndexFunction<CylindricalPositionsFunctor> CylindricalPositionsEngineTag_t;
  typedef IndexFunction<typename GenericURM<MeshTraits>::PositionsFunctor> SphericalPositionsEngineTag_t;
  inline T_t VOLXA(int i) const
  {
    return (std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 3)
     - std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i-1), 3))
      / 3.0;
  }
  inline T_t VOLXA(const Loc<dimensions>& l) const { return VOLXA(l[0].first()); }
  inline T_t VOLYA(int j) const
  {
    return std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j-1))
      - std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t VOLYA(const Loc<dimensions>& l) const { return VOLYA(l[1].first()); }
  inline T_t VOLZA(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZA(const Loc<dimensions>&) const { return VOLZA(0); }
  inline T_t VOLXB(int i) const
  {
    return (std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i+1), 3)
     - std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i), 3))
      / 3.0;
  }
  inline T_t VOLXB(const Loc<dimensions>& l) const { return VOLXB(l[0].first()); }
  inline T_t VOLYB(int j) const
  {
    return std::cos(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j))
      - std::cos(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j+1));
  }
  inline T_t VOLYB(const Loc<dimensions>& l) const { return VOLYB(l[1].first()); }
  inline T_t VOLZB(int) const
  {
    return static_cast<const Mesh_t&>(*this).spacings()(2);
  }
  inline T_t VOLZB(const Loc<dimensions>&) const { return VOLZB(0); }
  inline T_t SURXA(int i) const
  {
    return std::pow(static_cast<const Mesh_t&>(*this).vertexPosition( 0, i), 2);
  }
  inline T_t SURXA(const Loc<dimensions>& l) const { return SURXA(l[0].first()); }
  inline T_t SURYA(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t SURYA(const Loc<dimensions>& l) const { return SURYA(l[1].first()); }
  inline One<T_t> SURZA(int) const { return One<T_t>(); }
  inline One<T_t> SURZA(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t SURXB(int i) const
  {
    return std::pow(static_cast<const Mesh_t&>(*this).cellPosition( 0, i), 2);
  }
  inline T_t SURXB(const Loc<dimensions>& l) const { return SURXB(l[0].first()); }
  inline T_t SURYB(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t SURYB(const Loc<dimensions>& l) const { return SURYB(l[1].first()); }
  inline One<T_t> SURZB(int) const { return One<T_t>(); }
  inline One<T_t> SURZB(const Loc<dimensions>&) const { return One<T_t>(); }
  inline T_t CCXA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t CCXA(const Loc<dimensions>& l) const { return CCXA(l[0].first()); }
  inline T_t CCYA(int j) const
  {
    return 0.5*std::cos(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t CCYA(const Loc<dimensions>& l) const { return CCYA(l[1].first()); }
  inline Zero<T_t> CCZA(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZA(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline T_t CCXB(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t CCXB(const Loc<dimensions>& l) const { return CCXB(l[0].first()); }
  inline T_t CCYB(int j) const
  {
    return 0.5*std::cos(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t CCYB(const Loc<dimensions>& l) const { return CCYB(l[1].first()); }
  inline Zero<T_t> CCZB(int) const { return Zero<T_t>(); }
  inline Zero<T_t> CCZB(const Loc<dimensions>&) const { return Zero<T_t>(); }
  inline T_t GEOXG(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXG(const Loc<dimensions>& l) const { return GEOXG(l[0].first()); }
  inline T_t GEOXH(int i) const
  {
    return static_cast<const Mesh_t&>(*this).cellPosition( 0, i);
  }
  inline T_t GEOXH(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline T_t GEOYH(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).cellPosition( 1, j));
  }
  inline T_t GEOYH(const Loc<dimensions>& l) const { return GEOYH(l[1].first()); }
  inline T_t GEOXGA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXGA(const Loc<dimensions>& l) const { return GEOXG(l[0].first()); }
  inline T_t GEOXHA(int i) const
  {
    return static_cast<const Mesh_t&>(*this).vertexPosition( 0, i);
  }
  inline T_t GEOXHA(const Loc<dimensions>& l) const { return GEOXH(l[0].first()); }
  inline T_t GEOYHA(int j) const
  {
    return std::sin(static_cast<const Mesh_t&>(*this).vertexPosition( 1, j));
  }
  inline T_t GEOYHA(const Loc<dimensions>& l) const { return GEOYH(l[1].first()); }
};
template<class Mesh, class T, class EngineTag> class Field;
namespace Pooma {
template<class Mesh>
struct PositionsTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::PointType_t,
    typename Mesh::PositionsEngineTag_t> Type_t;
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::PointType_t,
    typename Mesh::CartesianPositionsEngineTag_t> CartesianType_t;
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::PointType_t,
    typename Mesh::CylindricalPositionsEngineTag_t> CylindricalType_t;
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::PointType_t,
    typename Mesh::SphericalPositionsEngineTag_t> SphericalType_t;
};
template<class Mesh, class T, class EngineTag>
typename PositionsTraits<Mesh>::Type_t
positions(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  typename PositionsTraits<Mesh>::Type_t
    of(f.numMaterials(), f.centering(), f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializePositions(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh, int Dim>
typename PositionsTraits<Mesh>::Type_t
positions(const Mesh &mesh, Centering<Dim> c)
{
  GuardLayers<Mesh::dimensions> g;
  for (int i = 0; i < Mesh::dimensions; ++i) {
    g.lower(i) = mesh.physicalVertexDomain()[i].min() - mesh.totalVertexDomain()[i].min();
    g.upper(i) = mesh.totalVertexDomain()[i].max() - mesh.physicalVertexDomain()[i].max();
  }
  DomainLayout<Mesh::dimensions> layout(mesh.physicalVertexDomain(), g);
  NoMesh<Mesh::dimensions> m(layout);
  typename PositionsTraits<Mesh>::Type_t
    of(1, c, layout, m);
  for (int j = 0; j < of.centeringSize(); j++)
    mesh.initializePositions(of.subField(0, j).engine(), of.centering(j));
  return of;
}
template<class Mesh, class T, class EngineTag>
typename PositionsTraits<Mesh>::CartesianType_t
cartesianPositions(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  typename PositionsTraits<Mesh>::CartesianType_t
    of(f.numMaterials(), f.centering(), f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializePositions(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh, class T, class EngineTag>
typename PositionsTraits<Mesh>::CylindricalType_t
cylindricalPositions(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  typename PositionsTraits<Mesh>::CylindricalType_t
    of(f.numMaterials(), f.centering(), f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializePositions(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh, class T, class EngineTag>
typename PositionsTraits<Mesh>::SphericalType_t
sphericalPositions(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  typename PositionsTraits<Mesh>::SphericalType_t
    of(f.numMaterials(), f.centering(), f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializePositions(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh>
struct SpacingsTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::VectorType_t,
    typename Mesh::SpacingsEngineTag_t> Type_t;
};
template<class Mesh, class T, class EngineTag>
typename SpacingsTraits<Mesh>::Type_t
spacings(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  typename SpacingsTraits<Mesh>::Type_t
    of(f.numMaterials(), f.centering(), f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializeSpacings(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh, int Dim>
typename SpacingsTraits<Mesh>::Type_t
spacings(const Mesh &mesh, Centering<Dim> c)
{
  GuardLayers<Mesh::dimensions> g;
  for (int i = 0; i < Mesh::dimensions; ++i) {
    g.lower(i) = mesh.physicalVertexDomain()[i].min() - mesh.totalVertexDomain()[i].min();
    g.upper(i) = mesh.totalVertexDomain()[i].max() - mesh.physicalVertexDomain()[i].max();
  }
  DomainLayout<Mesh::dimensions> layout(mesh.physicalVertexDomain(), g);
  NoMesh<Mesh::dimensions> m(layout);
  typename SpacingsTraits<Mesh>::Type_t
    of(1, c, layout, m);
  for (int j = 0; j < of.centeringSize(); j++)
    mesh.initializeSpacings(of.subField(0, j).engine(), of.centering(j));
  return of;
}
template<class Mesh>
struct NormalsTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::VectorType_t,
    typename Mesh::NormalsEngineTag_t> Type_t;
};
template<class Mesh, class T, class EngineTag>
typename NormalsTraits<Mesh>::Type_t
outwardNormals(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  Centering<Mesh::dimensions> c =
    canonicalCentering<Mesh::dimensions>(FaceType, Discontinuous);
  typename NormalsTraits<Mesh>::Type_t
    of(f.numMaterials(), c, f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializeNormals(of.subField(i, j).engine(), of.centering(j), true);
  return of;
}
template<class Mesh, class T, class EngineTag>
typename NormalsTraits<Mesh>::Type_t
coordinateNormals(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  Centering<Mesh::dimensions> c =
    canonicalCentering<Mesh::dimensions>(FaceType, Continuous);
  typename NormalsTraits<Mesh>::Type_t
    of(f.numMaterials(), c, f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializeNormals(of.subField(i, j).engine(), of.centering(j), false);
  return of;
}
template<class Mesh>
struct CellVolumesTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::Scalar_t,
    typename Mesh::CellVolumesEngineTag_t> Type_t;
};
template<class Mesh, class T, class EngineTag>
typename CellVolumesTraits<Mesh>::Type_t
cellVolumes(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  Centering<Mesh::dimensions> c =
    canonicalCentering<Mesh::dimensions>(CellType, Continuous);
  typename CellVolumesTraits<Mesh>::Type_t
    of(f.numMaterials(), c, f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    f.mesh().initializeCellVolumes(of.subField(i, 0).engine(), of.centering(0));
  return of;
}
template<class Mesh>
struct FaceAreasTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::Scalar_t,
    typename Mesh::FaceAreasEngineTag_t> Type_t;
};
template<class Mesh, class T, class EngineTag>
typename FaceAreasTraits<Mesh>::Type_t
faceAreas(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  Centering<Mesh::dimensions> c =
    canonicalCentering<Mesh::dimensions>(FaceType, Continuous);
  typename FaceAreasTraits<Mesh>::Type_t
    of(f.numMaterials(), c, f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializeFaceAreas(of.subField(i, j).engine(), of.centering(j));
  return of;
}
template<class Mesh>
struct EdgeLengthsTraits {
  typedef Field<NoMesh<Mesh::dimensions>,
    typename Mesh::Scalar_t,
    typename Mesh::EdgeLengthsEngineTag_t> Type_t;
};
template<class Mesh, class T, class EngineTag>
typename EdgeLengthsTraits<Mesh>::Type_t
edgeLengths(const Field<Mesh, T, EngineTag> &f)
{
  NoMesh<Mesh::dimensions> m(f.layout());
  Centering<Mesh::dimensions> c =
    canonicalCentering<Mesh::dimensions>(EdgeType, Continuous);
  typename EdgeLengthsTraits<Mesh>::Type_t
    of(f.numMaterials(), c, f.layout(), m);
  for (int i = 0; i < of.numMaterials(); i++)
    for (int j = 0; j < of.centeringSize(); j++)
      f.mesh().initializeEdgeLengths(of.subField(i, j).engine(), of.centering(j));
  return of;
}
}
using Pooma::PositionsTraits;
using Pooma::positions;
using Pooma::NormalsTraits;
using Pooma::outwardNormals;
using Pooma::coordinateNormals;
using Pooma::CellVolumesTraits;
using Pooma::cellVolumes;
using Pooma::FaceAreasTraits;
using Pooma::faceAreas;
using Pooma::EdgeLengthsTraits;
using Pooma::edgeLengths;
class InfluenceRelation : public RelationListItem
{
public:
  template<class Target>
  InfluenceRelation(const Target &t)
  : RelationListItem(),
    list_m(const_cast<RelationList*>(&t.fieldEngine().relations()))
    {
      setPriority(100u);
    }
  InfluenceRelation(const InfluenceRelation &model)
  : RelationListItem(model), list_m(model.list_m)
    { }
  InfluenceRelation() { }
  void setDirty()
    {
      if (!dirty())
        {
          RelationListItem::setDirty();
          list_m->setDirty();
        }
    }
  void apply() { }
private:
  RelationList *list_m;
};
template<class Target, class RelationFunctor>
class Relation0: public RelationBase<Target, RelationFunctor>
{
public:
  Relation0(const Target &t, const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f)
  { }
  ~Relation0()
  { }
  void apply()
  {
    this->functor_m(this->target_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    return new Relation0<Target, RelationFunctor>(target, this->functor_m);
  }
};
template<class Target, class R1, class RelationFunctor>
class Relation1: public RelationBase<Target, RelationFunctor>
{
public:
  Relation1(const Target &t, const R1 &r,
    const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f), r1_m(r)
  { }
  ~Relation1()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    return new Relation1<Target, R1, RelationFunctor>
                 (target, r1_m, this->functor_m);
  }
protected:
  R1 r1_m;
};
template<class Target, class R1, class R2, class RelationFunctor>
class Relation2: public RelationBase<Target, RelationFunctor>
{
public:
  Relation2(const Target &t, const R1 &r1, const R2 &r2,
    const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f), r1_m(r1), r2_m(r2)
  { }
  ~Relation2()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m, r2_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    r2_m.addRelation(new InfluenceRelation(target));
    return new Relation2<Target, R1, R2, RelationFunctor>
                 (target, r1_m, r2_m, this->functor_m);
  }
protected:
  R1 r1_m;
  R2 r2_m;
};
template<class Target, class R1, class R2, class R3, class RelationFunctor>
class Relation3: public RelationBase<Target, RelationFunctor>
{
public:
  Relation3(const Target &t, const R1 &r1, const R2 &r2, const R3 &r3,
            const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f),
    r1_m(r1),
    r2_m(r2),
    r3_m(r3)
  { }
  ~Relation3()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m, r2_m, r3_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    r2_m.addRelation(new InfluenceRelation(target));
    r3_m.addRelation(new InfluenceRelation(target));
    return new Relation3<Target, R1, R2, R3, RelationFunctor>
      (target, r1_m, r2_m, r3_m, this->functor_m);
  }
protected:
  R1 r1_m;
  R2 r2_m;
  R3 r3_m;
};
template<class Target, class R1, class R2, class R3, class R4,
         class RelationFunctor>
class Relation4: public RelationBase<Target, RelationFunctor>
{
public:
  Relation4(const Target &t, const R1 &r1, const R2 &r2, const R3 &r3,
            const R4 &r4, const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f),
    r1_m(r1),
    r2_m(r2),
    r3_m(r3),
    r4_m(r4)
  { }
  ~Relation4()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m, r2_m, r3_m, r4_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    r2_m.addRelation(new InfluenceRelation(target));
    r3_m.addRelation(new InfluenceRelation(target));
    r4_m.addRelation(new InfluenceRelation(target));
    return new Relation4<Target, R1, R2, R3, R4, RelationFunctor>
      (target, r1_m, r2_m, r3_m, r4_m, this->functor_m);
  }
protected:
  R1 r1_m;
  R2 r2_m;
  R3 r3_m;
  R4 r4_m;
};
template<class Target, class R1, class R2, class R3, class R4, class R5,
         class RelationFunctor>
class Relation5: public RelationBase<Target, RelationFunctor>
{
public:
  Relation5(const Target &t, const R1 &r1, const R2 &r2, const R3 &r3,
            const R4 &r4, const R5 &r5, const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f),
    r1_m(r1),
    r2_m(r2),
    r3_m(r3),
    r4_m(r4),
    r5_m(r5)
  { }
  ~Relation5()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m, r2_m, r3_m, r4_m, r5_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    r2_m.addRelation(new InfluenceRelation(target));
    r3_m.addRelation(new InfluenceRelation(target));
    r4_m.addRelation(new InfluenceRelation(target));
    r5_m.addRelation(new InfluenceRelation(target));
    return new Relation5<Target, R1, R2, R3, R4, R5, RelationFunctor>
      (target, r1_m, r2_m, r3_m, r4_m, r5_m, this->functor_m);
  }
protected:
  R1 r1_m;
  R2 r2_m;
  R3 r3_m;
  R4 r4_m;
  R5 r5_m;
};
template<class Target, class R1, class R2, class R3, class R4, class R5,
         class R6, class RelationFunctor>
class Relation6: public RelationBase<Target, RelationFunctor>
{
public:
  Relation6(const Target &t, const R1 &r1, const R2 &r2, const R3 &r3,
            const R4 &r4, const R5 &r5, const R6 &r6, const RelationFunctor &f)
  : RelationBase<Target, RelationFunctor>(t, f),
    r1_m(r1),
    r2_m(r2),
    r3_m(r3),
    r4_m(r4),
    r5_m(r5),
    r6_m(r6)
  { }
  ~Relation6()
  { }
  void apply()
  {
    this->functor_m(this->target_m, r1_m, r2_m, r3_m, r4_m, r5_m, r6_m);
  }
  virtual RelationListItem *retarget(const Target &target) const
  {
    r1_m.addRelation(new InfluenceRelation(target));
    r2_m.addRelation(new InfluenceRelation(target));
    r3_m.addRelation(new InfluenceRelation(target));
    r4_m.addRelation(new InfluenceRelation(target));
    r5_m.addRelation(new InfluenceRelation(target));
    r6_m.addRelation(new InfluenceRelation(target));
    return new Relation6<Target, R1, R2, R3, R4, R5, R6, RelationFunctor>
      (target, r1_m, r2_m, r3_m, r4_m, r5_m, r6_m, this->functor_m);
  }
protected:
  R1 r1_m;
  R2 r2_m;
  R3 r3_m;
  R4 r4_m;
  R5 r5_m;
  R6 r6_m;
};
template<class L>
class RelationFunctionPtr0 {
public:
  RelationFunctionPtr0(void (*f)(const L &))
  : f_m(f)
  { }
  RelationFunctionPtr0(const RelationFunctionPtr0<L> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l)
  {
    f_m(l);
  }
private:
  void (*f_m)(const L &);
};
template<class L, class R1>
class RelationFunctionPtr1 {
public:
  RelationFunctionPtr1(void (*f)(const L &, const R1 &))
  : f_m(f)
  { }
  RelationFunctionPtr1(const RelationFunctionPtr1<L, R1> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1)
  {
    f_m(l, r1);
  }
private:
  void (*f_m)(const L &, const R1 &);
};
template<class L, class R1, class R2>
class RelationFunctionPtr2 {
public:
  RelationFunctionPtr2(void (*f)(const L &, const R1 &, const R2 &))
  : f_m(f)
  { }
  RelationFunctionPtr2(const RelationFunctionPtr2<L, R1, R2> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2)
  {
    f_m(l, r1, r2);
  }
private:
  void (*f_m)(const L &, const R1 &, const R2 &);
};
template<class L, class R1, class R2, class R3>
class RelationFunctionPtr3 {
public:
  RelationFunctionPtr3(void (*f)(const L &,
    const R1 &, const R2 &, const R3 &))
  : f_m(f)
  { }
  RelationFunctionPtr3(
    const RelationFunctionPtr3<L, R1, R2, R3> &model)
  : f_m(model.f_m)
  { }
  RelationFunctionPtr3(
    const RelationFunctionPtr3<L, R1, R2, R3> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3)
  {
    f_m(l, r1, r2, r3);
  }
private:
  void (*f_m)(const L &, const R1 &, const R2 &, const R3 &);
};
template<class L, class R1, class R2, class R3, class R4>
class RelationFunctionPtr4 {
public:
  RelationFunctionPtr4(void (*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &))
  : f_m(f)
  { }
  RelationFunctionPtr4(
    const RelationFunctionPtr4<L, R1, R2, R3, R4> &model)
  : f_m(model.f_m)
  { }
  RelationFunctionPtr4(
    const RelationFunctionPtr4<L, R1, R2, R3, R4> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4)
  {
    f_m(l, r1, r2, r3, r4);
  }
private:
  void (*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &);
};
template<class L,
  class R1, class R2, class R3, class R4, class R5>
class RelationFunctionPtr5 {
public:
  RelationFunctionPtr5(void (*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &, const R5 &))
  : f_m(f)
  { }
  RelationFunctionPtr5(
    const RelationFunctionPtr5<L, R1, R2, R3, R4, R5> &model)
  : f_m(model.f_m)
  { }
  RelationFunctionPtr5(
    const RelationFunctionPtr5<L, R1, R2, R3, R4, R5> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4, const R5 &r5)
  {
    f_m(l, r1, r2, r3, r4, r5);
  }
private:
  void (*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &, const R5 &);
};
template<class L,
  class R1, class R2, class R3, class R4, class R5, class R6>
class RelationFunctionPtr6 {
public:
  RelationFunctionPtr6(void (*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &, const R5 &, const R6 &))
  : f_m(f)
  { }
  RelationFunctionPtr6(
    const RelationFunctionPtr6<L, R1, R2, R3, R4, R5, R6> &model)
  : f_m(model.f_m)
  { }
  RelationFunctionPtr6(
    const RelationFunctionPtr6<L, R1, R2, R3, R4, R5, R6> &init, const L &)
  : f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4, const R5 &r5, const R6 &r6)
  {
    f_m(l, r1, r2, r3, r4, r5, r6);
  }
private:
  void (*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &, const R5 &, const R6 &);
};
template<class C, class L>
class RelationMemberPtr0 {
public:
  RelationMemberPtr0(const C &obj, void (C::*f)(const L &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr0(const RelationMemberPtr0<C, L> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr0(const RelationMemberPtr0<C, L> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l)
  {
    (obj_m.*f_m)(l);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &);
};
template<class C, class L, class R1>
class RelationMemberPtr1 {
public:
  RelationMemberPtr1(const C &obj, void (C::*f)(const L &,
    const R1 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr1(const RelationMemberPtr1<C, L, R1> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr1(const RelationMemberPtr1<C, L, R1> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1)
  {
    (obj_m.*f_m)(l, r1);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &);
};
template<class C, class L, class R1, class R2>
class RelationMemberPtr2 {
public:
  RelationMemberPtr2(const C &obj, void (C::*f)(const L &,
    const R1 &, const R2 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr2(const RelationMemberPtr2<C, L, R1, R2> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr2(const RelationMemberPtr2<C, L, R1, R2> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2)
  {
    (obj_m.*f_m)(l, r1, r2);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &, const R2 &);
};
template<class C, class L, class R1, class R2, class R3>
class RelationMemberPtr3 {
public:
  RelationMemberPtr3(const C &obj, void (C::*f)(const L &,
    const R1 &, const R2 &, const R3 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr3(
    const RelationMemberPtr3<C, L, R1, R2, R3> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr3(
    const RelationMemberPtr3<C, L, R1, R2, R3> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3)
  {
    (obj_m.*f_m)(l, r1, r2, r3);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &, const R2 &, const R3 &);
};
template<class C, class L, class R1, class R2, class R3, class R4>
class RelationMemberPtr4 {
public:
  RelationMemberPtr4(const C &obj, void (C::*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr4(
    const RelationMemberPtr4<C, L, R1, R2, R3, R4> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr4(
    const RelationMemberPtr4<C, L, R1, R2, R3, R4> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4)
  {
    (obj_m.*f_m)(l, r1, r2, r3, r4);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &);
};
template<class C, class L,
  class R1, class R2, class R3, class R4, class R5>
class RelationMemberPtr5 {
public:
  RelationMemberPtr5(const C &obj, void (C::*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &, const R5 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr5(
    const RelationMemberPtr5<C, L, R1, R2, R3, R4, R5> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr5(
    const RelationMemberPtr5<C, L, R1, R2, R3, R4, R5> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4, const R5 &r5)
  {
    (obj_m.*f_m)(l, r1, r2, r3, r4, r5);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &, const R5 &);
};
template<class C, class L,
  class R1, class R2, class R3, class R4, class R5, class R6>
class RelationMemberPtr6 {
public:
  RelationMemberPtr6(const C &obj, void (C::*f)(const L &,
    const R1 &, const R2 &, const R3 &, const R4 &, const R5 &, const R6 &))
  : obj_m(obj), f_m(f)
  { }
  RelationMemberPtr6(
    const RelationMemberPtr6<C, L, R1, R2, R3, R4, R5, R6> &model)
  : obj_m(model.obj_m), f_m(model.f_m)
  { }
  RelationMemberPtr6(
    const RelationMemberPtr6<C, L, R1, R2, R3, R4, R5, R6> &init, const L &)
  : obj_m(init.obj_m), f_m(init.f_m)
  { }
  inline void operator()(const L &l, const R1 &r1, const R2 &r2,
    const R3 &r3, const R4 &r4, const R5 &r5, const R6 &r6)
  {
    (obj_m.*f_m)(l, r1, r2, r3, r4, r5, r6);
  }
private:
  C obj_m;
  void (C::*f_m)(const L &, const R1 &, const R2 &,
    const R3 &, const R4 &, const R5 &, const R6 &);
};
template<class RelationFunctor>
struct RelationFunctorTraits {
  enum { defaultPriority = 0 };
};
namespace Pooma {
  template<class RelationFunctor, class L>
  void newRelation(const RelationFunctor &f, const L &l)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            RelationListItem *r = new Relation0<L, RelationFunctor>(lsub, f);
            r->setPriority(RelationFunctorTraits<RelationFunctor>::defaultPriority);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r = new
              Relation1<L, R1, RelationFunctor>
                (lsub, r1sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1, class R2>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1, const R2 &r2)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            const R2 &r2sub = r2.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            r2sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r =
              new Relation2<L, R1, R2, RelationFunctor>(lsub, r1sub, r2sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1, class R2, class R3>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1, const R2 &r2, const R3 &r3)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            const R2 &r2sub = r2.subField(m, c);
            const R3 &r3sub = r3.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            r2sub.addRelation(new InfluenceRelation(lsub));
            r3sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r = new
              Relation3<L, R1, R2, R3, RelationFunctor>
                (lsub, r1sub, r2sub, r3sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1, class R2, class R3,
    class R4>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1, const R2 &r2,
                   const R3 &r3, const R4 &r4)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            const R2 &r2sub = r2.subField(m, c);
            const R3 &r3sub = r3.subField(m, c);
            const R4 &r4sub = r4.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            r2sub.addRelation(new InfluenceRelation(lsub));
            r3sub.addRelation(new InfluenceRelation(lsub));
            r4sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r = new
              Relation4<L, R1, R2, R3, R4, RelationFunctor>
                (lsub, r1sub, r2sub, r3sub, r4sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1, class R2, class R3,
    class R4, class R5>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1, const R2 &r2,
                   const R3 &r3, const R4 &r4, const R5 &r5)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            const R2 &r2sub = r2.subField(m, c);
            const R3 &r3sub = r3.subField(m, c);
            const R4 &r4sub = r4.subField(m, c);
            const R5 &r5sub = r5.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            r2sub.addRelation(new InfluenceRelation(lsub));
            r3sub.addRelation(new InfluenceRelation(lsub));
            r4sub.addRelation(new InfluenceRelation(lsub));
            r5sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r = new
              Relation5<L, R1, R2, R3, R4, R5, RelationFunctor>
                (lsub, r1sub, r2sub, r3sub, r4sub, r5sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class RelationFunctor, class L, class R1, class R2, class R3,
    class R4, class R5, class R6>
  void newRelation(const RelationFunctor &f, const L &l,
                   const R1 &r1, const R2 &r2,
                   const R3 &r3, const R4 &r4, const R5 &r5, const R6 &r6)
  {
    for (int m = 0; m < l.numMaterials(); ++m)
      {
        for (int c = 0; c < l.centeringSize(); ++c)
          {
            const L &lsub = l.subField(m, c);
            const R1 &r1sub = r1.subField(m, c);
            const R2 &r2sub = r2.subField(m, c);
            const R3 &r3sub = r3.subField(m, c);
            const R4 &r4sub = r4.subField(m, c);
            const R5 &r5sub = r5.subField(m, c);
            const R6 &r6sub = r6.subField(m, c);
            r1sub.addRelation(new InfluenceRelation(lsub));
            r2sub.addRelation(new InfluenceRelation(lsub));
            r3sub.addRelation(new InfluenceRelation(lsub));
            r4sub.addRelation(new InfluenceRelation(lsub));
            r5sub.addRelation(new InfluenceRelation(lsub));
            r6sub.addRelation(new InfluenceRelation(lsub));
            RelationListItem *r = new
              Relation6<L, R1, R2, R3, R4, R5, R6, RelationFunctor>
                (lsub, r1sub, r2sub, r3sub, r4sub, r5sub, r6sub, f);
            lsub.addRelation(r);
          }
      }
  }
  template<class L>
  RelationFunctionPtr0<L>
  functionPtr(void (*f)(const L &))
  {
    return RelationFunctionPtr0<L>(f);
  }
  template<class L, class R1>
  RelationFunctionPtr1<L, R1>
  functionPtr(void (*f)(const L &, const R1 &))
  {
    return RelationFunctionPtr1<L, R1>(f);
  }
  template<class L, class R1, class R2>
  RelationFunctionPtr2<L, R1, R2>
  functionPtr(void (*f)(const L &, const R1 &, const R2 &))
  {
    return RelationFunctionPtr2<L, R1, R2>(f);
  }
  template<class L, class R1, class R2, class R3>
  RelationFunctionPtr3<L, R1, R2, R3>
  functionPtr(void (*f)(const L &, const R1 &, const R2 &, const R3 &))
  {
    return RelationFunctionPtr3<L, R1, R2, R3>(f);
  }
  template<class L, class R1, class R2, class R3, class R4>
  RelationFunctionPtr4<L, R1, R2, R3, R4>
  functionPtr(void (*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4))
  {
    return RelationFunctionPtr4<L, R1, R2, R3, R4>(f);
  }
  template<class L, class R1, class R2, class R3,
    class R4, class R5>
  RelationFunctionPtr5<L, R1, R2, R3, R4, R5>
  functionPtr(void (*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4, const R5 &r5))
  {
    return RelationFunctionPtr5<L, R1, R2, R3, R4, R5>(f);
  }
  template<class L, class R1, class R2, class R3,
    class R4, class R5, class R6>
  RelationFunctionPtr6<L, R1, R2, R3, R4, R5, R6>
  functionPtr(void (*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4, const R5 &r5, const R6 &r6))
  {
    return RelationFunctionPtr6<L, R1, R2, R3, R4, R5, R6>(f);
  }
  template<class C, class L>
  RelationMemberPtr0<C, L>
  memberPtr(const C &obj, void (C::*f)(const L &))
  {
    return RelationMemberPtr0<C, L>(obj, f);
  }
  template<class C, class L, class R1>
  RelationMemberPtr1<C, L, R1>
  memberPtr(const C &obj, void (C::*f)(const L &, const R1 &))
  {
    return RelationMemberPtr1<C, L, R1>(obj, f);
  }
  template<class C, class L, class R1, class R2>
  RelationMemberPtr2<C, L, R1, R2>
  memberPtr(const C &obj, void (C::*f)(const L &, const R1 &, const R2 &))
  {
    return RelationMemberPtr2<C, L, R1, R2>(obj, f);
  }
  template<class C, class L, class R1, class R2, class R3>
  RelationMemberPtr3<C, L, R1, R2, R3>
  memberPtr(const C &obj,
    void (C::*f)(const L &, const R1 &, const R2 &, const R3 &))
  {
    return RelationMemberPtr3<C, L, R1, R2, R3>(obj, f);
  }
  template<class C, class L, class R1, class R2, class R3,
    class R4>
  RelationMemberPtr4<C, L, R1, R2, R3, R4>
  memberPtr(const C &obj,
    void (C::*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4))
  {
    return RelationMemberPtr4<C, L, R1, R2, R3, R4>(obj, f);
  }
  template<class C, class L, class R1, class R2, class R3,
    class R4, class R5>
  RelationMemberPtr5<C, L, R1, R2, R3, R4, R5>
  memberPtr(const C &obj,
    void (C::*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4, const R5 &r5))
  {
    return RelationMemberPtr5<C, L, R1, R2, R3, R4, R5>(obj, f);
  }
  template<class C, class L, class R1, class R2, class R3,
    class R4, class R5, class R6>
  RelationMemberPtr6<C, L, R1, R2, R3, R4, R5, R6>
  memberPtr(const C &obj,
    void (C::*f)(const L &, const R1 &, const R2 &, const R3 &,
    const R4 &r4, const R5 &r5, const R6 &r6))
  {
    return RelationMemberPtr6<C, L, R1, R2, R3, R4, R5, R6>(obj, f);
  }
}
template<int Dim, class T>
class ConstantFaceBC
{
public:
  ConstantFaceBC(int face, const T &constant,
    bool enforceConstantBoundary = false)
  : domain_m(Pooma::NoInit()),
    face_m(face),
    constant_m(constant),
    enforceConstantBoundary_m(enforceConstantBoundary)
    { }
  ConstantFaceBC(const ConstantFaceBC<Dim, T> &model)
  : domain_m(model.domain_m),
    face_m(model.face_m),
    constant_m(model.constant_m),
    enforceConstantBoundary_m(model.enforceConstantBoundary_m)
    { }
  template<class Target>
  ConstantFaceBC(const ConstantFaceBC<Dim, T> &init, const Target &t)
  : domain_m(t.totalDomain()),
    face_m(init.face_m),
    constant_m(init.constant_m),
    enforceConstantBoundary_m(init.enforceConstantBoundary_m)
  {
    ;
    int d = face_m / 2;
    int adjust;
    if (enforceConstantBoundary_m &&
        t.centering().orientation(0)[d].min() == 0)
      adjust = 0;
    else
      adjust = 1;
    if (face_m & 1)
      {
        int nGuards = t.fieldEngine().guardLayers().upper(d);
        domain_m[d] = Interval<1>(domain_m[d].max() - nGuards + adjust,
             domain_m[d].max());
      }
    else
      {
        int nGuards = t.fieldEngine().guardLayers().lower(d);
        domain_m[d] = Interval<1>(domain_m[d].min(),
      domain_m[d].min() + nGuards - adjust);
      }
  }
  ConstantFaceBC<Dim, T> &operator=(const ConstantFaceBC<Dim, T> &rhs)
  {
    domain_m = rhs.domain_m;
    face_m = rhs.face_m;
    constant_m = rhs.constant_m;
    enforceConstantBoundary_m = rhs.enforceConstantBoundary_m;
    return *this;
  }
  T constant() const { return constant_m; }
  void setConstant(T newConstant) { constant_m = newConstant; }
  int face() const { return face_m; }
  template<class Target>
  void operator()(const Target &t) const
  {
    t(domain_m) = constant_m;
  }
private:
  Interval<Dim> domain_m;
  int face_m;
  T constant_m;
  bool enforceConstantBoundary_m;
};
template<int Dim, class T>
struct RelationFunctorTraits<ConstantFaceBC<Dim, T> > {
  enum { defaultPriority = 100 };
};
namespace Pooma {
  template<class Target, class T>
  void addConstantFaceBC(const Target &f, int face, const T &constant,
    bool enforceConstantBoundary = false)
  {
    newRelation(ConstantFaceBC<Target::dimensions, T>
      (face, constant, enforceConstantBoundary), f);
  }
  template<class Target, class T>
  void addAllConstantFaceBC(const Target &f, const T &constant,
    bool enforceConstantBoundary = false)
  {
    for (int i = 0; i < 2 * Target::dimensions; i++)
      {
        addConstantFaceBC(f, i, constant, enforceConstantBoundary);
      }
  }
}
template<int Dim>
class ReflectFaceBase
{
public:
  ReflectFaceBase(int face, bool enforceZeroBoundary = false)
  : domain_m(Pooma::NoInit()),
    vertFaceDomain_m(Pooma::NoInit()),
    srcRange_m(Pooma::NoInit()),
    face_m(face),
    enforceZeroBoundary_m(enforceZeroBoundary)
    { }
  ReflectFaceBase(const ReflectFaceBase<Dim> &model)
  : domain_m(model.domain_m),
    vertFaceDomain_m(model.vertFaceDomain_m),
    srcRange_m(model.srcRange_m),
    face_m(model.face_m),
    enforceZeroBoundary_m(model.enforceZeroBoundary_m)
    { }
  template<class Target>
  ReflectFaceBase(const ReflectFaceBase<Dim> &init, const Target &t)
  : domain_m(t.totalDomain()),
    vertFaceDomain_m(t.totalDomain()),
    srcRange_m(Pooma::NoInit()),
    face_m(init.face_m),
    enforceZeroBoundary_m(init.enforceZeroBoundary_m)
  {
    ;
    for (int dd = 0; dd < Dim; ++dd)
      {
        srcRange_m[dd] =
          Range<1>(domain_m[dd].min(), domain_m[dd].max(), 1);
      }
    int d = face_m / 2;
    int adjust = 1 - t.centering().orientation(0)[d].min();
    if (face_m & 1)
      {
        int nGuards = t.fieldEngine().guardLayers().upper(d);
 if (adjust == 1)
   {
            vertFaceDomain_m[d] =
       Interval<1>(t.physicalDomain()[d].max(),
     t.physicalDomain()[d].max());
          }
        srcRange_m[d] =
          Range<1>(t.physicalDomain()[d].max() - adjust,
     t.physicalDomain()[d].max() - adjust - (nGuards - 1),
     -1);
        domain_m[d] = Interval<1>(domain_m[d].max() - (nGuards - 1),
      domain_m[d].max());
      }
    else
      {
        int nGuards = t.fieldEngine().guardLayers().lower(d);
 if (adjust == 1)
   {
            vertFaceDomain_m[d] =
              Interval<1>(t.physicalDomain()[d].min(),
     t.physicalDomain()[d].min());
    }
        srcRange_m[d] =
          Range<1>(t.physicalDomain()[d].min() + adjust +
     (nGuards - 1),
     t.physicalDomain()[d].min() + adjust, -1);
 domain_m[d] = Interval<1>(domain_m[d].min(),
      domain_m[d].min() + (nGuards - 1));
      }
  }
  ReflectFaceBase<Dim> &operator=(const ReflectFaceBase<Dim> &rhs)
  {
    domain_m = rhs.domain_m;
    vertFaceDomain_m = rhs.vertFaceDomain_m;
    srcRange_m = rhs.srcRange_m;
    face_m = rhs.face_m;
    enforceZeroBoundary_m = rhs.enforceZeroBoundary_m;
    return *this;
  }
  int face() const { return face_m; }
  bool enforceZeroBoundary() const { return enforceZeroBoundary_m; }
protected:
  Interval<Dim> domain_m, vertFaceDomain_m;
  Range<Dim> srcRange_m;
  int face_m;
  bool enforceZeroBoundary_m;
};
template<int Dim>
class PosReflectFaceBC : public ReflectFaceBase<Dim>
{
public:
  PosReflectFaceBC(int face, bool enforceZeroBoundary = false)
    : ReflectFaceBase<Dim>(face, enforceZeroBoundary)
  {}
  template<class Target>
  PosReflectFaceBC(const PosReflectFaceBC<Dim>& init, const Target &t)
    : ReflectFaceBase<Dim>(init, t)
  {}
  template<class Target>
  void operator()(const Target &t) const
  {
    t(this->domain_m) = t(this->srcRange_m);
    if (this->enforceZeroBoundary_m &&
        t.centering().orientation(0)[this->face_m / 2].min() == 0)
      {
        typedef typename Target::Element_t T;
        t(this->vertFaceDomain_m) = T(0.0);
      }
  }
};
template<int Dim>
class NegReflectFaceBC : public ReflectFaceBase<Dim>
{
public:
  NegReflectFaceBC(int face, bool enforceZeroBoundary = false)
    : ReflectFaceBase<Dim>(face, enforceZeroBoundary)
  {}
  template<class Target>
  NegReflectFaceBC(const NegReflectFaceBC<Dim>& init, const Target &t)
    : ReflectFaceBase<Dim>(init, t)
  {}
  template<class Target>
  void operator()(const Target &t) const
  {
    t(this->domain_m) = -t(this->srcRange_m);
    if (this->enforceZeroBoundary_m &&
        t.centering().orientation(0)[this->face_m / 2].min() == 0)
      {
        typedef typename Target::Element_t T;
        t(this->vertFaceDomain_m) = T(0.0);
      }
  }
};
template<int Dim>
struct RelationFunctorTraits<PosReflectFaceBC<Dim> > {
  enum { defaultPriority = 100 };
};
template<int Dim>
struct RelationFunctorTraits<NegReflectFaceBC<Dim> > {
  enum { defaultPriority = 100 };
};
namespace Pooma {
  template<class Target>
  void addPosReflectFaceBC(const Target &f, int face,
    bool enforceZeroBoundary = false)
  {
      newRelation(PosReflectFaceBC<Target::dimensions>
        (face, enforceZeroBoundary), f);
  }
  template<class Target>
  void addAllPosReflectFaceBC(const Target &f, bool enforceZeroBoundary = false)
  {
    for (int i = 0; i < 2 * Target::dimensions; i++)
      {
        addPosReflectFaceBC(f, i, enforceZeroBoundary);
      }
  }
  template<class Target>
  void addNegReflectFaceBC(const Target &f, int face,
    bool enforceZeroBoundary = false)
  {
      newRelation(NegReflectFaceBC<Target::dimensions>
        (face, enforceZeroBoundary), f);
  }
  template<class Target>
  void addAllNegReflectFaceBC(const Target &f, bool enforceZeroBoundary = false)
  {
    for (int i = 0; i < 2 * Target::dimensions; i++)
      {
        addNegReflectFaceBC(f, i, enforceZeroBoundary);
      }
  }
}
template<int Dim>
class PeriodicFaceBC
{
public:
  PeriodicFaceBC(int face)
  : domain_m(Pooma::NoInit()),
    srcDomain_m(Pooma::NoInit()),
    face_m(face)
    { }
  PeriodicFaceBC(const PeriodicFaceBC<Dim> &model)
  : domain_m(model.domain_m),
    srcDomain_m(model.srcDomain_m),
    face_m(model.face_m)
    { }
  template<class Target>
  PeriodicFaceBC(const PeriodicFaceBC<Dim> &init, const Target &t)
  : domain_m(t.totalDomain()),
    srcDomain_m(t.totalDomain()),
    face_m(init.face_m)
  {
    ;
    int d = face_m / 2;
    int adjust = 1 - t.centering().orientation(0)[d].min();
    if (face_m & 1)
      {
        int nGuards = t.fieldEngine().guardLayers().upper(d);
 domain_m[d] =
          Interval<1>(domain_m[d].max() - nGuards,
               domain_m[d].max());
 srcDomain_m[d] =
   Interval<1>(domain_m[d].min() -
        (t.physicalDomain()[d].length() - 1 - adjust),
         domain_m[d].max() -
         (t.physicalDomain()[d].length() - 1 - adjust));
      }
    else
      {
        int nGuards = t.fieldEngine().guardLayers().lower(d);
 domain_m[d] = Interval<1>(domain_m[d].min(),
      domain_m[d].min() + (nGuards - 1) + adjust);
 srcDomain_m[d] =
   Interval<1>(domain_m[d].min() +
        (t.physicalDomain()[d].length() - 1 - adjust),
        domain_m[d].max() +
         (t.physicalDomain()[d].length() - 1 - adjust));
      }
  }
  PeriodicFaceBC<Dim> &operator=(const PeriodicFaceBC<Dim> &rhs)
  {
    if (&rhs != this)
      {
        domain_m = rhs.domain_m;
        srcDomain_m = rhs.srcDomain_m;
        face_m = rhs.face_m;
      }
    return *this;
  }
  int face() const { return face_m; }
  template<class Target>
  void operator()(const Target &t) const
  {
    t(domain_m) = t(srcDomain_m);
  }
private:
  Interval<Dim> domain_m, srcDomain_m;
  int face_m;
};
template<int Dim>
struct RelationFunctorTraits<PeriodicFaceBC<Dim> > {
  enum { defaultPriority = 100 };
};
namespace Pooma {
  template<class Target>
  void addPeriodicFaceBC(const Target &f, int face)
  {
    newRelation(PeriodicFaceBC<Target::dimensions>(face), f);
  }
  template<class Target>
  void addAllPeriodicFaceBC(const Target &f)
  {
    for (int i = 0; i < 2 * Target::dimensions; i++)
      {
        addPeriodicFaceBC(f, i);
      }
  }
}
template<int Dim>
class ZeroGradientFaceBC
{
public:
  ZeroGradientFaceBC(int face)
  : srcDomain_m(Pooma::NoInit()),
    face_m(face)
    { }
  ZeroGradientFaceBC(const ZeroGradientFaceBC<Dim> &model)
  : srcDomain_m(model.srcDomain_m),
    domains_m(model.domains_m),
    face_m(model.face_m)
    { }
  template<class Target>
  ZeroGradientFaceBC(const ZeroGradientFaceBC<Dim> &init, const Target &t)
  : srcDomain_m(t.totalDomain()),
    face_m(init.face_m)
  {
    ;
    int d = face_m / 2;
    int adjust = 1 - t.centering().orientation(0)[d].min();
    if (face_m & 1)
      {
        int nGuards = t.fieldEngine().guardLayers().upper(d);
 domains_m.resize(nGuards+adjust, t.totalDomain());
 srcDomain_m[d] =
          Interval<1>(t.physicalDomain()[d].max() - adjust,
               t.physicalDomain()[d].max() - adjust);
 for (int i=0; i<nGuards+adjust; i++)
   domains_m[i][d] =
     Interval<1>(t.physicalDomain()[d].max() -adjust + i + 1,
   t.physicalDomain()[d].max() -adjust + i + 1);
      }
    else
      {
        int nGuards = t.fieldEngine().guardLayers().lower(d);
 domains_m.resize(nGuards+adjust, t.totalDomain());
 srcDomain_m[d] = Interval<1>(t.physicalDomain()[d].min()+adjust,
          t.physicalDomain()[d].min()+adjust);
 for (int i=0; i<nGuards+adjust; i++)
   domains_m[i][d] =
     Interval<1>(t.physicalDomain()[d].min() +adjust - i - 1,
   t.physicalDomain()[d].min() +adjust - i - 1);
      }
  }
  ZeroGradientFaceBC<Dim> &operator=(const ZeroGradientFaceBC<Dim> &rhs)
  {
    if (&rhs != this)
      {
        domains_m = rhs.domains_m;
        srcDomain_m = rhs.srcDomain_m;
        face_m = rhs.face_m;
      }
    return *this;
  }
  int face() const { return face_m; }
  template<class Target>
  void operator()(const Target &t) const
  {
    for (int i=0; i<domains_m.size(); i++) {
      t(domains_m[i]) = t(srcDomain_m);
    }
  }
private:
  Interval<Dim> srcDomain_m;
  std::vector<Interval<Dim> > domains_m;
  int face_m;
};
template<int Dim>
struct RelationFunctorTraits<ZeroGradientFaceBC<Dim> > {
  enum { defaultPriority = 100 };
};
namespace Pooma {
  template<class Target>
  void addZeroGradientFaceBC(const Target &f, int face)
  {
    newRelation(ZeroGradientFaceBC<Target::dimensions>(face), f);
  }
  template<class Target>
  void addAllZeroGradientFaceBC(const Target &f)
  {
    for (int i = 0; i < 2 * Target::dimensions; i++)
      {
        addZeroGradientFaceBC(f, i);
      }
  }
}
template<class Functor, class Expression>
struct FieldStencilSimple
{
  typedef typename Expression::MeshTag_t MeshTag_t;
  enum { outputDim = Expression::dimensions };
  typedef typename Functor::OutputElement_t OutputElement_t;
  typedef StencilEngine<Functor, Expression> OutputEngineTag_t;
  typedef Field<MeshTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  static inline
  Type_t make(const Functor &stencil, const Expression &f)
  {
 return make(stencil, f, f.physicalDomain());
  }
  static inline
  Type_t make(const Functor &stencil, const Expression &f, const Interval<outputDim> &domain)
  {
 Type_t h(stencil.outputCentering(), f.layout(), f.mesh());
 h.fieldEngine().engine() = SEngine_t(stencil, f, domain);
 return h;
  }
  template<class Accumulate>
  static inline
  Type_t make(const Expression &f,
              const std::vector<FieldOffsetList<outputDim> > &nn,
              const Centering<outputDim> &outputCentering,
              Accumulate accumulate = Accumulate())
  {
    ;
    Type_t h(outputCentering, f.layout(), f.mesh());
    h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
    h.fieldEngine().guardLayers() = f.fieldEngine().guardLayers();
    if (outputCentering.size() == 1)
    {
      h.fieldEngine().engine()
        = SEngine_t(Functor(nn[0], outputCentering, f.centering(),
                            accumulate),
                    f, h.physicalDomain());
    }
    else
    {
      int oc;
      for (oc = 0; oc < nn.size(); ++oc)
      {
        h[oc].fieldEngine().guardLayers() = f.fieldEngine().guardLayers();
        h[oc].fieldEngine().engine()
          = SEngine_t(Functor(nn[oc], outputCentering[oc], f.centering(),
                              accumulate),
                      f, h[oc].physicalDomain());
      }
    }
    return h;
  }
};
template<class T2, class Mesh>
class DivVertToCell;
template<class T2, int Dim, class TM>
class DivVertToCell<Vector<Dim, T2>, UniformRectilinearMesh<MeshTraits<Dim, TM, UniformRectilinearTag, CartesianTag> > >
{
public:
  typedef T2 OutputElement_t;
  Centering<Dim> outputCentering() const
  {
    return canonicalCentering<Dim>(CellType, Continuous, AllDim);
  }
  Centering<Dim> inputCentering() const
  {
    return canonicalCentering<Dim>(VertexType, Continuous, AllDim);
  }
  DivVertToCell()
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 1.0;
    }
  }
  template<class FE>
  DivVertToCell(const FE &fieldEngine)
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 1 / fieldEngine.mesh().spacings()(d);
    }
  }
  int lowerExtent(int d) const { return 0; }
  int upperExtent(int d) const { return 1; }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1) const
  {
    return OutputElement_t
      (fact_m(0)*(f.read(i1+1)(0) - f.read(i1)(0)));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2) const
  {
    return OutputElement_t
      (0.5*(fact_m(0)*(f.read(i1+1,i2)(0) - f.read(i1,i2)(0)
       + f.read(i1+1,i2+1)(0) - f.read(i1,i2+1)(0))
   + fact_m(1)*(f.read(i1, i2+1)(1) - f.read(i1, i2)(1)
       + f.read(i1+1,i2+1)(1) - f.read(i1+1,i2)(1))));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2, int i3) const
  {
    return OutputElement_t
      (0.25*(fact_m(0)*(f.read(i1+1,i2, i3)(0) - f.read(i1,i2, i3)(0)
        + f.read(i1+1,i2+1,i3)(0) - f.read(i1,i2+1,i3)(0)
        + f.read(i1+1,i2, i3+1)(0) - f.read(i1,i2, i3+1)(0)
        + f.read(i1+1,i2+1,i3+1)(0) - f.read(i1,i2+1,i3+1)(0))
    + fact_m(1)*(f.read(i1, i2+1,i3)(1) - f.read(i1, i2,i3)(1)
        + f.read(i1+1,i2+1,i3)(1) - f.read(i1+1,i2,i3)(1)
        + f.read(i1, i2+1,i3+1)(1) - f.read(i1, i2,i3+1)(1)
        + f.read(i1+1,i2+1,i3+1)(1) - f.read(i1+1,i2,i3+1)(1))
    + fact_m(2)*(f.read(i1, i2, i3+1)(2) - f.read(i1, i2, i3)(2)
        + f.read(i1+1,i2, i3+1)(2) - f.read(i1+1,i2, i3)(2)
        + f.read(i1, i2+1,i3+1)(2) - f.read(i1, i2+1,i3)(2)
        + f.read(i1+1,i2+1,i3+1)(2) - f.read(i1+1,i2+1,i3)(2))));
  }
private:
  Vector<Dim, TM> fact_m;
};
template<class T2, class Mesh>
class DivCellToVert;
template<class T2, int Dim, class TM>
class DivCellToVert<Vector<Dim, T2>, UniformRectilinearMesh<MeshTraits<Dim, TM> > >
{
public:
  typedef T2 OutputElement_t;
  Centering<Dim> outputCentering() const
  {
    return canonicalCentering<Dim>(CellType, Continuous, AllDim);
  }
  Centering<Dim> inputCentering() const
  {
    return canonicalCentering<Dim>(VertexType, Continuous, AllDim);
  }
  DivCellToVert()
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 1.0;
    }
  }
  template<class FE>
  DivCellToVert(const FE &fieldEngine)
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 1 / fieldEngine.mesh().spacings()(d);
    }
  }
  int lowerExtent(int d) const { return 0; }
  int upperExtent(int d) const { return 1; }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1) const
  {
    return OutputElement_t
      (fact_m(0)*(f.read(i1)(0) - f.read(i1-1)(0)));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2) const
  {
    return OutputElement_t
      (0.5*(fact_m(0)*(f.read(i1,i2-1)(0) - f.read(i1-1,i2-1)(0)
       + f.read(i1,i2)(0) - f.read(i1-1,i2)(0))
   + fact_m(1)*(f.read(i1-1,i2)(1) - f.read(i1-1,i2-1)(1)
       + f.read(i1, i2)(1) - f.read(i1, i2-1)(1))));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2, int i3) const
  {
    return OutputElement_t
      (0.25*(fact_m(0)*(f.read(i1,i2-1,i3-1)(0) - f.read(i1-1,i2-1,i3-1)(0)
        + f.read(i1,i2, i3-1)(0) - f.read(i1-1,i2, i3-1)(0)
        + f.read(i1,i2-1,i3)(0) - f.read(i1-1,i2-1,i3)(0)
        + f.read(i1,i2, i3)(0) - f.read(i1-1,i2, i3)(0))
    + fact_m(1)*(f.read(i1-1,i2,i3-1)(1) - f.read(i1-1,i2-1,i3-1)(1)
        + f.read(i1, i2,i3-1)(1) - f.read(i1, i2-1,i3-1)(1)
        + f.read(i1-1,i2,i3)(1) - f.read(i1-1,i2-1,i3)(1)
        + f.read(i1, i2,i3)(1) - f.read(i1, i2-1,i3)(1))
    + fact_m(2)*(f.read(i1-1,i2-1,i3)(2) - f.read(i1-1,i2-1,i3-1)(2)
        + f.read(i1, i2-1,i3)(2) - f.read(i1, i2-1,i3-1)(2)
        + f.read(i1-1,i2, i3)(2) - f.read(i1-1,i2, i3-1)(2)
        + f.read(i1, i2, i3)(2) - f.read(i1, i2, i3-1)(2))));
  }
private:
  Vector<Dim, TM> fact_m;
};
template<class T2, class Mesh, CenteringType OC>
class DivSameToSame;
template<class T2, int Dim, class TM, CenteringType OC>
class DivSameToSame<Vector<Dim, T2>, UniformRectilinearMesh<MeshTraits<Dim, TM, UniformRectilinearTag, CartesianTag> >, OC>
{
public:
  typedef T2 OutputElement_t;
  Centering<Dim> outputCentering() const
  {
    return canonicalCentering<Dim>(OC, Continuous);
  }
  Centering<Dim> inputCentering() const
  {
    return canonicalCentering<Dim>(OC, Continuous);
  }
  DivSameToSame()
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 0.5;
    }
  }
  template<class FE>
  DivSameToSame(const FE &fieldEngine)
  {
    for (int d = 0; d < Dim; ++d)
    {
      fact_m(d) = 0.5 / fieldEngine.mesh().spacings()(d);
    }
  }
  int lowerExtent(int d) const { return 1; }
  int upperExtent(int d) const { return 1; }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1) const
  {
    return OutputElement_t
      (fact_m(0)*(f.read(i1+1)(0) - f.read(i1-1)(0)));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2) const
  {
    return OutputElement_t
      (fact_m(0)*(f.read(i1+1,i2)(0) - f.read(i1-1,i2)(0))
     + fact_m(1)*(f.read(i1, i2+1)(1) - f.read(i1, i2-1)(1)));
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2, int i3) const
  {
    return OutputElement_t
      (fact_m(0)*(f.read(i1+1,i2, i3)(0) - f.read(i1-1,i2, i3)(0))
     + fact_m(1)*(f.read(i1, i2+1,i3)(1) - f.read(i1, i2-1,i3)(1))
     + fact_m(2)*(f.read(i1, i2, i3+1)(2) - f.read(i1, i2, i3-1)(2)));
  }
private:
  Vector<Dim, TM> fact_m;
};
template<class T2, class Mesh>
class DivCellToVert;
template<class T2, class Mesh>
class DivVertToCell;
template<class T2, class Mesh, CenteringType OC>
class DivSameToSame;
template<class Mesh, class T, class EngineTag>
typename
FieldStencilSimple<DivSameToSame<T, Mesh, CellType>,
  Field<Mesh, T, EngineTag> >::Type_t
divCellToCell(const Field<Mesh, T, EngineTag> &f)
{
  typedef DivSameToSame<T, Mesh, CellType> Div_t;
  typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
  return Ret_t::make(Div_t(f.fieldEngine()), f);
}
template<class Mesh, class T, class EngineTag>
typename
FieldStencilSimple<DivVertToCell<T, Mesh>,
  Field<Mesh, T, EngineTag> >::Type_t
divVertToCell(const Field<Mesh, T, EngineTag> &f)
{
  typedef DivVertToCell<T, Mesh> Div_t;
  typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
  return Ret_t::make(Div_t(f.fieldEngine()), f);
}
template<class Mesh, class T, class EngineTag>
typename
FieldStencilSimple<DivCellToVert<T, Mesh>,
  Field<Mesh, T, EngineTag> >::Type_t
divCellToVert(const Field<Mesh, T, EngineTag> &f)
{
  typedef DivCellToVert<T, Mesh> Div_t;
  typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
  return Ret_t::make(Div_t(f.fieldEngine()), f);
}
template<class Mesh, class T, class EngineTag>
typename
FieldStencilSimple<DivSameToSame<T, Mesh, VertexType>,
  Field<Mesh, T, EngineTag> >::Type_t
divVertToVert(const Field<Mesh, T, EngineTag> &f)
{
  typedef DivSameToSame<T, Mesh, VertexType> Div_t;
  typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
  return Ret_t::make(Div_t(f.fieldEngine()), f);
}
template<class D1,class T1,class E1>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t> >::Expression_t
min(const Field<D1,T1,E1> & l,const Field<D1,T1,E1> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<D1,T1,E1> >::make(l),
    CreateLeaf<Field<D1,T1,E1> >::make(r)));
}
template<class D1,class T1,class E1>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t> >::Expression_t
max(const Field<D1,T1,E1> & l,const Field<D1,T1,E1> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Field<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<D1,T1,E1> >::make(l),
    CreateLeaf<Field<D1,T1,E1> >::make(r)));
}
template <int Dim>
class DomainLayout;
template<class Functor> class FieldShift;
template <class Expression>
struct FieldShift;
template<int Dim, class T, class Expression>
class Engine<Dim, T, FieldShift<Expression> >
{
public:
  typedef FieldShift<Expression> Tag_t;
  typedef Expression Expression_t;
  typedef Engine<Dim, T, Tag_t> This_t;
  typedef This_t Engine_t;
  typedef Interval<Dim> Domain_t;
  typedef T Element_t;
  typedef ErrorType ElementRef_t;
  typedef typename Expression_t::Engine_t ExprEngine_t;
  typedef DomainLayout<Dim> Layout_t;
  enum { dimensions = Dim };
  enum { hasDataObject = ExprEngine_t::hasDataObject };
  enum { dynamic = false };
  enum { zeroBased = false };
  enum { multiPatch = ExprEngine_t::multiPatch };
  Engine()
    : domain_m(Pooma::NoInit()), exprEngine_m()
  {
  }
  template<class Layout>
  explicit Engine(const Layout &layout)
    : domain_m(layout.domain()), exprEngine_m()
  {
  }
  Engine(const Expression_t &f, const Loc<Dim> &offset, Domain_t domain)
    : domain_m(domain),
      offset_m(offset),
      exprEngine_m(f)
  {
  }
  Engine(const This_t &model)
    : domain_m(model.domain()),
      offset_m(model.offset_m),
      exprEngine_m(model.exprEngine())
  {
  }
  This_t &operator=(const This_t &model)
  {
    domain_m = model.domain();
    offset_m = model.offset_m;
    exprEngine_m = model.exprEngine();
    return *this;
  }
  inline Element_t read(int i) const
  {
    return exprEngine()(i + offset_m[0].first());
  }
  inline Element_t read(int i, int j) const
  {
    return exprEngine()(i + offset_m[0].first(),
                        j + offset_m[1].first());
  }
  inline Element_t read(int i, int j, int k) const
  {
    return exprEngine()(i + offset_m[0].first(),
                        j + offset_m[1].first(),
                        k + offset_m[2].first());
  }
  inline Element_t read(const Loc<Dim> &loc) const
  {
    return exprEngine()(loc + offset_m);
  }
  inline Element_t operator()(int i) const
  {
    return read(i);
  }
  inline Element_t operator()(int i, int j) const
  {
    return read(i, j);
  }
  inline Element_t operator()(int i, int j, int k) const
  {
    return read(i, j, k);
  }
  inline Element_t operator()(const Loc<Dim> &loc) const
  {
    return read(loc);
  }
  inline const Domain_t &domain() const { return domain_m; }
  inline Loc<Dim> offset() const
  {
    return offset_m;
  }
  inline const Expression_t &exprEngine() const { return exprEngine_m; }
  template<class RequestType>
  inline
  typename DataObjectRequest<RequestType>::Type_t
  dataObjectRequest(const DataObjectRequest<RequestType> &req) const
  {
    return exprEngine().engine().dataObjectRequest(req);
  }
  inline
  Interval<Dim> viewDomain(const Interval<Dim> &domain) const
  {
    Interval<Dim> ret;
    int d;
    for (d = 0; d < Dim; ++d)
    {
      ret[d] =
 Interval<1>(
      domain[d].first() + offset_m[d].first(),
      domain[d].last() + offset_m[d].first()
      );
    }
    return ret;
  }
  inline
  INode<Dim> viewDomain(const INode<Dim> &inode) const
  {
    return INode<Dim>(inode, viewDomain(inode.domain()));
  }
  inline
  Interval<Dim> intersectDomain() const
  {
    Interval<Dim> ret;
    int d;
    for (d = 0; d < Dim; ++d)
    {
      ret[d] =
 Interval<1>(
      domain_m[d].first() + offset_m[d].first(),
                    domain_m[d].last() + offset_m[d].first()
      );
    }
    return ret;
  }
private:
  Interval<Dim> domain_m;
  Loc<Dim> offset_m;
  Expression_t exprEngine_m;
};
template <int Dim, class T, class E>
struct NewEngine<Engine<Dim, T, FieldShift<E> >, Interval<Dim> >
{
  typedef typename NewEngine<E, Interval<Dim> >::Type_t Type_t;
};
template <int Dim, class T, class E>
struct NewEngineEngine<Engine<Dim, T, FieldShift<E> >, Interval<Dim> >
{
  typedef typename NewEngineEngine<E, Interval<Dim> >::Type_t Type_t;
  static inline
  Type_t apply(const Engine<Dim, T, FieldShift<E> > &e, const Interval<Dim> &d)
  {
    return NewEngineEngine<E, Interval<Dim> >::apply(e.exprEngine(),
                                                     e.viewDomain(d));
  }
};
template <int Dim, class T, class E>
struct NewEngineDomain<Engine<Dim, T, FieldShift<E> >, Interval<Dim> >
{
  typedef typename NewEngineDomain<E, Interval<Dim> >::Type_t Type_t;
  static inline
  Type_t apply(const Engine<Dim, T, FieldShift<E> > &e, const Interval<Dim> &d)
  {
    return NewEngineDomain<E, Interval<Dim> >::apply(e.exprEngine(),
                                                     e.viewDomain(d));
  }
};
template <int Dim, class T, class E>
struct NewEngine<Engine<Dim, T, FieldShift<E> >, INode<Dim> >
{
  typedef typename NewEngine<E, INode<Dim> >::Type_t Type_t;
};
template <int Dim, class T, class E>
struct NewEngineEngine<Engine<Dim, T, FieldShift<E> >, INode<Dim> >
{
  typedef typename NewEngineEngine<E, INode<Dim> >::Type_t Type_t;
  static inline
  Type_t apply(const Engine<Dim, T, FieldShift<E> > &e, const INode<Dim> &d)
  {
    return NewEngineEngine<E, INode<Dim> >::apply(e.exprEngine(),
                                                  e.viewDomain(d));
  }
};
template <int Dim, class T, class E>
struct NewEngineDomain<Engine<Dim, T, FieldShift<E> >, INode<Dim> >
{
  typedef typename NewEngineDomain<E, INode<Dim> >::Type_t Type_t;
  static inline
  Type_t apply(const Engine<Dim, T, FieldShift<E> > &e, const INode<Dim> &d)
  {
    return NewEngineDomain<E, INode<Dim> >::apply(e.exprEngine(),
                                                  e.viewDomain(d));
  }
};
template<class Expression>
struct FieldShiftSimple
{
  typedef typename Expression::MeshTag_t MeshTag_t;
  typedef typename Expression::Element_t OutputElement_t;
  enum { outputDim = Expression::dimensions };
  typedef typename Expression::Engine_t InputEngine_t;
  typedef FieldShift<InputEngine_t> OutputEngineTag_t;
  typedef Field<MeshTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  static inline
  Type_t make(const Expression &f,
       const FieldOffset<outputDim> &s1,
              const Centering<outputDim> &centering)
  {
    Type_t h(centering, f.layout(), f.mesh());
    h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
    Expression fld =
      (f.numSubFields() > 1) ? f[s1.subFieldNumber()] : f;
    const Loc<outputDim> &offset = s1.cellOffset();
    GuardLayers<outputDim> og(fld.fieldEngine().guardLayers());
    for (int d = 0; d < outputDim; d++)
      {
 og.lower(d) += offset[d].first();
 og.upper(d) -= offset[d].first();
      }
    h.fieldEngine().guardLayers() = og;
    h.fieldEngine().engine() = SEngine_t(fld.engine(), offset, fld.domain());
    return h;
  }
  static inline
  Type_t make(const Expression &f,
       const std::vector<FieldOffset<outputDim> > &vs1,
              const Centering<outputDim> &centering)
  {
    typedef typename std::vector<FieldOffset<outputDim> >::size_type size_type;
    Type_t h(centering, f.layout(), f.mesh());
    h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
    if (__builtin_expect(!!(vs1.size() == centering.size()), true)) {} else Pooma::toss_cookies("The FieldOffset vector's length must match the centering's size.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/DiffOps/FieldShiftEngine.h", 433);
    for (size_type s1Index = 0; s1Index < vs1.size(); ++s1Index) {
      const FieldOffset<outputDim> s1 = vs1[s1Index];
      Type_t hField = (h.numSubFields() > 1) ? h[s1Index] : h;
      Expression fld =
 (f.numSubFields() > 1) ? f[s1.subFieldNumber()] : f;
      const Loc<outputDim> &offset = s1.cellOffset();
      GuardLayers<outputDim> og(fld.fieldEngine().guardLayers());
      for (int d = 0; d < outputDim; d++)
 {
   og.lower(d) += offset[d].first();
   og.upper(d) -= offset[d].first();
 }
      hField.fieldEngine().guardLayers() = og;
      hField.fieldEngine().engine() =
 SEngine_t(fld.engine(), offset, fld.domain());
    }
    return h;
  }
};
template<class Expression>
struct EvaluatorEngineTraits<FieldShift<Expression> >
{
  typedef typename CreateLeaf<Expression>::Leaf_t Expr_t;
  typedef typename
    ForEach<Expr_t, EvaluatorTypeTag, EvaluatorCombineTag>::Type_t
      Evaluator_t;
};
template<int Dim, class Intersect>
class FieldShiftIntersector
{
public:
  typedef typename Intersect::IntersectorData_t IntersectorData_t;
  typedef FieldShiftIntersector<Dim, Intersect> This_t;
  typedef typename IntersectorData_t::const_iterator const_iterator;
  typedef RefCountedPtr<IntersectorData_t> DataPtr_t;
  typedef Interval<Dim> Domain_t;
  enum { dimensions = Intersect::dimensions };
  FieldShiftIntersector(const This_t &model)
    : domain_m(model.domain_m), intersector_m(model.intersector_m)
  { }
  FieldShiftIntersector(const Domain_t &dom, const Intersect &intersect)
    : domain_m(dom), intersector_m(intersect)
  { }
  This_t &operator=(const This_t &model)
  {
    if (this != &model)
    {
      domain_m = model.domain_m;
      intersector_m = model.intersector_m;
    }
    return *this;
  }
  ~FieldShiftIntersector() { }
  inline DataPtr_t &data() { return intersector_m.data(); }
  inline const DataPtr_t &data() const { return intersector_m.data(); }
  inline const_iterator begin() const { return data()->inodes_m.begin(); }
  inline const_iterator end() const { return data()->inodes_m.end(); }
  template<class Engine>
  inline void intersect(const Engine &engine)
  {
    typedef typename NewEngine<Engine, Interval<Dim> >::Type_t NewEngine_t;
    NewEngine_t newEngine(engine, domain_m);
    intersector_m.intersect(newEngine);
    data()->shared(engine.layout().ID(), newEngine.layout().ID());
  }
  template<class Engine, int Dim2>
  inline bool intersect(const Engine &engine, const GuardLayers<Dim2> &)
  {
    intersect(engine);
    return true;
  }
private:
  Interval<Dim> domain_m;
  Intersect intersector_m;
};
template <int Dim, class T, class Expression, class Intersect>
struct LeafFunctor<Engine<Dim, T, FieldShift<Expression> >,
  ExpressionApply<IntersectorTag<Intersect> > >
{
  typedef int Type_t;
  static
  int apply(const Engine<Dim, T, FieldShift<Expression> >
     &engine, const ExpressionApply<IntersectorTag<Intersect> > &tag)
  {
    typedef FieldShiftIntersector<Dim, Intersect> NewIntersector_t;
    NewIntersector_t newIntersector(engine.intersectDomain(),
        tag.tag().intersector_m);
    expressionApply(engine.field(),
      IntersectorTag<NewIntersector_t>(newIntersector));
    return 0;
  }
};
template<class RequestType> class DataObjectRequest;
template <int Dim, class T, class Expression, class RequestType>
struct EngineFunctor<Engine<Dim, T, FieldShift<Expression> >,
  DataObjectRequest<RequestType> >
{
  typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
  static Type_t
  apply(const Engine<Dim, T, FieldShift<Expression> > &engine,
 const DataObjectRequest<RequestType> &tag)
  {
    return engineFunctor(engine.field().engine(), tag);
  }
};
template <int Dim, class T, class Expression, class Tag>
struct LeafFunctor<Engine<Dim, T, FieldShift<Expression> >,
  EngineView<Tag> >
{
  typedef LeafFunctor<Expression, EngineView<Tag> > LeafFunctor_t;
  typedef typename LeafFunctor_t::Type_t NewViewed_t;
  typedef Engine<Dim, T, FieldShift<NewViewed_t> > Type_t;
  static
  Type_t apply(const Engine<Dim, T,
        FieldShift<Expression> > &engine,
        const EngineView<Tag> &tag)
  {
    return Type_t(LeafFunctor_t::apply(engine.field(), tag), engine);
  }
};
template <int Dim, class T, class Expression, class Tag>
struct LeafFunctor<Engine<Dim, T, FieldShift<Expression> >,
                   ExpressionApply<Tag> >
{
  typedef LeafFunctor<Expression, ExpressionApply<Tag> > LeafFunctor_t;
  typedef int Type_t;
  static
  Type_t apply(const Engine<Dim, T,
        FieldShift<Expression> > &engine,
        const ExpressionApply<Tag> &tag)
  {
    return LeafFunctor_t::apply(engine.field(), tag);
  }
};
template<class MeshTag, class T, class EngineTag, int Dim>
struct View2<Field<MeshTag, T, EngineTag>, FieldOffset<Dim>,
             Centering<Dim> >
{
  typedef Field<MeshTag, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef Field<MeshTag, T, FieldShift<Engine_t> > ReadType_t;
  typedef Field<MeshTag, T, FieldShift<Engine_t> > Type_t;
  inline static
  Type_t make(const Subject_t &f, const FieldOffset<Dim> &s1,
              const Centering<Dim> &c)
  {
    PoomaCTAssert<(Dim == Subject_t::dimensions)>::test();
    return FieldShiftSimple<Subject_t>::make(f, s1, c);
  }
  inline static
  ReadType_t makeRead(const Subject_t &f, const FieldOffset<Dim> &s1,
                      const Centering<Dim> &c)
  {
    PoomaCTAssert<(Dim == Subject_t::dimensions)>::test();
    return FieldShiftSimple<Subject_t>::make(f, s1, c);
  }
};
template<class MeshTag, class T, class EngineTag, int Dim>
struct View2<Field<MeshTag, T, EngineTag>, std::vector<FieldOffset<Dim> >,
             Centering<Dim> >
{
  typedef Field<MeshTag, T, EngineTag> Subject_t;
  typedef typename Subject_t::Engine_t Engine_t;
  typedef Field<MeshTag, T, FieldShift<Engine_t> > ReadType_t;
  typedef Field<MeshTag, T, FieldShift<Engine_t> > Type_t;
  inline static
  Type_t make(const Subject_t &f,
       const std::vector<FieldOffset<Dim> > &s1,
              const Centering<Dim> &c)
  {
    PoomaCTAssert<(Dim == Subject_t::dimensions)>::test();
    return FieldShiftSimple<Subject_t>::make(f, s1, c);
  }
  inline static
  ReadType_t makeRead(const Subject_t &f,
        const std::vector<FieldOffset<Dim> > &s1,
                      const Centering<Dim> &c)
  {
    PoomaCTAssert<(Dim == Subject_t::dimensions)>::test();
    return FieldShiftSimple<Subject_t>::make(f, s1, c);
  }
};
template<class T, int Dim, class Accumulate>
class FieldOffsetReduction
{
public:
  typedef T OutputElement_t;
  const Centering<Dim> &outputCentering() const
  {
    return outputCentering_m;
  }
  const Centering<Dim> &inputCentering() const
  {
    return inputCentering_m;
  }
  int lowerExtent(int d) const { return lower_m[d]; }
  int upperExtent(int d) const { return upper_m[d]; }
  FieldOffsetReduction()
  {
  }
  FieldOffsetReduction(const FieldOffsetList<Dim> &neighbors,
                       const Centering<Dim> &outputCentering,
                       const Centering<Dim> &inputCentering,
                       Accumulate accumulate = Accumulate())
    : neighbors_m(neighbors),
      outputCentering_m(outputCentering),
      inputCentering_m(inputCentering),
      accumulate_m(accumulate)
  {
    if (__builtin_expect(!!(neighbors.size() > 0), true)) {} else Pooma::toss_cookies("no support for empty accumulation", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Field/DiffOps/FieldOffsetReduction.h", 115);
    ;
    int d, i;
    for (d = 0; d < Dim; ++d)
    {
      upper_m[d] = 0;
      lower_m[d] = 0;
    }
    for (i = 0; i < neighbors_m.size(); ++i)
    {
      for (d = 0; d < Dim; ++d)
      {
        if (-neighbors_m[i].cellOffset()[d].first() > lower_m[d])
        {
          lower_m[d] = -neighbors_m[i].cellOffset()[d].first();
        }
        if (neighbors_m[i].cellOffset()[d].first() > upper_m[d])
        {
          upper_m[d] = neighbors_m[i].cellOffset()[d].first();
        }
      }
    }
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1) const
  {
    T ret = f(neighbors_m[0], Loc<1>(i1));
    for (int i = 1; i < neighbors_m.size(); ++i)
    {
      ret = accumulate_m(ret, f(neighbors_m[i], Loc<1>(i1)));
    }
    return ret;
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2) const
  {
    T ret = f(neighbors_m[0], Loc<2>(i1, i2));
    for (int i = 1; i < neighbors_m.size(); ++i)
    {
      ret = accumulate_m(ret, f(neighbors_m[i], Loc<2>(i1, i2)));
    }
    return ret;
  }
  template<class F>
  inline OutputElement_t
  operator()(const F &f, int i1, int i2, int i3) const
  {
    T ret = f(neighbors_m[0], Loc<3>(i1, i2, i3));
    for (int i = 1; i < neighbors_m.size(); ++i)
    {
      ret = accumulate_m(ret, f(neighbors_m[i], Loc<3>(i1, i2, i3)));
    }
    return ret;
  }
private:
  FieldOffsetList<Dim> neighbors_m;
  Centering<Dim> outputCentering_m;
  Centering<Dim> inputCentering_m;
  Accumulate accumulate_m;
  int lower_m[Dim];
  int upper_m[Dim];
};
template<class GeometryTag, class T, class EngineTag, int Dim>
typename FieldStencilSimple<FieldOffsetReduction<T, Dim, OpAdd>,
                            Field<GeometryTag, T, EngineTag> >::Type_t
sum(const Field<GeometryTag, T, EngineTag> &f,
    const std::vector<FieldOffsetList<Dim> > &nn,
    const Centering<Dim> &outputCentering)
{
  typedef FieldOffsetReduction<T, Dim, OpAdd> Functor_t;
  typedef Field<GeometryTag, T, EngineTag> Field_t;
  return FieldStencilSimple<Functor_t, Field_t>::make(f, nn, outputCentering,
                                                      OpAdd());
}
template <int Dim>
struct Deltas
{
  static const DomainDelta<Dim, 0> dX;
  static const DomainDelta<Dim, 1> dY;
  static const DomainDelta<Dim, 2> dZ;
};
template <int Dim>
const DomainDelta<Dim, 0> Deltas<Dim>::dX;
template <int Dim>
const DomainDelta<Dim, 1> Deltas<Dim>::dY;
template <int Dim>
const DomainDelta<Dim, 2> Deltas<Dim>::dZ;
static const DomainDelta<3, 0> dX;
static const DomainDelta<3, 1> dY;
static const DomainDelta<3, 2> dZ;
template <int dim, class MeshTag = UniformRectilinearTag, class CoordinateSystemTag = CartesianTag>
struct SerialTraits {
  typedef MeshTag MeshTag_t;
  typedef CoordinateSystemTag CoordinateSystemTag_t;
  enum { Dim = dim };
  typedef DomainLayout<dim> Layout_t;
  typedef MeshTraits<dim, double, MeshTag, CoordinateSystemTag> MeshTraits_t;
  typedef typename MeshTraits_t::Mesh_t Mesh_t;
  typedef Brick Engine_t;
  typedef CompressibleBrick CompressibleEngine_t;
  static void createLayout(DomainLayout<Dim>& l,
      const Grid<Dim>&, const Interval<Dim>& domain,
      const GuardLayers<Dim>&, const GuardLayers<Dim>& egc)
  {
    l = DomainLayout<Dim>(domain, egc);
  }
};
template <int dim, class MeshTag = UniformRectilinearTag, class CoordinateSystemTag = CartesianTag>
struct ParallelTraits {
  typedef MeshTag MeshTag_t;
  typedef CoordinateSystemTag CoordinateSystemTag_t;
  enum { Dim = dim };
  typedef GridLayout<dim> Layout_t;
  typedef MeshTraits<dim, double, MeshTag, CoordinateSystemTag> MeshTraits_t;
  typedef typename MeshTraits_t::Mesh_t Mesh_t;
  typedef MultiPatch<GridTag, Remote<Brick> > Engine_t;
  typedef MultiPatch<GridTag, Remote<CompressibleBrick> > CompressibleEngine_t;
  static void createLayout(GridLayout<Dim>& l,
      const Grid<Dim>& grid, const Interval<Dim>&,
      const GuardLayers<Dim>& igc, const GuardLayers<Dim>& egc)
  {
    l = GridLayout<Dim>(grid, igc, egc, DistributedTag());
  }
};
template <int dim, class MeshTag = UniformRectilinearTag, class CoordinateSystemTag = CartesianTag>
struct SerialMPTraits {
  typedef MeshTag MeshTag_t;
  typedef CoordinateSystemTag CoordinateSystemTag_t;
  enum { Dim = dim };
  typedef GridLayout<dim> Layout_t;
  typedef MeshTraits<dim, double, MeshTag, CoordinateSystemTag> MeshTraits_t;
  typedef typename MeshTraits_t::Mesh_t Mesh_t;
  typedef MultiPatch<GridTag, Brick> Engine_t;
  typedef MultiPatch<GridTag, CompressibleBrick> CompressibleEngine_t;
  static void createLayout(GridLayout<Dim>& l,
      const Grid<Dim>& grid, const Interval<Dim>&,
      const GuardLayers<Dim>& igc, const GuardLayers<Dim>& egc)
  {
    l = GridLayout<Dim>(grid, igc, egc, DistributedTag());
  }
};
template <class ComputeTraits>
struct RhalkTraits : public ComputeTraits {
  typedef ComputeTraits ComputeTraits_t;
  typedef typename ComputeTraits::Layout_t Layout_t;
  typedef typename ComputeTraits::Mesh_t Mesh_t;
  typedef typename ComputeTraits::Engine_t Engine_t;
  typedef typename ComputeTraits::CompressibleEngine_t CompressibleEngine_t;
  enum { Dim = ComputeTraits::Dim };
  typedef Centering<Dim> Centering_t;
  typedef typename Mesh_t::PositionsType_t Positions_t;
  typedef typename Mesh_t::SpacingsType_t Spacings_t;
  typedef Interval<Dim> Domain_t;
  typedef Loc<Dim> Loc_t;
  typedef Field<Mesh_t, double, Engine_t> Scalar_t;
  typedef Field<Mesh_t, Vector<Dim, double>, Engine_t> Vector_t;
};
enum { Dim = 3 };
typedef RhalkTraits<ParallelTraits<Dim, UniformRectilinearTag, CartesianTag> > Traits_t;
extern GuardLayers<Dim> corr_v[Dim];
extern bool a_dump_debug_f;
inline void enable_fp_exceptions(void)
{
  fexcept_t f;
  fegetexceptflag(&f, 
# 51969 "tramp3d-v4.cpp" 3 4
                     0x01
# 51969 "tramp3d-v4.cpp"
                               |
# 51969 "tramp3d-v4.cpp" 3 4
                                0x04
# 51969 "tramp3d-v4.cpp"
                                            |
# 51969 "tramp3d-v4.cpp" 3 4
                                             0x08
# 51969 "tramp3d-v4.cpp"
                                                        |
# 51969 "tramp3d-v4.cpp" 3 4
                                                         0x10
# 51969 "tramp3d-v4.cpp"
                                                                     );
  fesetexceptflag(&f, 
# 51970 "tramp3d-v4.cpp" 3 4
                     0x01
# 51970 "tramp3d-v4.cpp"
                               |
# 51970 "tramp3d-v4.cpp" 3 4
                                0x04
# 51970 "tramp3d-v4.cpp"
                                            |
# 51970 "tramp3d-v4.cpp" 3 4
                                             0x08
# 51970 "tramp3d-v4.cpp"
                                                        |
# 51970 "tramp3d-v4.cpp" 3 4
                                                         0x10
# 51970 "tramp3d-v4.cpp"
                                                                     );
}
inline void disable_fp_exceptions(void)
{
  feclearexcept((
# 51974 "tramp3d-v4.cpp" 3 4
                0x20 
# 51974 "tramp3d-v4.cpp"
                           | 
# 51974 "tramp3d-v4.cpp" 3 4
                             0x04 
# 51974 "tramp3d-v4.cpp"
                                          | 
# 51974 "tramp3d-v4.cpp" 3 4
                                            0x10 
# 51974 "tramp3d-v4.cpp"
                                                         | 
# 51974 "tramp3d-v4.cpp" 3 4
                                                           0x08 
# 51974 "tramp3d-v4.cpp"
                                                                       | 
# 51974 "tramp3d-v4.cpp" 3 4
                                                                         0x01
# 51974 "tramp3d-v4.cpp"
                                                                                   ));
}
# 1 "/usr/include/c++/6/fstream" 1 3
# 36 "/usr/include/c++/6/fstream" 3
       
# 37 "/usr/include/c++/6/fstream" 3




# 1 "/usr/include/c++/6/cstdio" 1 3
# 39 "/usr/include/c++/6/cstdio" 3
       
# 40 "/usr/include/c++/6/cstdio" 3
# 42 "/usr/include/c++/6/fstream" 2 3
# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/basic_file.h" 1 3
# 37 "/usr/include/c++/6/x86_64-suse-linux/bits/basic_file.h" 3
       
# 38 "/usr/include/c++/6/x86_64-suse-linux/bits/basic_file.h" 3


# 1 "/usr/include/c++/6/x86_64-suse-linux/bits/c++io.h" 1 3
# 35 "/usr/include/c++/6/x86_64-suse-linux/bits/c++io.h" 3
# 1 "/usr/include/c++/6/cstdio" 1 3
# 39 "/usr/include/c++/6/cstdio" 3
       
# 40 "/usr/include/c++/6/cstdio" 3
# 36 "/usr/include/c++/6/x86_64-suse-linux/bits/c++io.h" 2 3



# 38 "/usr/include/c++/6/x86_64-suse-linux/bits/c++io.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/include/c++/6/x86_64-suse-linux/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* __lock = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/include/c++/6/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/6/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 147 "/usr/include/c++/6/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      { this->close(); }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 296 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 306 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 323 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 355 "/usr/include/c++/6/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 375 "/usr/include/c++/6/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 421 "/usr/include/c++/6/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 454 "/usr/include/c++/6/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 481 "/usr/include/c++/6/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 494 "/usr/include/c++/6/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 510 "/usr/include/c++/6/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 533 "/usr/include/c++/6/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 565 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 594 "/usr/include/c++/6/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 614 "/usr/include/c++/6/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 632 "/usr/include/c++/6/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 655 "/usr/include/c++/6/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 682 "/usr/include/c++/6/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 696 "/usr/include/c++/6/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 714 "/usr/include/c++/6/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 737 "/usr/include/c++/6/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 769 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 798 "/usr/include/c++/6/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 819 "/usr/include/c++/6/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 838 "/usr/include/c++/6/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 861 "/usr/include/c++/6/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 889 "/usr/include/c++/6/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 901 "/usr/include/c++/6/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 939 "/usr/include/c++/6/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 971 "/usr/include/c++/6/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1000 "/usr/include/c++/6/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1021 "/usr/include/c++/6/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1040 "/usr/include/c++/6/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}

# 1 "/usr/include/c++/6/bits/fstream.tcc" 1 3
# 37 "/usr/include/c++/6/bits/fstream.tcc" 3
       
# 38 "/usr/include/c++/6/bits/fstream.tcc" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             );
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                                );
         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {
         _M_set_buffer(0);
         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 787 "/usr/include/c++/6/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1082 "/usr/include/c++/6/fstream" 2 3
# 51977 "tramp3d-v4.cpp" 2

# 51977 "tramp3d-v4.cpp"
namespace Pooma {
Inform pinfo("Pooma");
Inform pwarn("Warning", std::cerr, Inform::allContexts);
Inform perr("Error", std::cerr, Inform::allContexts);
Inform pdebug("** Debug **", std::cerr, Inform::allContexts);
Context_t myContext_g = 0;
int numContexts_g = 1;
int expression_g = 0;
  namespace {
    bool initialized_s = false;
    bool weInitializedRTS_s = false, weInitializedArch_s = false;
    Options options_s;
    Scheduler_t mainScheduler_s;
    Statistics statistics_s;
    std::ofstream *logstream_s = 0;
    Inform::ID_t pinfoLogID_s;
    Inform::ID_t pwarnLogID_s;
    Inform::ID_t perrLogID_s;
    Inform::ID_t pdebugLogID_s;
    void defAbortHandler_s()
    {
      std::cerr << "In default abort handler." << std::endl;
    }
    AbortHandler_t currentAbortHandler_s = defAbortHandler_s;
    long reductionFilter_s(long val)
    {
      ReduceOverContexts<long, OpAddAssign> reduce(val, 0);
      return reduce;
    }
    void cleanup_s()
    {
      if (printStats())
        statistics_s.print(pinfo, reductionFilter_s);
      logMessages(0);
      infoMessages(false);
      warnMessages(false);
      errorMessages(false);
      debugLevel(Inform::off);
    }
  }
namespace { Pooma::StatisticsData *statNumExpressions_s = statistics_s.add("Number of expressions evaluated"); } void incrementNumExpressions(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumExpressions_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumZBExpressions_s = statistics_s.add("Number of zero-based expressions evaluated"); } void incrementNumZBExpressions(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumZBExpressions_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumMultiPatchExpressions_s = statistics_s.add("Number of multi-patch expressions evaluated"); } void incrementNumMultiPatchExpressions(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumMultiPatchExpressions_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumCompressedAssigns_s = statistics_s.add("Number of fully compressed assignments"); } void incrementNumCompressedAssigns(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumCompressedAssigns_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumAssignsRequiringUnCompression_s = statistics_s.add("Number of assignments requiring uncompression"); } void incrementNumAssignsRequiringUnCompression(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumAssignsRequiringUnCompression_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumInlineEvaluations_s = statistics_s.add("Number of assignments using the inline evaluator"); } void incrementNumInlineEvaluations(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumInlineEvaluations_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumLocalPatchesEvaluated_s = statistics_s.add("Number of local patches evaluated"); } void incrementNumLocalPatchesEvaluated(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumLocalPatchesEvaluated_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumReductions_s = statistics_s.add("Number of reductions performed"); } void incrementNumReductions(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumReductions_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumUnCompresses_s = statistics_s.add("Number of times a compressible block uncompresses"); } void incrementNumUnCompresses(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumUnCompresses_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumUnsuccessfulTryCompresses_s = statistics_s.add("Number of times a compression attempt fails"); } void incrementNumUnsuccessfulTryCompresses(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumUnsuccessfulTryCompresses_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumSuccessfulTryCompresses_s = statistics_s.add("Number of times a compression attempt succeeds"); } void incrementNumSuccessfulTryCompresses(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumSuccessfulTryCompresses_s->increment(val); mutex.unlock(); }
namespace { Pooma::StatisticsData *statNumPolls_s = statistics_s.add("Number of calls to Pooma::poll()"); } void incrementNumPolls(long val) { static Pooma::Mutex_t mutex; mutex.lock(); statNumPolls_s->increment(val); mutex.unlock(); }
bool initialize(int &argc, char ** &argv, bool initRTS, bool getCLArgsArch,
  bool initArch)
{
  if (getCLArgsArch)
    Pooma::Arch::getCommandLineArguments(argc, argv);
  Options opts(argc, argv);
  return initialize(opts, initRTS, initArch);
}
bool initialize(Options &opts, bool initRTS, bool initArch)
{
  if (__builtin_expect(!!(!initialized_s), true)) {} else Pooma::toss_cookies("You can only call Pooma::initialize once.", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Pooma/Pooma.cmpl.cpp", 306);
  initialized_s = true;
  weInitializedRTS_s = initRTS;
  weInitializedArch_s = initArch;
  if (initArch)
    Pooma::Arch::initialize();
  debugLevel(opts.debug());
  options_s = opts;
  if (initRTS)
  {
    Smarts::concurrency(opts.concurrency());
  }
  myContext_g = 0;
  numContexts_g = 1;
  logstream_s = 0;
  logMessages(opts.logfile().c_str());
  infoMessages(opts.printInfo());
  warnMessages(opts.printWarnings());
  errorMessages(opts.printErrors());
  Inform::setContext(myContext_g);
  Inform::setNumContexts(numContexts_g);
  return true;
}
bool finalize()
{
  return finalize(weInitializedRTS_s, weInitializedArch_s);
}
bool finalize(bool quitRTS, bool quitArch)
{
  Pooma::blockAndEvaluate();
  if (initialized_s)
  {
    Smarts::wait();
    cleanup_s();
    if (quitRTS)
    {
    }
  }
  if (quitArch)
    Pooma::Arch::finalize();
  return true;
}
void pAbort(int errorcode)
{
  pAbort("Pooma::pAbort called.", errorcode);
}
void pAbort(const char *msg, int)
{
  if (msg != 0)
    std::cerr << msg << std::endl;
  currentAbortHandler_s();
  if (initialized_s)
  {
    cleanup_s();
  }
  ::abort();
}
AbortHandler_t abortHandler()
{
  return currentAbortHandler_s;
}
AbortHandler_t abortHandler(AbortHandler_t ah)
{
  AbortHandler_t oldah = currentAbortHandler_s;
  currentAbortHandler_s = ah;
  return oldah;
}
AbortHandler_t resetAbortHandler()
{
  return abortHandler(defAbortHandler_s);
}
const char *version()
{
  ;
  return "FreePOOMA 2.4.devel";
}
int majorVersion()
{
  ;
  return 2;
}
int minorVersion()
{
  ;
  return 4;
}
const char *buildDate()
{
  ;
  return "Wed Mar 23 16:19:43 CET 2005";
}
bool printStats()
{
  ;
  return options_s.printStats();
}
void printStats(bool on)
{
  ;
  options_s.printStats(on);
}
bool infoMessages()
{
  ;
  return (pinfo.outputLevel() >= 0);
}
void infoMessages(bool on)
{
  ;
  pinfo.setOutputLevel(on ? Inform::on : Inform::off);
}
bool warnMessages()
{
  ;
  return (pwarn.outputLevel() >= 0);
}
void warnMessages(bool on)
{
  ;
  pwarn.setOutputLevel(on ? Inform::on : Inform::off);
}
bool errorMessages()
{
  ;
  return (perr.outputLevel() >= 0);
}
void errorMessages(bool on)
{
  ;
  perr.setOutputLevel(on ? Inform::on : Inform::off);
}
void logMessages(const char *filename)
{
  ;
  if (logstream_s != 0)
    {
      pinfo.close(pinfoLogID_s);
      pwarn.close(pwarnLogID_s);
      perr.close(perrLogID_s);
      pdebug.close(pdebugLogID_s);
      delete logstream_s;
      logstream_s = 0;
    }
  if (filename != 0 && *filename != 0)
    {
      logstream_s = new std::ofstream(filename, std::ios::out);
      pinfoLogID_s = pinfo.open(*logstream_s);
      pwarnLogID_s = pwarn.open(*logstream_s);
      perrLogID_s = perr.open(*logstream_s);
      pdebugLogID_s = pdebug.open(*logstream_s);
      pinfo.setOutputLevel(pinfo.outputLevel());
      pwarn.setOutputLevel(pwarn.outputLevel());
      perr.setOutputLevel(perr.outputLevel());
      pdebug.setOutputLevel(pdebug.outputLevel());
    }
}
int debugLevel()
{
  ;
  return pdebug.outputLevel();
}
void debugLevel(int level)
{
  ;
  pdebug.setOutputLevel(level);
}
bool neverCompress()
{
  ;
  return options_s.neverCompress();
}
void neverCompress(bool p)
{
  ;
  options_s.neverCompress(p);
}
bool deferredGuardFills()
{
  ;
  return options_s.deferredGuardFills();
}
void deferredGuardFills(bool p)
{
  ;
  options_s.deferredGuardFills(p);
}
Scheduler_t &scheduler()
{
  ;
  return mainScheduler_s;
}
void blockAndEvaluate()
{
  ;
  mainScheduler_s.blockingEvaluate();
}
bool hardInit()
{
  ;
  return options_s.hardInit();
}
void hardInit(bool on)
{
  ;
  options_s.hardInit(on);
}
bool hardRun()
{
  ;
  return options_s.hardRun();
}
void hardRun(bool on)
{
  ;
  options_s.hardRun(on);
}
bool lockThreads()
{
  ;
  return options_s.lockThreads();
}
void lockThreads(bool on)
{
  ;
  options_s.lockThreads(on);
}
bool blockingExpressions()
{
  ;
  return options_s.blockingExpressions();
}
void blockingExpressions(bool on)
{
  ;
  options_s.blockingExpressions(on);
}
}
extern "C" void pooma_stop_here();
void Pooma::stopHere()
{
  ::pooma_stop_here();
}
extern "C" void pooma_stop_here()
{
}
namespace Pooma {
class PatchSizeSyncer
{
public:
  typedef Grid<1> Grid_t;
  PatchSizeSyncer(int contextKey, Grid_t &localGrid);
  ~PatchSizeSyncer();
 void calcGlobalGrid(Grid_t &globalGrid);
private:
  int myContext_m;
  int numContexts_m;
  int localKey_m;
  Grid_t localGrid_m;
  typedef std::pair<int,Grid_t *> Elem_t;
  std::vector<Elem_t> gridList_m;
  PatchSizeSyncer(const PatchSizeSyncer &);
  PatchSizeSyncer &operator=(const PatchSizeSyncer &);
  static int tag_s;
};
}
template<class T>
class CollectFromContexts
{
public:
  CollectFromContexts(const T &val, int context = 0, bool valid = true)
    {
      ;
      ;
      value_m = val;
    }
  T &operator[](int i)
    {
      ;
      return value_m;
    }
  T operator[](int i) const
    {
      ;
      return value_m;
    }
private:
  T value_m;
};
namespace Pooma {
PatchSizeSyncer::PatchSizeSyncer(int contextKey, Grid_t &localGrid)
  : myContext_m(Pooma::context()),
    numContexts_m(Pooma::contexts()),
    localKey_m(contextKey),
    localGrid_m(localGrid)
{
  if (myContext_m == 0) gridList_m.reserve(numContexts_m);
}
PatchSizeSyncer::~PatchSizeSyncer()
{
  ;
  for (int i = 0; i < gridList_m.size(); ++i)
    delete gridList_m[i].second;
}
namespace {
struct ElemCompare
{
  typedef std::pair<int,Grid<1>*> Elem_t;
  inline bool operator()(const Elem_t &l, const Elem_t &r)
  {
    return l.first < r.first;
  }
};
}
void PatchSizeSyncer::calcGlobalGrid(Grid_t &globalGrid)
{
  globalGrid = localGrid_m;
}
}
TagGenerator tagGenerator_g;
namespace Pooma {
int expectedMessages_g = 0;
void initializeCheetahHelpers(int contexts)
{
  tagGenerator_g = TagGenerator(contexts);
  expectedMessages_g = 0;
}
void finalizeCheetahHelpers()
{
  ;
}
int sendTag(int context)
{
  return tagGenerator_g.send(context);
}
int receiveTag(int context)
{
  return tagGenerator_g.receive(context);
}
}
const unsigned int Inform::bufSize = 32000;
Pooma::Mutex_t Inform::outputMutex_s;
Inform::Context_t Inform::context_s = 0;
Inform::Context_t Inform::nContexts_s = 1;
class InformStream
{
public:
  InformStream(std::ostream *s, Inform::Context_t oc)
    : stream_m(s), close_m(false), outputContext_m(oc), level_m(0)
  {
    ;
  }
  InformStream(const char *fname, int mode, Inform::Context_t oc)
    : stream_m(0), close_m(true), outputContext_m(oc), level_m(0)
  {
    ;
    ;
    if (oc < 0 || oc == Inform::context()) {
      if (mode == Inform::out)
 stream_m = new std::ofstream(fname, std::ios::out);
      else
 stream_m = new std::ofstream(fname, std::ios::app);
    }
  }
  ~InformStream()
  {
    if (close_m && stream_m != 0)
      delete stream_m;
  }
  Inform::Context_t outputContext() const
  {
    return outputContext_m;
  }
  void setOutputContext(Inform::Context_t val)
  {
    outputContext_m = val;
  }
  Inform::Level_t outputLevel() const
  {
    return level_m;
  }
  void setOutputLevel(Inform::Level_t val)
  {
    level_m = val;
  }
  void print(Inform::Level_t l, const std::string &prefix, const char *msg)
  {
    if (shouldPrint(l))
      {
        if (prefix.length() > 0)
          {
            *stream_m << prefix;
            if (Inform::numContexts() > 1)
              {
                if ((outputContext_m == Inform::allContexts) ||
                    (outputContext_m == Inform::context()))
                  {
                    *stream_m << "{" << Inform::context() << "}";
                  }
              }
            *stream_m << "> ";
          }
        *stream_m << msg << "\n";
        stream_m->flush();
      }
  }
private:
  std::ostream *stream_m;
  bool close_m;
  Inform::Context_t outputContext_m;
  Inform::Level_t level_m;
  bool shouldPrint(Inform::Level_t level)
  {
    ;
    if (stream_m == 0)
      return false;
    return (level <= level_m &&
     (outputContext_m == Inform::context() ||
      outputContext_m == Inform::allContexts));
  }
};
namespace std {
  Inform &endl(Inform &inf)
  {
    inf.flush();
    return inf;
  }
  Inform &flush(Inform &inf)
  {
    inf.flush();
    return inf;
  }
  Inform &lock(Inform &inf)
  {
    inf.lock();
    return inf;
  }
  Inform &unlock(Inform &inf)
  {
    inf.unlock();
    return inf;
  }
}
Inform::Inform(const char *prefix, Context_t outputContext)
  : prefix_m(""), outputContext_m(outputContext), level_m(0),
    message_m(0), buffer_m(0), nextID_m(0)
{
  open(outputContext);
  setup(prefix);
}
Inform::Inform(const char *prefix, const char *fname, int writemode,
        Context_t outputContext)
  : prefix_m(""), outputContext_m(outputContext), level_m(0),
    message_m(0), buffer_m(0), nextID_m(0)
{
  open(fname, writemode, outputContext);
  setup(prefix);
}
Inform::Inform(const char *prefix, std::ostream &outstream,
               Context_t outputContext)
  : prefix_m(""), outputContext_m(outputContext), level_m(0),
    message_m(0), buffer_m(0), nextID_m(0)
{
  open(outstream, outputContext);
  setup(prefix);
}
Inform::~Inform()
{
  close();
  delete message_m;
  if (buffer_m != 0)
    delete [] buffer_m;
}
Inform::ID_t Inform::open(Context_t oc)
{
  streams_m.insert(Value_t(nextID_m, new InformStream(&std::cout, oc)));
  return nextID_m++;
}
Inform::ID_t Inform::open(const char *fname, int mode, Context_t oc)
{
  streams_m.insert(Value_t(nextID_m, new InformStream(fname, mode, oc)));
  return nextID_m++;
}
Inform::ID_t Inform::open(std::ostream &outstream, Context_t oc)
{
  streams_m.insert(Value_t(nextID_m, new InformStream(&outstream, oc)));
  return nextID_m++;
}
void Inform::close(ID_t id)
{
  iterator s = streams_m.find(id);
  ;
  delete ((*s).second);
  streams_m.erase(s);
}
void Inform::close()
{
  for (iterator a = streams_m.begin(); a != streams_m.end(); ++a)
    delete ((*a).second);
  streams_m.erase(streams_m.begin(), streams_m.end());
}
Inform::Level_t Inform::outputLevel(ID_t id) const
{
  InformStream *s = findStream(id);
  ;
  return s->outputLevel();
}
void Inform::setOutputLevel(Level_t newval, ID_t id)
{
  InformStream *s = findStream(id);
  ;
  s->setOutputLevel(newval);
}
void Inform::setOutputLevel(Level_t newval)
{
  for (iterator a = streams_m.begin(); a != streams_m.end(); ++a)
    (*a).second->setOutputLevel(newval);
}
Inform::Context_t Inform::outputContext(ID_t id) const
{
  InformStream *s = findStream(id);
  ;
  return s->outputContext();
}
void Inform::setOutputContext(Context_t outputContext, ID_t id)
{
  InformStream *s = findStream(id);
  ;
  s->setOutputContext(outputContext);
}
void Inform::setOutputContext(Context_t outputContext)
{
  for (iterator a = streams_m.begin(); a != streams_m.end(); ++a)
    (*a).second->setOutputContext(outputContext);
}
void Inform::flush()
{
  *message_m << std::ends;
  outputMutex_s.lock();
  std::string formatstr = message_m->str();
  char *outputbuf = new char[formatstr.length() + 2];
  char *endbuf = outputbuf;
  char *begbuf = outputbuf;
  const char *formatbuf = formatstr.c_str();
  do {
    while (*formatbuf != '\n' && *formatbuf != '\0')
      *endbuf++ = *formatbuf++;
    *endbuf = '\0';
    if (*formatbuf == '\n')
      ++formatbuf;
    for (iterator a = streams_m.begin(); a != streams_m.end(); ++a)
      (*a).second->print(level_m, prefix_m, begbuf);
    begbuf = endbuf;
  } while (*formatbuf != '\0');
  message_m->str( std::string() );
  delete [] outputbuf;
  outputMutex_s.unlock();
}
InformStream *Inform::findStream(ID_t id) const
{
  const_iterator s = streams_m.find(id);
  if (s != streams_m.end())
    return (*s).second;
  else
    return 0;
}
void Inform::setup(const char *prefix)
{
  setPrefix(prefix);
  buffer_m = 0;
  message_m = new std::ostringstream(std::ios::out);
}
void Inform::setPrefix(const char *prefix)
{
  if (prefix == 0 || *prefix == '\0')
    prefix_m = "";
  else
    prefix_m = prefix;
}
Pool::Pool(size_t sz)
  :
  head_m(0),
  outstandingAllocs_m(0),
  bsize_m(roundToAlign(sz)),
  nblock_m(blocksInPage(bsize_m))
{
}
Pool::Pool()
  :
  head_m(0),
  outstandingAllocs_m(0),
  bsize_m(0),
  nblock_m(0)
{
}
Pool::~Pool()
{
  if (__builtin_expect(!!(outstandingAllocs_m==0), true)) {} else Pooma::toss_cookies("Not all of the pooled memory was freed!", "/home/rguenth/ix86/pooma/tat-serial/pooma/linux/src/Utilities/Pool.cmpl.cpp", 73);
  for (std::vector<char*>::iterator p=chunks_m.begin(); p!=chunks_m.end(); ++p)
    delete [] *p;
}
void Pool::grow()
{
  size_t alloc_this;
  if ( bsize_m>page )
    alloc_this = bsize_m;
  else
    alloc_this = page;
  char *start = new char[alloc_this];
  chunks_m.push_back(start);
  char *last = start + (nblock_m-1)*bsize_m;
  for (char *p=start; p!=last; p+=bsize_m)
    ((Link*)p)->next_m = (Link*)(p+bsize_m);
  ((Link*)last)->next_m = head_m;
  head_m = (Link*)start;
}

namespace Pooma {
Assertion::Assertion(const char *msg, const char *file, int line)
{
  msg_m = new char[strlen(msg) + 1];
  strcpy(msg_m, msg);
  file_m = new char[strlen(file) + 1];
  strcpy(file_m, file);
  line_m = line;
}
Assertion::Assertion(const Assertion &a)
{
  msg_m = new char[strlen(a.what())+1];
  strcpy(msg_m, a.what());
  file_m = new char[strlen(a.file())+1];
  strcpy(file_m, a.file());
  line_m = a.line();
}
Assertion &Assertion::operator=(const Assertion &a)
{
  msg_m = new char[strlen(a.what())+1];
  strcpy(msg_m, a.what());
  file_m = new char[strlen(a.file())+1];
  strcpy(file_m, a.file());
  line_m = a.line();
  return *this;
}
void toss_cookies(const char *msg, const char *file, int line ...)
{
  va_list ap;
  
# 52684 "tramp3d-v4.cpp" 3 4
 __builtin_va_start(
# 52684 "tramp3d-v4.cpp"
 ap
# 52684 "tramp3d-v4.cpp" 3 4
 ,
# 52684 "tramp3d-v4.cpp"
 line
# 52684 "tramp3d-v4.cpp" 3 4
 )
# 52684 "tramp3d-v4.cpp"
                  ;
  char buf[256];
  vsprintf(buf, msg, ap);
  
# 52687 "tramp3d-v4.cpp" 3 4
 __builtin_va_end(
# 52687 "tramp3d-v4.cpp"
 ap
# 52687 "tramp3d-v4.cpp" 3 4
 )
# 52687 "tramp3d-v4.cpp"
           ;
  Assertion a(buf, file, line);
  Pooma::stopHere();
  fprintf(
# 52690 "tramp3d-v4.cpp" 3 4
         stderr
# 52690 "tramp3d-v4.cpp"
               , "### POOMA Assertion Failure on context %i ###\n", Pooma::context());
  fprintf(
# 52691 "tramp3d-v4.cpp" 3 4
         stderr
# 52691 "tramp3d-v4.cpp"
               , "### %s\n", a.what());
  fprintf(
# 52692 "tramp3d-v4.cpp" 3 4
         stderr
# 52692 "tramp3d-v4.cpp"
               , "### File %s; Line %d.\n", a.file(), a.line());
  Pooma::pAbort();
}
}
Unique::Value_t Unique::next_s = 0;
Pooma::Mutex_t Unique::mutex_s;
bool findLeftCommonEndpoint(int a0, int a1, int s, int b0, int b1, int t,
       int &endpoint)
{
  ;
  if (s < 0) s = -s;
  if (t < 0) t = -t;
  if (a0 > b0) {
    int tmp;
    tmp = a0; a0 = b0; b0 = tmp;
    tmp = a1; a1 = b1; b1 = tmp;
    tmp = s; s = t; t = tmp;
  }
  int i1 = b0 - ((b0 - a0) % s);
  int i2 = b0;
  int maxdiff = 0;
  int minright = a1;
  if (b1 < a1)
    minright = b1;
  while (i1 <= minright && i2 <= minright) {
    while (i1 < i2)
      i1 += s;
    int newdiff = i1 - i2;
    if (i1 == i2 || newdiff == maxdiff) {
      break;
    } else if (newdiff > maxdiff) {
      maxdiff = newdiff;
    }
    i2 += t;
  }
  if (i1 == i2 && i1 <= minright) {
    endpoint = i1;
    return true;
  } else {
    return false;
  }
}
int findLCM(int s, int t)
{
  ;
  int i1 = s, i2 = t;
  if (s > t) {
    s = t;
    t = i1;
    i1 = s;
    i2 = t;
  }
  while (i1 != i2) {
    while (i1 < i2)
      i1 += s;
    if (i1 > i2)
      i2 += t;
  }
  return i1;
}
bool findIntersectionEndpoints(int a0, int a1, int s, int b0, int b1, int t,
                               int &left, int &right, int &stride)
{
  ;
  if (s < 0) s = -s;
  if (t < 0) t = -t;
  if (!findLeftCommonEndpoint(a0, a1, s, b0, b1, t, left))
    return false;
  stride = findLCM(s, t);
  int m = a1;
  if (b1 < a1)
    m = b1;
  right = m - ((m - left) % stride);
  return true;
}
GlobalIDDataBase::NodeKey_t
GlobalIDDataBase::push(LayoutID_t layoutID, int context, GlobalID_t globalID)
{
  int ret = data_m.size();
  data_m.push_back(Pack(layoutID, context, globalID, nullNodeKey()));
  return ret;
}
GlobalIDDataBase::NodeKey_t
GlobalIDDataBase::push(LayoutID_t layoutID,
         int context,
         GlobalID_t globalID,
         NodeKey_t parentNode)
{
  int ret = data_m.size();
  data_m.push_back(Pack(layoutID, context, globalID, parentNode));
  return ret;
}
void
GlobalIDDataBase::shared(LayoutID_t idNew, LayoutID_t idOld)
{
  Shared_t::const_iterator p = shared_m.find(idOld);
  if (p != shared_m.end())
  {
    idOld = p->second;
  }
  Shared_t::value_type i(idNew, idOld);
  shared_m.insert(i);
}
GlobalIDDataBase::GlobalID_t
GlobalIDDataBase::globalID(LayoutID_t layoutID, NodeKey_t key) const
{
  Shared_t::const_iterator p = shared_m.find(layoutID);
  if (p != shared_m.end())
  {
    layoutID = p->second;
  }
  while( key != nullNodeKey() )
  {
    if (data_m[key].layoutID() == layoutID)
    {
      return data_m[key].globalID();
    }
    else
    {
      key = data_m[key].parent();
    }
  }
  ;
  return -1;
}
int
GlobalIDDataBase::context(LayoutID_t layoutID, NodeKey_t key) const
{
  Shared_t::const_iterator p = shared_m.find(layoutID);
  if (p != shared_m.end())
  {
    layoutID = p->second;
  }
  while( key != nullNodeKey() )
  {
    if (data_m[key].layoutID() == layoutID)
    {
      return data_m[key].context();
    }
    else
    {
      key = data_m[key].parent();
    }
  }
  ;
  return -1;
}
int
GlobalIDDataBase::context(NodeKey_t key) const
{
  ;
  return data_m[key].context();
}
bool
GlobalIDDataBase::contextParticipates(int context, NodeKey_t key) const
{
  while( key != nullNodeKey() )
  {
    if (data_m[key].context() == context)
    {
      return true;
    }
    else
    {
      key = data_m[key].parent();
    }
  }
  return false;
}
namespace Pooma {
  namespace {
    unsigned int activeGroups_g = 1;
    unsigned int numGroups_g = 1;
  }
  unsigned int activeRelationGroups()
    {
      return activeGroups_g;
    }
  bool isRelationGroupActive(unsigned int groups)
    {
      return (groups & activeGroups_g) != 0;
    }
  void activateRelationGroup(unsigned int group)
    {
      blockAndEvaluate();
      activeGroups_g |= group;
    }
  void deactivateRelationGroup(unsigned int group)
    {
      blockAndEvaluate();
      activeGroups_g &= ~group;
    }
  unsigned int newRelationGroup()
    {
      unsigned int n = (1 << numGroups_g++);
      activateRelationGroup(n);
      return n;
    }
}
template <int Dim>
CanonicalCentering<Dim>::CanonicalCentering()
{
  Centering<Dim> centering;
  typename Centering<Dim>::Orientation orientation;
  typename Centering<Dim>::Position position;
  typename Centering<Dim>::Orientations orientations[Dim][2];
  typename Centering<Dim>::Positions positions[Dim][2];
  enum { x = 0, y, z };
  if (class_count_m == 0) {
    centering_table_m = new Centering<Dim>**[CellType+1];
    for (int i = 0; i <= CellType; ++i) {
      centering_table_m[i] = new Centering<Dim>*[2];
      for (int j = 0; j < 2; ++j)
 centering_table_m[i][j] = new Centering<Dim>[1<<Dim];
    }
  }
  ++class_count_m;
  centering = Centering<Dim>(CellType, Continuous);
  orientation = 1;
  position = 0.5;
  centering.addValue(orientation, position);
  centering_table_m[CellType][Continuous][AllDim%(1<<Dim)] = centering;
  orientation = 0; orientation[0] = 1;
  position = 0.0; position(0) = 0.5;
  addValue(orientations[x][Continuous],
    positions[x][Continuous],
    orientation, position);
  orientations[x][Discontinuous] =
    orientations[x][Continuous];
  positions[x][Discontinuous] =
    positions[x][Continuous];
  if (Dim > 1) {
    position(1) = 1.0;
    addValue(orientations[x][Discontinuous],
      positions[x][Discontinuous],
      orientation, position);
    if (Dim > 2) {
      position(2) = 1.0;
      addValue(orientations[x][Discontinuous],
        positions[x][Discontinuous],
        orientation, position);
      position(1) = 0.0;
      addValue(orientations[x][Discontinuous],
        positions[x][Discontinuous],
        orientation, position);
    }
  }
  if (Dim > 1) {
    orientation = 0; orientation[1] = 1;
    position = 0.0; position(1) = 0.5;
    addValue(orientations[y][Continuous],
      positions[y][Continuous],
      orientation, position);
    orientations[y][Discontinuous] =
      orientations[y][Continuous];
    positions[y][Discontinuous] =
      positions[y][Continuous];
    position(0) = 1.0;
    addValue(orientations[y][Discontinuous],
      positions[y][Discontinuous],
      orientation, position);
    if (Dim > 2) {
      position(2) = 1.0;
      addValue(orientations[y][Discontinuous],
        positions[y][Discontinuous],
        orientation, position);
      position(0) = 0.0;
      addValue(orientations[y][Discontinuous],
        positions[y][Discontinuous],
        orientation, position);
    }
  }
  if (Dim > 2) {
    orientation = 0; orientation[2] = 1;
    position = 0.0; position(2) = 0.5;
    addValue(orientations[z][Continuous],
      positions[z][Continuous],
      orientation, position);
    orientations[z][Discontinuous] =
      orientations[z][Continuous];
    positions[z][Discontinuous] =
      positions[z][Continuous];
    position(0) = 1.0;
    addValue(orientations[z][Discontinuous],
      positions[z][Discontinuous],
      orientation, position);
    position(1) = 1.0;
    addValue(orientations[z][Discontinuous],
      positions[z][Discontinuous],
      orientation, position);
    position(0) = 0.0;
    addValue(orientations[z][Discontinuous],
      positions[z][Discontinuous],
      orientation, position);
  }
  for (int cont = 0; cont < 2; ++cont) {
    centering_table_m[EdgeType][cont][XDim] =
      Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
       orientations[x][cont], positions[x][cont]);
    if (Dim > 1) {
      centering_table_m[EdgeType][cont][YDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         orientations[y][cont], positions[y][cont]);
      centering_table_m[EdgeType][cont][XDim|YDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],orientations[y][cont]),
         combine(positions[x][cont], positions[y][cont]));
    }
    if (Dim > 2) {
      centering_table_m[EdgeType][cont][ZDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         orientations[z][cont], positions[z][cont]);
      centering_table_m[EdgeType][cont][XDim|ZDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],orientations[z][cont]),
         combine(positions[x][cont], positions[z][cont]));
      centering_table_m[EdgeType][cont][YDim|ZDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         combine(orientations[y][cont],orientations[z][cont]),
         combine(positions[y][cont], positions[z][cont]));
      centering_table_m[EdgeType][cont][XDim|YDim|ZDim] =
 Centering<Dim>(EdgeType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],
          combine(orientations[y][cont],orientations[z][cont])),
         combine(positions[x][cont],
          combine(positions[y][cont], positions[z][cont])));
    }
  }
  for (int dim = 0; dim < Dim; ++dim)
    for (int cont = 0; cont < 2; ++cont)
      {
 orientations[dim][cont].clear();
 positions[dim][cont].clear();
      }
  orientation = 1; orientation[0] = 0;
  position = 0.5; position(0) = 0.0;
  addValue(orientations[x][Continuous],
    positions[x][Continuous],
    orientation, position);
  orientations[x][Discontinuous] =
    orientations[x][Continuous];
  positions[x][Discontinuous] =
    positions[x][Continuous];
  position(0) = 1.0;
  addValue(orientations[x][Discontinuous],
    positions[x][Discontinuous],
    orientation, position);
  if (Dim > 1) {
    orientation = 1; orientation[1] = 0;
    position = 0.5; position(1) = 0.0;
    addValue(orientations[y][Continuous],
      positions[y][Continuous],
      orientation, position);
    orientations[y][Discontinuous] =
      orientations[y][Continuous];
    positions[y][Discontinuous] =
      positions[y][Continuous];
    position(1) = 1.0;
    addValue(orientations[y][Discontinuous],
      positions[y][Discontinuous],
      orientation, position);
  }
  if (Dim > 2) {
    orientation = 1; orientation[2] = 0;
    position = 0.5; position(2) = 0.0;
    addValue(orientations[z][Continuous],
      positions[z][Continuous],
      orientation, position);
    orientations[z][Discontinuous] =
      orientations[z][Continuous];
    positions[z][Discontinuous] =
      positions[z][Continuous];
    position(2) = 1.0;
    addValue(orientations[z][Discontinuous],
      positions[z][Discontinuous],
      orientation, position);
  }
  for (int cont = 0; cont < 2; ++cont) {
    centering_table_m[FaceType][cont][XDim] =
      Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
       orientations[x][cont], positions[x][cont]);
    if (Dim > 1) {
      centering_table_m[FaceType][cont][XDim|YDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],orientations[y][cont]),
         combine(positions[x][cont], positions[y][cont]));
      centering_table_m[FaceType][cont][YDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         orientations[y][cont], positions[y][cont]);
    }
    if (Dim > 2) {
      centering_table_m[FaceType][cont][ZDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         orientations[z][cont], positions[z][cont]);
      centering_table_m[FaceType][cont][XDim|ZDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],orientations[z][cont]),
         combine(positions[x][cont], positions[z][cont]));
      centering_table_m[FaceType][cont][YDim|ZDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         combine(orientations[y][cont],orientations[z][cont]),
         combine(positions[y][cont], positions[z][cont]));
      centering_table_m[FaceType][cont][XDim|YDim|ZDim] =
 Centering<Dim>(FaceType, static_cast<enum ContinuityType>(cont),
         combine(orientations[x][cont],
          combine(orientations[y][cont],orientations[z][cont])),
         combine(positions[x][cont],
          combine(positions[y][cont], positions[z][cont])));
    }
  }
  for (int dim = 0; dim < Dim; ++dim)
    for (int cont = 0; cont < 2; ++cont)
      {
 orientations[dim][cont].clear();
 positions[dim][cont].clear();
      }
  centering = Centering<Dim>(VertexType, Continuous);
  orientation = 0;
  position = 0.0;
  centering.addValue(orientation, position);
  centering_table_m[VertexType][Continuous][AllDim%(1<<Dim)] =
    centering;
  centering = Centering<Dim>(VertexType, Discontinuous);
  orientation = 0;
  position = 0.0;
  centering.addValue(orientation, position);
  position(0) = 1.0; centering.addValue(orientation, position);
  if (Dim > 1) {
    position(1) = 1.0; centering.addValue(orientation, position);
    position(0) = 0.0; centering.addValue(orientation, position);
    if (Dim > 2) {
      position(2) = 1.0; centering.addValue(orientation, position);
      position(0) = 1.0; centering.addValue(orientation, position);
      position(1) = 0.0; centering.addValue(orientation, position);
      position(0) = 0.0; centering.addValue(orientation, position);
    }
  }
  centering_table_m[VertexType][Discontinuous][AllDim%(1<<Dim)] =
    centering;
  return;
}
const CanonicalCentering<1> canonicalCenteringOne_g;
const CanonicalCentering<2> canonicalCenteringTwo_g;
const CanonicalCentering<3> canonicalCenteringThree_g;
template <int Dim>
const Centering<Dim> canonicalCentering
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension);
template <>
const Centering<1> canonicalCentering<1>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension)
{
  return canonicalCenteringOne_g(type, discontinuous, dimension);
}
template <>
const Centering<2> canonicalCentering<2>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension)
{
  return canonicalCenteringTwo_g(type, discontinuous, dimension);
}
template <>
const Centering<3> canonicalCentering<3>
    (const enum CenteringType type,
     const enum ContinuityType discontinuous,
     const int dimension)
{
  return canonicalCenteringThree_g(type, discontinuous, dimension);
}
template class CanonicalCentering<1>;
template class CanonicalCentering<2>;
template class CanonicalCentering<3>;
void UniformMapper::map(const List_t& templist) const
{
  int contexts = Pooma::contexts();
  int npc = blocks_m.first() / contexts;
  int remainder = blocks_m.first() % contexts;
  int index = 0;
  for (int c=0; c<contexts; ++c)
  {
    for (int i=0; i<npc; ++i)
      templist[index++]->context() = c;
    if (c < remainder)
      templist[index++]->context() = c;
  }
  setAffinity(templist);
}
namespace Pooma {
Options::Options()
{
  reset();
}
Options::Options(int &argc, char ** argv)
{
  reset();
  parse(argc, argv);
}
Options::Options(const Options &opts)
{
  *this = opts;
}
Options &Options::operator=(const Options &opts)
{
  concurrency_m = opts.concurrency();
  info_m = opts.printInfo();
  warn_m = opts.printWarnings();
  err_m = opts.printErrors();
  logfile_m = opts.logfile();
  stats_m = opts.printStats();
  debug_m = opts.debug();
  neverCompress_m = opts.neverCompress();
  deferredFills_m = opts.deferredGuardFills();
  hardinit_m = opts.hardInit();
  hardrun_m = opts.hardRun();
  lockthreads_m = opts.lockThreads();
  blockingExpressions_m = opts.blockingExpressions();
  return *this;
}
Options::~Options()
{
}
void Options::usage()
{
  Inform msg("POOMA Usage", std::cerr);
  msg << ">>>-----------------------------------<<<\n";
  msg << ">>> POOMA command-line option summary <<<\n";
  msg << ">>>-----------------------------------<<<\n";
  msg << "Standard options:\n";
  msg << "--pooma-threads <N> ......... set concurrency level (N >= 1)\n";
  msg << "--pooma-info ................ turn on output of info messages\n";
  msg << "--pooma-warn ................ turn on output of warning messages\n";
  msg << "--pooma-err ................. turn on output of error messages\n";
  msg << "--pooma-log <file> .......... turn on logging of output to <file>\n";
  msg << "--pooma-stats ............... turn on output of stats at end\n";
  msg << "--pooma-nocompress .......... disable compression of\n";
  msg << "                              compressible brick-engines\n";
  msg << "--pooma-help ................ print out this summary\n";
  msg << "Developer options:\n";
  msg << "--pooma-debug <N> ........... set debug output level to <N>\n";
  msg << "--pooma-smarts-hardinit\n";
  msg << "--pooma-smarts-hardrun\n";
  msg << "--pooma-smarts-lockthreads\n";
  msg << "--pooma-blocking-expressions\n";
  msg << "All options exist as \"yes\" and \"no\" pairs.\n";
  msg << "For example --pooma-info and --pooma-noinfo.\n";
  msg << "The \"no\" versions listed above imply that \"yes\" is the default.";
  msg << std::endl;
}
void Options::reset()
{
  concurrency_m = 1;
  info_m = true;
  warn_m = true;
  err_m = true;
  logfile_m = "";
  stats_m = false;
  debug_m = Inform::off;
  neverCompress_m = false;
  deferredFills_m = true;
  hardinit_m = true;
  hardrun_m = false;
  lockthreads_m = false;
  blockingExpressions_m = false;
}
void Options::parse(int &argc, char ** &argv)
{
  if (argc < 2)
    return;
  int retargc = 1;
  char **retargv = new char *[argc];
  retargv[0] = argv[0];
  int i = 1;
  while (i < argc)
    {
      bool argok = true;
      bool argvalerr = false;
      std::string word(argv[i]);
      if (word == "--pooma-threads")
 {
   argok = intArgument(argc, argv, i+1, concurrency_m);
   argvalerr = (concurrency_m < 1);
   ++i;
 }
      else if (word == "--pooma-nothreads")
 {
   concurrency_m = 1;
 }
      else if (word == "--pooma-info" || word == "--pooma-noinfo")
 {
   info_m = (word == "--pooma-info");
 }
      else if (word == "--pooma-nocompress" || word == "--pooma-compress")
 {
   neverCompress_m = (word == "--pooma-nocompress");
 }
      else if (word == "--pooma-nodeferred-guardfills" ||
               word == "--pooma-deferred-guardfills")
 {
   deferredFills_m = (word == "--pooma-deferred-guardfills");
 }
      else if (word == "--pooma-warn" || word == "--pooma-nowarn")
 {
   warn_m = (word == "--pooma-warn");
 }
      else if (word == "--pooma-err" || word == "--pooma-noerr")
 {
   err_m = (word == "--pooma-err");
 }
      else if (word == "--pooma-stats" || word == "--pooma-nostats")
 {
   stats_m = (word == "--pooma-stats");
 }
      else if (word == "--pooma-log")
 {
   argok = stringArgument(argc, argv, i+1, logfile_m);
   ++i;
 }
      else if (word == "--pooma-debug")
 {
   argok = intArgument(argc, argv, i+1, debug_m);
   ++i;
 }
      else if (word == "--pooma-nodebug")
 {
   debug_m = Inform::off;
 }
      else if (word == "--pooma-smarts-hardinit")
 {
   hardinit_m = true;
 }
      else if (word == "--pooma-smarts-nohardinit")
 {
   hardinit_m = false;
 }
      else if (word == "--pooma-smarts-hardrun")
 {
   hardrun_m = true;
 }
      else if (word == "--pooma-smarts-nohardrun")
 {
   hardrun_m = false;
 }
      else if (word == "--pooma-smarts-lockthreads")
 {
   lockthreads_m = true;
 }
      else if (word == "--pooma-smarts-nolockthreads")
 {
   lockthreads_m = false;
 }
      else if (word == "--pooma-blocking-expressions")
 {
   blockingExpressions_m = true;
 }
      else if (word == "--pooma-noblocking-expressions")
 {
   blockingExpressions_m = false;
 }
      else if (word == "--pooma-help")
 {
   usage();
   exit(0);
 }
      else
 {
   retargv[retargc++] = argv[i];
 }
      if (!argok)
 {
   std::cerr << "\nERROR: Bad format for POOMA command-line option '";
   std::cerr << word.c_str() << "'.\n" << std::endl;
   usage();
   exit(0);
 }
      if (argvalerr)
 {
   std::cerr << "\n";
   std::cerr << "ERROR: Illegal value for POOMA command-line option '";
   std::cerr << word.c_str() << "'.\n" << std::endl;
   usage();
   exit(0);
 }
      ++i;
    }
  argc = retargc;
  for (i = 0; i < retargc; ++i) argv[i] = retargv[i];
  delete [] retargv;
}
bool intArgument(int argc, char **argv, int pos, int &val)
{
  if (pos >= argc)
    return false;
  char firstchar = argv[pos][0];
  if (firstchar < '0' || firstchar > '9')
    {
      if ((firstchar != '-' && firstchar != '+') || argv[pos][1] == 0 ||
   (argv[pos][1] < '0' || argv[pos][1] > '9'))
 return false;
    }
  val = atoi(argv[pos]);
  return true;
}
bool stringArgument(int argc, char **argv, int pos, std::string &val)
{
  if (pos >= argc)
    return false;
  val = argv[pos];
  return true;
}
bool doubleArgument(int argc, char **argv, int pos, double &val)
{
  if (pos >= argc)
    return false;
  val = atof(argv[pos]);
  return true;
}
}
namespace Pooma {
Statistics::Statistics()
{
}
Statistics::~Statistics()
{
  for (int i = 0; i < statList_m.size(); ++i)
    {
      delete statList_m[i];
    }
}
long Statistics::defaultFilter(long val)
{
  return val;
}
void Statistics::print(Inform &o, long (*filter)(long))
{
  int i, j;
  if (statList_m.size() == 0)
    return;
  o << "Runtime statistics summary:" << std::endl;
  for (i = 0; i < statList_m.size(); ++i)
    {
      o << statList_m[i]->description() << " ";
      int numperiods = 53 - strlen(statList_m[i]->description().c_str());
      if (numperiods < 2)
        numperiods = 2;
      for (j = 0; j < numperiods; ++j)
        o << ".";
      o << " " << std::setw(12) << filter(statList_m[i]->value()) << std::endl;
    }
}
}
namespace EOS {
  typedef enum {
    IdealAdiabatic = 0,
    Last = 4
  } Eos_t;
  struct pg_ig
  {
    pg_ig() {}
    template <class F1>
    pg_ig(const pg_ig& f, const F1&) {}
    template <class F1, class F2, class F3, class F4>
    void operator()(const F1& pg, const F2& T, const F3& rh, const F4& xmue) const
    {
      Interval<F1::dimensions> I = pg.totalDomain();
      pg(I) = (T*rh/xmue)(I);
    }
  };
  struct cs_adiabatic
  {
    cs_adiabatic() {}
    cs_adiabatic(double gamma) : gamma_m(gamma) {}
    template <class F>
    cs_adiabatic(const cs_adiabatic& f, const F&)
      : gamma_m(f.gamma_m) {}
    template <class F1, class F2, class F3>
    void operator()(const F1& cs, const F2& pg, const F3& rh) const
    {
      Interval<F1::dimensions> I = cs.totalDomain();
      cs(I) = (sqrt(gamma_m * pg/rh))(I);
    }
    double gamma_m;
  };
}
namespace Hacks {
  struct limit_rh
  {
    limit_rh() {}
    limit_rh(double rhomin) : rhomin_m(rhomin) {}
    template <class F>
    limit_rh(const limit_rh& l, const F&) : rhomin_m(l.rhomin_m) {}
    template <class F>
    void operator()(const F& rh);
    double rhomin_m;
  };
  template <class F>
  void checkRegularity(const F& f);
};
namespace Hacks {
  template <class F>
  void limit_rh::operator()(const F& rh)
  {
    Interval<F::dimensions> I = rh.physicalDomain();
    rh(I) = where(rh(I) < rhomin_m, rhomin_m);
  }
  template <int Dim>
  struct CheckRegularity {
    CheckRegularity() {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 1> &i) const
    {
      i.write(0, false);
      i.useGuards(0, false);
    }
    template <class F1>
    inline void operator()(const F1 &f, const Loc<Dim>& I) const
    {
      if (std::isnan(f(I)))
 Pooma::pAbort("NaN detected");
      if (std::isinf(f(I)))
 Pooma::pAbort("Inf detected");
    }
  };
  template <class F>
  void checkRegularity(const F& f)
  {
    ScalarCode<CheckRegularity<F::dimensions> >()(f);
  }
};
namespace CFL {
  template <int Dim>
  struct CflFunctor : public Deltas<Dim> {
    CflFunctor(double omrot, bool vis) : omrot_m(omrot), vis_m(vis) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
    {
      for (int d=0; d<Dim; ++d)
 i.extent().upper(d) = 1;
      i.write(0, true, false);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.useGuards(1, false);
      i.useGuards(2, false);
      i.useGuards(3, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4>
    inline void operator()(const F1 &dt, const F2 &cs, const F3 &nue, const F4 &v,
      const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = dt.mesh();
      double dtmin = m.vertexSpacing(0, I[0].first()+1)
 / (std::max(fabs(v.fieldEngine().engine(0, 0).read(I)), fabs(v.fieldEngine().engine(0, 0).read(I+dX)))
    + cs.read(I));
      if (Dim > 1)
 dtmin = std::min(dtmin,
    m.vertexSpacing(1, I[1].first()+1)
    / (std::max(fabs(v.fieldEngine().engine(0, 1).read(I)), fabs(v.fieldEngine().engine(0, 1).read(I+dY)))
       + cs.read(I)/m.GEOXG(I)));
      if (Dim > 2)
 dtmin = std::min(dtmin,
    m.vertexSpacing(2, I[2].first()+1)
    / (std::max(fabs(v.fieldEngine().engine(0, 2).read(I))+omrot_m, fabs(v.fieldEngine().engine(0, 2).read(I+dZ))+omrot_m)
       + cs.read(I)/(m.GEOXH(I)*m.GEOYH(I))));
 dt(I) = dtmin;
    }
    const double omrot_m;
    const bool vis_m;
  };
  template <int Dim, class F1, class F2, class F3, class F4>
  double schritt(const F1 &v, const F2 &cs, const F3 &nue,
   const F4 &scratch, double omrot, bool vis_f)
  {
    Interval<Dim> I(cs.physicalDomain());
    ScalarCode<CflFunctor<Dim> >(CflFunctor<Dim>(omrot, vis_f))(scratch, I, cs, nue, v);
    return min(scratch(I));
  }
}
GuardLayers<Dim> corr_v[Dim];
Interval<Dim> vertexDomain;
Vector<Dim> origin;
Traits_t::Spacings_t spacings;
double gamma_, K, cartvis_nr, cartvis_av;
Vector<2> smooth;
std::string commandline;
Vector<Dim, int> periodicity;
std::vector<Loc<Dim> > dump_points;
EOS::Eos_t eos;
bool a_nr_f = false;
int a_nr = std::numeric_limits<int>::max();
bool a_end_t_f = false;
double a_end_t = std::numeric_limits<double>::max();
bool a_blocks_f = false;
Loc<Dim> a_blocks;
bool a_cfl_f = false;
double a_cfl = 0.5;
bool a_constant_timestep_f = false;
double dt;
bool a_min_dt_f = false;
double a_min_dt = 0.0;
bool a_max_dt_f = false;
double a_max_dt = std::numeric_limits<double>::max();
bool a_cartvis_f = false;
bool a_eos_f = false;
EOS::Eos_t a_eos;
bool a_rhomin_f = false;
double a_rhomin = 1e-6;
namespace Adv5 {
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
  void advect(double dt,
       const F1 &rh, const F2 &v, double omrot_, const F3 &T,
       const F4 &flm, const F5 &fle, const F6 &flvv,
       const F7 &flvc, const F8 &cv, const F9 &ekin,
       bool eeq, bool ietot);
}
namespace Adv5 {
  template <int Dim>
  struct Ekin : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &ekin, const F2 &v, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = ekin.mesh();
      double ek = (v.fieldEngine().engine(0, 0).read(I)+v.fieldEngine().engine(0, 0).read(I+dX)) * (v.fieldEngine().engine(0, 0).read(I)+v.fieldEngine().engine(0, 0).read(I+dX));
      if (Dim > 1)
 ek += (v.fieldEngine().engine(0, 1).read(I)+v.fieldEngine().engine(0, 1).read(I+dY)) * (v.fieldEngine().engine(0, 1).read(I)+v.fieldEngine().engine(0, 1).read(I+dY)) * std::pow(m.GEOXG(I), 2);
      if (Dim > 2)
 ek += (v.fieldEngine().engine(0, 2).read(I)+v.fieldEngine().engine(0, 2).read(I+dZ)) * (v.fieldEngine().engine(0, 2).read(I)+v.fieldEngine().engine(0, 2).read(I+dZ)) * std::pow(m.GEOXH(I)*m.GEOYH(I), 2);
      ekin(I) = ek / 8.0;
    }
  };
  template <int Dim>
  struct VelupdX : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent().lower(0) = 1;
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &vx, const F2 &rh, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vx(I) = vx(I)
 / (m.DDX1(I)*rh(I)+m.DDX0(I)*rh(I-dX));
    }
  };
  template <int Dim>
  struct VelupdY : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent().lower(1) = 1;
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &vy, const F2 &rh, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vy(I) = vy(I)
 / ((m.DDY1(I)*rh(I)+m.DDY0(I)*rh(I-dY))
    * std::pow(m.GEOXG(I), 2));
    }
  };
  template <int Dim>
  struct VelupdZ : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent().lower(2) = 1;
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &vz, const F2 &rh, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vz(I) = vz(I)
 / ((m.DDZ1(I)*rh(I)+m.DDZ0(I)*rh(I-dZ))
    * std::pow(m.GEOXH(I),2) * std::pow(m.GEOYH(I),2));
    }
  };
  namespace X {
    template <int Dim>
    struct Massflow : public Deltas<Dim> {
      Massflow(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(0) = 2;
 i.extent().upper(0) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flmx, const F2 &rh, const F3 &vx, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 double s = vx(I)*dt;
 Loc<Dim> IND = s > 0.0 ? I-dX : I;
 double grad1 = (rh(IND)-rh(IND-dX)) * (rh(IND+dX)-rh(IND));
 double grad = grad1 > 0.0
   ? 2.0*grad1 / ((rh(IND)-rh(IND-dX))*m.cellSpacing(IND+dX)(0)
    + (rh(IND+dX)-rh(IND))*m.cellSpacing(IND)(0))
   : 0.0;
 flmx(I) = (m.SURXA(I)-m.CCXA(I)*s) * s
   * (rh(IND)
      + (m.vertexPosition(I)(0) - m.cellPosition(IND)(0) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux : public Deltas<Dim> {
      Energyflux(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(0) = 2;
 i.extent().upper(0) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
 i.useGuards(3, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flex, const F2 &T, const F3 &vx, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = vx(I)*dt;
 IND = s > 0.0 ? I-dX : I;
 ddm1 = T(IND-dX);
 dd = T(IND);
 ddp1 = T(IND+dX);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(0)
    + (dd-ddm1)*m.cellSpacing(IND+dX)(0))
   : 0.0;
 flex(I) = flmx(I)
   * (dd + (m.vertexPosition(I)(0) - m.cellPosition(IND)(0) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxX : public Deltas<Dim> {
      MomentumfluxX(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(0) = 1;
 i.extent().upper(0) = 2;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flx, const F2 &vx, const F3 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (vx(I) + vx(I+dX)) * 0.5*dt;
 IND = s > 0.0 ? I : I+dX;
 ddm1 = vx(IND-dX);
 dd = vx(IND);
 ddp1 = vx(IND+dX);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.vertexSpacing(IND)(0)
    + (dd-ddm1)*m.vertexSpacing(IND+dX)(0))
   : 0.0;
 flx(I) = 0.5*(flmx(I) + flmx(I+dX))
   * (dd + (m.cellPosition(I)(0) - m.vertexPosition(IND)(0) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxY : public Deltas<Dim> {
      MomentumfluxY(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(0) = 2;
 i.extent().upper(0) = 1;
 i.extent().lower(1) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vx, const F3 &vy, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDY1(I)*vx(I) + m.DDY0(I)*vx(I-dY)) * dt;
 IND = s > 0.0 ? I-dX : I;
 ddm1 = vy(IND-dX) * std::pow(m.GEOXG(IND-dX), 2);
 dd = vy(IND) * std::pow(m.GEOXG(IND), 2);
 ddp1 = vy(IND+dX) * std::pow(m.GEOXG(IND+dX), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(0)
    + (dd-ddm1)*m.cellSpacing(IND+dX)(0))
   : 0.0;
 flx(I) = (m.DDY1(I)*flmx(I) + m.DDY0(I)*flmx(I-dY))
   * (dd + (m.vertexPosition(I)(0) - m.cellPosition(IND)(0) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxZ : public Deltas<Dim> {
      MomentumfluxZ(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(0) = 2;
 i.extent().upper(0) = 1;
 i.extent().lower(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vx, const F3 &vz, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDZ1(I)*vx(I)
      + m.DDZ0(I)*vx(I-dZ)) * dt;
 IND = s > 0.0 ? I-dX : I;
 ddm1 = vz.read(IND-dX)
   * std::pow(m.GEOXH(IND-dX), 2) * std::pow(m.GEOYH(I), 2);
 dd = vz.read(IND)
   * std::pow(m.GEOXH(IND), 2) * std::pow(m.GEOYH(I), 2);
 ddp1 = vz.read(IND+dX)
   * std::pow(m.GEOXH(IND+dX), 2) * std::pow(m.GEOYH(I), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(0)
    + (dd-ddm1)*m.cellSpacing(IND+dX)(0))
   : 0.0;
 flx(I) = (m.DDZ1(I)*flmx(I) + m.DDZ0(I)*flmx(I-dZ))
   * (dd + (m.vertexPosition(I)(0) - m.cellPosition(IND)(0) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux2 : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(0) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, false);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &T, const F2 &rh, const F3 &flex,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 T(I) = T(I)*rh(I)
   - (flex(I+dX) - flex(I)) / m.VOLXB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2X : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(0) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vx, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vx(I) = vx(I)
   * (m.DDX1(I)*rh(I)+m.DDX0(I)*rh(I-dX))
   - (flx(I) - flx(I-dX)) / m.VOLXA(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Y : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(0) = 1;
 i.extent().lower(1) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vy, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vy(I) = vy(I) * std::pow(m.GEOXG(I), 2)
   * (m.DDY1(I)*rh(I)+m.DDY0(I)*rh(I-dY))
   - (flx(I+dX) - flx(I)) / m.VOLXB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Z : public Deltas<Dim> {
      Momentumflux2Z(double omrot) : omrot_m(omrot) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(0) = 1;
 i.extent().lower(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vz, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vz(I) = (vz(I) + omrot_m) * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2)
   * (m.DDZ1(I)*rh(I)+m.DDZ0(I)*rh(I-dZ))
   - (flx(I+dX) - flx(I)) / m.VOLXB(I);
      }
      const double omrot_m;
    };
    template <int Dim>
    struct Densupd : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
      {
 i.extent().upper(0) = 1;
 i.write(0, true);
 i.write(1, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
      }
      using Deltas<Dim>::dX;
      template <class F1, class F2>
      inline void operator()(const F1 &rh, const F2 &flmx, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 rh(I) = rh(I) - (flmx(I+dX)-flmx(I))/m.VOLXB(I);
      }
    };
    template<int Dim, class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
    inline
    void advect(double dt,
  const F1 &rh, const F2 &v, const F3 &T,
  const F4 &flm, const F5 &fle, const F6 &flvv, const F7 &flvc,
  const F8 &cv, const F9 &ekin,
  double omrot, bool eeq, bool ietot)
    {
      (ScalarCode<Massflow<Dim> >(dt))(flm.center(0),
           rh, v.center(0));
      if (eeq) {
 if (ietot) {
   Interval<Dim> I(T.physicalDomain());
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = (cv*T + ekin)(I);
 }
 (ScalarCode<Energyflux<Dim> >(dt))(fle.center(0),
        T, v.center(0), flm.center(0));
 ScalarCode<Energyflux2<Dim> >()(T, T.physicalDomain(),
     rh, fle.center(0));
      }
      (ScalarCode<MomentumfluxX<Dim> >(dt))(flvc,
         v.center(0), flm.center(0));
      if (Dim > 1)
 (ScalarCode<MomentumfluxY<Dim> >(dt))(flvv.comp(1), shrink(flvv.physicalDomain(), corr_v[1]),
           v.center(0), v.center(1), flm.center(0));
      if (Dim > 2)
 (ScalarCode<MomentumfluxZ<Dim> >(dt))(flvv.comp(2), shrink(flvv.physicalDomain(), corr_v[2]),
           v.center(0), v.center(2)+omrot, flm.center(0));
      ScalarCode<Momentumflux2X<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
      rh, flvc);
      if (Dim > 1)
 ScalarCode<Momentumflux2Y<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
        rh, flvv.comp(1));
      if (Dim > 2)
 (ScalarCode<Momentumflux2Z<Dim> >(omrot))(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
        rh, flvv.comp(2));
      ScalarCode<Densupd<Dim> >()(rh, rh.physicalDomain(), flm.center(0));
      ScalarCode<VelupdX<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]), rh);
      if (Dim > 1)
 ScalarCode<VelupdY<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]), rh);
      if (Dim > 2) {
 ScalarCode<VelupdZ<Dim> >()(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]), rh);
 if (omrot != 0.0)
   v.center(2)(shrink(v.center(2).physicalDomain(), corr_v[2])) -= omrot;
      }
      if (eeq) {
 Interval<Dim> I(T.physicalDomain());
 if (!ietot)
   T(I) = (T / rh)(I);
 else {
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = ((T / rh - ekin)/cv)(I);
 }
      }
    }
  };
  namespace Y {
    template <int Dim>
    struct Massflow : public Deltas<Dim> {
      Massflow(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(1) = 2;
 i.extent().upper(1) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flmx, const F2 &rh, const F3 &vy, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 double s = vy(I)*dt;
 Loc<Dim> IND = s > 0.0 ? I-dY : I;
 double grad1 = (rh(IND)-rh(IND-dY)) * (rh(IND+dY)-rh(IND));
 double grad = grad1 > 0.0
   ? 2.0*grad1 / ((rh(IND)-rh(IND-dY))*m.cellSpacing(IND+dY)(1)
    + (rh(IND+dY)-rh(IND))*m.cellSpacing(IND)(1))
   : 0.0;
 flmx(I) = (m.SURYA(I)+m.CCYA(I)*s) * s
   * (rh(IND)
      + (m.vertexPosition(I)(1) - m.cellPosition(IND)(1) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux : public Deltas<Dim> {
      Energyflux(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(1) = 2;
 i.extent().upper(1) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
 i.useGuards(3, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flex, const F2 &T, const F3 &vy, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = vy(I)*dt;
 IND = s > 0.0 ? I-dY : I;
 ddm1 = T(IND-dY);
 dd = T(IND);
 ddp1 = T(IND+dY);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(1)
    + (dd-ddm1)*m.cellSpacing(IND+dY)(1))
   : 0.0;
 flex(I) = flmx(I)
   * (dd + (m.vertexPosition(I)(1) - m.cellPosition(IND)(1) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxX : public Deltas<Dim> {
      MomentumfluxX(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(0) = 1;
 i.extent().lower(1) = 2;
 i.extent().upper(1) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vy, const F3 &vx, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDX1(I)*vy(I) + m.DDX0(I)*vy(I-dX)) * dt;
 IND = s > 0.0 ? I-dY : I;
 ddm1 = vx(IND-dY);
 dd = vx(IND);
 ddp1 = vx(IND+dY);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(1)
    + (dd-ddm1)*m.cellSpacing(IND+dY)(1))
   : 0.0;
 flx(I) = (m.DDX1(I)*flmx(I) + m.DDX0(I)*flmx(I-dX))
   * (dd + (m.vertexPosition(I)(1) - m.cellPosition(IND)(1) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxY : public Deltas<Dim> {
      MomentumfluxY(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(1) = 1;
 i.extent().upper(1) = 2;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flx, const F2 &vy, const F3 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (vy(I) + vy(I+dY)) * 0.5 * dt;
 IND = s > 0.0 ? I : I+dY;
 ddm1 = vy(IND-dY) * std::pow(m.GEOXG(I), 2);
 dd = vy(IND) * std::pow(m.GEOXG(I), 2);
 ddp1 = vy(IND+dY) * std::pow(m.GEOXG(I), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.vertexSpacing(IND)(1)
    + (dd-ddm1)*m.vertexSpacing(IND+dY)(1))
   : 0.0;
 flx(I) = 0.5*(flmx(I) + flmx(I+dY))
   * (dd + (m.cellPosition(I)(1) - m.vertexPosition(IND)(1) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxZ : public Deltas<Dim> {
      MomentumfluxZ(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(1) = 2;
 i.extent().upper(1) = 1;
 i.extent().lower(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vy, const F3 &vz, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDZ1(I)*vy(I)
      + m.DDZ0(I)*vy(I-dZ)) * dt;
 IND = s > 0.0 ? I-dY : I;
 ddm1 = vz.read(IND-dY)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(IND-dY), 2);
 dd = vz.read(IND)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(IND), 2);
 ddp1 = vz.read(IND+dY)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(IND+dY), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(1)
    + (dd-ddm1)*m.cellSpacing(IND+dY)(1))
   : 0.0;
 flx(I) = (m.DDZ1(I)*flmx(I) + m.DDZ0(I)*flmx(I-dZ))
   * (dd + (m.vertexPosition(I)(1) - m.cellPosition(IND)(1) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux2 : public Deltas<Dim> {
      Energyflux2() {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(1) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, false);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dY;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &T, const F2 &rh, const F3 &flex,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 T(I) = T(I)*rh(I)
   - (flex(I+dY) - flex(I)) / m.VOLYB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2X : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(0) = 1;
 i.extent().upper(1) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vx, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vx(I) = vx(I)
   * (m.DDX1(I)*rh(I)+m.DDX0(I)*rh(I-dX))
   - (flx(I+dY) - flx(I)) / m.VOLYB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Y : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(1) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vy, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vy(I) = vy(I) * std::pow(m.GEOXG(I), 2)
   * (m.DDY1(I)*rh(I)+m.DDY0(I)*rh(I-dY))
   - (flx(I) - flx(I-dY)) / m.VOLYA(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Z : public Deltas<Dim> {
      Momentumflux2Z(double omrot) : omrot_m(omrot) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(1) = 1;
 i.extent().lower(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vz, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vz(I) = (vz(I)+omrot_m) * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2)
   * (m.DDZ1(I)*rh(I)+m.DDZ0(I)*rh(I-dZ))
   - (flx(I+dY) - flx(I)) / m.VOLYB(I);
      }
      const double omrot_m;
    };
    template <int Dim>
    struct Densupd : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
      {
 i.extent().upper(1) = 1;
 i.write(0, true);
 i.write(1, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
      }
      using Deltas<Dim>::dY;
      template <class F1, class F2>
      inline void operator()(const F1 &rh, const F2 &flmx, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 rh(I) = rh(I) - (flmx(I+dY)-flmx(I))/m.VOLYB(I);
      }
    };
    template<int Dim, class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
    inline
    void advect(double dt,
  const F1 &rh, const F2 &v, const F3 &T,
  const F4 &flm, const F5 &fle, const F6 &flvv, const F7 &flvc,
  const F8 &cv, const F9 &ekin,
  double omrot, bool eeq, bool ietot)
    {
      (ScalarCode<Massflow<Dim> >(dt))(flm.center(1),
           rh, v.center(1));
      if (eeq) {
 if (ietot) {
   Interval<Dim> I(T.physicalDomain());
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = (cv*T + ekin)(I);
 }
 (ScalarCode<Energyflux<Dim> >(dt))(fle.center(1),
        T, v.center(1), flm.center(1));
 ScalarCode<Energyflux2<Dim> >()(T, T.physicalDomain(),
     rh, fle.center(1));
      }
      (ScalarCode<MomentumfluxX<Dim> >(dt))(flvv.comp(0), shrink(flvv.physicalDomain(), corr_v[0]),
         v.center(1), v.center(0), flm.center(1));
      if (Dim > 1)
 (ScalarCode<MomentumfluxY<Dim> >(dt))(flvc,
           v.center(1), flm.center(1));
      if (Dim > 2)
 (ScalarCode<MomentumfluxZ<Dim> >(dt))(flvv.comp(2), shrink(flvv.physicalDomain(), corr_v[2]),
           v.center(1), v.center(2)+omrot, flm.center(1));
      ScalarCode<Momentumflux2X<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
      rh, flvv.comp(0));
      if (Dim > 1)
 ScalarCode<Momentumflux2Y<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
        rh, flvc);
      if (Dim > 2)
 (ScalarCode<Momentumflux2Z<Dim> >(omrot))(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
        rh, flvv.comp(2));
      ScalarCode<Densupd<Dim> >()(rh, rh.physicalDomain(), flm.center(1));
      ScalarCode<VelupdX<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]), rh);
      if (Dim > 1)
 ScalarCode<VelupdY<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]), rh);
      if (Dim > 2) {
 ScalarCode<VelupdZ<Dim> >()(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]), rh);
 if (omrot != 0.0)
   v.center(2)(shrink(v.center(2).physicalDomain(), corr_v[2])) -= omrot;
      }
      if (eeq) {
 Interval<Dim> I(T.physicalDomain());
 if (!ietot)
   T(I) = (T / rh)(I);
 else {
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = ((T / rh - ekin)/cv)(I);
 }
      }
    }
  };
  namespace Z {
    template <int Dim>
    struct Massflow : public Deltas<Dim> {
      Massflow(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(2) = 2;
 i.extent().upper(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flmx, const F2 &rh, const F3 &vz, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 double s = vz(I)*dt;
 Loc<Dim> IND = s > 0.0 ? I-dZ : I;
 double grad1 = (rh(IND)-rh(IND-dZ)) * (rh(IND+dZ)-rh(IND));
 double grad = grad1 > 0.0
   ? 2.0*grad1 / ((rh(IND)-rh(IND-dZ))*m.cellSpacing(IND+dZ)(2)
    + (rh(IND+dZ)-rh(IND))*m.cellSpacing(IND)(2))
   : 0.0;
 flmx(I) = (m.SURZA(I)-m.CCZA(I)*s) * s
   * (rh(IND)
      + (m.vertexPosition(I)(2) - m.cellPosition(IND)(2) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux : public Deltas<Dim> {
      Energyflux(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(2) = 2;
 i.extent().upper(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, false);
 i.useGuards(3, false);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flex, const F2 &T, const F3 &vz, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = vz(I)*dt;
 IND = s > 0.0 ? I-dZ : I;
 ddm1 = T(IND-dZ);
 dd = T(IND);
 ddp1 = T(IND+dZ);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(2)
    + (dd-ddm1)*m.cellSpacing(IND+dZ)(2))
   : 0.0;
 flex(I) = flmx(I)
   * (dd + (m.vertexPosition(I)(2) - m.cellPosition(IND)(2) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxX : public Deltas<Dim> {
      MomentumfluxX(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(0) = 1;
 i.extent().lower(2) = 2;
 i.extent().upper(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vz, const F3 &vx, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDX1(I)*vz(I) + m.DDX0(I)*vz(I-dX)) * dt;
 IND = s > 0.0 ? I-dZ : I;
 ddm1 = vx(IND-dZ);
 dd = vx(IND);
 ddp1 = vx(IND+dZ);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(2)
    + (dd-ddm1)*m.cellSpacing(IND+dZ)(2))
   : 0.0;
 flx(I) = (m.DDX1(I)*flmx(I) + m.DDX0(I)*flmx(I-dX))
   * (dd + (m.vertexPosition(I)(2) - m.cellPosition(IND)(2) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxY : public Deltas<Dim> {
      MomentumfluxY(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
      {
 i.extent().lower(1) = 1;
 i.extent().lower(2) = 2;
 i.extent().upper(2) = 1;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.write(3, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
 i.useGuards(3, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3, class F4>
      inline void operator()(const F1 &flx, const F2 &vz, const F3 &vy, const F4 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (m.DDY1(I)*vz(I)
      + m.DDY0(I)*vz(I-dY)) * dt;
 IND = s > 0.0 ? I-dZ : I;
 ddm1 = vy(IND-dZ) * std::pow(m.GEOXG(I), 2);
 dd = vy(IND) * std::pow(m.GEOXG(I), 2);
 ddp1 = vy(IND+dZ) * std::pow(m.GEOXG(I), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.cellSpacing(IND)(2)
    + (dd-ddm1)*m.cellSpacing(IND+dZ)(2))
   : 0.0;
 flx(I) = (m.DDY1(I)*flmx(I) + m.DDY0(I)*flmx(I-dY))
   * (dd + (m.vertexPosition(I)(2) - m.cellPosition(IND)(2) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct MomentumfluxZ : public Deltas<Dim> {
      MomentumfluxZ(double dt_) : dt(dt_) {}
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(2) = 1;
 i.extent().upper(2) = 2;
 i.write(0, true, false);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      double dt;
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &flx, const F2 &vz, const F3 &flmx,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = flx.mesh();
 Loc<Dim> IND = Pooma::NoInit();
 double s, ddm1, dd, ddp1, grad1, grad;
 s = (vz(I) + vz(I+dZ)) * 0.5*dt;
 IND = s > 0.0 ? I : I+dZ;
 ddm1 = vz(IND-dZ)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2);
 dd = vz(IND)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2);
 ddp1 = vz(IND+dZ)
   * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2);
 grad1 = (dd-ddm1)*(ddp1-dd);
 grad = grad1 > 0.0
   ? 2.0*grad1 / ((ddp1-dd)*m.vertexSpacing(IND)(2)
    + (dd-ddm1)*m.vertexSpacing(IND+dZ)(2))
   : 0.0;
 flx(I) = 0.5*(flmx(I) + flmx(I+dZ))
   * (dd + (m.cellPosition(I)(2) - m.vertexPosition(IND)(2) - 0.5*s) * grad);
      }
    };
    template <int Dim>
    struct Energyflux2 : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().upper(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, false);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &T, const F2 &rh, const F3 &flex,
        const Loc<Dim>& I) const
      {
 const typename F3::Mesh_t &m = T.mesh();
 T(I) = T(I)*rh(I)
   - (flex(I+dZ) - flex(I)) / m.VOLZB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2X : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(0) = 1;
 i.extent().upper(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vx, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vx(I) = vx(I)
   * (m.DDX1(I)*rh(I)+m.DDX0(I)*rh(I-dX))
   - (flx(I+dZ) - flx(I)) / m.VOLZA(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Y : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(1) = 1;
 i.extent().upper(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vy, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vy(I) = vy(I) * std::pow(m.GEOXG(I), 2)
   * (m.DDY1(I)*rh(I)+m.DDY0(I)*rh(I-dY))
   - (flx(I+dZ) - flx(I)) / m.VOLZB(I);
      }
    };
    template <int Dim>
    struct Momentumflux2Z : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 3> &i) const
      {
 i.extent().lower(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.write(2, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
 i.useGuards(2, true);
      }
      using Deltas<Dim>::dX;
      using Deltas<Dim>::dY;
      using Deltas<Dim>::dZ;
      template <class F1, class F2, class F3>
      inline void operator()(const F1 &vz, const F2 &rh, const F3 &flx,
        const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 vz(I) = vz(I) * std::pow(m.GEOXH(I), 2) * std::pow(m.GEOYH(I), 2)
   * (m.DDZ1(I)*rh(I)+m.DDZ0(I)*rh(I-dZ))
   - (flx(I) - flx(I-dZ)) / m.VOLZB(I);
      }
    };
    template <int Dim>
    struct Densupd : public Deltas<Dim> {
      inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
      {
 i.extent().upper(2) = 1;
 i.write(0, true);
 i.write(1, false);
 i.useGuards(0, false);
 i.useGuards(1, true);
      }
      using Deltas<Dim>::dZ;
      template <class F1, class F2>
      inline void operator()(const F1 &rh, const F2 &flmx, const Loc<Dim>& I) const
      {
 const typename F1::Mesh_t &m = rh.mesh();
 rh(I) = rh(I) - (flmx(I+dZ)-flmx(I))/m.VOLZB(I);
      }
    };
    template<int Dim, class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
    inline
    void advect(double dt,
  const F1 &rh, const F2 &v, const F3 &T,
  const F4 &flm, const F5 &fle, const F6 &flvv, const F7 &flvc,
  const F8 &cv, const F9 &ekin,
  bool eeq, bool ietot)
    {
      (ScalarCode<Massflow<Dim> >(dt))(flm.center(2),
           rh, v.center(2));
      if (eeq) {
 if (ietot) {
   Interval<Dim> I(T.physicalDomain());
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = (cv*T + ekin)(I);
 }
 (ScalarCode<Energyflux<Dim> >(dt))(fle.center(2),
        T, v.center(2), flm.center(2));
 ScalarCode<Energyflux2<Dim> >()(T, T.physicalDomain(), rh, fle.center(2));
      }
      (ScalarCode<MomentumfluxX<Dim> >(dt))(flvv.comp(0), shrink(flvv.physicalDomain(), corr_v[0]),
         v.center(2), v.center(0), flm.center(2));
      if (Dim > 1)
 (ScalarCode<MomentumfluxY<Dim> >(dt))(flvv.comp(1), shrink(flvv.physicalDomain(), corr_v[1]),
           v.center(2), v.center(1), flm.center(2));
      if (Dim > 2)
 (ScalarCode<MomentumfluxZ<Dim> >(dt))(flvc,
           v.center(2), flm.center(2));
      ScalarCode<Momentumflux2X<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
      rh, flvv.comp(0));
      if (Dim > 1)
 ScalarCode<Momentumflux2Y<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
        rh, flvv.comp(1));
      if (Dim > 2)
 ScalarCode<Momentumflux2Z<Dim> >()(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
        rh, flvc);
      ScalarCode<Densupd<Dim> >()(rh, rh.physicalDomain(), flm.center(2));
      ScalarCode<VelupdX<Dim> >()(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]), rh);
      if (Dim > 1)
 ScalarCode<VelupdY<Dim> >()(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]), rh);
      if (Dim > 2)
 ScalarCode<VelupdZ<Dim> >()(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]), rh);
      if (eeq) {
 Interval<Dim> I(T.physicalDomain());
 if (!ietot)
   T(I) = (T / rh)(I);
 else {
   ScalarCode<Ekin<Dim> >()(ekin, v);
   T(I) = ((T / rh - ekin)/cv)(I);
 }
      }
    }
  };
  template <class CoordinateSystemTag>
  double omrotForAdvect(double omrot) { return omrot; }
  template <>
  double omrotForAdvect<CartesianTag>(double omrot) { return 0.0; }
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
  void advect(double dt,
       const F1 &rh, const F2 &v, double omrot_, const F3 &T,
       const F4 &flm, const F5 &fle, const F6 &flvv,
       const F7 &flvc, const F8 &cv, const F9 &ekin,
       bool eeq, bool ietot)
  {
    static int it = 0;
    enum { Dim = F1::dimensions };
    double omrot = omrotForAdvect<typename F1::Mesh_t::MeshTraits_t::CoordinateSystemTag_t>(omrot_);
    if (it++ % 2 == 0) {
      X::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, omrot, eeq, ietot);
      Y::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, omrot, eeq, ietot);
      Z::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, eeq, ietot);
    } else {
      Z::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, eeq, ietot);
      Y::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, omrot, eeq, ietot);
      X::advect<Dim>(dt, rh, v, T, flm, fle, flvv, flvc, cv, ekin, omrot, eeq, ietot);
    }
  }
};
namespace Forgas {
  template <class F1, class F2, class F3, class F4, class F5,
     class F6, class F7, class F8, class F9, class F10,
     class F11, class F12, class F13,
     class F14, class F15, class F16, class F17>
  void force(double dt, const F1 &rh, F2 &T, F3 &v, double omrot, F4 &pg, const F5 &ph,
      const F11& cs, const F6 &cv, const F7 &dlmdlt, const F8 &xmue,
      const F9 &vint, F10 &cent, const F12 &a_pg, const F13 &gradv,
      const F14 &Tii, const F15 &Tij, const F16 &fvis, const F17 &eta, bool vis,
      double c_nr, bool cartvis_f, bool eeq);
  template <class F1, class F2, class F3, class F4, class F5,
     class F6, class F7, class F8, class F9, class F10, class F11,
     class F12, class F13, class F14, class F15>
  void force(double dt, const F1 &rh, const F2 &T, const F3 &v, double omrot, F4 &pg, const F5 &ph,
      const F11 &cs, const F6 &cv, const F7 &dlmdlt, const F8 &xmue,
      const F9 &vint, const F10 &cent,
      const F12 &Tii, const F13 &Tij, const F14 &fvis, const F15 &eta, bool vis,
      double c_nr, double c_av, bool cartvis_f, bool eeq);
}
namespace Forgas {
template <class F>
struct IsSpherical {
  enum { result = false };
};
template <template <class> class Mesh, int Dim, class MeshTag, class T, class E>
struct IsSpherical<Field<Mesh<MeshTraits<Dim, T, MeshTag, SphericalTag> >, T, E> > {
  enum { result = true };
};
template <class F>
static bool isSpherical()
{
  return IsSpherical<F>::result;
}
template <class F>
struct IsNotCartesian {
  enum { result = true };
};
template <template <class> class Mesh, int Dim, class MeshTag, class T, class E>
struct IsNotCartesian<Field<Mesh<MeshTraits<Dim, T, MeshTag, CartesianTag> >, T, E> > {
  enum { result = false };
};
template <class F>
static bool isNotCartesian()
{
  return IsNotCartesian<F>::result;
}
template <class CAV>
struct ViscTii : public Deltas<3> {
  ViscTii(const CAV& av) : c_av(av) {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 4> &i) const
  {
    i.extent(GuardLayers<3>(Loc<3>(0), Loc<3>(1)));
    i.write(0, true);
    i.write(1, false);
    i.write(2, false);
    i.write(3, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
    i.useGuards(2, false);
    i.useGuards(3, false);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2, class F3, class F4>
  inline void operator()(const F1 &T, const F2 &v, const F4 &rh, const F3 &eta,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = T.mesh();
    double divu = ((m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX) - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I))/m.VOLXB(I)
     + (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY) - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I))/m.VOLYB(I)
     + (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ) - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I))/m.VOLZB(I));
    T(I)(0) = 2.0 * eta.read(I) * rh.read(I)
      * ((v.fieldEngine().engine(0, 0).read(I+dX) - v.fieldEngine().engine(0, 0).read(I))/m.vertexSpacing(I+dX)(0)
  - 1.0/3.0 * divu)
      - rh.read(I)*c_av*std::pow(std::min(divu, 0.0)*m.vertexSpacing(I)(0), 2);
    T(I)(1) = 2.0 * eta.read(I) * rh.read(I)
      * ((v.fieldEngine().engine(0, 1).read(I+dY) - v.fieldEngine().engine(0, 1).read(I))/m.vertexSpacing(I+dY)(1)
  + (isSpherical<F1>() ? (v.fieldEngine().engine(0, 0).read(I) + v.fieldEngine().engine(0, 0).read(I+dX))/(2.0*m.cellPosition(I)(0)) : 0.0)
  - 1.0/3.0 * divu)
      - rh.read(I)*c_av*std::pow(std::min(divu, 0.0)*m.vertexSpacing(I)(0), 2);
    T(I)(2) = 2.0 * eta.read(I) * rh.read(I)
      * ((v.fieldEngine().engine(0, 2).read(I+dZ) - v.fieldEngine().engine(0, 2).read(I))/m.vertexSpacing(I+dZ)(2)
  + (isNotCartesian<F1>() ? 0.5 * (v.fieldEngine().engine(0, 0).read(I) + v.fieldEngine().engine(0, 0).read(I+dX))/m.cellPosition(I)(0) : 0.0)
  - (isSpherical<F1>() ? 0.5 * (v.fieldEngine().engine(0, 1).read(I) + v.fieldEngine().engine(0, 1).read(I+dY))/tan(m.cellPosition(I)(1)) : 0.0)
  - 1.0/3.0 * divu)
      - rh.read(I)*c_av*std::pow(std::min(divu, 0.0)*m.vertexSpacing(I)(0), 2);
  }
  CAV c_av;
};
struct Txy : public Deltas<3> {
  Txy() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 2> &i) const
  {
    i.extent().lower(0) = 1;
    i.extent().lower(1) = 1;
    i.write(0, true);
    i.write(1, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2>
  inline void operator()(const F1 &T, const F2 &v,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = T.mesh();
    T(I) = (v.fieldEngine().engine(0, 1).read(I) - v.fieldEngine().engine(0, 1).read(I-dX)) * m.GEOXGA(I) / m.cellSpacing(I)(0)
      + (v.fieldEngine().engine(0, 0).read(I) - v.fieldEngine().engine(0, 0).read(I-dY)) / (m.GEOXGA(I) * m.cellSpacing(I)(1));
  }
};
struct Txz : public Deltas<3> {
  Txz() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 2> &i) const
  {
    i.extent().lower(0) = 1;
    i.extent().lower(2) = 1;
    i.write(0, true);
    i.write(1, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2>
  inline void operator()(const F1 &T, const F2 &v,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = T.mesh();
    T(I) = (v.fieldEngine().engine(0, 2).read(I) - v.fieldEngine().engine(0, 2).read(I-dX)) * m.GEOXH(I) * m.GEOYH(I) / m.cellSpacing(I)(0)
      + (v.fieldEngine().engine(0, 0).read(I) - v.fieldEngine().engine(0, 0).read(I-dZ)) / (m.GEOXH(I) * m.GEOYH(I) * m.cellSpacing(I)(2));
  }
};
struct Tyz : public Deltas<3> {
  Tyz() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 2> &i) const
  {
    i.extent().lower(1) = 1;
    i.extent().lower(2) = 1;
    i.write(0, true);
    i.write(1, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2>
  inline void operator()(const F1 &T, const F2 &v,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = T.mesh();
    T(I) = (v.fieldEngine().engine(0, 2).read(I) - v.fieldEngine().engine(0, 2).read(I-dY)) * m.GEOYHA(I) / m.cellSpacing(I)(1)
      + (v.fieldEngine().engine(0, 1).read(I) - v.fieldEngine().engine(0, 1).read(I-dZ)) / (m.GEOYHA(I) * m.cellSpacing(I)(2));
  }
};
struct ViscForceX : public Deltas<3> {
  ViscForceX() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 3> &i) const
  {
    i.extent().lower(0) = 1;
    i.extent().upper(1) = 1;
    i.extent().upper(2) = 1;
    i.write(0, true);
    i.write(1, false);
    i.write(2, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
    i.useGuards(2, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2, class F3>
  inline void operator()(const F1 &f, const F2 &Tii, const F3 &Tij,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = f.mesh();
    f(I) = (Tii(I)(0) * m.SURXB(I) - Tii(I-dX)(0) * m.SURXB(I-dX)) / m.VOLXA(I-dX)
      + (Tij.fieldEngine().engine(0, 0).read(I+dY) * m.SURYA(I+dY) - Tij.fieldEngine().engine(0, 0).read(I) * m.SURYA(I)) / (m.VOLYB(I)*m.GEOXHA(I))
      + (Tij.fieldEngine().engine(0, 1).read(I+dZ) * m.SURZA(I+dZ) - Tij.fieldEngine().engine(0, 1).read(I) * m.SURZA(I)) / (m.VOLZB(I)*m.GEOXHA(I)*m.GEOYH(I))
      - (isNotCartesian<F1>() ? ((isSpherical<F1>() ? Tii(I-dX)(1) + Tii(I)(1) : 0.0)
     + Tii(I-dX)(2) + Tii(I)(2)) / (2.0*m.vertexPosition(I)(0))
  : 0.0);
  }
};
struct ViscForceY : public Deltas<3> {
  ViscForceY() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 3> &i) const
  {
    i.extent().lower(1) = 1;
    i.extent().upper(0) = 1;
    i.extent().upper(2) = 1;
    i.write(0, true);
    i.write(1, false);
    i.write(2, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
    i.useGuards(2, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2, class F3>
  inline void operator()(const F1 &f, const F2 &Tii, const F3 &Tij,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = f.mesh();
    f(I) = (Tij.fieldEngine().engine(0, 0).read(I+dX) * m.SURXA(I+dX) - Tij.fieldEngine().engine(0, 0).read(I) * m.SURXA(I)) / m.VOLXB(I)
      + (Tii(I)(1) * m.SURYB(I) - Tii(I-dY)(1) * m.SURYB(I-dY)) / (m.VOLYA(I-dY)*m.GEOXG(I))
      + (Tij.fieldEngine().engine(0, 2).read(I+dZ) * m.SURZA(I+dZ) - Tij.fieldEngine().engine(0, 2).read(I) * m.SURZA(I)) / (m.VOLZB(I)*m.GEOXH(I)*m.GEOYHA(I))
      + (isSpherical<F1>() ? (Tij.fieldEngine().engine(0, 0).read(I) + Tij.fieldEngine().engine(0, 0).read(I+dX)
         + (Tii(I-dY)(2) + Tii(I)(2)) / tan(m.cellPosition(I)(1))) / (2.0*m.cellPosition(I)(0))
  : 0.0);
  }
};
struct ViscForceZ : public Deltas<3> {
  ViscForceZ() {}
  inline void scalarCodeInfo(ScalarCodeInfo<3, 3> &i) const
  {
    i.extent().lower(2) = 1;
    i.extent().upper(0) = 1;
    i.extent().upper(1) = 1;
    i.write(0, true);
    i.write(1, false);
    i.write(2, false);
    i.useGuards(0, false);
    i.useGuards(1, true);
    i.useGuards(2, true);
  }
  using Deltas<3>::dX;
  using Deltas<3>::dY;
  using Deltas<3>::dZ;
  template <class F1, class F2, class F3>
  inline void operator()(const F1 &f, const F2 &Tii, const F3 &Tij,
    const Loc<3>& I) const
  {
    const typename F1::Mesh_t &m = f.mesh();
    f(I) = (Tij.fieldEngine().engine(0, 1).read(I+dX) * m.SURXA(I+dX) - Tij.fieldEngine().engine(0, 1).read(I) * m.SURXA(I)) / m.VOLXB(I)
      + (Tij.fieldEngine().engine(0, 2).read(I+dY) * m.SURYA(I+dY) - Tij.fieldEngine().engine(0, 2).read(I) * m.SURYA(I)) / (m.VOLYB(I)*m.GEOXG(I))
      + (Tii(I)(2) * m.SURZB(I) - Tii(I-dZ)(2) * m.SURZB(I-dZ)) / (m.VOLZA(I)*m.GEOXH(I)*m.GEOYH(I))
      + (isNotCartesian<F1>() ? ((Tij.fieldEngine().engine(0, 1).read(I) + Tij.fieldEngine().engine(0, 1).read(I+dX)
      - (isSpherical<F1>() ? (Tij.fieldEngine().engine(0, 2).read(I) + Tij.fieldEngine().engine(0, 2).read(I+dY))
         / tan(m.cellPosition(I)(1))
         : 0.0))
     / (2.0*m.cellPosition(I)(0)))
  : 0.0);
  }
};
  template <int Dim>
  struct TGuess : public Deltas<Dim> {
    TGuess(double dt_) : dt(dt_) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 7> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.write(4, false);
      i.write(5, false);
      i.write(6, false);
      i.useGuards(0, false);
      i.useGuards(1, false);
      i.useGuards(2, false);
      i.useGuards(3, true);
      i.useGuards(4, false);
      i.useGuards(5, false);
      i.useGuards(6, false);
    }
    double dt;
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4, class F5, class F6, class F7>
    inline void operator()(const F1 &pg, const F2 &T, const F3 &rh, const F4 &v,
      const F5 &cv, const F6 &dlmdlt, const F7 &xmue, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = pg.mesh();
      double g = (m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX)
    - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I)) / m.VOLXB(I);
      if (Dim > 1)
 g += (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY)
       - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I)) / m.VOLYB(I);
      if (Dim > 2)
 g += (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ)
       - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I)) / m.VOLZB(I);
      double tguess = T(I)
 - (dt
    * pg(I) / rh(I) / cv.read(I)
    * (1.0 - dlmdlt.read(I))
    * g);
      pg(I) = tguess * rh(I) / xmue.read(I);
    }
  };
  template <int Dim>
  struct CentX : public Deltas<Dim> {
    CentX(double omrot) : omrot_m(omrot) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
    {
      i.extent().lower(0) = 1;
      i.extent().upper(1) = 1;
      if (Dim > 2)
 i.extent().upper(2) = 1;
      i.write(0, true, false);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.useGuards(0, false);
      i.useGuards(1, false);
      i.useGuards(2, true);
      if (Dim > 2)
 i.useGuards(3, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, CartesianTag> >,
                  T, EngineTag> &centx,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      const typename MeshTraits<Dim, T, MeshTag, CartesianTag>::Mesh_t &m = centx.mesh();
      centx(I) = omrot_m*omrot_m*m.vertexPosition(I)(0);
    }
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, CylindricalTag> >,
                  T, EngineTag> &centx,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      const typename MeshTraits<Dim, T, MeshTag, CylindricalTag>::Mesh_t &m = centx.mesh();
      double hq = 0.5*(m.DDX0(I)*(vz(I-dX) + vz(I-dX+dZ))
         + m.DDX1(I)*(vz(I) + vz(I+dZ))) + omrot_m;
      centx(I) = m.vertexPosition(I)(0) * std::pow(hq, 2);
    }
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, SphericalTag> >,
                  T, EngineTag> &centx,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      const typename MeshTraits<Dim, T, MeshTag, SphericalTag>::Mesh_t &m = centx.mesh();
      double hq = 0.5*(m.DDX0(I)*(vz(I-dX) + vz(I-dX+dZ))
         + m.DDX1(I)*(vz(I) + vz(I+dZ))) + omrot_m;
      double gq = 0.5*(m.DDX0(I)*(vy(I-dX+dY) + vy(I-dX))
         + m.DDX1(I)*(vy(I+dY) + vy(I)));
      centx(I) = m.vertexPosition(I)(0)
 * (std::pow(gq, 2) + std::pow(hq*sin(m.cellPosition(I)(1)), 2));
    }
    const double omrot_m;
  };
  template <int Dim>
  struct CentY : public Deltas<Dim> {
    CentY(double omrot) : omrot_m(omrot) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
    {
      i.extent().upper(0) = 1;
      i.extent().lower(1) = 1;
      if (Dim > 2)
 i.extent().upper(2) = 1;
      i.write(0, true, false);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
      i.useGuards(2, false);
      if (Dim > 2)
 i.useGuards(3, true);
    }
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, CartesianTag> >,
                  T, EngineTag> &centy,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      const typename MeshTraits<Dim, T, MeshTag, CartesianTag>::Mesh_t &m = centy.mesh();
      centy(I) = - omrot_m*omrot_m*m.vertexPosition(I)(1);
    }
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, CylindricalTag> >,
                  T, EngineTag> &centy,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      centy(I) = 0.0;
    }
    template <template <class> class Mesh, class MeshTag, class T, class EngineTag,
       class F2, class F3, class F4>
    inline void operator()(const Field<Mesh<MeshTraits<Dim, T, MeshTag, SphericalTag> >,
                  T, EngineTag> &centy,
      const F4 &vx, const F2 &vy, const F3 &vz,
      const Loc<Dim>& I) const
    {
      const typename MeshTraits<Dim, T, MeshTag, SphericalTag>::Mesh_t &m = centy.mesh();
      double hq = 0.5*(m.DDY0(I)*(vz(I-dY) + vz(I-dY+dZ))
         + m.DDY1(I)*(vz(I) + vz(I+dZ))) + omrot_m;
      centy(I) = -cos(m.vertexPosition(I)(1)) * sin(m.vertexPosition(I)(1)) * std::pow(hq, 2)
 * m.cellPosition(I)(0);
    }
    const double omrot_m;
  };
  template <int Dim>
  struct VXUpd : public Deltas<Dim> {
    VXUpd(double dt_) : dt(dt_) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 6> &i) const
    {
      i.extent().lower(0) = 1;
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.write(4, false);
      i.write(5, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
      i.useGuards(2, true);
      i.useGuards(3, true);
      i.useGuards(4, false);
      i.useGuards(5, false);
    }
    double dt;
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4, class F5, class F6>
    inline void operator()(const F1 &vx, const F2 &rh, const F3 &pg, const F4 &ph,
      const F5 &centx, const F6 &fvisx, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vx(I) = vx(I)
 + dt * ((-(pg.read(I)-pg.read(I-dX)) / m.cellSpacing(I)(0)
   + fvisx(I))
  / (m.DDX1(I)*rh(I)+m.DDX0(I)*rh(I-dX))
  - (ph(I)-ph(I-dX)) / m.cellSpacing(I)(0)
  + centx(I));
    }
  };
  template <int Dim>
  struct VYUpd : public Deltas<Dim> {
    VYUpd(double dt_) : dt(dt_) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 6> &i) const
    {
      i.extent().lower(1) = 1;
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.write(4, false);
      i.write(5, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
      i.useGuards(2, true);
      i.useGuards(3, true);
      i.useGuards(4, false);
      i.useGuards(5, false);
    }
    double dt;
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4, class F5, class F6>
    inline void operator()(const F1 &vy, const F2 &rh, const F3 &pg, const F4 &ph,
      const F5 &centy, const F6 &fvisy, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vy(I) = vy(I)
 + (dt * ((-(pg.read(I)-pg.read(I-dY)) / (m.cellSpacing(I)(1) * m.GEOXG(I))
    + fvisy(I))
   / (m.DDY1(I)*rh(I)+m.DDY0(I)*rh(I-dY))
   -((ph(I)-ph(I-dY))
     / (m.cellSpacing(I)(1) * m.GEOXG(I)))
   - centy(I))
    / m.GEOXG(I));
    }
  };
  template <int Dim>
  struct VZUpd : public Deltas<Dim> {
    VZUpd(double dt_) : dt(dt_) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 5> &i) const
    {
      i.extent().lower(2) = 1;
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.write(4, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
      i.useGuards(2, true);
      i.useGuards(3, true);
      i.useGuards(4, true);
    }
    double dt;
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4, class F5>
    inline void operator()(const F1 &vz, const F2 &rh, const F3 &pg, const F4 &ph,
      const F5 &fvisz, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = rh.mesh();
      vz(I) = vz(I)
 + (dt * ((-(pg.read(I)-pg.read(I-dZ)) / (m.cellSpacing(I)(2)*m.GEOXH(I)*m.GEOYH(I))
    + fvisz(I))
   / (m.DDZ1(I)*rh(I)+m.DDZ0(I)*rh(I-dZ))
   -((ph(I)-ph(I-dZ))
     / (m.cellSpacing(I)(2)*m.GEOXH(I)*m.GEOYH(I)))
                          )
    / (m.GEOXH(I)*m.GEOYH(I)));
    }
  };
  template <int Dim>
  struct TUpd : public Deltas<Dim> {
    TUpd(double dt_) : dt(dt_) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 6> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.write(4, false);
      i.write(5, false);
      i.useGuards(0, false);
      i.useGuards(1, false);
      i.useGuards(2, true);
      i.useGuards(3, false);
      i.useGuards(4, false);
      i.useGuards(5, false);
    }
    double dt;
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4, class F5, class F6>
    inline void operator()(const F1 &T, const F2 &rh, const F3 &v, const F4 &pg,
      const F5 &cv, const F6 &dlmdlt, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = T.mesh();
      double g = (m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX)
    - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I)) / m.VOLXB(I);
      if (Dim > 1)
 g += (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY)
       - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I)) / m.VOLYB(I);
      if (Dim > 2)
 g += (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ)
       - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I)) / m.VOLZB(I);
      T(I) = T(I)
 - (dt
    * pg.read(I) / rh(I) / cv.read(I)
    * (1.0 - dlmdlt.read(I))
    * g);
    }
  };
  template <int Dim>
  struct GradV : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true, false);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &grad_v, const F2 &v, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = grad_v.mesh();
      grad_v(I)(0) = (m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX)
        - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I))/m.VOLXB(I);
      if (Dim > 1)
 grad_v(I)(1) = (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY)
   - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I))/m.VOLYB(I);
      if (Dim > 2)
 grad_v(I)(2) = (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ)
   - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I))/m.VOLZB(I);
    }
  };
  template <int Dim>
  struct GradVdX : public Deltas<Dim> {
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true, false);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2>
    inline void operator()(const F1 &grad_v, const F2 &v, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = grad_v.mesh();
      grad_v(I)(0) = (m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX)
        - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I));
      if (Dim > 1)
 grad_v(I)(1) = (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY)
   - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I));
      if (Dim > 2)
 grad_v(I)(2) = (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ)
   - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I));
    }
  };
  template <int Dim>
  struct APressure : public Deltas<Dim> {
    APressure(double cnr, double cav) : c_nr(cnr), c_av(cav) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 4> &i) const
    {
      i.extent(GuardLayers<Dim>(Loc<Dim>(0), Loc<Dim>(1)));
      i.write(0, true);
      i.write(1, false);
      i.write(2, false);
      i.write(3, false);
      i.useGuards(0, false);
      i.useGuards(1, false);
      i.useGuards(2, true);
      i.useGuards(3, false);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    using Deltas<Dim>::dZ;
    template <class F1, class F2, class F3, class F4>
    inline void operator()(const F1 &pg, const F2 &rh, const F3 &v, const F4 &cs,
      const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = pg.mesh();
      double q = (m.SURXA(I+dX)*v.fieldEngine().engine(0, 0).read(I+dX)
    - m.SURXA(I)*v.fieldEngine().engine(0, 0).read(I))/m.VOLXB(I);
      if (Dim > 1)
 q += (m.SURYA(I+dY)*v.fieldEngine().engine(0, 1).read(I+dY)
       - m.SURYA(I)*v.fieldEngine().engine(0, 1).read(I))/m.VOLYB(I);
      if (Dim > 2)
 q += (m.SURZA(I+dZ)*v.fieldEngine().engine(0, 2).read(I+dZ)
       - m.SURZA(I)*v.fieldEngine().engine(0, 2).read(I))/m.VOLZB(I);
      if (q >= 0.0)
 return;
      q *= m.vertexSpacing(I)(0);
      pg(I) += c_nr * q * q * rh(I);
      pg(I) -= c_av * rh(I) * cs(I) * q;
    }
  private:
    const double c_nr, c_av;
  };
  template <class CoordinateSystemTag>
  struct ApplyCoriolis
  {
    template <class F1, class F2>
    static void applyCoriolis(const F1&, const F2&, double) {}
  };
  template <int Dim>
  struct CoriolisX : public Deltas<Dim> {
    CoriolisX(double dphi) : sin2o_m(sin(2*dphi)), cos2o_m(cos(2*dphi)) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent().lower(0) = 1;
      i.extent().upper(1) = 1;
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    template <class F1, class F2>
    inline void operator()(const F1 &vx, const F2 &v, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = v.mesh();
      double vyx = 0.5*(m.DDX0(I)*(v.fieldEngine().engine(0, 1).read(I-dX)
       + v.fieldEngine().engine(0, 1).read(I-dX+dY))
   + m.DDX1(I)*(v.fieldEngine().engine(0, 1).read(I)
         + v.fieldEngine().engine(0, 1).read(I+dY)));
      vx(I) = v.fieldEngine().engine(0, 0).read(I)*cos2o_m + vyx*sin2o_m;
    }
  private:
    const double sin2o_m, cos2o_m;
  };
  template <int Dim>
  struct CoriolisY : public Deltas<Dim> {
    CoriolisY(double dphi) : sin2o_m(sin(2*dphi)), cos2o_m(cos(2*dphi)) {}
    inline void scalarCodeInfo(ScalarCodeInfo<Dim, 2> &i) const
    {
      i.extent().lower(1) = 1;
      i.extent().upper(0) = 1;
      i.write(0, true);
      i.write(1, false);
      i.useGuards(0, false);
      i.useGuards(1, true);
    }
    using Deltas<Dim>::dX;
    using Deltas<Dim>::dY;
    template <class F1, class F2>
    inline void operator()(const F1 &vy, const F2 &v, const Loc<Dim>& I) const
    {
      const typename F1::Mesh_t &m = v.mesh();
      double vxy = 0.5*(m.DDY1(I)*(v.fieldEngine().engine(0, 0).read(I)
       + v.fieldEngine().engine(0, 0).read(I+dX))
   + m.DDY0(I)*(v.fieldEngine().engine(0, 0).read(I-dY)
         + v.fieldEngine().engine(0, 0).read(I-dY+dX)));
      vy(I) = -vxy*sin2o_m + v.fieldEngine().engine(0, 1).read(I)*cos2o_m;
    }
  private:
    const double sin2o_m, cos2o_m;
  };
  template <>
  struct ApplyCoriolis<CartesianTag>
  {
    template <class F1, class F2>
    static void applyCoriolis(const F1& v, const F2& scratchv, double dphi)
    {
      (ScalarCode<CoriolisX<Dim> >(dphi))(scratchv.center(0), v);
      (ScalarCode<CoriolisY<Dim> >(dphi))(scratchv.center(1), v);
      v.center(0) = scratchv.center(0);
      v.center(1) = scratchv.center(1);
    }
  };
  template <class F1, class F2>
  void applyCoriolis(const F1& v, const F2& scratchv, double omrot, double dt)
  {
    ApplyCoriolis<typename F1::Mesh_t::MeshTraits_t::CoordinateSystemTag_t>
      ::applyCoriolis(v, scratchv, omrot*dt);
  }
template <class Tag, class T>
struct FnSave
{
  inline T
  operator()(const T &a) const
  {
    val = a;
    return a;
  }
  static T val;
};
template <class Tag, class T>
T FnSave<Tag, T>::val;
template<class Tag, int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSave<Tag, T1>,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
save(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnSave<Tag, T1>,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}
template<class Tag, class M1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSave<Tag, T1>,
  typename CreateLeaf<Field<M1,T1,E1> >::Leaf_t> >::Expression_t
save(const Field<M1,T1,E1> & l)
{
  typedef UnaryNode<FnSave<Tag, T1>,
    typename CreateLeaf<Field<M1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Field<M1,T1,E1> >::make(l)));
}
template <class Tag, class T>
struct SaveRef
{
  SaveRef() {}
  inline
  operator T() const
  {
    return FnSave<Tag, T>::val;
  }
};
template<class Tag, class T>
inline Expression<Scalar<SaveRef<Tag, T> > >
ref()
{
  return Expression<Scalar<SaveRef<Tag, T> > >(SaveRef<Tag, T>());
}
struct DivV {};
  template <class F1, class F2, class F3, class F4, class F5,
     class F6, class F7, class F8, class F9, class F10,
     class F11, class F12, class F13,
     class F14, class F15, class F16, class F17>
  void force(double dt, const F1 &rh, F2 &T, F3 &v, double omrot, F4 &pg, const F5 &ph,
      const F11& cs, const F6 &cv, const F7 &dlmdlt, const F8 &xmue,
      const F9 &vint, F10 &cent, const F12 &a_pg, const F13 &gradv,
      const F14 &Tii, const F15 &Tij, const F16 &fvis, const F17 &eta, bool vis,
      double c_nr, bool cartvis_f, bool eeq)
  {
    enum { Dim = F1::dimensions };
    if (Dim == 3) {
      (ScalarCode<CentX<Dim> >(omrot))(cent.center(0), shrink(cent.center(0).physicalDomain(), corr_v[0]),
           v.center(0), v.center(1), v.center(2));
      (ScalarCode<CentY<Dim> >(omrot))(cent.center(1), shrink(cent.center(1).physicalDomain(), corr_v[1]),
           v.center(0), v.center(1), v.center(2));
    } else if (Dim == 2) {
      (ScalarCode<CentX<Dim> >(omrot))(cent.center(0), shrink(cent.center(0).physicalDomain(), corr_v[0]),
           v.center(0), v.center(1), v.center(0));
      (ScalarCode<CentY<Dim> >(omrot))(cent.center(1), shrink(cent.center(1).physicalDomain(), corr_v[1]),
           v.center(0), v.center(1), v.center(0));
    }
    if ((cartvis_f && !vis) || eeq) {
      Interval<Dim> I(grow(a_pg.physicalDomain(), GuardLayers<Dim>(1)));
      ScalarCode<GradV<Dim> >()(gradv, I, v);
    }
    if (cartvis_f && !vis) {
      Interval<Dim> I(grow(a_pg.physicalDomain(), GuardLayers<Dim>(1)));
      a_pg(I) = where(save<DivV>(dot(gradv, Vector<Dim>(1))(I)) < 0.0,
        (c_nr * rh * pow2(Pooma::spacings(rh).comp(0)) * ref<DivV, double>())(I),
        0.0);
    }
    if (eeq) {
      Interval<Dim> I(grow(a_pg.physicalDomain(), GuardLayers<Dim>(1)));
      pg(I) = (T(I) - (0.5*dt * pg(I)
         / rh(I) / cv.read(I)
         * (1.0 - dlmdlt.read(I)) * dot(gradv(I), Vector<Dim>(1)))) * rh(I) / xmue.read(I);
      pg.clearDirty();
    }
    if (eeq) {
      vint.all() = v.all();
    }
      fvis.all() = 0.0;
    if (cartvis_f && !vis) {
      (ScalarCode<VXUpd<Dim> >(dt))(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
        rh,
        pg + a_pg * min(gradv.comp(0), 0.0),
        ph, cent.center(0), fvis.center(0));
      if (Dim > 1)
 (ScalarCode<VYUpd<Dim> >(dt))(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
          rh,
          pg + a_pg * min(gradv.comp(1), 0.0),
          ph, cent.center(1), fvis.center(1));
      if (Dim > 2)
 (ScalarCode<VZUpd<Dim> >(dt))(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
          rh,
          pg + a_pg * min(gradv.comp(2), 0.0),
          ph, fvis.center(2));
    } else {
      (ScalarCode<VXUpd<Dim> >(dt))(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
        rh, pg, ph, cent.center(0), fvis.center(0));
      if (Dim > 1)
 (ScalarCode<VYUpd<Dim> >(dt))(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
          rh, pg, ph, cent.center(1), fvis.center(1));
      if (Dim > 2)
 (ScalarCode<VZUpd<Dim> >(dt))(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
          rh, pg, ph, fvis.center(2));
    }
    if (omrot != 0.0)
      applyCoriolis(v, cent, omrot, dt);
    if (eeq) {
      for (int i=0; i<Dim; ++i)
 vint.center(i).all() = 0.5*(vint.center(i).all() + v.center(i).all());
      if (cartvis_f && !vis)
 (ScalarCode<TUpd<Dim> >(dt))(T, T.physicalDomain(), rh, vint,
         pg + a_pg * dot(gradv, Vector<Dim>(1)), cv, dlmdlt);
      else
 (ScalarCode<TUpd<Dim> >(dt))(T, T.physicalDomain(), rh, vint, pg, cv, dlmdlt);
    }
  }
  template <class F1, class F2, class F3, class F4, class F5,
     class F6, class F7, class F8, class F9, class F10, class F11,
     class F12, class F13, class F14, class F15>
  void force(double dt, const F1 &rh, const F2 &T, const F3 &v, double omrot, F4 &pg, const F5 &ph,
      const F11 &cs, const F6 &cv, const F7 &dlmdlt, const F8 &xmue,
      const F9 &vint, const F10 &cent,
      const F12 &Tii, const F13 &Tij, const F14 &fvis, const F15 &eta, bool vis,
      double c_nr, double c_av, bool cartvis_f, bool eeq)
  {
    enum { Dim = F1::dimensions };
    if (Dim == 3) {
      (ScalarCode<CentX<Dim> >(omrot))(cent.center(0), shrink(cent.center(0).physicalDomain(), corr_v[0]),
           v.center(0), v.center(1), v.center(2));
      (ScalarCode<CentY<Dim> >(omrot))(cent.center(1), shrink(cent.center(1).physicalDomain(), corr_v[1]),
           v.center(0), v.center(1), v.center(2));
    } else if (Dim == 2) {
      (ScalarCode<CentX<Dim> >(omrot))(cent.center(0), shrink(cent.center(0).physicalDomain(), corr_v[0]),
           v.center(0), v.center(1), v.center(0));
      (ScalarCode<CentY<Dim> >(omrot))(cent.center(1), shrink(cent.center(1).physicalDomain(), corr_v[1]),
           v.center(0), v.center(1), v.center(0));
    }
    if (eeq) {
      (ScalarCode<TGuess<Dim> >(0.5*dt))(pg, pg.physicalDomain(),
      T, rh, v, cv, dlmdlt, xmue);
      pg.clearDirty();
      vint.all() = v.all();
    }
    if (cartvis_f && !vis) {
      (ScalarCode<APressure<Dim> >(APressure<Dim>(c_nr, c_av)))(pg, pg.physicalDomain(), rh, v, cs);
      pg.clearDirty();
    }
      fvis.all() = 0.0;
    (ScalarCode<VXUpd<Dim> >(dt))(v.center(0), shrink(v.center(0).physicalDomain(), corr_v[0]),
      rh, pg, ph, cent.center(0), fvis.center(0));
    if (Dim > 1)
      (ScalarCode<VYUpd<Dim> >(dt))(v.center(1), shrink(v.center(1).physicalDomain(), corr_v[1]),
        rh, pg, ph, cent.center(1), fvis.center(1));
    if (Dim > 2)
      (ScalarCode<VZUpd<Dim> >(dt))(v.center(2), shrink(v.center(2).physicalDomain(), corr_v[2]),
        rh, pg, ph, fvis.center(2));
    if (omrot != 0.0)
      applyCoriolis(v, cent, omrot, dt);
    if (eeq) {
      for (int i=0; i<Dim; ++i)
 vint.center(i).all() = 0.5*(vint.center(i).all() + v.center(i).all());
      (ScalarCode<TUpd<Dim> >(dt))(T, T.physicalDomain(), rh, vint, pg, cv, dlmdlt);
    }
  }
};
Loc<Dim> vdom(64, 64, 64);
void usage(int ret)
{
  std::cerr
    << "Usage: tramp3d-v4\n"
    << "  --help|-h|-?        show this command line help\n"
    << "  --num-iter|-n       number of iterations to perform [Inf]\n"
    << "  --end-t|-t          time to stop simulation [Inf]\n"
    << "  --cfl               cfl number [0.6]\n"
    << "  --dt                constant timestep, used with cfl number [off]\n"
    << "  --min-dt            minimum timestep allowed\n"
    << "  --max-dt            maximum timestep allowed\n"
    << "  --blocks nx ny nz   processor setup [automatic]\n"
    << "  --cartvis nr av     artificial viscosity NR AV [off]\n"
    << "  --eos n             choose eos\n"
    << "  --rhomin rho        density floor [off]\n"
    << "  --blocking-expressions  set blocking expressions [off]\n"
    << "  --domain x y z      computational vertex domain [64x64x64]\n\n"
    << "A particularly benchmarky and checky command-line includes\n"
    << "both artificial viscosity and density minimum via f.i.\n"
    << "  ./tramp3d-v4 --cartvis 1.0 0.0 --rhomin 1e-8\n"
    << std::flush;
  Pooma::finalize();
  exit(ret);
}
void handle_cmd_args(int argc, char** argv)
{
  int i = 1;
  while (i < argc) {
    if (strcmp(argv[i], "--help") == 0
 || strcmp(argv[i], "-h") == 0
 || strcmp(argv[i], "-?") == 0) {
      usage(0);
    } else if (argc > i+1
        && (strcmp(argv[i], "--num-iter") == 0
     || strcmp(argv[i], "-n") == 0)) {
      a_nr_f = true;
      a_nr = atoi(argv[i+1]);
      i += 1;
    } else if (argc > i+1
        && (strcmp(argv[i], "--end-t") == 0
     || strcmp(argv[i], "-t") == 0)) {
      a_end_t_f = true;
      a_end_t = atof(argv[i+1]);
      i += 1;
    } else if (argc > i+Dim
      && strcmp(argv[i], "--blocks") == 0) {
      a_blocks_f = true;
      a_blocks[0] = Loc<1>(atoi(argv[i+1]));
      if (Dim > 1)
 a_blocks[1] = Loc<1>(atoi(argv[i+2]));
      if (Dim > 2)
 a_blocks[2] = Loc<1>(atoi(argv[i+3]));
      i += 3;
    } else if (argc > i+Dim
      && strcmp(argv[i], "--domain") == 0) {
      vdom[0] = Loc<1>(atoi(argv[i+1]));
      if (Dim > 1)
 vdom[1] = Loc<1>(atoi(argv[i+2]));
      if (Dim > 2)
 vdom[2] = Loc<1>(atoi(argv[i+3]));
      i += 3;
    } else if (argc > i+1
        && strcmp(argv[i], "--cfl") == 0) {
      a_cfl_f = true;
      a_cfl = atof(argv[i+1]);
      i += 1;
    } else if (argc > i+1
        && strcmp(argv[i], "--dt") == 0) {
      a_constant_timestep_f = true;
      dt = atof(argv[i+1]);
      i += 1;
    } else if (argc > i+1
        && strcmp(argv[i], "--min-dt") == 0) {
      a_min_dt_f = true;
      a_min_dt = atof(argv[i+1]);
      i += 1;
    } else if (argc > i+1
        && strcmp(argv[i], "--max-dt") == 0) {
      a_max_dt_f = true;
      a_max_dt = atof(argv[i+1]);
      i += 1;
    } else if (argc > i+2
        && strcmp(argv[i], "--cartvis") == 0) {
      a_cartvis_f = true;
      cartvis_nr = atof(argv[i+1]);
      cartvis_av = atof(argv[i+2]);
      i += 2;
    } else if (argc > i+1
        && strcmp(argv[i], "--rhomin") == 0) {
      a_rhomin_f = true;
      a_rhomin = atof(argv[i+1]);
      i += 1;
    } else if (strcmp(argv[i], "--blocking-expressions") == 0) {
      Pooma::blockingExpressions(true);
    } else {
      std::cerr << "Unknown option " << argv[i] << ".\n\n";
      usage(1);
    }
    ++i;
  }
  commandline.append(argv[0]);
  for (int i=1; i<argc; ++i) {
    commandline.append(" ");
    commandline.append(argv[i]);
  }
}
static void initSpacings(Array<1, double, Brick> s[Dim], const Interval<Dim>& dom)
{
  for (int i=0; i<Dim; ++i)
    s[i].engine() = Engine<1, double, Brick>(grow(dom[i], 2));
}
static void initSpacings(Vector<Dim>& s, const Interval<Dim>&)
{
}
int main(int argc, char** argv)
{
    Pooma::initialize(argc,argv);
    Pooma::blockingExpressions(false);
  Inform out;
  if (argc == 1)
    usage(1);
  handle_cmd_args(argc, argv);
  origin = Vector<Dim>(-1.0);
  for (int i=0; i<Dim; ++i) {
    vertexDomain[i] = Interval<1>(vdom[i].min());
    spacings(i) = 2.0/(vertexDomain[i].size()-1);
  }
  periodicity = Vector<Dim, int>(1);
  if (a_blocks[0].min() == 0)
    a_blocks = makeRBlocks(vertexDomain, Pooma::contexts());
  Grid<Dim> grid = makeRGrid(vertexDomain, a_blocks);
  for (int i=0; i<Dim; ++i) {
    corr_v[i] = GuardLayers<Dim>(0);
    corr_v[i].lower(i) = 1;
    corr_v[i].upper(i) = 1;
  }
  Traits_t::Layout_t layout;
  Traits_t::createLayout(layout, grid, vertexDomain,
    GuardLayers<Dim>(2),
    GuardLayers<Dim>(2));
  Traits_t::Mesh_t mesh(layout, origin, spacings);
  Traits_t::Layout_t layout1;
  Traits_t::createLayout(layout1, grid, vertexDomain,
    GuardLayers<Dim>(1),
    GuardLayers<Dim>(1));
  Traits_t::Mesh_t mesh1(layout1, origin, spacings);
  Traits_t::Layout_t layout0;
  Traits_t::createLayout(layout0, grid, vertexDomain,
    GuardLayers<Dim>(0),
    GuardLayers<Dim>(0));
  Traits_t::Mesh_t mesh0(layout0, origin, spacings);
  Traits_t::Centering_t cell = canonicalCentering<Traits_t::Dim>(CellType, Continuous);
  Traits_t::Centering_t face = canonicalCentering<Traits_t::Dim>(FaceType, Continuous);
  Traits_t::Centering_t edge = canonicalCentering<Traits_t::Dim>(EdgeType, Continuous);
  Traits_t::Centering_t vertex = canonicalCentering<Traits_t::Dim>(VertexType, Continuous);
  Traits_t::Scalar_t rh(cell, layout, mesh);
  Traits_t::Scalar_t v(face, layout, mesh);
  Traits_t::Scalar_t T;
  Traits_t::Scalar_t pg(cell, layout, mesh);
  Traits_t::Scalar_t ph(cell, layout, mesh);
  Traits_t::Scalar_t cs(cell, layout, mesh);
  rh.all() = std::numeric_limits<double>::signaling_NaN();
  for (int i=0; i<Dim; ++i)
    v.center(i).all() = std::numeric_limits<double>::signaling_NaN();
  pg.all() = std::numeric_limits<double>::signaling_NaN();
  ph.all() = std::numeric_limits<double>::signaling_NaN();
  cs.all() = std::numeric_limits<double>::signaling_NaN();
  double t;
  Traits_t::Scalar_t scratchv(vertex, layout, mesh);
  Traits_t::Scalar_t scratchc(cell, layout, mesh);
  Traits_t::Vector_t scratchc_v(cell, layout, mesh);
  Traits_t::Vector_t scratchc_v2;
  Traits_t::Scalar_t flm(face, layout1, mesh1);
  Traits_t::Scalar_t fle;
  Traits_t::Vector_t flvv(vertex, layout0, mesh0);
  Traits_t::Scalar_t flvc(cell, layout0, mesh0);
  Traits_t::Scalar_t Tij;
  scratchv.all() = std::numeric_limits<double>::signaling_NaN();
  scratchc.all() = std::numeric_limits<double>::signaling_NaN();
  scratchc_v.all() = Vector<Dim>(std::numeric_limits<double>::signaling_NaN());
  for (int i=0; i<Dim; ++i)
    flm.center(i).all() = std::numeric_limits<double>::signaling_NaN();
  flvc.all() = std::numeric_limits<double>::signaling_NaN();
  flvv.all() = Vector<Dim>(std::numeric_limits<double>::signaling_NaN());
  Field<Traits_t::Mesh_t, double, ConstantFunction> cv(cell, layout, mesh);
  Field<Traits_t::Mesh_t, Zero<double>, ConstantFunction> dlmdlt(cell, layout, mesh);
  Field<Traits_t::Mesh_t, double, ConstantFunction> xmue(cell, layout, mesh);
  Field<Traits_t::Mesh_t, double, ConstantFunction> nue(cell, layout, mesh);
  int it;
    it = 0;
  it++;
    t = 0.0;
    T.initialize(cell, layout, mesh);
  bool eeq = true;
  if (eeq) {
    fle.initialize(face, layout0, mesh0);
    for (int i=0; i<Dim; ++i)
      fle.center(i).all() = std::numeric_limits<double>::signaling_NaN();
  }
  bool ietot = true;
    gamma_ = 1.33;
    K = 4.0*3.14159265358979323846/(1.0/(gamma_-1.0)+1.0);
    if (! a_cartvis_f) {
    cartvis_nr = 0.0;
    cartvis_av = 0.0;
    }
  xmue.engine().setConstant(2.3);
  cv.engine().setConstant(1.0/(xmue.engine().constant()*(gamma_-1.0)));
  nue.engine().setConstant(0.0);
  {
    Interval<Dim> I(rh.physicalDomain());
    rh(I) = 0.1;
    v.all() = 0.0;
    T(I) = 99.0/exp(100.0*pow(norm(positions(T)(I)-Vector<Dim>(0.25)), 2.0))+1.0;
    Pooma::addAllPeriodicFaceBC(rh);
    Pooma::addAllPeriodicFaceBC(T);
    Pooma::addAllPeriodicFaceBC(v);
  }
  Traits_t::Scalar_t vint(v);
  vint.makeOwnCopy();
  vint.all() = std::numeric_limits<double>::signaling_NaN();
  Traits_t::Scalar_t cent(face, layout0, mesh0);
  cent.all() = 0.0;
    ph.initialize(rh);
    ph.makeOwnCopy();
    ph.all() = 0.0;
  eos = EOS::IdealAdiabatic;
  double rh0 = sum(rh);
  double T0 = sum(rh*T);
  out << "Using\n"
      << "  using " << a_blocks << " block setup for computation on domain " << vertexDomain << "\n"
      << "  " << (eeq ? "" : "not ") << "solving eeq\n";
  if (a_constant_timestep_f)
    out << "  time increments fixed at " << dt << ", cfl " << a_cfl << "\n";
  else
    out << "  time increments from [" << a_min_dt << ", " << a_max_dt << "], cfl " << a_cfl << "\n";
  out << "  starting at t = " << t << ", i = " << it << "\n"
      << "  cell physical/total domain " << rh.physicalDomain() << ", " << rh.totalDomain() << "\n"
      << "  face  physical/total domain " << v.physicalDomain() << ", " << v.totalDomain() << "\n";
  if (periodicity(0)
      || (Dim > 1 && periodicity(1))
      || (Dim > 2 && periodicity(2))) {
    out << "  periodic boundaries in";
    if (periodicity(0))
      out << " X";
    if (Dim > 1 && periodicity(1))
      out << " Y";
    if (Dim > 2 && periodicity(2))
      out << " Z";
    out << "\n";
  }
  out << std::flush;
  struct timeval end_time, start_time;
  gettimeofday(&start_time, 
# 56031 "tramp3d-v4.cpp" 3 4
                           __null
# 56031 "tramp3d-v4.cpp"
                               );


  end_time = start_time;

  if (a_rhomin_f)
    Pooma::newRelation(Hacks::limit_rh(a_rhomin), rh);
  switch (eos) {
  case EOS::IdealAdiabatic:
    Pooma::newRelation(EOS::pg_ig(), pg, T, rh, xmue);
    Pooma::newRelation(EOS::cs_adiabatic(gamma_), cs, pg, rh);
    break;
  }
  double iteration_time = 0.0;
  for (; it<=a_nr && t<=a_end_t; it++) {
    if (!a_constant_timestep_f) {
      double dt_ = CFL::schritt<Dim>(v, cs, nue,
                       scratchc,
                       0.0, false);
      if (dt_ <= 0.0 || std::isnan(dt_) || std::isinf(dt_)) {
 out << "dt is " << dt_ << std::endl;
 Pooma::pAbort("Blowup.");
      }
      dt = std::min(a_max_dt, std::max(a_min_dt, a_cfl*dt_));
    }
    t += dt;



    out << "i = " << it << "\t t = " << t << "\t dt = " << dt;

    iteration_time += end_time.tv_sec + end_time.tv_usec/1000000.0 - start_time.tv_sec - start_time.tv_usec/1000000.0;
    start_time = end_time;
    Adv5::advect(dt, rh, v, 0.0, T, flm, fle, flvv, flvc, cv, scratchc, eeq, ietot);
    Forgas::force(dt,
    rh, T, v, 0.0, pg, ph,
    cs, cv, dlmdlt, xmue, vint, cent,
    scratchc_v , Tij, flm , nue*rh, false,
    cartvis_nr, cartvis_av, a_cartvis_f,
    eeq);
      Hacks::checkRegularity(rh);
      Hacks::checkRegularity(v.center(0));
      if (Dim > 1)
 Hacks::checkRegularity(v.center(1));
      if (Dim > 2)
 Hacks::checkRegularity(v.center(2));
  }


  out << "Correctness:"
      << "\n\tsum(rh) difference = " << sum(rh)-rh0
      << "\n\tsum(vx) = " << sum(v.center(0))
      << "\n\tsum(vy) = " << sum(v.center(1))
      << "\n\tsum(vz) = " << sum(v.center(2))
      << "\n\tsum(rh*T) difference = " << sum(rh*T)-T0 << std::endl;
  Pooma::finalize();
  return 0;
}
